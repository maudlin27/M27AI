local M27Config = import('/mods/M27AI/lua/M27Config.lua')
local GetPlatoonUnits = moho.platoon_methods.GetPlatoonUnits
local AIAttackUtils = import('/lua/AI/aiattackutilities.lua')
local M27Utilities = import('/mods/M27AI/lua/M27Utilities.lua')
local M27MapInfo = import('/mods/M27AI/lua/AI/M27MapInfo.lua')
local M27Logic = import('/mods/M27AI/lua/AI/M27GeneralLogic.lua')
local M27Overseer = import('/mods/M27AI/lua/AI/M27Overseer.lua')
local AIBuildStructures = import('/lua/AI/aibuildstructures.lua')
local M27Conditions = import('/mods/M27AI/lua/AI/M27CustomConditions.lua')
local M27PlatoonTemplates = import('/mods/M27AI/lua/AI/M27PlatoonTemplates.lua')
local M27PlatoonFormer = import('/mods/M27AI/lua/AI/M27PlatoonFormer.lua')
local M27EngineerOverseer = import('/mods/M27AI/lua/AI/M27EngineerOverseer.lua')
local M27FactoryOverseer = import('/mods/M27AI/lua/AI/M27FactoryOverseer.lua')
local M27UnitInfo = import('/mods/M27AI/lua/AI/M27UnitInfo.lua')
local M27UnitMicro = import('/mods/M27AI/lua/AI/M27UnitMicro.lua')
local M27EconomyOverseer = import('/mods/M27AI/lua/AI/M27EconomyOverseer.lua')
local M27AirOverseer = import('/mods/M27AI/lua/AI/M27AirOverseer.lua')
local M27Transport = import('/mods/M27AI/lua/AI/M27Transport.lua')
local M27Team = import('/mods/M27AI/lua/AI/M27Team.lua')

--    Platoon variables and constants:
--1) Action related
refiCurrentAction = 'M27CurrentAction'
reftPrevAction = 'M27PrevAction'
refbHavePreviouslyRun = 'M27HavePreviouslyRun' --True if platoon has been given refactionrun, or in most cases when it's been told to go to a rally point (if its due to enemy threats); Resets to false if platoon completes its movement path (or in the case of ACU if it looks like ACU is safe)
refbForceActionRefresh = 'M27ForceActionRefresh' --E.g. used by overseer the first time a platoon is given a command
refiGameTimeOfLastRefresh = 'M27ForceActionRefresh' --so other code can reference to avoid forcing a refresh too often
refActionAttack = 1
refActionRun = 2
refActionContinueMovementPath = 3
refActionReissueMovementPath = 4 --as per refActionContinueMovementPath but ignores the 'dont refresh continue movementpath' check, and forces re-issuing of movement path even if prev action was a new movement path
refActionNewMovementPath = 5
refActionUseAttackAI = 6
refActionDisband = 7
refActionMoveDFToNearestEnemy = 8 --Direct fire units in the platoon move to the nearest enemy (doesnt affect scouts, T1 arti, and MAA)
refActionReturnToBase = 9
refActionReclaimTarget = 10 --Reclaim a specific target
refActionBuildMex = 11
refActionAssistConstruction = 12
refActionMoveJustWithinRangeOfNearestPD = 13
refActionMoveToTemporaryLocation = 14 --uses reftTemporaryMoveTarget
refActionAttackSpecificUnit = 15
refActionBuildFactory = 16
refActionBuildInitialPower = 17 --NOTE: I(f adding more build actions that the ACU will use, then update the overseer acu manager as it will clear engineer t rackers if the ACU switches to a different non-building action
refActionTemporaryRetreat = 18 --similar to actionrun, but wont clear movement path
refActionUpgrade = 19 --Either gets a new upgrade, or continues existing upgrade if we have one
refActionKillACU = 20 --Units will target enemy ACU if they have combat units, regardless of overrides
refActionReclaimAllNearby = 21 --Use normal engineer logic for reclaiming wrecks nearby
refActionGoToNearestRallyPoint = 22
refActionMoveInCircle = 23 --Tells every unit in platoon to run in a circle
refActionKitingRetreat = 24 --For use where we think we can kite the enemy, so if we no longer detect enemies we shouldnt treat the platoon as having previously run
refActionSuicide = 25 --ctrl-K units in platoon
refActionGoToRandomLocationForAWhile = 26 --Used when units have been stuck for a long time - will force this action until this has been the action for 10s
refActionBuildStructure = 27 --Uses refiStructureCategoryToBuild
refActionGoToRallyPointNearAir = 28 --similar to gotonearestrallypoint, but looks for rally point near the air rally point
refActionCoordinatedAttack = 29 --Will try and split up damage against all units in range to avoid over-killing.  Intended for use for sniperbot platoons
refActionTurnAwayFromEnemy = 30 --Intended for skirmishers where almost in range of enemy as an alternative to running away - unit will just get ready to run without actually running far away

--Extra actions (i.e. performed in addition to main action)
refiExtraAction = 'M27ExtraActionRef'
refExtraActionOvercharge = 1
refExtraActionTargetUnit = 'M27ExtraActionTargetUnit'

local refiRefreshActionCount = 'M27RefreshActionCount' --used to track no. of times action has been skipped
refbOverseerAction = 'M27OverseerActionOverrideFlag'
refiOverseerAction = 'M27OverseerActionOverrideAction'
refiLastPrevActionOverride = 'M27PlatoonLastPrevActionOverride' --Used to track the most recent prev action number that used an overseer override
refbConsiderReclaim = 'M27ConsiderNearbyReclaim'
refbConsiderMexes = 'M27ConsiderNearbyMexes'
refbNeedToHeal = 'M27NeedToHeal'
refbNeededToHealWhenGotMovementPath = 'M27PlatoonNeededToHeal' --True if when we got a new movement path the platoon needed to heal - used for ACU
refbRecentlyRunFromT2Arti = 'M27PlatoonRecentlyRunFromT2Arti' --True if platoon has recently run from an enemy t2 arti

--2) Pathing related
--refiLastPathTarget = 'M27LastPathTarget' --Replaced with table.getn due to too high a risk of error if this wasnt updated
refiCurrentPathTarget = 'M27CurrentPathTarget'
reftMovementPath = 'M27MovementPath'
refiCyclesForLastStuckAction = 'M27CyclesForLastStuckAction'
reftTemporaryMoveTarget = 'M27TemporaryMoveTarget'
refoTemporaryAttackTarget = 'M27TemporaryAttackTarget'
refoPrevTemporaryAttackTarget = 'M27PrevTemporaryAttackTarget'
reftMergeLocation = 'M27MergeLocation' --Temporarily stores the location for merged platoons to head to
reftFrontPosition = 'M27PlatoonFrontPosition' --Records position of the unit in the platoon nearest to the enemy base
refoFrontUnit = 'M27PlatoonFrontUnit' --Records the unit in the platoon nearest the enemy base
refiFrontUnitRefreshCount = 'M27PlatoonFrontRefreshCount' --Tracks how many cycles since we last refreshed the front unit
reftRearPosition = 'M27PlatoonRearPosition'
refoRearUnit = 'M27PlatoonRearUnit'
refiRearUnitRefreshCount = 'M27PlatoonRearRefreshCount'
refoPathingUnit = 'M27PlatoonPathingUnit'

reftDestinationCount = 'M27PlatoonDestinationCount' --[a] = location ref X1Z1, returns number of times we have been told to move to this location (using math.floor of the x and z)
refiMultiPathReissueCount = 'M27PlatoonMultiPathReissueCount' --against platoon, returns number of times we have actions reissue move order where platoon has more than 1 move order

--3) Unit related
reftCurrentUnits = 'M27CurrentUnitsTable'
refiCurrentUnits = 'M27CurrentUnitsCount'
refiPrevCurrentUnits = 'M27PrevUnitsCount'
reftDFUnits = 'M27DFUnitsTable'
reftIndirectUnits = 'M27IndirectUnitsTable'
reftScoutUnits = 'M27ScoutUnitsTable'
reftBuilders = 'M27BuilderUnitsTable'
reftReclaimers = 'M27ReclaimerUnitsTable'
reftUnitsWithShields = 'M27UnitsWithShieldTable'
refiDFUnits = 'M27DFUnitsCount'
refiIndirectUnits = 'M27IndirectUnitsCount'
refiScoutUnits = 'M27ScoutUnitsCount'
refiBuilders = 'M27BuilderUnitsCount'
refiReclaimers = 'M27ReclaimerUnitsCount'
refiUnitsWithShields = 'M27UnitsWithShieldCount'
refbACUInPlatoon = 'M27ACUInPlatoon'
refbHoverInPlatoon = 'M27HoverInPlatoon'
refbPlatoonHasUnderwaterLand = 'M27PlatoonHasUnderwaterLand'
refbPlatoonHasOverwaterLand = 'M27PlatoonHasOverwaterLand'
reftMAA = 'M27MAAInPlatoon' --NOTE: not updated as part of normal details of platoon units; Only updated if refiAirAttackRange isnt nil and want to get action for nearby air

reftFriendlyNearbyCombatUnits = 'M27FriendlyUnitsTable'
refiOverrideDistanceToReachDestination = 'M27OverrideDistanceToReachDestination'

refiEnemySearchRadius = 'M27EnemySearchRadius' --distance that have looked for nearby enemies when getting nearby enemy data
refiEnemiesInRange = 'M27EnemiesInRangeCount'
reftEnemiesInRange = 'M27EnemiesInRangeTable'
refiEnemyStructuresInRange = 'M27EnemiesInRangeStructureCount'
reftEnemyStructuresInRange = 'M27EnemiesInRangeStructureTable'
reftVisibleEnemyIndirect = 'M27EnemyIndirectInRangeTable'
refiVisibleEnemyIndirect = 'M27EnemyIndirectInRangeCount'
refiACUNearestEnemy = 'M27PlatoonACUNearestEnemy' --Nearest enemy to ACU platoon
reftEnemyAirNearby = 'M27EnemyAirNearby' --NOTE: Not updated as part of normal details of enemy units; If refiAirAttackRange isnt nil then this will  be updated to reflect nearby air units

reftPlatoonDFTargettingCategories = 'M27PlatoonTargettingReference' --variable name in unit info that contains the DF targetting for the platoon to use

--escort related
refoSupportHelperUnitTarget = 'M27ScoutHelperUnitTarget' --e.g. used by MAA
refoSupportHelperPlatoonTarget = 'M27ScoutHelperPlatoonTarget' --e.g. used by MAA
refiSupportHelperFollowDistance = 'M27ScoutHelperFollowDistance'
refoPlatoonOrUnitToEscort = 'M27PlatoonEscortPlatoon'
refoEscortingPlatoon = 'M27PlatoonEscortingPlatoon' --platoon that is escorting oPlatoon
refbShouldHaveEscort = 'M27PlatoonShouldHaveEscort'
refiLastTimeWantedEscort = 'M27PlatoonLastTimeWantedEscort' --Used for ACU which keeps switching between wanting and not wanting an escort
refiNeedingEscortUniqueCount = 'M27NeedingEscortUniqueCount'
reftPlatoonsOrUnitsNeedingEscorts = 'M27TablePlatoonsNeedingEscorts'
refiEscortThreatWanted = 'M27PlatoonEscortThreatWanted'
refiCurrentEscortThreat = 'M27PlatoonCurEscortThreat'
refbNeedEscortUnits = 'M27PlatoonBrainNeedEscortUnits' --flag for the brain to say if any untis need an escort, used to determine what to produce at factories
refoSupportingShieldPlatoon = 'M27PlatoonSupportingShield' --if have a platoon with mobile shield units assigned to protect the platoon
refoSupportingStealthPlatoon = 'M27PlatoonSupportingStealth' --Against platoon, returns the stealth platoon handle
reftLocationToGuard = 'M27LocationToGuard' --e.g. for scouts to stay by a mex

--5) Misc
refbPlatoonLogicActive = 'M27PlatoonLogicActive' --will toggle backup code to ensure platoon cycler is active in the event the normal platoon.lua fails to work
refiTimeOfLastRefresh = 'M27PlatoonLastRefresh' --Will update with game time that last ran a platoon cycle
refbMovingToBuild = 'M27MovingToBuild'
refiMMLCountWhenLastSynchronised = 'M27PlatoonMMLsWhenLastSynchronised'
refiTimeOfLastSyncronisation = 'M27PlatoonTimeOfLastSyncronisation'
reftNearestTMDWhenLastSynchronised = 'M27PlatoonNearestTMDWhenLastSynchronised'
refiPlatoonThreatValue = 'M27PlatoonThreatValue'
refiPlatoonMassValue = 'M27PlatoonMassValue' --Used by escorts (if need to use for non-escort then need to update the function that records platoon information as for cpu optimisation reasons it only does this if the platoon has a flag that it needs an esecort
refiLifetimePlatoonCount = 'M27LifetimePlatoonCount'
refiPlatoonCount = 'M27PlatoonCount' --Count of how many times a particular platoonAI has been initiated
refiPlatoonUniqueCount = 'M27PlatoonUniqueCount' --Unique number for an ai brain, to help track platoons when debugging and the platoon plan has changed
reftNearbyMexToBuildOn = 'M27NearbyMexBuildTarget'
refoNearbyReclaimTarget = 'M27NearbyReclaimTarget'
refbNotStartedReclaimingYet = 'M27PlatoonNotStartedReclaimingYet' --Against platoon; true when told to reclaim a unit, get set to false when the event for reclaimstarted triggers
refoConstructionToAssist = 'M27NearbyConstructionTarget'
refbHasBeenGivenExpansionOrder = 'M27HasBeenGivenExpansionOrder' --used for ACU platoon so can add extra checks if its not the first time its expanding
refbKiteEnemies = 'M27KiteEnemies' --True/false; set to true if want combat units to try and kite the enemy
refbKitingLogicActive = 'M27CurrentlyKiting'
refiPrevNearestEnemyDistance = 'M27PrevNearestEnemyDistance'
refoBrain = 'M27PlatoonBrain'
reftLastAttackLocation = 'M27PlatoonLastAttackLocation' --When a platoon is given the actionattack order, this stores the location of the target, so the unit wont  have its commands cleared if the new target is close to this
refbAttackMovedToLastAttackLocation = 'M27PlatoonAttackMovedToLastAttackLocation' --recorded along with lastattacklocation, so can tell if we need to clear commands
refbPlatoonUnitDetailsChangedRecently = 'M27PlatoonUnitDiedRecently' --true if a unit has died after the platoon units were last refreshed
reftLastBuildLocation = 'M27EngineerLastBuildLocation' --Used by ACU to track where it last tried building
refiPlatoonMergeCount = 'M27PlatoonMergeCount' --Number of times a platoon has been involved in a merger
refiStructureCategoryToBuild = 'M27PlatoonStructureCategory' --Category to build
reftStructureLocationToBuild = 'M27PlatoonStructureLocationToBuild' --Rough location that want to build at
refiPlatoonMaxRange = 'M27PlatoonMaxRange' --Higher of direct and indirect fire range for the platoon's front unit
reftSkirmisherPlatoonWantingIntel = 'M27PlatoonSkirmishersWantingIntel' --against aiBrain, [x] is [PlatoonName+Count], returns the platoon
refiThreatWhenRetreatToRallyOrBase = 'M27PlatoonThreatWhenRetreated' --Against platoon, threat value when told to return to base or nearest rally
refiSecondsSinceLastCycle = 'M27PlatoonSecondsSinceLastCycle' --against platoon, number of SECONDS we waited in the last cycle
refiTimeOfLastDeathToSurfaceUnit = 'M27PlatoonTimeOfLastDeathToSurfaceUnit' --e.g. intended for MAA to track if they're dying to enemy surface threats so can keep them further back
refbFasterRefreshNextCycle = 'M27PlatoonFasterRefreshNextCycle' --against platoon, true if want to wait less than 1s before refreshing platoon orders

--Plateau
refbPlateauPlatoon = 'M27PlatoonPlateau'
refiLocationVisitationCount = 'M27PlatoonLocationVisitationCount' --[x] = sLocationRef; returns count of the times the location has been assigned as a movement path.  Used to cycle through e.g. mexes on a plateau

--Order types
refiLastOrderType = 'M27PlatoonLastOrderType' --Against platoon, records if was given a move or attack order
refiOrderIssueMove = 1
refiOrderIssueFormMove = 2
refiOrderIssueAttack = 3
refiOrderIssueAggressiveMove = 4
refiOrderIssueAggressiveFormMove = 5
refiOrderIssueReclaim = 6
refiOrderIssueGuard = 7
refiOrderIssueRepair = 8
refiOrderIssueBuild = 9
refiOrderOvercharge = 10
refiOrderUpgrade = 11
refiOrderTransportLoad = 12
refiOrderIssueGroundAttack = 13
reftLastOrderPosition = 'M27PlatoonLastOrderPosition' --against platoon, records the location of the last order (so e.g. if doing dodge micro we can have this given as the move command to use afterwards)

function UpdateUnitNames(tUnits, sNewName, bAddLifetimeCount)
    local sUnitNewName = sNewName
    for iUnit, oUnit in tUnits do
        if not(oUnit.Dead) then
            if oUnit.SetCustomName then
                if bAddLifetimeCount then sUnitNewName = sNewName..':LC='..M27UnitInfo.GetUnitLifetimeCount(oUnit) end
                oUnit:SetCustomName(sUnitNewName)
            else
                M27Utilities.ErrorHandler('oUnit cant have a custom name set, so likely isnt a unit')
            end
        end
    end
end

function UpdatePlatoonName(oPlatoon, sNewName)
    local sFunctionRef = 'UpdatePlatoonName'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    if oPlatoon.GetPlan then
        local sPlan = oPlatoon:GetPlan()
        if sPlan == M27PlatoonTemplates.refoAllEngineers then
            --Do nothing - handled via engineer overseer
        elseif oPlatoon[M27PlatoonTemplates.refbIdlePlatoon] then
            --Update each name individually instead to note the Unit ref
            local tPlatoonUnits = oPlatoon:GetPlatoonUnits()
            if M27Utilities.IsTableEmpty(tPlatoonUnits) == false then
                for iUnit, oUnit in tPlatoonUnits do
                    if not(oUnit.Dead) then UpdateUnitNames({oUnit}, sNewName..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
                end
            end
        else
            --Add details of who we are assisting if we're an assister/escort platoon
            if oPlatoon[refoPlatoonOrUnitToEscort] or oPlatoon[refoSupportHelperUnitTarget] or oPlatoon[refoSupportHelperPlatoonTarget] then
                local oUnitHelping
                local oPlatoonHelping

                if oPlatoon[refoPlatoonOrUnitToEscort] and oPlatoon[refoPlatoonOrUnitToEscort].GetUnitId then oUnitHelping = oPlatoon[refoPlatoonOrUnitToEscort]
                elseif oPlatoon[refoSupportHelperUnitTarget] and oPlatoon[refoSupportHelperUnitTarget].GetUnitId then
                    oUnitHelping = oPlatoon[refoSupportHelperUnitTarget]
                elseif oPlatoon[refoPlatoonOrUnitToEscort] and oPlatoon[refoPlatoonOrUnitToEscort].GetPlan then oPlatoonHelping = oPlatoon[refoPlatoonOrUnitToEscort]
                elseif oPlatoon[refoSupportHelperPlatoonTarget] and oPlatoon[refoSupportHelperPlatoonTarget].GetPlan then oPlatoonHelping = oPlatoon[refoSupportHelperPlatoonTarget]
                end
                if oUnitHelping and not(oUnitHelping.Dead) and oUnitHelping.GetUnitId then
                    sNewName = sNewName..': '..oUnitHelping.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitHelping)
                elseif oPlatoonHelping then sNewName = sNewName..': '..oPlatoonHelping:GetPlan()..(oPlatoonHelping[refiPlatoonCount] or '0')..'-'..(oPlatoonHelping[refiPlatoonUniqueCount] or '0') end
            end
            UpdateUnitNames(GetPlatoonUnits(oPlatoon), sNewName, true)
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetPlatoonFrontPosition(oPlatoon)
    --M27Utilities.ErrorHandler('Temp To help ID crash')
    if not(oPlatoon[reftFrontPosition]) then
        if oPlatoon.GetUnitId then oPlatoon[reftFrontPosition] = oPlatoon:GetPosition()
        else
            oPlatoon[reftFrontPosition] = oPlatoon:GetPlatoonPosition()
        end
    end

    return oPlatoon[reftFrontPosition]
end

function GetPlatoonRearPosition(oPlatoon)
    --M27Utilities.ErrorHandler('Temp To help ID crash')
    if oPlatoon[reftRearPosition] then return oPlatoon[reftRearPosition]
    else
        if oPlatoon.GetUnitId then return oPlatoon:GetPosition()
        else
            return oPlatoon:GetPlatoonPosition() end
    end
end

function GetActivePlatoonCount(aiBrain, sPlatoonPlan)
    --Returns the number of platoons using sPlatoonPlan that contain alive units
    local sFunctionRef = 'GetActivePlatoonCount'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local iMatchingPlatoonCount = 0
    if sPlatoonPlan then
        for iPlatoon, oPlatoon in aiBrain:GetPlatoonsList() do
            if oPlatoon.GetPlan and oPlatoon:GetPlan() == sPlatoonPlan then
                iMatchingPlatoonCount = iMatchingPlatoonCount + 1
            end
        end
    else M27Utilities.ErrorHandler('sPlatoonPlan is nil')
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return iMatchingPlatoonCount
end

function GetPlatoonUnitsOrUnitCount(oPlatoon, sFriendlyUnitTableVariableWanted, bReturnCountNotTable, bOnlyGetIfUnitAvailable)
    --if bOnlyGetIfUnitAvailable is true then will check if unit is microing on special task and exclude it
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPlatoonUnitsOrUnitCount'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    --if oPlatoon:GetPlan() == 'M27Skirmisher' and oPlatoon[refiPlatoonCount] == 3 and GetGameTimeSeconds() >= 360 then bDebugMessages = true end

    local tBaseVariable = oPlatoon[sFriendlyUnitTableVariableWanted]
    local tNewVariable = {}
    local iCount = 0
    if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Start of code') end
    if not(bOnlyGetIfUnitAvailable) or not(oPlatoon[M27UnitInfo.refbSpecialMicroActive]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Either no micro active or not interested in checking if its active') end
        --if oPlatoon[M27UnitInfo.refbSpecialMicroActive] then LOG('refbSpecialMicroActive='..tostring(oPlatoon[M27UnitInfo.refbSpecialMicroActive])) end
        if not(bOnlyGetIfUnitAvailable==nil) and bDebugMessages == true then LOG('bOnlyGetIfUnitAvailable='..tostring(bOnlyGetIfUnitAvailable)) end
        if bReturnCountNotTable then
            if M27Utilities.IsTableEmpty(tBaseVariable) == true then iCount = 0 else iCount = table.getn(tBaseVariable) end
            return iCount
        else
            return tBaseVariable
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Want to exclude any units on micro duty') end
        --Want to exclude units on micro duty
        if M27Utilities.IsTableEmpty(tBaseVariable) == true then
            if bReturnCountNotTable then return 0 else return tBaseVariable end
        else

            for iUnit, oUnit in tBaseVariable do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if micro active for oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M27UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M27UnitInfo.refbSpecialMicroActive])) end
                if not(oUnit[M27UnitInfo.refbSpecialMicroActive]) then
                    iCount = iCount + 1
                    if not(bReturnCountNotTable) then tNewVariable[iCount] = oUnit end
                    if bDebugMessages == true then LOG(sFunctionRef..': Micro isnt active for this unit so will include in the table variable. iCount='..iCount) end
                end
            end
            if bReturnCountNotTable then return iCount else return tNewVariable end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ShouldPlatoonMoveInFormation(oPlatoon, bAttackMove)
    --if bAttackMove is false and we arent in growth formation then will move in formation
    local sFunctionRef = 'ShouldPlatoonMoveInFormation'
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local bMoveInFormation = false
    if oPlatoon[refiCurrentUnits] > 1 then
        if oPlatoon[M27PlatoonTemplates.refbFormMoveIfCloseTogetherAndNoEnemies] and oPlatoon[refiEnemiesInRange] == 0 and oPlatoon[refiEnemyStructuresInRange] == 0 then
            --Are the front and rear platoon units close together?
            if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), GetPlatoonRearPosition(oPlatoon)) <= oPlatoon[M27PlatoonTemplates.refiFormMoveCloseDistanceThreshold] then
                bMoveInFormation = true
            end
        end
        if bMoveInFormation == false then
            local sFormation = oPlatoon.PlatoonData.UseFormation
            if sFormation == nil then sFormation = 'GrowthFormation' end
            if bAttackMove == false and not(sFormation == 'GrowthFormation') then
                if bDebugMessages == true then LOG(sFunctionRef..': Not attack-moving and not using growth formation so will move in formation') end
                bMoveInFormation = true
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return bMoveInFormation
end

function PlatoonMove(oPlatoon, tLocation)
    --Default logic for whether to move, or attack-move, and whether to do it in formation or not
    --Will attack-move with indirect fire units, or if platoon is marked as attack-moving, unless the platoon is flagged as having previously run
    --Assumes have already called issueclearcommands if appropriate (since sometimes might want to queue up move orders)

    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PlatoonMove'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon:GetPlan() == 'M27DefenderAI' and oPlatoon[refiPlatoonCount] == 2 then bDebugMessages = true end
    --if oPlatoon:GetPlan() == 'M27GroundExperimental' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
    --if oPlatoon[refbACUInPlatoon] and GetGameTimeSeconds() >= 900 then bDebugMessages = true end
    --if oPlatoon:GetPlan() == 'M27CombatPatrolAI' and oPlatoon[refiPlatoonCount] == 1 and GetGameTimeSeconds() >= 480 and oPlatoon:GetBrain():GetArmyIndex() == 3 then bDebugMessages = true end

    --Attackmove with indirect if theyre part of a platoon with DF units and arent running; for simplicity indirect fire units will be given both an attackorder, and then the default move order given to all platoon units, if the indirect+direct fire units is < the current units


    --Do we have a mixture of indirect and non-indirect units?
    local bMoveInFormation
    local tCurrentUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftCurrentUnits, false, true)
    local bGiveSameOrdersToEveryone = true
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, will first see if we can give the same order to all platoon units. oPlatoon[refbHavePreviouslyRun]='..tostring(oPlatoon[refbHavePreviouslyRun] or false)..'; oPlatoon[M27PlatoonTemplates.refbAttackMove]='..tostring(oPlatoon[M27PlatoonTemplates.refbAttackMove] or false)..'; oPlatoon[refiIndirectUnits]='..oPlatoon[refiIndirectUnits]..'; oPlatoon[refiCurrentUnits]='..oPlatoon[refiCurrentUnits]..'; front unit shot blocked='..tostring(oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] or false)) end
    if not(oPlatoon[refbHavePreviouslyRun]) and not(oPlatoon[M27PlatoonTemplates.refbAttackMove]) and oPlatoon[refiIndirectUnits] > 0 and oPlatoon[refiCurrentUnits] > oPlatoon[refiIndirectUnits] and not(oPlatoon[refiCurrentAction] == refActionKitingRetreat or oPlatoon[refiCurrentAction] == refActionTemporaryRetreat) then
        --Want to split up attacks based on unit type, and attack-move with any indirect fire units
        local tIndirectUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftIndirectUnits, false, true)
        if M27Utilities.IsTableEmpty(tIndirectUnits) == false then
            bGiveSameOrdersToEveryone = false
            --Attack-move to tIndirectUnits
            bMoveInFormation = ShouldPlatoonMoveInFormation(oPlatoon, true)
            if bMoveInFormation then
                --Per FAF documentation:
                --function IssueFormAggressiveMove(tblUnits, position, formation, degrees)
                -- @param degrees The orientation the platoon should take when it reaches the position. South is 0 degrees, east is 90 degrees, etc.
                --Per below, assume we always want to face towards enemy base
                IssueFormAggressiveMove(tIndirectUnits, tLocation, oPlatoon[M27PlatoonTemplates.refsDefaultFormation], M27Utilities.ConvertM27AngleToFAFAngle(M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.GetPrimaryEnemyBaseLocation(oPlatoon:GetBrain()))))
                oPlatoon[refiLastOrderType] = refiOrderIssueAggressiveFormMove
                oPlatoon[reftLastOrderPosition] = tLocation
            else
                IssueAggressiveMove(tIndirectUnits, tLocation)
                oPlatoon[refiLastOrderType] = refiOrderIssueAggressiveMove
                oPlatoon[reftLastOrderPosition] = tLocation
            end

            --Normal move to all other units
            bMoveInFormation = ShouldPlatoonMoveInFormation(oPlatoon, false)
            local iAngle
            if bMoveInFormation then iAngle = M27Utilities.ConvertM27AngleToFAFAngle(M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.GetPrimaryEnemyBaseLocation(oPlatoon:GetBrain()))) end
            for iUnit, oUnit in tCurrentUnits do
                if M27UnitInfo.IsUnitValid(oUnit) and not(EntityCategoryContains(M27UnitInfo.refCategoryIndirect, oUnit.UnitId)) then

                    if bMoveInFormation then
                        IssueFormMove({ oUnit }, tLocation, oPlatoon[M27PlatoonTemplates.refsDefaultFormation], iAngle )
                    else
                        IssueMove({ oUnit }, tLocation)
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Sent move order to tLocation='..repru(tLocation)..' for current units. Will draw in blue, and list out every unit in tCurrentUnits')
                M27Utilities.DrawLocation(tLocation)
                for iUnit, oUnit in tCurrentUnits do
                    LOG(sFunctionRef..': Unit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit state='..M27Logic.GetUnitState(oUnit))
                end
            end
            if bMoveInFormation then oPlatoon[refiLastOrderType] = refiOrderIssueFormMove else oPlatoon[refiLastOrderType] = refiOrderIssueMove end
            oPlatoon[reftLastOrderPosition] = tLocation
        end
    end


    if bDebugMessages == true then LOG(sFunctionRef..': bGiveSameOrdersToEveryone='..tostring(bGiveSameOrdersToEveryone)) end
    if bGiveSameOrdersToEveryone then
        --Can just give command to all current units - do we want to attackmove?
        local bAttackMove
        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to attackmove.  Will base decisino on both the refbAttackMove status. oPlatoon[refiIndirectUnits]='..oPlatoon[refiIndirectUnits]..'; oPlatoon[refiCurrentUnits]='..oPlatoon[refiCurrentUnits]..'; oPlatoon[M27PlatoonTemplates.refbAttackMove]='..tostring(oPlatoon[M27PlatoonTemplates.refbAttackMove] or false)..'; oPlatoon[refbHavePreviouslyRun]='..tostring(oPlatoon[refbHavePreviouslyRun] or false)) end
        if oPlatoon[M27PlatoonTemplates.refbAttackMove] then
            --if oPlatoon[refiCurrentAction] == refActionTemporaryRetreat or oPlatoon[refiCurrentAction] == refActionKitingRetreat or oPlatoon[refiCurrentAction] == refActionRun or oPlatoon[refiCurrentAction] == refActionReturnToBase then
                --if bDebugMessages == true then LOG(sFunctionRef..': Platoon is retreating so in most cases will want to move instead of attack-move') end
                --If we have T3 mobile arti then just attack-move due to deployment time unless are close to a firebase, otherwise normal move if we have a run type action
                --v58 - removed this as already ahve this logic when getting nearby enemies for the platoon, and will get inconsistent results
                --bAttackMove = false
                --[[if oPlatoon[refiIndirectUnits] > 0 and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryT3MobileArtillery, oPlatoon[reftIndirectUnits])) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': We have T3 mobile arti in platoon so will force an attackmove unless close to a firebase') end
                    bAttackMove = true
                    local aiBrain = oPlatoon:GetBrain()
                    if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFirebasePosition]) == false then
                        local iDistToFirebase
                        for iFirebaseRef, tFirebaseLocation in aiBrain[M27EngineerOverseer.reftFirebasePosition] do
                            iDistToFirebase = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tFirebaseLocation)
                            if iDistToFirebase <= 50 and iDistToFirebase >= 5 then
                                bAttackMove = false
                                break
                            end
                        end
                    end
                else
                    bAttackMove = false
                end--]]
            --else
            --[[
                --Is it an experimental indirect unit? If so then refer to the main platoon attackmove command since its less reliable to attack-move e.g. with fatboy due to low arc
                if M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.EXPERIMENTAL, oPlatoon[reftIndirectUnits])) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have any experimentals in the platoon so will attackmove') end
                    bAttackMove = true
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an indirect fire experimental platoon so will defer to the refbAttackMove position='..tostring(oPlatoon[M27PlatoonTemplates.refbAttackMove] or false)) end
                    bAttackMove = oPlatoon[M27PlatoonTemplates.refbAttackMove]
                end
            end--]]
            bAttackMove = true
        else
            bAttackMove = false
        end

        --Dont attack move if shot is blocked and have DF units

        if oPlatoon[refiDFUnits] > 0 and oPlatoon[refoFrontUnit] and oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] then
            bAttackMove = false
        end



        --Dont attackmove if underwater either with no antinavy, or with nearby enemy hover units
        if bDebugMessages == true then LOG(sFunctionRef..': Further override - if front unit is underwater then will ignore an attacmove order.  bAttackMove='..tostring(bAttackMove)..'; Is front unit underwater='..tostring(M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit]))) end
        if bAttackMove and M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit]) then
            if not (EntityCategoryContains(categories.ANTINAVY + categories.OVERLAYANTINAVY, oPlatoon[refoFrontUnit].UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Dont contain any-navy so will move since are underwater') end
                bAttackMove = false
            else
                local aiBrain = oPlatoon:GetBrain()
                local iSearchRange = 60
                if oPlatoon:GetPlan() == 'M27GroundExperimental' then
                    iSearchRange = 120
                end
                local tNearbyHover = aiBrain:GetUnitsAroundPoint(categories.HOVER, GetPlatoonFrontPosition(oPlatoon), iSearchRange, 'Enemy')
                if bDebugMessages == true then LOG(sFunctionRef..': Contain anti-navy, so will only move instead of attackmove if is nearby enemy hover units.  Is table of nearby hover units empty='..tostring(M27Utilities.IsTableEmpty(tNearbyHover))) end
                if M27Utilities.IsTableEmpty(tNearbyHover) == false then
                    bAttackMove = false
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': If platoon ahs DF units and front unit shot is blocked then dont want to attack move. Is front unit shot blocked='..tostring(oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] or false)..'; bAttackMove='..tostring(bAttackMove)) end

        bMoveInFormation = ShouldPlatoonMoveInFormation(oPlatoon, bAttackMove)
        if bAttackMove then
            if bMoveInFormation then
                IssueFormAggressiveMove(tCurrentUnits, tLocation, oPlatoon[M27PlatoonTemplates.refsDefaultFormation], M27Utilities.ConvertM27AngleToFAFAngle(M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.GetPrimaryEnemyBaseLocation(oPlatoon:GetBrain()))))
                oPlatoon[refiLastOrderType] = refiOrderIssueAggressiveFormMove
            else
                IssueAggressiveMove(tCurrentUnits, tLocation)
                oPlatoon[refiLastOrderType] = refiOrderIssueAggressiveMove
            end
            oPlatoon[reftLastOrderPosition] = tLocation
        else
            if bMoveInFormation then
                IssueFormMove(tCurrentUnits, tLocation, oPlatoon[M27PlatoonTemplates.refsDefaultFormation], M27Utilities.ConvertM27AngleToFAFAngle(M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.GetPrimaryEnemyBaseLocation(oPlatoon:GetBrain()))))
                oPlatoon[refiLastOrderType] = refiOrderIssueFormMove
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Sent a move order to tLocation='..repru(tLocation)) end
                IssueMove(tCurrentUnits, tLocation)
                oPlatoon[refiLastOrderType] = refiOrderIssueMove
            end
            oPlatoon[reftLastOrderPosition] = tLocation
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end


function MoveAlongPath(oPlatoon, tMovementPath, iPathStartPoint, bDontClearActions)
    --iPathStartPoint - defaults to 1 (first entry in tMovementPath); otherwise will ignore earlier entries in tMovementPath
    if iPathStartPoint == nil then iPathStartPoint = 1 end
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end

    --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 1 then bDebugMessages = true end
    --if oPlatoon:GetPlan() == 'M27MAAAssister' then bDebugMessages = true end
    local sFunctionRef = 'MoveAlongPath'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon:GetPlan() == 'M27AttackNearestUnits' then bDebugMessages = true end
    --if oPlatoon:GetPlan() == 'M27PlateauScout' then bDebugMessages = true end
    local tCurrentUnits = {}
    --tCurrentUnits = oPlatoon[reftCurrentUnits]

    tCurrentUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftCurrentUnits, false, true)
    if M27Utilities.IsTableEmpty(tCurrentUnits) == false then
        --Ignore the first point on the path if have considered it too much
        if table.getn(tMovementPath) > iPathStartPoint and ReconsiderTarget(oPlatoon, tMovementPath[iPathStartPoint]) then iPathStartPoint = iPathStartPoint + 1 end

        local tLocation = {}
        if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Start of function; iPathStartPoint='..iPathStartPoint..'; tMovementPath size='..table.getn(tMovementPath)..'; currentunits='..table.getn(oPlatoon[reftCurrentUnits])) end
        for iCurPath = iPathStartPoint, table.getn(tMovementPath) do
            --for iLoc, tLocation in tMovementPath do
            tLocation = tMovementPath[iCurPath]
            if iCurPath == iPathStartPoint then
                if bDebugMessages == true then LOG(sFunctionRef..': Clearing existing actions') end
                --tCurrentUnits = GetPlatoonUnits(oPlatoon)
                if bDontClearActions == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                    M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Moving to tLocationXZ='..tLocation[1]..'-'..tLocation[3]..'; deciding whether will be in formation.  oPlatoon[M27PlatoonTemplates.refbFormMoveIfCloseTogetherAndNoEnemies]='..tostring(oPlatoon[M27PlatoonTemplates.refbFormMoveIfCloseTogetherAndNoEnemies] or false)..'; oPlatoon[refiEnemiesInRange]='..oPlatoon[refiEnemiesInRange]..'oPlatoon[refiEnemyStructuresInRange]='..oPlatoon[refiEnemyStructuresInRange]..'; distance between front and rear position='..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), GetPlatoonRearPosition(oPlatoon))..'; oPlatoon[M27PlatoonTemplates.refiFormMoveCloseDistanceThreshold]='..(oPlatoon[M27PlatoonTemplates.refiFormMoveCloseDistanceThreshold] or 'nil')) end
            PlatoonMove(oPlatoon, tLocation)
        end
        --oPlatoon[refiLastPathTarget] = table.getn(tMovementPath)
        if iPathStartPoint > table.getn(oPlatoon[reftMovementPath]) then iPathStartPoint = table.getn(oPlatoon[reftMovementPath]) end --redundancy just in case
        oPlatoon[refiCurrentPathTarget] = iPathStartPoint
    else
        if oPlatoon[refiCurrentUnits] == 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Disbanding platoon') end
            oPlatoon[refiCurrentAction] = refActionDisband
        else
            if bDebugMessages == true then LOG(sFunctionRef..': All units in platoon are microing so not doing anything') end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, platoon current path target='..oPlatoon[refiCurrentPathTarget]) end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    --[[if bDebugMessages == true then
        LOG(sFunctionRef..'TEMP ERROR - Platoon not moving - delaying code 5s')
        WaitSeconds(5)
    end]]--
end

function GetPlatoonPositionDeviation(oPlatoon)
    --Returns the standard deviation in positions of oPlatoon; will target a centre point whose size increases based on the platoon size
    --very approximate guide: <3 is close, >10 spread out, >30 very spread out, >100 likely on different parts of the map altogether
    local sFunctionRef = 'GetPlatoonPositionDeviation'
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local tPositions = {}
    local iCount = 0
    if oPlatoon[refiCurrentUnits] > 0 then
        for iCurUnit=1, oPlatoon[refiCurrentUnits] do
            tPositions[iCurUnit] = oPlatoon[reftCurrentUnits][iCurUnit]:GetPosition()
        end
        local iCentreSize = math.sqrt(oPlatoon[refiCurrentUnits])*3
        if bDebugMessages == true then LOG(oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': GetPlatoonPositionDeviation: CentreSize='..iCentreSize..'; UnitCount='..oPlatoon[refiCurrentUnits]) end
        if bDebugMessages == true then LOG(oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Deviation='..M27Utilities.CalculateDistanceDeviationOfPositions(tPositions, iCentreSize)) end
        local iDeviation = M27Utilities.CalculateDistanceDeviationOfPositions(tPositions, iCentreSize)
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return iDeviation
    else
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return 0
    end
end

function ConsiderRemovingFarAwayUnits(oPlatoon)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderRemovingFarAwayUnits'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon:GetPlan() == 'M27Skirmisher' and oPlatoon[refiPlatoonCount] == 9 then bDebugMessages = true end
    if bDebugMessages == true then LOG(sFunctionRef..': Platoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'; Current units='..oPlatoon[refiCurrentUnits]..'; Dist between rear and front position='..M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftRearPosition], oPlatoon[reftFrontPosition])..'; Front unit='..oPlatoon[refoFrontUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit]..'; Rear unit='..oPlatoon[refoRearUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoRearUnit]))) end
    if oPlatoon[refiCurrentUnits] > 1 then
        if M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftRearPosition], oPlatoon[reftFrontPosition]) >= 50 then
            local tUnitsToRemove = {}
            for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                if M27UnitInfo.IsUnitValid(oUnit) and M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oPlatoon[reftFrontPosition]) >= 50 then
                    table.insert(tUnitsToRemove, oUnit)
                end
            end
            if M27Utilities.IsTableEmpty(tUnitsToRemove) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Will create a new platoon as units in the platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..' are too far away from each other. Cur units in platoon='..oPlatoon[refiCurrentUnits]..'; Units to remove='..table.getn(tUnitsToRemove)) end
                M27PlatoonFormer.CreatePlatoon(oPlatoon:GetBrain(), 'M27Skirmisher', tUnitsToRemove)
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function TestAltMostRestriveLayer(platoon)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TestAltMostRestriveLayer'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    -- in case the platoon is already destroyed return false.
    if not platoon then
        if bDebugMessages == true then LOG(sFunctionRef..': platoon is nil, returning false') end
        return false
    end
    local unit = false
    platoon.MovementLayer = 'Air'
    for k,v in platoon:GetPlatoonUnits() do
        if not v.Dead then
            local mType = v:GetBlueprint().Physics.MotionType
            if bDebugMessages == true then LOG(sFunctionRef..': MotionType for Unit '..v.UnitId..' is '..mType) end
            if (mType == 'RULEUMT_AmphibiousFloating' or mType == 'RULEUMT_Hover' or mType == 'RULEUMT_Amphibious') and (platoon.MovementLayer == 'Air' or platoon.MovementLayer == 'Water') then
                platoon.MovementLayer = 'Amphibious'
                unit = v
            elseif (mType == 'RULEUMT_Water' or mType == 'RULEUMT_SurfacingSub') and (platoon.MovementLayer ~= 'Water') then
                platoon.MovementLayer = 'Water'
                unit = v
                break   --Nothing more restrictive than water, since there should be no mixed land/water platoons
            elseif mType == 'RULEUMT_Air' and platoon.MovementLayer == 'Air' then
                platoon.MovementLayer = 'Air'
                unit = v
            elseif (mType == 'RULEUMT_Biped' or mType == 'RULEUMT_Land') and platoon.MovementLayer ~= 'Land' then
                platoon.MovementLayer = 'Land'
                unit = v
                break   --Nothing more restrictive than land, since there should be no mixed land/water platoons
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return unit
end


function GetPathingUnit(oPlatoon, oExistingPathingUnit, bRecheckAllUnits)
    --if oExistingPathingUnit is specified, then returns this if it's still alive
    --otherwise, returns the most restrictive pathing unit in the platoon
    --returns nil if no valid units
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPathingUnit'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon:GetPlan() == 'M27LargeAttackForce' then bDebugMessages = true end
    local bGetNewUnit = false
    local oNewPathingUnit
    if bRecheckAllUnits or not(M27UnitInfo.IsUnitValid(oExistingPathingUnit)) then bGetNewUnit = true end
    --[[if oExistingPathingUnit == nil then oExistingPathingUnit = oPlatoon[refoPathingUnit] end
    if oExistingPathingUnit == nil or bRecheckAllUnits then bGetNewUnit = true
    elseif oExistingPathingUnit.Dead then bGetNewUnit = true end--]]

    if bGetNewUnit == true then
        local sPathing
        local sMostRestrictivePathingType
        if bDebugMessages == true then
            LOG(sFunctionRef..': Get unit with worst pathing in platoon')
            oNewPathingUnit = TestAltMostRestriveLayer(oPlatoon)
        end
        for iUnit, oUnit in oPlatoon:GetPlatoonUnits() do
            if M27UnitInfo.IsUnitValid(oUnit) then
                sPathing = M27UnitInfo.GetUnitPathingType(oUnit)
                if not(sMostRestrictivePathingType) then
                    sMostRestrictivePathingType = sPathing
                    oNewPathingUnit = oUnit
                else
                    if sPathing == M27UnitInfo.refPathingTypeLand or sPathing == M27UnitInfo.refPathingTypeNavy then
                        --Most restrictive, on assumption not mixing naval and land units
                        sMostRestrictivePathingType = sPathing
                        oNewPathingUnit = oUnit
                        break
                    elseif sPathing == M27UnitInfo.refPathingTypeAmphibious then
                        --Wouldve stopped already if had land or navy, so must either have amphibious, air, or none
                        sMostRestrictivePathingType = sPathing
                        oNewPathingUnit = oUnit
                    end
                end
            end
        end

        --[[oNewPathingUnit = AIAttackUtils.GetMostRestrictiveLayer(oPlatoon)
        if oNewPathingUnit == false then
            if bDebugMessages == true then LOG(sFunctionRef..': aiAttackUtils returned false') end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return nil
        elseif oNewPathingUnit == nil then
            if bDebugMessages == true then LOG(sFunctionRef..': aiAttackUtils returned nil') end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return nil
        elseif oNewPathingUnit.Dead then
            if bDebugMessages == true then LOG(sFunctionRef..': aiAttackUtils returned dead unit') end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return nil
        end--]]
    else oNewPathingUnit = oExistingPathingUnit
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return oNewPathingUnit
        --[[if oNewPathingUnit.Dead then
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return nil
        else
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return oNewPathingUnit
            end
        end--]]
end

function RemoveUnitsFromPlatoon(oPlatoon, tUnits, bReturnToBase, oPlatoonToAddTo)
    --if bReturnToBase is true then units will be told to move to aiBrain's base
    --if tUnits isnt in oPlatoon then does nothing
    --If try to assign to armypool platoon then instead tries to form a platoon
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitsFromPlatoon'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if oPlatoon and oPlatoon.GetBrain and oPlatoon.GetPlan and not(oPlatoon.Dead) then
        local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())

        --if tUnits[1] == M27Utilities.GetACU(aiBrain) then bDebugMessages = true LOG(sFunctionRef..': ACU is about to be removed from its current platoon='..M27Overseer.DebugPrintACUPlatoon(aiBrain, true)) end
        if bDebugMessages == true then
            LOG(sFunctionRef..': About to list out every unit that is about to be removed')
            for iUnit, oUnit in tUnits do
                if oUnit.GetUnitId then LOG('iUnit='..iUnit..'; oUnitId='..oUnit.UnitId)
                else LOG('iUnit='..iUnit..'; Unit has no unitId') end
            end
        end
        if not(oPlatoonToAddTo == oPlatoon) then
            local oArmyPool = aiBrain:GetPlatoonUniquelyNamed('ArmyPool')
            --if not(oPlatoon==oArmyPool) then if oPlatoon:GetPlan() == 'M27ACUMain' then bDebugMessages = true end end
            local sName
            if oPlatoonToAddTo == nil then
                if bDebugMessages == true then LOG(sFunctionRef..': Will add units to army pool') end
                oPlatoonToAddTo = oArmyPool
                sName = 'ArmyPool'
            else
                if oPlatoonToAddTo == oArmyPool then sName = 'ArmyPool'
                else
                    if oPlatoonToAddTo.GetPlan then
                        sName = oPlatoonToAddTo:GetPlan()
                    end
                    if sName == nil then sName = 'nil' end
                    if oPlatoonToAddTo[refiPlatoonCount] == nil then sName = sName..0
                    else sName = sName..oPlatoonToAddTo[refiPlatoonCount]
                    end
                    oPlatoonToAddTo[refbForceActionRefresh] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to '..sName..'; oPlatoonToAddTo[refbForceActionRefresh] = '..tostring(oPlatoonToAddTo[refbForceActionRefresh])) end
                end
            end
            if oPlatoonToAddTo == nil then
                LOG(sFunctionRef..': WARNING: oPlatoonToAddTo is nil')
            else
                local sCurPlatoonName
                if oPlatoon == oArmyPool then
                    sCurPlatoonName = 'ArmyPool'
                else
                    sCurPlatoonName = oPlatoon:GetPlan()
                    if sCurPlatoonName == nil then sCurPlatoonName = 'None' end
                    if oPlatoon[refiPlatoonCount] == nil then sCurPlatoonName = sCurPlatoonName..0
                    else sCurPlatoonName = sCurPlatoonName..oPlatoon[refiPlatoonCount] end
                    if bDebugMessages == true then LOG(sFunctionRef..': sCurPlatoonName='..sCurPlatoonName) end
                end

                if not(sCurPlatoonName == sName) then
                    if bDebugMessages == true then
                        if oPlatoon == oArmyPool then
                            M27Utilities.ErrorHandler('ideally shouldnt have any units using armypool platoon now, see if can figure out where this came from')
                            LOG(sFunctionRef..': About to remove units from ArmyPool platoon and add to platoon '..sName)
                        else
                            LOG(sFunctionRef..': About to remove units from platoon '..oPlatoon:GetPlan())
                            if oPlatoon[refiPlatoonCount] == nil then LOG('which has nil count') else LOG('which has count='..oPlatoon[refiPlatoonCount]) end
                        end
                    end

                    if bReturnToBase == true then
                        if bDebugMessages == true then LOG(sFunctionRef..': Issuing move command to tUnits') end
                        if bDebugMessages == true then LOG(sFunctionRef..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                        M27Utilities.IssueTrackedClearCommands(tUnits)
                        IssueMove(tUnits, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                    end

                    if oPlatoonToAddTo == oArmyPool then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..'; tUnits size='..table.getn(tUnits)..'; IsTableEmpty='..tostring(M27Utilities.IsTableEmpty(tUnits)))
                        end

                        M27PlatoonFormer.AllocateUnitsToIdlePlatoons(aiBrain, tUnits)
                        M27PlatoonFormer.AllocateNewUnitsToPlatoonNotFromFactory(tUnits)
                    else
                        aiBrain:AssignUnitsToPlatoon(oPlatoonToAddTo, tUnits, 'Unassigned', 'None')
                        if M27Config.M27ShowUnitNames == true then
                            if bDebugMessages == true then LOG(sFunctionRef..': About to update name to '..sName) end
                            UpdatePlatoonName(oPlatoonToAddTo, sName)
                        end
                        if oPlatoonToAddTo == oArmyPool then
                            M27PlatoonFormer.AllocateNewUnitsToPlatoonNotFromFactory(tUnits)
                        end
                        --Update basic platoon tracker details
                        RecordPlatoonUnitsByType(oPlatoon)
                    end
                end
            end
        end
        if bDebugMessages == true then if tUnits[1] == M27Utilities.GetACU(aiBrain) then LOG(sFunctionRef..': end of function; ACU current platoon='..M27Overseer.DebugPrintACUPlatoon(aiBrain, true)) end end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end


function GetCyclesSinceLastMoved(oUnit, bIsPlatoonNotUnit, iTriggerDistance)
    --returns the number of times this function has been called where oUnit hasnt moved by more than x spaces
    local sFunctionRef = 'GetCyclesSinceLastMoved'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    if bIsPlatoonNotUnit == nil then bIsPlatoonNotUnit = false end

    local iDistTreatedAsStuck = iTriggerDistance
    if iDistTreatedAsStuck == nil then
        if bIsPlatoonNotUnit == true and oUnit.GetPlatoonUnits then
            iDistTreatedAsStuck = 4 + math.floor(oUnit[refiCurrentUnits] / 4)
            if iDistTreatedAsStuck > 15 then iDistTreatedAsStuck = 15 end
        else iDistTreatedAsStuck = 5 end
    end
    local sLastX = 'M27LastX'
    local sLastZ = 'M27LastZ'
    local sCyclesSinceMoved = 'M27CyclesSinceMoved'
    local iLastX = oUnit[sLastX]
    local iLastZ = oUnit[sLastZ]
    local tCurPos = {}
    if oUnit == nil then
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return 0
    elseif oUnit.Dead then
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return 0
    else
        if bIsPlatoonNotUnit then tCurPos = GetPlatoonFrontPosition(oUnit)
        else tCurPos = oUnit:GetPosition() end
        local iCyclesSinceMoved
        if iLastX == nil or iLastZ == nil then iCyclesSinceMoved = 0
        else
            if M27Utilities.GetDistanceBetweenPositions(tCurPos, { iLastX, 0, iLastZ }) <= iDistTreatedAsStuck then
                iCyclesSinceMoved = oUnit[sCyclesSinceMoved]
                if iCyclesSinceMoved == nil then iCyclesSinceMoved = 0 end
                iCyclesSinceMoved = iCyclesSinceMoved + 1
            else
                iCyclesSinceMoved = 0
            end
        end
        if iCyclesSinceMoved == 0 then
            oUnit[sLastX] = tCurPos[1]
            oUnit[sLastZ]= tCurPos[3]
        end
        oUnit[sCyclesSinceMoved] = iCyclesSinceMoved
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return iCyclesSinceMoved
    end
end

function IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPos, tCurDestination, iEnemySearchRadius, bAlsoRunFromEnemyStartLocation, iMinDistanceOverride, tOptionalNearbyEnemies)
    --Used for running away from enemies (if they have a threat rating)
    --iMinDistanceOverride - will default to 5, if our location is < this distance away, then will treat it as being too close to enemies
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsDestinationAwayFromNearbyEnemies'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if GetGameTimeSeconds() >= 985 then bDebugMessages = true end
    local bIsAwayFromNearbyEnemies = false
    local bStoppedLoop = false
    local tNearbyEnemies
    if M27Utilities.IsTableEmpty(tOptionalNearbyEnemies) then tNearbyEnemies = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryDangerousToLand, tCurPos, iEnemySearchRadius, 'Enemy')
    else tNearbyEnemies = EntityCategoryFilterDown(M27UnitInfo.refCategoryDangerousToLand, tOptionalNearbyEnemies)
    end
    local iClosestEnemyDist = 100000
    if tNearbyEnemies == nil then bIsAwayFromNearbyEnemies = true
    else
        if table.getn(tNearbyEnemies) == 0 then bIsAwayFromNearbyEnemies = true
        else
            --Filter to just show units with a threat rating:
            local tEnemiesWithThreat = {}
            for iCurUnit, oCurUnit in tNearbyEnemies do
                if M27Logic.GetCombatThreatRating(aiBrain, { oCurUnit}, false) > 0 then
                    table.insert(tEnemiesWithThreat, oCurUnit)
                end
            end
            if table.getn(tEnemiesWithThreat) == 0 then
                bIsAwayFromNearbyEnemies = true
                if bDebugMessages == true then LOG(sFunctionRef..': No enemies with threat so any location is away from enemies') end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Have nearby enemies with threat, so about to check if are moving away') end
                local tRunAwayComparisonPos = {}
                local iComparisonDistance = (iMinDistanceOverride or 5)
                if M27Utilities.GetDistanceBetweenPositions(tCurPos, tCurDestination) < iComparisonDistance then
                    if bDebugMessages == true then LOG(sFunctionRef..': Current destination is less than 5 from current position so will say we arent running from nearby enemy as want to refresh our action') end
                    --tRunAwayComparisonPos = tCurDestination
                    --MoveTowardsTarget(tStartPos, tTargetPos, iDistanceToTravel, iAngle)
                    bIsAwayFromNearbyEnemies = false
                else
                    tRunAwayComparisonPos =  M27Utilities.MoveTowardsTarget(tCurPos, tCurDestination, iComparisonDistance, 0)
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Only want to move iComparisonDistance='..iComparisonDistance..' along the current destination to see if its further from enemy; tRunAwayComparisonPos='..repru(tRunAwayComparisonPos)..'; will draw in red')
                        M27Utilities.DrawLocation(tRunAwayComparisonPos, nil, 2)
                    end
                    local iAngleToDestination = M27Utilities.GetAngleFromAToB(tCurPos, tCurDestination)
                    local iAngleToEnemy


                    local iDistFromComparison, iDistFromStart
                    local tUnitCurPos
                    bIsAwayFromNearbyEnemies = true
                    for iCurUnit, oCurUnit in tEnemiesWithThreat do
                        tUnitCurPos = oCurUnit:GetPosition()

                        iDistFromStart = M27Utilities.GetDistanceBetweenPositions(tCurPos, tUnitCurPos)
                        iDistFromComparison = M27Utilities.GetDistanceBetweenPositions(tRunAwayComparisonPos, tUnitCurPos)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering oCurUnit='..oCurUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oCurUnit)..'; iDistFromComparison='..iDistFromStart..'; iDistFromStart='..iDistFromStart..'; iComparisonDistance='..iComparisonDistance) end
                        if iDistFromStart <= math.min(5, iComparisonDistance - 1) or iDistFromComparison - iDistFromStart <= (iComparisonDistance * 0.65) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Not moving away from enemy oCurUnit='..oCurUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oCurUnit)..'; iDistFromStart='..iDistFromStart) end
                            bIsAwayFromNearbyEnemies = false
                            bStoppedLoop = true
                            break
                        else
                            iAngleToEnemy = M27Utilities.GetAngleFromAToB(tCurPos, oCurUnit:GetPosition())



                            if bDebugMessages == true then LOG(sFunctionRef..': iCurUnit='..iCurUnit..': iDistFromStart='..iDistFromStart..'; iDistFromComparison='..iDistFromComparison..'; iDistFromStart='..iDistFromStart) end
                            if iDistFromComparison < iDistFromStart or M27Utilities.GetAngleDifference(iAngleToEnemy, iAngleToDestination) <= 90 then --If changing angle threshold here then also change for the simpler 'away from nearest enemy' function after this function
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurUnit='..iCurUnit..': The location to run to is closer to this enemy than where the unit currently is') end
                                bIsAwayFromNearbyEnemies = false
                                bStoppedLoop = true
                                break
                                --[[elseif iDistFromStart < iClosestEnemyDist then

                                    iClosestEnemyDist = iDistFromStart

                                    if iClosestEnemyDist > iEnemySearchRadius then
                                        --No need to keep looking as this position is further away than we're interested in
                                        bStoppedLoop = true
                                        break
                                    end--]]
                            end
                        end

                    end
                    if not(bStoppedLoop) then bIsAwayFromNearbyEnemies = true end
                end
            end
        end
    end
    if bIsAwayFromNearbyEnemies == true then
        --Do we also want to be away from the enemy start?
        if bAlsoRunFromEnemyStartLocation == nil or bAlsoRunFromEnemyStartLocation == false then

            bIsAwayFromNearbyEnemies = true
        else
            if bDebugMessages == true then LOG('IsDestinationAwayFromEnemy: Is away from nearest enemy, checking if away from enemy start pos') end
            local bEnemyStartXLessThanTarget = false
            local bEnemyStartZLessThanTarget = false
            local bEnemyStartXLessThanOurs = false
            local bEnemyStartZLessThanOurs = false
            if M27Logic.GetNearestEnemyStartNumber(aiBrain) == nil then
                M27Utilities.ErrorHandler('M27Logic.GetNearestEnemyStartNumber(aiBrain)=nil')
            else
                local tEnemyStartPosition = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                if tEnemyStartPosition[1] < tCurDestination[1] then bEnemyStartXLessThanTarget = true end
                if tEnemyStartPosition[3] < tCurDestination[3] then bEnemyStartZLessThanTarget = true end
                if tEnemyStartPosition[1] < tCurPos[1] then bEnemyStartXLessThanOurs = true end
                if tEnemyStartPosition[3] < tCurPos[3] then bEnemyStartZLessThanOurs = true end
                if bEnemyStartXLessThanOurs == bEnemyStartXLessThanTarget and bEnemyStartZLessThanOurs == bEnemyStartZLessThanTarget then
                    if bDebugMessages == true then LOG('IsDestinationAwayFromEnemy: Is away from enemy start as well') end
                    bIsAwayFromNearbyEnemies = true
                else
                    if bDebugMessages == true then LOG('IsDestinationAwayFromEnemy: Isnt away from enemystart; tCurPos[1][3]='..tCurPos[1]..'-'..tCurPos[3]..'tCurDestination='..tCurDestination[1]..'-'..tCurDestination[3]..'; tEnemyStartPosition='..tEnemyStartPosition[1]..'-'..tEnemyStartPosition[3]) end
                    bIsAwayFromNearbyEnemies = false end
            end
        end
    else
        bIsAwayFromNearbyEnemies = false
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return bIsAwayFromNearbyEnemies
end


function IsDestinationAwayFromNearbyEnemy(tCurPos, tCurDestination, oNearestEnemy, bAlsoRunFromEnemyStartLocation)
    --Quicker but much more limited version of 'IsDestinationAwayFromNearbyEnemies' - will only consider the nearest enemy, and does very basic approach of just working out if we are further away with the destination (not how much further)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsDestinationAwayFromNearbyEnemy'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local tNearestEnemy = oNearestEnemy:GetPosition()

    local iAngleToDestination = M27Utilities.GetAngleFromAToB(tCurPos, tCurDestination)
    local iAngleToEnemy = M27Utilities.GetAngleFromAToB(tCurPos, tNearestEnemy)

    if M27Utilities.GetAngleDifference(iAngleToEnemy, iAngleToDestination) <= 90 then --If changing this test then also change for the above awayfromnearbyenemies function
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        if bDebugMessages == true then LOG(sFunctionRef..': Angle is less than 90 from nearest enemy') end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return false
    else
        --Does the current target move us away from the enemy in both directions? If so then dont change it
        local bXLessThanOurs = false
        local bZLessThanOurs = false
        local bTargetXLessThanOurs = false
        local bTargetZLessThanOurs = false


        if tCurPos[1] > tNearestEnemy[1] then bXLessThanOurs = true end
        if tCurPos[3] > tNearestEnemy[3] then bZLessThanOurs = true end
        if tCurPos[1] > tCurDestination[1] then bTargetXLessThanOurs = true end
        if tCurPos[3] > tCurDestination[3] then bTargetZLessThanOurs = true end
        if bDebugMessages == true then LOG(sFunctionRef..': Choosing location to run away to; tCurPos='..tCurPos[1]..'-'..tCurPos[3]) end
        if bDebugMessages == true then LOG('tNearestEnemy='..tNearestEnemy[1]..'-'..tNearestEnemy[3]) end
        if bDebugMessages == true then LOG('bTargetXLessThanOurs='..tostring(bTargetXLessThanOurs)..'; bTargetZLessThanOurs='..tostring(bTargetXLessThanOurs)) end
        if bTargetXLessThanOurs == bXLessThanOurs or bTargetZLessThanOurs == bZLessThanOurs then
            if bDebugMessages == true then LOG(sFunctionRef..': Isnt away from oNearestEnemy; tCurPos[1][3]='..tCurPos[1]..'-'..tCurPos[3]..'tNearestEnemy='..tNearestEnemy[1]..'-'..tNearestEnemy[3]..'; tCurDestination='..tCurDestination[1]..'-'..tCurDestination[3]) end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return false
        else
            if bAlsoRunFromEnemyStartLocation == nil or bAlsoRunFromEnemyStartLocation == false then
                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                return true
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Is away from nearest enemy, checking if away from enemy start pos') end
                local bEnemyStartXLessThanTarget = false
                local bEnemyStartZLessThanTarget = false
                local bEnemyStartXLessThanOurs = false
                local bEnemyStartZLessThanOurs = false
                local tEnemyStartPosition = M27MapInfo.PlayerStartPoints[oNearestEnemy:GetAIBrain().M27StartPositionNumber]
                if tEnemyStartPosition[1] < tCurDestination[1] then bEnemyStartXLessThanTarget = true end
                if tEnemyStartPosition[3] < tCurDestination[3] then bEnemyStartZLessThanTarget = true end
                if tEnemyStartPosition[1] < tCurPos[1] then bEnemyStartXLessThanOurs = true end
                if tEnemyStartPosition[3] < tCurPos[3] then bEnemyStartZLessThanOurs = true end
                if bEnemyStartXLessThanOurs == bEnemyStartXLessThanTarget and bEnemyStartZLessThanOurs == bEnemyStartZLessThanTarget then
                    if bDebugMessages == true then LOG(sFunctionRef..': Is away from enemy start as well') end
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                    return true
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Isnt awway from enemystart; tCurPos[1][3]='..tCurPos[1]..'-'..tCurPos[3]..'tCurDestination='..tCurDestination[1]..'-'..tCurDestination[3]..'; tEnemyStartPosition='..tEnemyStartPosition[1]..'-'..tEnemyStartPosition[3]) end
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                    return false
                end
            end
        end
    end
end


function MergePlatoons(oPlatoonToMergeInto, oPlatoonToBeMerged)
    --Adds all units from oPlatoonToBeMerged into oPlatoonToMergeInto unless they're dead or attached
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MergePlatoons'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of mergeplatoons, gametime='..GetGameTimeSeconds()) end
    --if oPlatoonToBeMerged:GetPlan() == 'M27AttackNearestUnits' or oPlatoonToMergeInto:GetPlan() == 'M27AttackNearestUnits' then if oPlatoonToBeMerged[refiPlatoonCount] == 86 or oPlatoonToMergeInto[refiPlatoonCount] == 86 then bDebugMessages = true end end
    --if oPlatoonToBeMerged:GetPlan() == 'M27PlateauScout' then bDebugMessages = true end
    local tMergingUnits = oPlatoonToBeMerged:GetPlatoonUnits()
    local tValidUnits = {}
    local bValidUnits = false
    local aiBrain = (oPlatoonToMergeInto[refoBrain] or oPlatoonToMergeInto:GetBrain())
    local oArmyPool = aiBrain:GetPlatoonUniquelyNamed('ArmyPool')
    if oPlatoonToMergeInto == oArmyPool then
        if bDebugMessages == true then LOG(sFunctionRef..': Will allocate merging units to idle platoons') end
        M27PlatoonFormer.AllocateUnitsToIdlePlatoons(aiBrain, tMergingUnits)
    else
        if bDebugMessages == true then LOG(sFunctionRef..': oPlatoonToMergeInto='..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..'; oPlatoonToBeMerged='..oPlatoonToBeMerged:GetPlan()..oPlatoonToBeMerged[refiPlatoonCount]) end
        for iCurUnit, oUnit in tMergingUnits do
            if not oUnit.Dead and not oUnit:IsUnitState('Attached') then
                if bDebugMessages == true then
                    if oUnit == M27Utilities.GetACU(aiBrain) then
                        LOG(sFunctionRef..': oPlatoon includes ACU; oPlatoonTo mergeInto plan='..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount])
                        if oPlatoonToBeMerged == aiBrain:GetPlatoonUniquelyNamed('ArmyPool') then LOG('oPlatoonToBeMerged is army pool')
                        else LOG('oPlatoonToBeMerged='..oPlatoonToBeMerged:GetPlan()..oPlatoonToBeMerged[refiPlatoonCount])
                        end
                    end
                end
                table.insert(tValidUnits, oUnit)
                bValidUnits = true
            end
        end
        if bValidUnits == true then
            if bDebugMessages == true then LOG(sFunctionRef..': have units in tMergingUnits; table.getn(tMergingUnits)='..table.getn(tMergingUnits)..'; oPlatoonToMergeInto:GetPlan()='..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..'-UC='..oPlatoonToMergeInto[refiPlatoonUniqueCount]) end
            if M27Config.M27ShowUnitNames == true then
                local sPlanOfNewPlatoon = oPlatoonToMergeInto:GetPlan()
                if sPlanOfNewPlatoon == nil then sPlanOfNewPlatoon = 'UnknownPlan' end
                local iPlanOfNewPlatoon = oPlatoonToMergeInto[refiPlatoonCount]
                if iPlanOfNewPlatoon == nil then iPlanOfNewPlatoon = 0 end
                UpdatePlatoonName(oPlatoonToBeMerged, 'MergeInto:'..sPlanOfNewPlatoon..iPlanOfNewPlatoon) end
            local sFormation = oPlatoonToMergeInto.PlatoonData.UseFormation
            if sFormation == nil then sFormation = 'GrowthFormation' end
            aiBrain:AssignUnitsToPlatoon(oPlatoonToMergeInto, tValidUnits, 'Attack', sFormation)
            --Reissue movement path to just these units
            if M27Utilities.IsTableEmpty(oPlatoonToMergeInto[reftMovementPath]) == false then
                MoveAlongPath(oPlatoonToMergeInto, oPlatoonToMergeInto[reftMovementPath], oPlatoonToMergeInto[refiCurrentPathTarget], false)
                ForceActionRefresh(oPlatoonToMergeInto)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Disbanding oPlatoonToBeMerged (UC='..oPlatoonToBeMerged[refiPlatoonUniqueCount]) end
    oPlatoonToBeMerged[refiCurrentAction] = refActionDisband

    oPlatoonToMergeInto[refiPlatoonMergeCount] = (oPlatoonToMergeInto[refiPlatoonMergeCount] or 0) + math.max(1, (oPlatoonToBeMerged[refiCurrentUnits] or 0)*0.5)
    oPlatoonToBeMerged[refiPlatoonMergeCount] = (oPlatoonToBeMerged[refiPlatoonMergeCount] or 0) + math.max(1, (oPlatoonToBeMerged[refiCurrentUnits] or 0)*0.5)
    if bDebugMessages == true then LOG(sFunctionRef..': End of code') end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetMergeLocation(oPlatoonToMergeInto, iPercentOfWayToDestination)
    --Returns a pathable location as close to iPercentOfWayToDestination% of the way to oPlatoonToMergeInto's first movement path position as possible, or nil if a pathable location can't be found
    --iPercentOfWayToDestination - default 0.4; % of the way between current location and target location; suggested <=0.5
    --Returns the platoon current position if an error occurs
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMergeLocation'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoonToMergeInto:GetPlan() == 'M27LargeAttackForce' then bDebugMessages = true end
    local iDistanceFactor
    if iPercentOfWayToDestination == nil then iDistanceFactor = 0.4
    else iDistanceFactor = iPercentOfWayToDestination end
    local tCurPos = GetPlatoonFrontPosition(oPlatoonToMergeInto)
    local tTargetPos = oPlatoonToMergeInto[reftMovementPath][1]

    if bDebugMessages == true then LOG('about to get merge location; platoon to merge into='..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..'; Position of platoon to merge into='..repru(tCurPos)..' platoontomergeinto movement path='..repru(oPlatoonToMergeInto[reftMovementPath])) end
    local tBaseMergePosition = {}
    for iAxis = 1, 3 do
        if not(iAxis == 2) then tBaseMergePosition[iAxis] = tCurPos[iAxis] + (tTargetPos[iAxis] - tCurPos[iAxis]) * iDistanceFactor end
    end
    tBaseMergePosition[2] = GetTerrainHeight(tBaseMergePosition[1], tBaseMergePosition[3])
    --Check we can path here:
    local oPathingUnit = GetPathingUnit(oPlatoonToMergeInto)
    if oPathingUnit then
        if bDebugMessages == true then LOG(sFunctionRef..': platoon unit count='..table.getn(oPlatoonToMergeInto:GetPlatoonUnits())) end
        local iCurSegmentX, iCurSegmentZ = M27MapInfo.GetPathingSegmentFromPosition(tCurPos)
        local sPathing = M27UnitInfo.GetUnitPathingType(oPathingUnit)


        if oPathingUnit == nil or oPathingUnit.Dead or not(oPathingUnit.GetUnitId) then
            M27Utilities.ErrorHandler(oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..':'..sFunctionRef..': Pathing unit is nil or dead or has no unit Id')
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return tCurPos
        elseif sPathing == nil then
            M27Utilities.ErrorHandler(oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..':'..sFunctionRef..': sPathing is nil')
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return tCurPos
        else
            local iSegmentGroup = M27MapInfo.GetSegmentGroupOfTarget(sPathing, iCurSegmentX, iCurSegmentZ)
            local iMergePositionGroup, iMergeSegmentX, iMergeSegmentZ
            local tMergePosition = {}
            local iAttemptCount = 0
            local iDistanceMod = 0
            local iDistanceCount = 0
            local iXSign = 1
            local iZSign = 1
            if bDebugMessages == true then LOG('oPathingUnit='..oPathingUnit.UnitId..' sPathing='..sPathing..'; iCurSegmentXZ='..iCurSegmentX..'-'..iCurSegmentZ) end
            if iSegmentGroup == nil then
                M27Utilities.ErrorHandler(oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..': GetMergeLocation: iSegmentGroup is nil')
                if oPathingUnit == nil then LOG('oPathingUnilt is nil')
                else
                    if iCurSegmentX == nil then LOG('iCurSegmentX is nil')
                    else LOG('iCurSegmentX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ)
                    end
                end
                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                return tCurPos
            end
            local bNearbySegmentsSameGroup = false
            local iNearbySegmentSize = 1
            local iPlatoonUnits = oPlatoonToMergeInto[refiCurrentUnits]
            iNearbySegmentSize = math.ceil( iPlatoonUnits / 10)
            if iNearbySegmentSize >= 5 then iNearbySegmentSize = 5 end
            local iSegmentStart = -iNearbySegmentSize
            local iSegmentEnd = iNearbySegmentSize
            local iCount = 0
            while bNearbySegmentsSameGroup == false do
                iCount = iCount + 1 if iCount > 100 then M27Utilities.ErrorHandler('Infinite loop') break end
                --Modify position so are cycling between 4 corners of a square around the position that steadily increases in size
                if iAttemptCount == 0 then iDistanceMod = 0
                else
                    iDistanceCount = iDistanceCount + 1
                    if iDistanceMod == 0 then iDistanceMod = 1 end
                    if iDistanceCount > 4 then
                        iDistanceCount = 0
                        iDistanceMod = iDistanceMod * 2.
                    end
                    if iDistanceCount == 1 then iXSign = 1 iZSign = 1
                    elseif iDistanceCount == 2 then iXSign = 1 iZSign = -1
                    elseif iDistanceCount == 3 then iXSign = -1 iZSign = 1
                    elseif iDistanceCount == 4 then iXSign = -1 iZSign = -1 end
                end
                tMergePosition = {tBaseMergePosition[1] + iDistanceMod * iXSign, 0, tBaseMergePosition[3] + iDistanceMod * iZSign}
                iMergeSegmentX, iMergeSegmentZ = M27MapInfo.GetPathingSegmentFromPosition(tMergePosition)
                iMergePositionGroup = M27MapInfo.GetSegmentGroupOfTarget(sPathing, iMergeSegmentX, iMergeSegmentZ)
                iAttemptCount = iAttemptCount + 1
                if bDebugMessages == true then M27Utilities.DrawLocation(tMergePosition) end

                if iMergePositionGroup == iSegmentGroup then
                    --Are the nearby segments the same group?
                    bNearbySegmentsSameGroup = true
                    --Cycle from -1 to +1 segments (or -x/+x for larger platoon)
                    for iXMod = iSegmentStart, iSegmentEnd do
                        for iZMod = iSegmentStart, iSegmentEnd do
                            if not(M27MapInfo.GetSegmentGroupOfTarget(sPathing, iMergeSegmentX + iXMod, iMergeSegmentZ + iZMod) == iSegmentGroup) then bNearbySegmentsSameGroup = false break end
                        end
                        if bNearbySegmentsSameGroup == false then break end
                    end
                end
                if iAttemptCount > 32 then
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                    return nil
                end --Infinite loop protection
            end
            if tMergePosition[1] == nil or tMergePosition[3] == nil then
                M27Utilities.ErrorHandler(oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..': GetMergeLocation: tMergePosition is nil')
                if iMergePositionGroup == nil then LOG('iMergePositionGroup is nil')
                else LOG('iMergePositionGroup='..iMergePositionGroup) end
                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                return tCurPos
            else
                if iMergePositionGroup == iSegmentGroup then tMergePosition[2] = GetTerrainHeight(tMergePosition[1], tMergePosition[3]) end
                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                return tMergePosition
            end
        end
    end
end

function MergeWithPlatoonsOnPath(oPlatoonToMergeInto, sTargetPlatoonPlanName, bOnlyOnOurSideOfMap)
    --Cycle through all platoons using sTargetPlatoonPlanName and if they're <= same distance from the merge location (based on the first movement path point) then will merge with it
    --bOnlyOnOurSideOfMap - will ignore platoons closer to enemy base than our base if this is true
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MergeWithPlatoonsOnPath'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    if (oPlatoonToMergeInto[refiPlatoonMergeCount] or 0) < 5 then
        if bOnlyOnOurSideOfMap == nil then bOnlyOnOurSideOfMap = false end
        local aiBrain = (oPlatoonToMergeInto[refoBrain] or oPlatoonToMergeInto:GetBrain())
        local tFriendlyPlatoons = aiBrain:GetPlatoonsList()
        local bNearToPath, iCurDistFromMerge
        local tBasePlatoonPos = {}
        tBasePlatoonPos = GetPlatoonFrontPosition(oPlatoonToMergeInto)
        local tMergePosition = GetMergeLocation(oPlatoonToMergeInto, 0.35)
        oPlatoonToMergeInto[reftMergeLocation] = tMergePosition
        local tCurPlatoonPos = {}
        if M27Utilities.IsTableEmpty(tMergePosition) == false then
            local iCorePlatoonDistFromMerge = M27Utilities.GetDistanceBetweenPositions(tBasePlatoonPos, tMergePosition)
            local iArmyStartNumber = aiBrain.M27StartPositionNumber
            if M27Logic.GetNearestEnemyStartNumber(aiBrain) == nil then
                M27Utilities.ErrorHandler('M27Logic.GetNearestEnemyStartNumber(aiBrain) is nil')
            else
                if bDebugMessages == true then LOG(sFunctionRef..': getn(tFriendlyPlatoons)='..table.getn(tFriendlyPlatoons)) end
                for iCurPlan, oCurPlatoon in tFriendlyPlatoons do
                    if not(oCurPlatoon == oPlatoonToMergeInto) and (oCurPlatoon[refiPlatoonMergeCount] or 0) < 5 then
                        if oCurPlatoon:GetPlan() == sTargetPlatoonPlanName then
                            if not oCurPlatoon.UsingTransport and (oCurPlatoon[refiCurrentUnits] or 0) < (oPlatoonToMergeInto[refiCurrentUnits] or 0) then
                                --Check if near enough
                                bNearToPath = false
                                tCurPlatoonPos = GetPlatoonFrontPosition(oCurPlatoon)
                                iCurDistFromMerge = M27Utilities.GetDistanceBetweenPositions(tMergePosition, tCurPlatoonPos)
                                if iCurDistFromMerge <= iCorePlatoonDistFromMerge then
                                    if bOnlyOnOurSideOfMap == false then bNearToPath = true
                                    else
                                        --Check if closer to our start base than enemy
                                        if M27Utilities.GetDistanceBetweenPositions(tCurPlatoonPos, M27MapInfo.PlayerStartPoints[iArmyStartNumber]) <= M27Utilities.GetDistanceBetweenPositions(tCurPlatoonPos, M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)) then bNearToPath = true end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurPlatoonPos='..tCurPlatoonPos[1]..'-'..tCurPlatoonPos[3]..'; tBasePlatoonPos='..tBasePlatoonPos[1]..'-'..tBasePlatoonPos[3]..'; iCurDistFromMerge='..iCurDistFromMerge) end
                                if bNearToPath == true then
                                    if bDebugMessages == true then LOG(sFunctionRef..': oCurPlatoon '..oCurPlatoon:GetPlan()..oCurPlatoon[refiPlatoonCount]..' is near to a destination, about to merge with '..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]) end
                                    MergePlatoons(oPlatoonToMergeInto, oCurPlatoon) end
                            end
                        end
                    end
                end
            end
        else
            M27Utilities.ErrorHandler('Merge location is nil - only scenarios where expect this are if map has lots of water or impassable areas')
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ForceActionRefresh(oPlatoon, iMinGapBetweenForces)
    --Flags to force a refresh when choosing platoon action, if last refresh >=5 seconds ago
    if iMinGapBetweenForces == nil then iMinGapBetweenForces = 5 end
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForceActionRefresh'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local iTimeOfLastRefresh = oPlatoon[refiGameTimeOfLastRefresh]
    if iTimeOfLastRefresh == nil then iTimeOfLastRefresh = 2 end
    local iCurGameTime = GetGameTimeSeconds()
    if iTimeOfLastRefresh == true or iTimeOfLastRefresh== false then
        iTimeOfLastRefresh = 2
        if bDebugMessages == true then LOG(sFunctionRef..': Warning: Platoons iTimeOfLastRefresh was a boolean - logs enabled in case its in unexpected scenario.  This somehow happens when a new platoon is created using a unit that formed part of a prev platoon') end
    end

    if bDebugMessages == true then
        if oPlatoon[refiPlatoonCount] == nil then oPlatoon[refiPlatoonCount] = 0 end
        local sPlatoonRef
        if not(oPlatoon.GetPlan) then
            sPlatoonRef='NoPlan'
        else
            sPlatoonRef = oPlatoon:GetPlan()
        end
        sPlatoonRef = sPlatoonRef..oPlatoon[refiPlatoonCount]
        LOG(sFunctionRef..': iCurGameTime='..iCurGameTime..'; iLastForcedRefresh='..tostring(iTimeOfLastRefresh)..'; sPlatoonRef='..sPlatoonRef)
    end

    if iCurGameTime - iTimeOfLastRefresh >= iMinGapBetweenForces then
        oPlatoon[refbForceActionRefresh] = true
        oPlatoon[refiGameTimeOfLastRefresh] = iCurGameTime
        if bDebugMessages == true then LOG(sFunctionRef..': Updated time of last refresh, oPlatoon[refiGameTimeOfLastRefresh]='..oPlatoon[refiGameTimeOfLastRefresh]) end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

--[[function GetFollowerTargetPosition(oPlatoon)
    --oPlatoon should be the platoon that is following another platoon
    local tTargetPosition
    local oUnitToFollow,
    oPlatoonToFollow = oPlatoon[refoSupportHelperPlatoonTarget]
    if oPlatoonToFollow then
        tTargetPosition = GetPlatoonFrontPosition(oPlatoonToFollow)
    else
        oUnitToFollow = oPlatoon[refoSupportHelperUnitTarget]
        if oUnitToFollow and not(oUnitToFollow.Dead) then
            tTargetPosition = oUnitToFollow:GetPosition()
        else M27Utilities.ErrorHandler('Dont have a valid target')
        end
    end
    return tTargetPosition
end--]]

function IncreasePlatoonMovementPath(oPlatoon)
    --Increases current path by 1; done via function so can also add in extra logic like taking into account mexes that ACU is expected to be able to build on

    oPlatoon[refiCurrentPathTarget] = oPlatoon[refiCurrentPathTarget] + 1
    if oPlatoon[refbACUInPlatoon] == true and oPlatoon[refiCurrentPathTarget] <= table.getn(oPlatoon[reftMovementPath]) then
        M27EngineerOverseer.UpdateActionsForACUMovementPath(oPlatoon[reftMovementPath], oPlatoon:GetBrain(), M27Utilities.GetACU(oPlatoon:GetBrain()), oPlatoon[refiCurrentPathTarget])
    end
end

function HasPlatoonReachedDestination(oPlatoon)
    --Returns true if have reached current movement point destination, false otherwise

    --Have we reached the current move destination?
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HasPlatoonReachedDestination'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local sPlatoonName = oPlatoon:GetPlan()
    --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 1 then bDebugMessages = true end
    --if EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId) then bDebugMessages = true end
    --if oPlatoon[refbOverseerAction] == true then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauLandCombat' then bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for platoon '..sPlatoonName..oPlatoon[refiPlatoonCount]..'; Current path number='..(oPlatoon[refiCurrentPathTarget] or 'nil')..'; oPlatoon[refiOverrideDistanceToReachDestination]='..(oPlatoon[refiOverrideDistanceToReachDestination] or 'nil')) end
    local iCurrentUnits = oPlatoon[refiCurrentUnits]
    if iCurrentUnits == nil then
        oPlatoon[refiCurrentUnits] = table.getn(oPlatoon:GetPlatoonUnits())
        iCurrentUnits = oPlatoon[refiCurrentUnits] end
    local iReachedTargetDist
    if oPlatoon[refiOverrideDistanceToReachDestination] == nil then
        local iBase = 7
        if oPlatoon[refiBuilders] > 0 then iBase = 3 end --redundancy - have put this in the platoon initial setup as well
        iReachedTargetDist = iBase + iCurrentUnits * 0.25
        if oPlatoon[refoFrontUnit].GetBlueprint then
            local oFrontBP = oPlatoon[refoFrontUnit]:GetBlueprint()
            iReachedTargetDist = iReachedTargetDist + math.max((oFrontBP.SizeX or 0), (oFrontBP.SizeZ or 0))
        end
        if iReachedTargetDist > 25 then iReachedTargetDist = 25 end
        if sPlatoonName == 'M27GroundExperimental' then
            local aiBrain = oPlatoon:GetBrain()
            if M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) < aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] then
                iReachedTargetDist = iReachedTargetDist + 40
            else iReachedTargetDist = iReachedTargetDist + 20
            end
        end
    else
        iReachedTargetDist = oPlatoon[refiOverrideDistanceToReachDestination]
    end
    --E.g. ACU might go near hydro (3.5 away fro mit) and only treat as reached destination at distance of 3; this should avoid that without messing up logic for getting near mexes
    if iReachedTargetDist < 5 and oPlatoon[refoFrontUnit] and M27Logic.IsUnitIdle(oPlatoon[refoFrontUnit], false, false, true) then
        iReachedTargetDist = 5
    end

    if oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]] == nil then
        --Rare error - debug messages and backup put in place for when this occurs
        M27Utilities.ErrorHandler(sPlatoonName..oPlatoon[refiPlatoonCount]..sFunctionRef..': oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]] is nil; iCurrentUnits='..iCurrentUnits..'; will print further details to log after this error message, and will assume have reached destination')
        --Print info to log so easier to ID issue
        if oPlatoon[reftMovementPath] == nil then
            LOG('reftMovementPath is nil, will disband platoon')
            oPlatoon[refiCurrentAction] = refActionDisband
        else

            local iMoveTableSize = table.getn(oPlatoon[reftMovementPath])
            LOG('reftMovementPath table size='..iMoveTableSize)
        end
        --Output prior actions:
        local sPrevAction = ''
        for iCount, iPrevActionRef in oPlatoon[reftPrevAction] do
            sPrevAction = sPrevAction .. iPrevActionRef .. '-'
        end
        LOG('sPrevAction='..sPrevAction)

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return true
        --[[
        if oPlatoon[refiCurrentPathTarget] == nil then LOG('refiCurrentPathTarget is nil') else LOG('refiCurrentPathTarget='..oPlatoon[refiCurrentPathTarget]) end
        if oPlatoon[reftMovementPath] == nil then
            LOG('reftMovementPath is nil, will disband platoon')
            oPlatoon[refiCurrentAction] = refActionDisband
        else

            local iMoveTableSize = table.getn(oPlatoon[reftMovementPath])
            LOG('reftMovementPath table size='..iMoveTableSize)
            --Try to fix:
            if iMoveTableSize > 0 then
                LOG('tMovementPath repr='..repru(oPlatoon[reftMovementPath]))
                if oPlatoon[refiCurrentPathTarget] > iMoveTableSize then oPlatoon[refiCurrentPathTarget] = iMoveTableSize end
                --]]
                --if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]) == true then
        --[[
                    if iMoveTableSize == 0 then
                        LOG('MoveTableSize is 0 so disbanding')
                        oPlatoon[refiCurrentAction] = refActionDisband
                    else
                        oPlatoon[refiCurrentPathTarget] = oPlatoon[refiCurrentPathTarget] - 1
                    end
                end
            else LOG('reftMovementPath size isnt >0, disbanding platoon')
                oPlatoon[refiCurrentAction] = refActionDisband
            end
        end--]]
    end

    local iCurDistToTarget = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..sFunctionRef..': iCurDistToTarget='..iCurDistToTarget..'; iReachedTargetDist='..iReachedTargetDist..'; GetPlatoonFrontPosition(oPlatoon)='..repru(GetPlatoonFrontPosition(oPlatoon))..'; oPlatoon[refiCurrentPathTarget]='..oPlatoon[refiCurrentPathTarget]..'; Movement path='..repru(oPlatoon[reftMovementPath])) end
    if iCurDistToTarget <= iReachedTargetDist then
        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..sFunctionRef..': Are close enough to the target, iCurDistToTarget='..iCurDistToTarget..'; iReachedTargetDist='..iReachedTargetDist..'; Movement path='..repru(oPlatoon[reftMovementPath])..'; movement target='..repru(oPlatoon[refiCurrentPathTarget])..'; platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))) end
        --oPlatoon[refiCurrentPathTarget] = oPlatoon[refiCurrentPathTarget] + 1
        --[[if oPlatoon[refiCurrentPathTarget] > table.getn(oPlatoon[reftMovementPath]) then
            oPlatoon[refiCurrentPathTarget] = table.getn(oPlatoon[reftMovementPath])
            oPlatoon[refiCurrentAction] = refActionNewMovementPath
        end--]]
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return true
    else
        if bDebugMessages == true then
            LOG(sFunctionRef..': We havent reached our current target destination yet, will draw blue for our current target and red for the remaining targets in the intel path. Current path target='..oPlatoon[refiCurrentPathTarget]..'; movement path including earlier paths='..repru(oPlatoon[reftMovementPath]))
            M27Utilities.DrawLocation(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], nil, 1, 100)
            if table.getn(oPlatoon[reftMovementPath]) > oPlatoon[refiCurrentPathTarget] then
                for iPath = oPlatoon[refiCurrentPathTarget], table.getn(oPlatoon[reftMovementPath]) do
                    M27Utilities.DrawLocation(oPlatoon[reftMovementPath][iPath], nil, 2, 100)
                end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return false end
end

function DeterminePlatoonCompletionAction(oPlatoon)
    --Updates oPlatoon's action if have completed movement path
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DeterminePlatoonCompletionAction'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
    local sPlatoonName = oPlatoon:GetPlan()
    --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 1 then bDebugMessages = true end
    --if sPlatoonName == 'M27GroundExperimental' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
    --if oPlatoon[refbOverseerAction] == true then bDebugMessages = true end
    --if sPlatoonName == 'M27CombatPatrolAI' then bDebugMessages = true end
    --if sPlatoonName == 'M27IndirectDefender' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauLandCombat' then bDebugMessages = true end

    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Determining platoon completion action') end
    --Intel path use special logic since expect them to remain at destination
    if sPlatoonName == M27Overseer.sIntelPlatoonRef then
        oPlatoon[refiCurrentPathTarget] = table.getn(oPlatoon[reftMovementPath])
        oPlatoon[refiCurrentAction] = refActionMoveInCircle
    else
        if oPlatoon[M27PlatoonTemplates.refbDisbandIfReachDestination] == true then
            if bDebugMessages == true then LOG(sFunctionRef..': Platoon set to disband if reaches destination so will disband') end
            oPlatoon[refiCurrentAction] = refActionDisband
        else
            if sPlatoonName == 'M27SuicideSquad' then
                --Are we near base? If not then presumably movement path was set to a nearby enemy
                if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) > 50 then
                    oPlatoon[refiCurrentAction] = refActionNewMovementPath
                else
                    --Are there any enemies within 250 of our base which can be pathed to by land? if so then attack-move to these
                    local tEnemyGroundNearBase = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryMobileLand, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], 250, 'Enemy')
                    if M27Utilities.IsTableEmpty(tEnemyGroundNearBase) then
                        oPlatoon[refiCurrentAction] = refActionSuicide
                    else
                        --Have enemies, see if can path to the nearest one
                        local oNearestEnemy = M27Utilities.GetNearestUnit(tEnemyGroundNearBase, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], aiBrain, nil, nil)
                        if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeLand, oNearestEnemy:GetPosition()) == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeLand, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) then
                            oPlatoon[reftMovementPath] = {[1] = oNearestEnemy:GetPosition()}
                            oPlatoon[refiCurrentPathTarget] = 1
                            oPlatoon[refiCurrentAction] = refActionReissueMovementPath
                        else
                            --Cant path to the nearest enemy, Move to first rally point if theyre within 100 of base though
                            if M27Utilities.GetDistanceBetweenPositions(oNearestEnemy:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) <= 100 then
                                oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                            else
                                oPlatoon[refiCurrentAction] = refActionSuicide
                            end
                        end
                    end
                end
            else
                --Have we previously run away?
                if oPlatoon[refbHavePreviouslyRun] == true then
                    --Default: New movement path.  Large attack platoons disband
                    if oPlatoon[M27PlatoonTemplates.refbDisbandAfterRunningAway] == true then
                    if bDebugMessages == true then LOG(sFunctionRef..': Disbanding large attack platoon as has reached destination and previously run') end
                    oPlatoon[refiCurrentAction] = refActionDisband
                    else oPlatoon[refiCurrentAction] = refActionNewMovementPath end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have previously run so will reset flag as reached destination') end
                    oPlatoon[refbHavePreviouslyRun] = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Flagging that we have no longer previously run since are getting new action') end
                    else
                    if bDebugMessages == true then LOG(sFunctionRef..': Havent previously run,, will use attack AI if flagged to attack once reach destination; '..tostring(oPlatoon[M27PlatoonTemplates.refbSwitchToAttackIfReachDestination])) end
                    --Default: New movement path.  Large attack platoons switch to attack AI (since we havent run away previously meaning we've presumably successfully reached our original target)
                    if oPlatoon[M27PlatoonTemplates.refbSwitchToAttackIfReachDestination] == true then
                        oPlatoon[refiCurrentAction] = refActionUseAttackAI
                    else oPlatoon[refiCurrentAction] = refActionNewMovementPath
                    end
                end
            end
        end
    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function RecordNearbyEnemyData(oPlatoon, iEnemySearchRadius, bPlatoonIsAUnit)
    --Updates the platoon to record details of nearby enemies
    --iEnemySearchRadius - used for mobile units (not structures)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordNearbyEnemyData'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local tCurPos = GetPlatoonFrontPosition(oPlatoon)
    local aiBrain, sPlatoonName
    local bAbort = false
    if bPlatoonIsAUnit then
        if oPlatoon.Dead or not (oPlatoon.GetUnitId) then
            bAbort = true
        else
            aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetAIBrain())
            sPlatoonName = oPlatoon.UnitId
        end
    else
        aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
        sPlatoonName = oPlatoon:GetPlan()
    end
    --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 1 then bDebugMessages = true end
    --if sPlatoonName == 'M27IndirectDefender' then bDebugMessages = true end
    --if sPlatoonName == 'M27MexLargerRaiderAI' and oPlatoon[refiPlatoonCount] == 5 and GetGameTimeSeconds() >= 465 then bDebugMessages = true end
    --if sPlatoonName == 'M27EscortAI' then bDebugMessages = true end
    --if sPlatoonName == 'M27CombatPatrolAI' then bDebugMessages = true end
    --if sPlatoonName == 'M27Skirmisher' and GetGameTimeSeconds() >= 30 then bDebugMessages = true end
    --if sPlatoonName == 'M27GroundExperimental' and M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) and oPlatoon[refiPlatoonMaxRange] >= 60 then bDebugMessages = true end

    if bAbort == false then
        local tNearbyEnemies
        oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures] = math.max(aiBrain[M27Overseer.refiSearchRangeForEnemyStructures], iEnemySearchRadius)

        --Skirmisher, combat patrol and ACU specific - increase search range to include T2 arti
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyArtiToAvoid]) == false then
            if oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] or sPlatoonName == 'M27CombatPatrolAI' or oPlatoon[refbACUInPlatoon] then
                oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures] = math.max(oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures], 135)
            end
        end

        --Include sera destroyers for high range platoons
        local bSeraDestroyerCheck = false

        oPlatoon[refiEnemySearchRadius] = iEnemySearchRadius
        --if oPlatoon[reftEnemiesInRange] == nil then oPlatoon[reftEnemiesInRange] = {} end
        local iMobileEnemyCategories = categories.LAND * categories.MOBILE
        if oPlatoon[refbPlatoonHasOverwaterLand] == true then
            iMobileEnemyCategories = categories.LAND * categories.MOBILE + categories.NAVAL * categories.MOBILE
        elseif oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] then
            iMobileEnemyCategories = iMobileEnemyCategories + M27UnitInfo.refCategoryNavalSurface
        elseif oPlatoon[M27PlatoonTemplates.refbRunFromAllEnemies] then
            if aiBrain[M27Overseer.refbEnemyHasSeraDestroyers] then
                iMobileEnemyCategories = categories.LAND * categories.MOBILE + M27UnitInfo.refCategoryNavalSurface + M27UnitInfo.refCategorySeraphimDestroyer
            else
                iMobileEnemyCategories = categories.LAND * categories.MOBILE + M27UnitInfo.refCategoryNavalSurface
            end
        elseif oPlatoon[refiPlatoonMaxRange] >= 30 then
            if aiBrain[M27Overseer.refbEnemyHasSeraDestroyers] then
                bSeraDestroyerCheck = true
                iMobileEnemyCategories = iMobileEnemyCategories + M27UnitInfo.refCategoryNavalSurface + M27UnitInfo.refCategorySeraphimDestroyer
            else
                iMobileEnemyCategories = iMobileEnemyCategories + M27UnitInfo.refCategoryNavalSurface
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Including naval surface in nearby enemies') end
        end




        tNearbyEnemies = aiBrain:GetUnitsAroundPoint(iMobileEnemyCategories, tCurPos, iEnemySearchRadius, 'Enemy')
        if bSeraDestroyerCheck and M27Utilities.IsTableEmpty(tNearbyEnemies) == false then
            local tSeraDestroyers = EntityCategoryFilterDown(M27UnitInfo.refCategorySeraphimDestroyer, tNearbyEnemies)
            local tDestroyersToExclude = {}
            if M27Utilities.IsTableEmpty(tSeraDestroyers) == false then
                for iUnit, oUnit in tSeraDestroyers do
                    if M27UnitInfo.IsUnitUnderwater(oUnit) then
                        table.insert(tDestroyersToExclude, oUnit)
                    end
                end
                if M27Utilities.IsTableEmpty(tDestroyersToExclude) == false then
                    local iLoopCount = 0
                    local bExcluded
                    while M27Utilities.IsTableEmpty(tDestroyersToExclude) == false do
                        bExcluded = false
                        iLoopCount = iLoopCount + 1
                        if iLoopCount >= 30 then
                            M27Utilities.ErrorHandler('Likely infinite loop')
                            break
                        end

                        for iDestroyer, oDestroyer in tDestroyersToExclude do
                            for iUnit, oUnit in tNearbyEnemies do
                                if oUnit == oDestroyer then
                                    table.remove(tNearbyEnemies, iUnit)
                                    table.remove(tDestroyersToExclude, iDestroyer)
                                    bExcluded = true
                                    break
                                end
                            end
                            if bExcluded then break end
                        end
                        if not(bExcluded) then break end --Infinite loop protection
                    end
                end
            end
        end
        if oPlatoon[refbACUInPlatoon] and oPlatoon[reftCurrentUnits][1][M27Overseer.refbInDangerOfBeingFlanked] and M27Utilities.IsTableEmpty(oPlatoon[reftCurrentUnits][1][M27Overseer.reftPotentialFlankingUnits]) == false then
            if not(tNearbyEnemies) then tNearbyEnemies = {} end
            for iUnit, oUnit in oPlatoon[reftCurrentUnits][1][M27Overseer.reftPotentialFlankingUnits] do
                if M27UnitInfo.IsUnitValid(oUnit) then
                    table.insert(tNearbyEnemies, oUnit)
                end
            end
        end
        if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyLandExperimentals]) == false then
            --Add land experimentals to skirmishers and ACU if not already in nearbyenemies - e.g. if recently seen monkeylord nearby and its briefly dropped out of intel
            for iUnit, oUnit in aiBrain[M27Overseer.reftEnemyLandExperimentals] do
                if M27UnitInfo.IsUnitValid(oUnit) and not(M27Utilities.CanSeeUnit(aiBrain, oUnit, true)) then
                    if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= math.max(iEnemySearchRadius, M27UnitInfo.GetNavalDirectAndSubRange(oUnit) + 20) then
                        table.insert(tNearbyEnemies, oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding experimental '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to nearby enemies for platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]) end
                    end
                end
            end
        end
        local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit])

        local iOurPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))
        local iIndirectRange = 0
        if oPlatoon[refiIndirectUnits] > 0 then
            iIndirectRange = oPlatoon[refiPlatoonMaxRange]
        end

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Platoon ' .. sPlatoonName .. (oPlatoon[refiPlatoonCount] or 'nil') .. '; iEnemySearchRadius=' .. iEnemySearchRadius .. '; Is table of nearby units empty=' .. tostring(M27Utilities.IsTableEmpty(tNearbyEnemies)))
        end
        if M27Utilities.IsTableEmpty(tNearbyEnemies) == true then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Are no enemies in range')
            end
            oPlatoon[refiEnemiesInRange] = 0
            oPlatoon[reftEnemiesInRange] = { }
        else
            --Rework the table to ignore units that are attached to a transport and units that we cant path to
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Have enemies in range, will exclude if their unit state is attached; size of table=' .. table.getn(tNearbyEnemies))
            end
            oPlatoon[refiEnemiesInRange] = 0
            oPlatoon[reftEnemiesInRange] = {}
            for iUnit, oUnit in tNearbyEnemies do
                if not (oUnit:IsUnitState('Attached')) then
                    --Can we path to the unit?  Or is it close enough to be in indirect fire range? Or is it a naval unit (relevant for those platoons that we want to consider navla units e.g. to run from)?
                    if EntityCategoryContains(categories.NAVAL, oUnit.UnitId) or iOurPathingGroup == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oUnit:GetPosition()) or (iIndirectRange > 0 and M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= iIndirectRange) then
                        oPlatoon[refiEnemiesInRange] = oPlatoon[refiEnemiesInRange] + 1
                        oPlatoon[reftEnemiesInRange][oPlatoon[refiEnemiesInRange]] = oUnit
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': enemy unit ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ' isnt attached so recording as an enemy in range; enemies in range=' .. oPlatoon[refiEnemiesInRange])
                        end
                    end
                end
            end
        end
        local iBuildingSearchRange = math.max(oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures], oPlatoon[refiPlatoonMaxRange] + 18)
        if (sPlatoonName == 'M27MexRaiderAI' or sPlatoonName == 'M27MexLargerRaiderAI') and iBuildingSearchRange < 60 and oPlatoon[refiPlatoonMaxRange] >= 18 then iBuildingSearchRange = 60 end

        tNearbyEnemies = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure - categories.BENIGN, tCurPos, math.max(oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures], iBuildingSearchRange), 'Enemy')
        if bDebugMessages == true then LOG(sFunctionRef..': Platoon '..sPlatoonName..oPlatoon[refiPlatoonCount]..' just searched for enemy buildings with a range of '..iBuildingSearchRange..'; is table empty='..tostring(M27Utilities.IsTableEmpty(tNearbyEnemies))) end


        if M27Utilities.IsTableEmpty(tNearbyEnemies) then
            oPlatoon[refiEnemyStructuresInRange] = 0
            oPlatoon[reftEnemyStructuresInRange] = {}
        else
            --Add any structures we can path to or which are in range of an indirect fire unit
            oPlatoon[refiEnemyStructuresInRange] = 0
            oPlatoon[reftEnemyStructuresInRange] = {}
            for iUnit, oUnit in tNearbyEnemies do
                if iOurPathingGroup == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oUnit:GetPosition()) or (iIndirectRange > 0 and M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= iIndirectRange) then
                    oPlatoon[refiEnemyStructuresInRange] = oPlatoon[refiEnemyStructuresInRange] + 1
                    oPlatoon[reftEnemyStructuresInRange][oPlatoon[refiEnemyStructuresInRange]] = oUnit
                end
            end
        end

        --Add enemy unseen T2 PD to enemy structures in range
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of unseen PD empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftUnseenPD]))) end
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftUnseenPD]) == false then
            local iSearchRange = math.max(60, oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures])
            for iUnit, oUnit in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftUnseenPD] do
                if not(M27UnitInfo.IsUnitValid) then
                    M27Team.tTeamData[aiBrain.M27Team][M27Team.reftUnseenPD][iUnit] = nil
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Distance between enemy PD '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' and us='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tCurPos)) end
                    if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tCurPos) <= iSearchRange then
                        table.insert(oPlatoon[reftEnemyStructuresInRange], oUnit)
                        oPlatoon[refiEnemyStructuresInRange] = oPlatoon[refiEnemyStructuresInRange] + 1
                        if bDebugMessages == true then LOG(sFunctionRef..': Added unit to list of structures in range. oPlatoon[refiEnemyStructuresInRange]='..oPlatoon[refiEnemyStructuresInRange]) end
                    end
                end
            end
        end

        if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] > 0 then
            --get all friendly units around a point for threat detection - use slightly larger area
            oPlatoon[reftFriendlyNearbyCombatUnits] = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandCombat, tCurPos, iEnemySearchRadius + 5, 'Ally')
            --Exclude combat units that are in a retreating platoon
            if M27Utilities.IsTableEmpty(oPlatoon[reftFriendlyNearbyCombatUnits]) == false then
                for iUnit, oUnit in oPlatoon[reftFriendlyNearbyCombatUnits] do
                    if oUnit.PlatoonHandle and oUnit.PlatoonHandle[M27PlatoonTemplates.refbRunFromAllEnemies] == true then
                        oPlatoon[reftFriendlyNearbyCombatUnits][iUnit] = nil
                    end
                end
            end

            --Record enemy indirect units that can see
            oPlatoon[reftVisibleEnemyIndirect] = M27Logic.GetVisibleUnitsOnly(aiBrain, EntityCategoryFilterDown(categories.INDIRECTFIRE, oPlatoon[reftEnemiesInRange]))
            if oPlatoon[reftVisibleEnemyIndirect] == nil then
                oPlatoon[refiVisibleEnemyIndirect] = 0
            else
                oPlatoon[refiVisibleEnemyIndirect] = table.getn(oPlatoon[reftVisibleEnemyIndirect])
            end
        end
        --Record nearest enemy to ACU (used by other platoons to decide if they should help out if theyre nearby)
        if oPlatoon[refbACUInPlatoon] == true and (oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange]) > 0 then
            local oMobileEnemyNearestACU, oStructureNearestACU
            local iNearestUnitDistance = 10000
            local oACUUnit = M27Utilities.GetACU(aiBrain)
            local tACUPosition = oACUUnit:GetPosition()
            if oPlatoon[refiEnemiesInRange] > 0 then
                oMobileEnemyNearestACU = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], tACUPosition, aiBrain, true)
                if oMobileEnemyNearestACU then
                    iNearestUnitDistance = M27Utilities.GetDistanceBetweenPositions(oMobileEnemyNearestACU:GetPosition(), tACUPosition)
                end
            end
            if oPlatoon[refiEnemyStructuresInRange] > 0 then
                oStructureNearestACU = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], tACUPosition, aiBrain, true)
                if oStructureNearestACU then
                    iNearestUnitDistance = math.min(iNearestUnitDistance, M27Utilities.GetDistanceBetweenPositions(oStructureNearestACU:GetPosition(), tACUPosition))
                end
            end
            oPlatoon[refiACUNearestEnemy] = iNearestUnitDistance
        else
            oPlatoon[refiACUNearestEnemy] = nil
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': ' .. sPlatoonName .. oPlatoon[refiPlatoonCount] .. ': iEnemySearchRadius=' .. iEnemySearchRadius .. '; iEnemiesInRange=' .. oPlatoon[refiEnemiesInRange] .. '; refiEnemyStructuresInRange=' .. oPlatoon[refiEnemyStructuresInRange] .. '; refiSearchRangeForEnemyStructure=' .. oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures])
            LOG('About to draw average platoon location')
            M27Utilities.DrawLocation(tCurPos, nil, 2, 50)
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function UpdatePlatoonActionIfStuck(oPlatoon)
    --Considers if oPlatoon is likely to be stuck, and if so then updates oPlatoon's action
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdatePlatoonActionIfStuck'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    --if oPlatoon[refbOverseerAction] == true then bDebugMessages = true LOG('UpdatePlatoonActionIfStuck: Start') end
    local sPlatoonName = oPlatoon:GetPlan()

    --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 1 and GetGameTimeSeconds() >= 660 then bDebugMessages = true end
    --if sPlatoonName == 'M27GroundExperimental' and oPlatoon[refiPlatoonCount] == 2 then bDebugMessages = true end
    --if sPlatoonName == 'M27ScoutAssister' then bDebugMessages = true end
    --if sPlatoonName == 'M27MAAAssister' then bDebugMessages = true end
    --if sPlatoonName == 'M27IndirectDefender' then bDebugMessages = true end
    --if sPlatoonName == 'M27LargeAttackForce' then bDebugMessages = true end
    --if sPlatoonName == 'M27CombatPatrolAI' and oPlatoon[refiPlatoonCount] == 4 and oPlatoon:GetBrain():GetArmyIndex() == 4 and GetGameTimeSeconds() >= 720 then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauLandCombat' then bDebugMessages = true end
    --if sPlatoonName == 'M27RAS' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for '..sPlatoonName..oPlatoon[refiPlatoonCount]..' at gametime='..GetGameTimeSeconds()) end

    local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
    local iNearTargetForSupport = 40 --if are within this range of destination then will ignore isstuck action)

    --Assister and Intel platoons - ignore if they're near their destination or destination isnt in the same pathing group
    local bIgnoreAssister = false
    local iAssisterDistanceFromDestination

    if oPlatoon[M27PlatoonTemplates.refbIgnoreStuckAction] == true then
        local tPlatoonPosition = GetPlatoonFrontPosition(oPlatoon)
        iAssisterDistanceFromDestination = M27Utilities.GetDistanceBetweenPositions(tPlatoonPosition, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
        if iAssisterDistanceFromDestination <= iNearTargetForSupport then
            bIgnoreAssister = true
        else
            --Not near target - however this is ok if we cant path to the target (e.g. land based MAA assisting ACU that is on island or underwater)
            local sPathing = M27UnitInfo.GetUnitPathingType(GetPathingUnit(oPlatoon))
            if not(M27MapInfo.GetSegmentGroupOfLocation(sPathing, tPlatoonPosition) == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])) then
                bIgnoreAssister = true
            end
        end
    end
    if bIgnoreAssister == false and not(M27MapInfo.bNoRushActive) then
        --Check we havent dealt damage in the last 5s
        if not(oPlatoon[refoFrontUnit][M27UnitInfo.refbRecentlyDealtDamage]) then
            --Check we're not busy reclaiming, building, upgrading:
            local bBusyBuildingOrReclaiming = false
            if bDebugMessages == true then
                LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': About to check if platoon is stuck; oPlatoon[refbConsiderMexes]='..tostring(oPlatoon[refbConsiderMexes])..'; platoon current action before running this:')
                if oPlatoon[refiCurrentAction] == nil then LOG('action is nil')
                else LOG('action is '..oPlatoon[refiCurrentAction]) end
            end
            if oPlatoon[refbConsiderMexes] == true then
                if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': Platoon considers building on mexes, will check unit state') end
                for iBuilder, oBuilder in oPlatoon[reftBuilders] do
                    if oBuilder:IsUnitState('Building') == true then bBusyBuildingOrReclaiming = true break end
                    if oBuilder:IsUnitState('Capturing') == true then bBusyBuildingOrReclaiming = true break end
                    if oBuilder:IsUnitState('Upgrading') == true then bBusyBuildingOrReclaiming = true break end
                    if oBuilder:IsUnitState('Repairing') == true then bBusyBuildingOrReclaiming = true break end
                    if oBuilder:IsUnitState('Guarding') == true then
                        --Get the unit being guarded, and see if its constructing something:
                        local oGuardedUnit = oBuilder:GetFocusUnit()
                        if oGuardedUnit and not(oGuardedUnit.Dead) then
                            if oGuardedUnit.GetFocusUnit then
                                local oPossibleBuilding = oGuardedUnit:GetFocusUnit()
                                if oPossibleBuilding and not(oPossibleBuilding.Dead) and oPossibleBuilding.GetFractionComplete then
                                    if oPossibleBuilding:GetFractionComplete() < 1 then
                                        bBusyBuildingOrReclaiming = true break
                                    end
                                end
                            end
                        end
                    end
                end


                if bBusyBuildingOrReclaiming == false then
                    if oPlatoon[refbConsiderReclaim] == true then
                        for iReclaimer, oReclaimer in oPlatoon[reftReclaimers] do
                            if oReclaimer:IsUnitState('Reclaiming') == true then bBusyBuildingOrReclaiming = true break end
                        end
                    end
                end
            end
            if bBusyBuildingOrReclaiming == false then
                --Check we arne't near a chokepoint (as might be sheltering here or defending it)
                if not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle) or M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), aiBrain[M27MapInfo.reftChokepointBuildLocation]) >= 50 then


                    --Check we dont have a temporary movement path order that is the current intel path, or a temporary movement path that are close to
                    local bHaveTemporaryIntelPathLocation = false
                    local bAreNearTemporaryMoveLocation = false
                    if oPlatoon[reftPrevAction][1] == refActionMoveToTemporaryLocation then
                        local tIntelPathLocation = aiBrain[M27Overseer.reftIntelLinePositions][aiBrain[M27Overseer.refiCurIntelLineTarget]][1]
                        if oPlatoon[reftTemporaryMoveTarget][1] == tIntelPathLocation[1] and oPlatoon[reftTemporaryMoveTarget][3] == tIntelPathLocation[3] then
                            --Are we close to this location?
                            if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[reftTemporaryMoveTarget]) <= 30 then
                                bHaveTemporaryIntelPathLocation = true
                            end
                        end
                        if bHaveTemporaryIntelPathLocation == false and M27Utilities.IsTableEmpty(oPlatoon[reftTemporaryMoveTarget]) == false then
                            if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[reftTemporaryMoveTarget]) <= math.max(6, oPlatoon[refiCurrentUnits]) then bAreNearTemporaryMoveLocation = true end
                        end
                    end
                    if bHaveTemporaryIntelPathLocation == false and bAreNearTemporaryMoveLocation == false then
                        --If indirect fire platoon whose action is to attack then dont treat as being stuck
                        local bIndirectAttacking = false
                        if oPlatoon[refiIndirectUnits] > 0 then
                            if oPlatoon[reftPrevAction] then
                                if oPlatoon[reftPrevAction][1] == refActionAttack or oPlatoon[reftPrevAction][1] == refActionAttackSpecificUnit then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Indirect fire platoon is attacking something so will ignore is stuck action') end
                                    bIndirectAttacking = true
                                end
                            end
                        end
                        if bIndirectAttacking == false then
                            --Escort specific exclusion
                            local bEscortingPlatoonAndNearIt = false
                            if oPlatoon[refoPlatoonOrUnitToEscort] and oPlatoon[refoPlatoonOrUnitToEscort].GetPlatoonPosition and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), GetPlatoonFrontPosition(oPlatoon[refoPlatoonOrUnitToEscort])) <= 20 then bEscortingPlatoonAndNearIt = true end
                            if bEscortingPlatoonAndNearIt == false then
                                --Are we near our destination and cant path to enemy base?
                                if not(not(aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand]) and (not(aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithAmphibious]) or M27UnitInfo.GetUnitPathingType(GetPathingUnit(oPlatoon, oPlatoon[refoPathingUnit], false))==M27UnitInfo.refPathingTypeLand) and HasPlatoonReachedDestination(oPlatoon)) then
                                    local iTriggerDistance = 5
                                    if oPlatoon[refbACUInPlatoon] then iTriggerDistance = 2.5 end
                                    local iCyclesSinceLastMoved = GetCyclesSinceLastMoved(oPlatoon, true, 5)
                                    local iCycleThreshold = 13
                                    if oPlatoon[refbHoverInPlatoon] then iCycleThreshold = iCycleThreshold + 5 end
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': UpdateActionIfStuck: iCyclesSinceLastMoved='..iCyclesSinceLastMoved..'; iCycleThreshold='..iCycleThreshold) end
                                    if iCyclesSinceLastMoved >= iCycleThreshold then
                                        if oPlatoon[refiCyclesForLastStuckAction] == nil then oPlatoon[refiCyclesForLastStuckAction] = 0 end
                                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': Reached threshold, will take action to unstick; iCyclesSinceLastMoved='..iCyclesSinceLastMoved..'; refiCyclesForLastStuckAction='..oPlatoon[refiCyclesForLastStuckAction]) end
                                        if iCyclesSinceLastMoved - oPlatoon[refiCyclesForLastStuckAction] >= iCycleThreshold then
                                            --Are we still stuck despite trying to get unstuck before?
                                            if oPlatoon[refiCyclesForLastStuckAction] >= iCycleThreshold * 6 and not(oPlatoon[M27PlatoonTemplates.refbIgnoreStuckAction]) and not(oPlatoon:GetPlan() == 'M27RetreatingShieldUnits') and not(oPlatoon:GetPlan() == 'M27MobileShield') and not(oPlatoon:GetPlan() == 'M27RAS') and oPlatoon[M27Transport.refiAssignedPlateau] == aiBrain[M27MapInfo.refiOurBasePlateauGroup] then
                                                --Are still stuck despite attempting to return to base; switch to attack AI
                                                if bDebugMessages == true then LOG(sFunctionRef..': Are still stuck despite attempting to return to base, will switch to attack AI') end
                                                M27Utilities.ErrorHandler('Platoon '..sPlatoonName..oPlatoon[refiPlatoonCount]..' has been stuck a while so switching to attack AI', true)
                                                oPlatoon[refiCurrentAction] = refActionUseAttackAI
                                            else
                                                --Still stuck despite trying preferred 'unstick' strategy; now try to return to base/rally point (unless are a defender)
                                                if oPlatoon[refiCyclesForLastStuckAction] >= iCycleThreshold * 3 then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have been stuck for 3x the cycle threshold now, will try moving to a random location (or disbanding if are indirect defender)') end
                                                    if sPlatoonName == M27Overseer.sDefenderPlatoonRef or sPlatoonName == 'M27IndirectDefender' then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Platoon is a defender and is very stuck so disbanding') end
                                                        oPlatoon[refiCurrentAction] = refActionDisband
                                                    else
                                                        oPlatoon[refiCurrentAction] = refActionGoToRandomLocationForAWhile
                                                        if bDebugMessages == true then LOG(sFunctionRef..': oPlatoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'want to move to random point when processing this action') end
                                                    end
                                                else
                                                    if oPlatoon[refiCyclesForLastStuckAction] >= iCycleThreshold * 2 and not(oPlatoon[refiEnemiesInRange] > 0) then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Trying second unstick action - go to nearest rally point') end
                                                        oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                                                    else
                                                        --First time the platoon is stuck; get preferred unsticking approach
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Not reached 2nd cycle threshold so will try initial unstick action subject to if been in combat recently') end

                                                        --Is the platoon in combat? If so it might be killing units hence why its not moving.  It might also be attacking cliffs
                                                        local bAttackingForAWhile = false
                                                        if not(oPlatoon[reftPrevAction] == nil) then
                                                            local iPrevActionCount = table.getn(oPlatoon[reftPrevAction])
                                                            if iPrevActionCount >= iCycleThreshold then
                                                                --Consider if all of the last iCycleThreshold actions have been attacking:
                                                                bAttackingForAWhile = true
                                                                for iPrevAction = 1, iPrevActionCount do
                                                                    if not(oPlatoon[reftPrevAction][iPrevAction] == refActionAttack) then
                                                                        if not(oPlatoon[reftPrevAction][iPrevAction] == nil) then
                                                                            bAttackingForAWhile = false
                                                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': UpdateActionIfStuck: bAttackingForAWhile just changed to false due to iPrevAction='..iPrevAction..'; iActionRef='..oPlatoon[reftPrevAction][iPrevAction]) end
                                                                            break
                                                                        end
                                                                    end
                                                                    if iPrevAction >= iCycleThreshold then break end
                                                                end
                                                            end
                                                        end

                                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': UpdateActionIfStuck: bAttackingForAWhile='..tostring(bAttackingForAWhile)..'; CyclesForLastStuckAction='..oPlatoon[refiCyclesForLastStuckAction]..'; iCyclesSinceLastMoved='..iCyclesSinceLastMoved) end
                                                        if bAttackingForAWhile == true and not(oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic]) then
                                                            if oPlatoon[refiDFUnits] > 0 then
                                                                oPlatoon[refiCurrentAction] = refActionMoveDFToNearestEnemy
                                                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': UpdateActionIfStuck: Been attacking for a while so will move DF to nearest enemy') end
                                                            else
                                                                --Move to a random location nearby (if cant find one then get a new movement path)
                                                                local tModPosition = {}
                                                                local iLoopCount = 0
                                                                local iMaxLoop = 10
                                                                local oPathingUnit = GetPathingUnit(oPlatoon)
                                                                if oPathingUnit then

                                                                    while M27Utilities.IsTableEmpty(tModPosition) == true do
                                                                        iLoopCount = iLoopCount + 1
                                                                        if iLoopCount > iMaxLoop then break end
                                                                        local iRandXFactor = math.random(0, 1)
                                                                        local iRandZFactor = math.random(0,1)
                                                                        local iRandXDistance = math.random(15,25)
                                                                        local iRandZDistance = math.random(15,25)
                                                                        if iRandXFactor == 1 then iRandXDistance = -iRandXDistance end
                                                                        if iRandZFactor == 1 then iRandZDistance = -iRandZDistance end
                                                                        tModPosition = GetPlatoonFrontPosition(oPlatoon)
                                                                        tModPosition[1] = tModPosition[1] + iRandXFactor
                                                                        tModPosition[3] = tModPosition[3] + iRandZFactor
                                                                        local rPlayableArea = M27MapInfo.rMapPlayableArea
                                                                        local iMapSizeX = rPlayableArea[3] - rPlayableArea[1]
                                                                        local iMapSizeZ = rPlayableArea[4] - rPlayableArea[2]
                                                                        if tModPosition[1] < rPlayableArea[1] + 1 then tModPosition[1] = rPlayableArea[1] + 1
                                                                        elseif tModPosition[1] > (iMapSizeX-1) then tModPosition[1] = iMapSizeX - 1 end
                                                                        if tModPosition[3] < rPlayableArea[2] + 1 then tModPosition[3] = rPlayableArea[2] + 1
                                                                        elseif tModPosition[3] > (iMapSizeZ - 1) then tModPosition[3] = iMapSizeZ - 1 end
                                                                        --GetPositionNearTargetInSamePathingGroup(tStartPos, tTargetPos, iDistanceFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions, bCheckAgainstExistingCommandTarget, iMinDistanceFromCurrentBuilderMoveTarget)
                                                                        --tModPosition = GetPositionNearTargetInSamePathingGroup(GetPlatoonFrontPosition(oPlatoon), tModPosition, 1, 0, oPathingUnit, 3, true, false, 0)
                                                                        --GetPositionAtOrNearTargetInPathingGroup(tStartPos, tTargetPos, iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
                                                                        tModPosition = GetPositionAtOrNearTargetInPathingGroup(GetPlatoonFrontPosition(oPlatoon), tModPosition, 1, 0, oPathingUnit, true, false)


                                                                    end
                                                                    if M27Utilities.IsTableEmpty(tModPosition) == false then
                                                                        oPlatoon[reftTemporaryMoveTarget] = tModPosition
                                                                        oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Setting temporary move location to'..repru(oPlatoon[reftTemporaryMoveTarget])) end
                                                                    else
                                                                        oPlatoon[refiCurrentAction] = refActionNewMovementPath
                                                                    end
                                                                else
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a pathing unit so likely that all units are dead') end
                                                                    oPlatoon[refiCurrentAction] = refActionDisband
                                                                end
                                                            end
                                                        else
                                                            --Have we just started attacking? If so then give slightly more time to do this
                                                            if oPlatoon[reftPrevAction][1] == refActionAttack then
                                                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': UpdateActionIfStuck: Recently started attacking so will give more time before stuck action') end
                                                                --Do nothing
                                                            else
                                                                --Are we moving along the path? If so skip the current path if we can
                                                                if oPlatoon[reftPrevAction][1] == refActionContinueMovementPath then
                                                                    if oPlatoon[refiCurrentPathTarget] < table.getn(oPlatoon[reftMovementPath]) then
                                                                        oPlatoon[refiCurrentPathTarget] = oPlatoon[refiCurrentPathTarget] + 1
                                                                        oPlatoon[refiCurrentAction] = refActionReissueMovementPath
                                                                    else
                                                                        --We're moving but we're already trying to reach the end destination - get new move orders
                                                                        --Exception - ACU defender - want to disband instead
                                                                        local bDisbandNotNewPath = false
                                                                        if oPlatoon[refbACUInPlatoon] and sPlatoonName == M27Overseer.sDefenderPlatoonRef then
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': sPlatoonName='..sPlatoonName..': Disbanding') end
                                                                            oPlatoon[refiCurrentAction] = refActionDisband
                                                                            bDisbandNotNewPath = true
                                                                        else
                                                                            --Exception - large attack AI That has run back to base and stuck near to base - want it to disband instead
                                                                            if oPlatoon[M27PlatoonTemplates.refbDisbandAfterRunningAway] == true then
                                                                                if oPlatoon[refbHavePreviouslyRun] == true then
                                                                                    --Are we relatively close to our start?
                                                                                    local tPlatoonPosition = GetPlatoonFrontPosition(oPlatoon)
                                                                                    if M27Utilities.GetDistanceBetweenPositions(tPlatoonPosition, M27MapInfo.PlayerStartPoints[M27Utilities.GetAIBrainArmyNumber(aiBrain)]) <= 50 then
                                                                                        bDisbandNotNewPath = true
                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': platoon is stuck-disbanding') end
                                                                                        oPlatoon[refiCurrentAction] = refActionDisband
                                                                                    end
                                                                                end
                                                                            end
                                                                        end
                                                                        if bDisbandNotNewPath == false then oPlatoon[refiCurrentAction] = refActionNewMovementPath end
                                                                    end
                                                                else

                                                                    --We're not moving along a path, and aren't attacking an enemy - do nothing for now
                                                                    --Are there nearby enemies? If so then attack them - decided to remove this due to risk of ACU attacking when its been told to ignore an attack order previously
                                                                    --also dont want action to continuemovementpath or else risk ignoring the 'have reached destination' logic

                                                                    --[[if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] > 0 then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Not moving along a path but have nearby enemies so will attack') end
                                                                        oPlatoon[refiCurrentAction] = refActionAttack
                                                                    else
                                                                        oPlatoon[refiCurrentAction] = refActionContinueMovementPath
                                                                    end--]]
                                                                end --Prev action refActionContinueMovementPath
                                                            end --Prev action refActionAttack
                                                        end --bAttackingForAWhile
                                                    end
                                                end
                                            end
                                            oPlatoon[refiCyclesForLastStuckAction] = iCyclesSinceLastMoved
                                            --Force a refresh in the platoon action (redundancy for unforseen impact of the 'ignore refresh' logic)
                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Stuck action forced refresh enabled') end
                                            ForceActionRefresh(oPlatoon)
                                        end
                                    elseif iCyclesSinceLastMoved > 2 then
                                        --Are we a DF platoon with enemies within range of the front unit of the platoon and our current shot is blocked?
                                        if bDebugMessages == true then LOG(sFunctionRef..sPlatoonName..oPlatoon[refiPlatoonCount]..': iCyclesSinceLastMoved='..iCyclesSinceLastMoved..'; will check if nearby enemies where shot is blocked') end
                                        local bNearbyEnemyWhereShotBlocked = false
                                        if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] > 0 and oPlatoon[refiDFUnits] > 0 and EntityCategoryContains(categories.DIRECTFIRE, oPlatoon[refoFrontUnit].UnitId) then
                                            if bDebugMessages == true then LOG('Our front unit is a DF unit, and has enemies nearby, will check if any are in its range and if so if its shot is blocked') end
                                            local iPlatoonRange = M27Logic.GetUnitMaxGroundRange({oPlatoon[refoFrontUnit]})
                                            local tNearbyEnemies = aiBrain:GetUnitsAroundPoint(categories.LAND + M27UnitInfo.refCategoryStructure, GetPlatoonFrontPosition(oPlatoon), iPlatoonRange, 'Enemy')
                                            if M27Utilities.IsTableEmpty(tNearbyEnemies) == false then
                                                local oNearestEnemy = M27Utilities.GetNearestUnit(tNearbyEnemies, GetPlatoonFrontPosition(oPlatoon), aiBrain, nil, nil)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Front unit='..oPlatoon[refoFrontUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit])..'; nearest enemy='..oNearestEnemy.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestEnemy)) end
                                                if M27Logic.IsShotBlocked(oPlatoon[refoFrontUnit], oNearestEnemy) then
                                                    if bDebugMessages == true then LOG('Shot is blocked so will set action to move DF to nearest enemy') end
                                                    oPlatoon[refiCurrentAction] = refActionMoveDFToNearestEnemy
                                                else
                                                    if bDebugMessages == true then LOG('Shot sint blocked so even though not moving will say we arent stuck') end
                                                    oPlatoon[refiCyclesForLastStuckAction] = 0
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            else
                oPlatoon[refiCyclesForLastStuckAction] = 0
            end
        else
            oPlatoon[refiCyclesForLastStuckAction] = 0
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': Platoon action following checking if stuck is:')
        if oPlatoon[refiCurrentAction] == nil then LOG('action is nil')
        else LOG('action is '..oPlatoon[refiCurrentAction]) end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code') end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetUnderwaterActionForLandUnit(oPlatoon)
    --Checks if platoon is underwater, and if so decides on action
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnderwaterActionForLandUnit'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon[refbACUInPlatoon] == true and GetGameTimeSeconds() >= 600 and oPlatoon:GetBrain():GetArmyIndex() == 4 then bDebugMessages = true end
    --if oPlatoon:GetPlan() == 'M27GroundExperimental' or oPlatoon[refoFrontUnit].UnitId == 'xsl0401' then bDebugMessages = true end
    --if oPlatoon:GetPlan() == 'M27RAS' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
    local iHeightAtWhichConsideredUnderwater = M27MapInfo.IsUnderwater(GetPlatoonFrontPosition(oPlatoon), true)
    local iMaxDistanceForLandSearch = math.max(20, oPlatoon[refiPlatoonMaxRange] * 0.5)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Checking if underwater; iHeightAtWhichConsideredUnderwater='..iHeightAtWhichConsideredUnderwater..'; Cur Position height='..GetPlatoonFrontPosition(oPlatoon)[2]..'; Surface height='..GetSurfaceHeight(GetPlatoonFrontPosition(oPlatoon)[1], GetPlatoonFrontPosition(oPlatoon)[3])..'; terrain height='..GetTerrainHeight(GetPlatoonFrontPosition(oPlatoon)[1], GetPlatoonFrontPosition(oPlatoon)[3])..'; Front unit position (if dif)='..repru(oPlatoon[refoFrontUnit]:GetPosition())..'; Front unit='..oPlatoon[refoFrontUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit])) end


    if GetPlatoonFrontPosition(oPlatoon)[2] < iHeightAtWhichConsideredUnderwater then
        if oPlatoon:GetPlan() == 'M27GroundExperimental' then
            if bDebugMessages == true then LOG(sFunctionRef..': Setting platoon to move instead of attackmove as are underwater') end
            oPlatoon[M27PlatoonTemplates.refbAttackMove] = false
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Are underwater, Checking if DF units in platoon') end
        if oPlatoon[refiDFUnits] > 0 then
            --Get blueprint for the first unit in the platoon that is underwater
            local oUnderwaterUnit
            if bDebugMessages == true then LOG(sFunctionRef..': Getting first amphibious unit in platoon') end
            for iUnit, oUnit in oPlatoon[reftDFUnits] do
                if M27UnitInfo.IsUnitUnderwaterAmphibious(oUnit) == true then
                    oUnderwaterUnit = oUnit
                    break
                end
            end
            if oUnderwaterUnit and not(oUnderwaterUnit.Dead) then
                --run away if we have nearby enemy units that have torpedos and we dont have antinavy in our platoon
                local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
                local iSearchRange = 80
                local tOurAntiNavy = EntityCategoryFilterDown(M27UnitInfo.refCategoryTorpedoLandAndNavy, GetPlatoonUnitsOrUnitCount(oPlatoon, reftCurrentUnits, false))
                --ACU - run if are in a pond with significant enemy antinaval threat
                local iPond = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, oUnderwaterUnit:GetPosition())

                if M27Utilities.IsTableEmpty(tOurAntiNavy) and EntityCategoryContains(categories.COMMAND, oUnderwaterUnit.UnitId) and (M27Team.tTeamData[aiBrain.M27Team][M27Team.refiEnemyNavalThreatByPond][iPond] or 0) >= 500 and M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond] ) == false and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.ANTINAVY * categories.MOBILE, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond])) == false  then
                    --ACU platoon and enemy has antinavy in this pond so just run
                    oPlatoon[refiCurrentAction] = refActionRun
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU has entered water with antinavy so want it to run') end
                else
                    local tNearbyAntiNavy = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryTorpedoLandAndNavy, oUnderwaterUnit:GetPosition(), iSearchRange, 'Enemy')

                    if M27Utilities.IsTableEmpty(tNearbyAntiNavy) == false and M27Utilities.IsTableEmpty(tOurAntiNavy) == true and not(oPlatoon:GetPlan() == 'M27GroundExperimental') then
                        oPlatoon[refiCurrentAction] = refActionRun
                        if bDebugMessages == true then LOG(sFunctionRef..': Need to run as enemy has nearby antinavy and we dont have anti navy, and we arent an experimental') end
                    else
                        --Do we have antinavy in our platoon, and the nearest enemy is on water? Then move towards nearest enemy
                        local bMoveToNearbyLand, tNearbyLandPosition, bAbort
                        if not(oPlatoon:GetPlan() == 'M27GroundExperimental') then
                            if M27Utilities.IsTableEmpty(tOurAntiNavy) == false and oPlatoon[refiEnemiesInRange] > 0 then
                                local oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                --Does the nearest enemy ahve hover?
                                if not(oNearestEnemy:GetBlueprint().Physics.MotionType == 'RULEUMT_Hover') then
                                    --Is the enemy unit underwater?
                                    local tNearestUnitPosition = oNearestEnemy:GetPosition()
                                    if GetSurfaceHeight(tNearestUnitPosition[1], tNearestUnitPosition[3]) <= iHeightAtWhichConsideredUnderwater and not(oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic]) then
                                        oPlatoon[refiCurrentAction] = refActionMoveDFToNearestEnemy
                                        bAbort = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': We have antinavy and nearest enemy unit doesnt have hover, so will move towards it') end
                                    end
                                end
                            end
                        end
                        if not(bAbort) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have amphibious unit, checking firing position') end
                            local tFiringPositionStart = M27Logic.GetDirectFireWeaponPosition(oUnderwaterUnit)
                            if tFiringPositionStart then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have firing position, checking if its below water') end
                                local iFiringHeight = tFiringPositionStart[2]
                                if iFiringHeight <= (iHeightAtWhichConsideredUnderwater + 0.2) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Gun is below water, checking if have reclaimers; refiReclaimers='..oPlatoon[refiReclaimers]) end

                                    --Do we contain reclaimers?
                                    if oPlatoon[refiReclaimers] > 0 then
                                        local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
                                        local oReclaimer = oPlatoon[reftReclaimers][1]
                                        if oReclaimer == nil or oReclaimer.Dead then
                                            M27Utilities.ErrorHandler('Reclaimer is nil or dead')
                                        else
                                            local iBuildDistance = oReclaimer:GetBlueprint().Economy.MaxBuildDistance
                                            local tNearbyEnemiesThatCanReclaim = aiBrain:GetUnitsAroundPoint(categories.RECLAIMABLE, GetPlatoonFrontPosition(oPlatoon), iBuildDistance + 10, 'Enemy')
                                            local oReclaimTarget
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have alive reclaimer in platoon, checking if enemy units nearby that can reclaim') end
                                            if M27Utilities.IsTableEmpty(tNearbyEnemiesThatCanReclaim) == false then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Are nearby enemies that can reclaim subject to fraction complete check') end
                                                local iCurDist
                                                local iClosestDist = 10000
                                                for iUnit, oUnit in tNearbyEnemiesThatCanReclaim do
                                                    if oUnit:GetFractionComplete() >= 1 then
                                                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                                        if iCurDist < iClosestDist then
                                                            iClosestDist = iCurDist
                                                            oReclaimTarget = oUnit
                                                        end
                                                    end
                                                end
                                                if M27UnitInfo.IsUnitValid(oReclaimTarget) then
                                                    local iDistanceToPlatoon = M27Utilities.GetDistanceBetweenPositions(oReclaimTarget:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a reclaim target, iDistanceToPlatoon='..iDistanceToPlatoon..'; iBuildDistance='..iBuildDistance) end
                                                    if iDistanceToPlatoon <= iBuildDistance then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Trying to target nearby enemy for reclaim') end
                                                        oPlatoon[refoNearbyReclaimTarget] = oReclaimTarget
                                                        oPlatoon[refiCurrentAction] = refActionReclaimTarget
                                                    else
                                                        --If we havent been trying to path to the reclaim target lots, then consider moving to it
                                                        if ReconsiderTarget(oPlatoon, oReclaimTarget:GetPosition(), true) then
                                                            --Not sure we can path to the target
                                                            bMoveToNearbyLand = false
                                                        else
                                                            --first see if nearby land that can move to
                                                            --GetNearestPathableLandPosition(oPathingUnit, tTravelTarget, iMaxSearchRange)
                                                            tNearbyLandPosition = M27MapInfo.GetNearestPathableLandPosition(oUnderwaterUnit, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], iMaxDistanceForLandSearch)
                                                            if M27Utilities.IsTableEmpty(tNearbyLandPosition) == false then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Have nearby land that can move to') end
                                                                bMoveToNearbyLand = true
                                                            else
                                                                if M27UnitInfo.IsUnitValid(oReclaimTarget) then
                                                                    --Reclaim the unit that is further away than our build distance
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': No nearby land so will move to enemy and try and reclaim') end
                                                                    oPlatoon[refoNearbyReclaimTarget] = oReclaimTarget
                                                                    oPlatoon[refiCurrentAction] = refActionReclaimTarget
                                                                end
                                                            end
                                                        end
                                                    end
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Are no nearby enemies that can reclaim') end
                                                end
                                            end
                                        end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': No reclaimers in our platoon.  If we have nearby antynavy enemies or enemies within our max range then will see if have nearby land') end
                                        if M27Utilities.IsTableEmpty(tNearbyAntiNavy) == false then
                                            tNearbyLandPosition = M27MapInfo.GetNearestPathableLandPosition(oUnderwaterUnit, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], iMaxDistanceForLandSearch)
                                            if M27Utilities.IsTableEmpty(tNearbyLandPosition) == false then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Nearby antinavy enemies and nearby land so will move there') end
                                                bMoveToNearbyLand = true
                                            end
                                        elseif oPlatoon[refiEnemiesInRange] > 0 then
                                            --Is the threat of mobile enemies sufficient to justify moving to land to attack them? (e.g. dont want an experimental chasing a T1 engineer)
                                            local tInRangeMobileThreat = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandCombat + M27UnitInfo.refCategoryIndirectT2Plus + M27UnitInfo.refCategoryNavalSurface, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refiPlatoonMaxRange], 'Enemy')
                                            local iEnemyMobileThreatMass = M27Logic.GetCombatThreatRating(aiBrain, tInRangeMobileThreat, true, nil, nil, false, true)
                                            if bDebugMessages == true then LOG(sFunctionRef..': iEnemyMobileThreatMass='..iEnemyMobileThreatMass..'; oPlatoon[refiPlatoonMassValue]='..oPlatoon[refiPlatoonMassValue]..'; will ignore very low threats relative to our mass value') end

                                            if iEnemyMobileThreatMass >= math.max(50, oPlatoon[refiPlatoonMassValue] * 0.04) then

                                                local oNearestMobileEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon))
                                                if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearestMobileEnemy:GetPosition()) < oPlatoon[refiPlatoonMaxRange] then
                                                    tNearbyLandPosition = M27MapInfo.GetNearestPathableLandPosition(oUnderwaterUnit, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], iMaxDistanceForLandSearch)
                                                    if M27Utilities.IsTableEmpty(tNearbyLandPosition) == false then
                                                        if bDebugMessages == true then
                                                            LOG(sFunctionRef..': Nearby mobile enemy '..oNearestMobileEnemy.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestMobileEnemy)..' withi nour max range of '..oPlatoon[refiPlatoonMaxRange]..' and nearby land so will move there.  Will draw the temporary target in white. Cur platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon)))
                                                            M27Utilities.DrawLocation(tNearbyLandPosition, false, 7)
                                                        end
                                                        bMoveToNearbyLand = true
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    if bMoveToNearbyLand == true then
                                        oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                                        oPlatoon[reftTemporaryMoveTarget] = tNearbyLandPosition
                                        if bDebugMessages == true then LOG(sFunctionRef..': Setting temporary move location to'..repru(oPlatoon[reftTemporaryMoveTarget])) end
                                    else
                                        if oPlatoon[refiCurrentAction] == nil then
                                            if bDebugMessages == true then LOG(sFunctionRef..': No action from main logic; if have nearby enemies and can path to them by land with no blocking cliff, and we have significantly more threat than them, and we arent an experimental platoon, then consider moving to them instead of continuing with movement path') end

                                            if not(oPlatoon:GetPlan() == 'M27GroundExperimental') and (oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange]) > 0 then
                                                local oNearestEnemyStructure
                                                local oNearestEnemyMobile
                                                local oNearestEnemyUnit
                                                if oPlatoon[refiEnemiesInRange] then oNearestEnemyMobile = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon)) end
                                                if oPlatoon[refiEnemyStructuresInRange] then oNearestEnemyStructure = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon)) end
                                                if not(oNearestEnemyStructure) then oNearestEnemyUnit = oNearestEnemyMobile
                                                elseif not(oNearestEnemyMobile) then oNearestEnemyUnit = oNearestEnemyStructure
                                                else
                                                    if M27Utilities.GetDistanceBetweenPositions(oNearestEnemyStructure:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) < M27Utilities.GetDistanceBetweenPositions(oNearestEnemyMobile:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) then
                                                        oNearestEnemyUnit = oNearestEnemyStructure
                                                    else
                                                        oNearestEnemyUnit = oNearestEnemyMobile
                                                    end
                                                end
                                                if oNearestEnemyUnit then
                                                    --Is the target in the same amphibious pathing group as us, and on land?
                                                    local sPathing = M27UnitInfo.refPathingTypeAmphibious
                                                    local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))
                                                    if iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oNearestEnemyUnit:GetPosition()) then
                                                        if not(M27UnitInfo.IsUnitUnderwater(oNearestEnemyUnit)) then
                                                            --If do a line to the enemy are we always in the same pathing group? (also require unit to be at least 2 away, or risk a larger unit than us showing as not underwater while we are; if had time better calculation would be to just see if we would be underwater at their position)
                                                            local iDistToEnemy = M27Utilities.GetDistanceBetweenPositions(oNearestEnemyUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                                            if iDistToEnemy >= 2 then
                                                                local iOurThreat = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits])
                                                                local iEnemyThreat = 0
                                                                if oPlatoon[refiEnemiesInRange] > 0 then iEnemyThreat = iEnemyThreat + M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemiesInRange]) end
                                                                if oPlatoon[refiEnemyStructuresInRange] > 0 then iEnemyThreat = iEnemyThreat + M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemyStructuresInRange]) end
                                                                if iOurThreat * 0.85 > iEnemyThreat then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': We can beat the enemy.  If either our last action was to move DF to nearest enemy, or we can apth in a straight line to them, then move to them if they are on land') end
                                                                    local iAngleToEnemy = M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), oNearestEnemyUnit:GetPosition())
                                                                    local bCanPathInLine = true
                                                                    for iCurDist = 2, math.floor(iDistToEnemy / 2) * 2, 2 do
                                                                        if not(iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(sPathing, M27Utilities.MoveInDirection(GetPlatoonFrontPosition(oPlatoon), iAngleToEnemy, iCurDist))) then
                                                                            bCanPathInLine = false
                                                                            break
                                                                        end
                                                                    end
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': bCanPathInLine='..tostring(bCanPathInLine)) end
                                                                    if bCanPathInLine then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': WIll move to the enemy unit as can path in a line and have enough threat') end
                                                                        oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                                                                        oPlatoon[reftTemporaryMoveTarget] = oNearestEnemyUnit:GetPosition()
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end

                                            if oPlatoon[refiCurrentAction] == nil then
                                                oPlatoon[refiCurrentAction] = refActionContinueMovementPath
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will just continue with our movement path') end
                                            end
                                        end
                                    end
                                end
                            else
                                M27Utilities.ErrorHandler('couldnt locate position value for direct fire weapon on oUnderwater unit '..oUnderwaterUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnderwaterUnit))
                            end
                        end
                    end
                end
            else
                M27Utilities.ErrorHandler('platoon is registered as having underwater amphibious units, but couldnt locate any with a direct fire weapon')
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': GetPlatoonFrontPosition(oPlatoon)[2]='..GetPlatoonFrontPosition(oPlatoon)[2]..'; terrain height='..GetTerrainHeight(GetPlatoonFrontPosition(oPlatoon)[1], GetPlatoonFrontPosition(oPlatoon)[3])..'; surface height='..GetSurfaceHeight(GetPlatoonFrontPosition(oPlatoon)[1], GetPlatoonFrontPosition(oPlatoon)[3])) end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function UpdatePlatoonActionForNearbyAirUnits(oPlatoon)
    local sFunctionRef = 'UpdatePlatoonActionForNearbyAirUnits'
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    --NOTE: Normal nearbyenemy logic also contains an override for MAA that will have them help out even if there are nearby ground threats they want to run from

    --In contrast to the main enemy logic, we dont update air unitls in the normal update for enemy data function for performance reasons, so update here
    oPlatoon[reftMAA] = EntityCategoryFilterDown(M27UnitInfo.refCategoryMAA, oPlatoon[reftCurrentUnits])
    if M27Utilities.IsTableEmpty(oPlatoon[reftMAA]) == false then
        local oMAA = oPlatoon[reftMAA][1]
        if not(M27UnitInfo.IsUnitValid(oMAA)) then
            oMAA = nil
            for iUnit, oUnit in oPlatoon[reftMAA] do
                if M27UnitInfo.IsUnitValid(oUnit) then
                    oMAA = oUnit
                    break
                end
            end
        end

        if oMAA then
            --Do we either have no action, or we are assisting the ACU and have mercies detected recently?
            local bConsiderAttacking = true
            local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
            if oPlatoon[refiCurrentAction] and aiBrain[M27AirOverseer.refbMercySightedRecently] then

                bConsiderAttacking = false
                if oPlatoon[refoSupportHelperUnitTarget] and M27Utilities.IsACU(oPlatoon[refoSupportHelperUnitTarget]) then
                    bConsiderAttacking = true
                elseif oPlatoon[refoSupportHelperPlatoonTarget] and oPlatoon[refoSupportHelperPlatoonTarget][refbACUInPlatoon] then
                    bConsiderAttacking = true
                elseif oPlatoon[refoPlatoonOrUnitToEscort] and oPlatoon[refoPlatoonOrUnitToEscort][refbACUInPlatoon] then
                    bConsiderAttacking = true
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Nearby enemies but will consider attacking air units anyway as mercies sighted recently, provided we are assisting the ACU. oPlatoon[refiCurrentAction]='..oPlatoon[refiCurrentAction]) end
            end
            if bConsiderAttacking then
                local iSearchRange = M27UnitInfo.GetUnitAARange(oPlatoon[reftMAA][1]) + oPlatoon[M27PlatoonTemplates.refiAirAttackRange]
                if aiBrain[M27AirOverseer.refbMercySightedRecently] then iSearchRange = iSearchRange + 30 end

                oPlatoon[reftEnemyAirNearby] = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryAirNonScout, GetPlatoonFrontPosition(oPlatoon), iSearchRange, 'Enemy')
                if M27Utilities.IsTableEmpty(oPlatoon[reftEnemyAirNearby]) == false then
                    --Are there mercies nearby? If so then move to the nearest one
                    oPlatoon[reftTemporaryMoveTarget] = nil
                    if aiBrain[M27AirOverseer.refbMercySightedRecently] then
                        local tNearbyMercies = EntityCategoryFilterDown(M27UnitInfo.refCategoryMercy, oPlatoon[reftEnemyAirNearby])
                        if M27Utilities.IsTableEmpty(tNearbyMercies) == false then
                            oPlatoon[reftEnemyAirNearby] = tNearbyMercies
                            if bDebugMessages == true then LOG(sFunctionRef..': Mercies detected nearby so will only consider these for MAA to attack') end
                        end
                    end
                    --Move to the nearest air unit
                    oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                    --GetPositionAtOrNearTargetInPathingGroup(tStartPos, tTargetPos, iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
                    oPlatoon[reftTemporaryMoveTarget] = GetPositionAtOrNearTargetInPathingGroup(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetNearestUnit(oPlatoon[reftEnemyAirNearby], GetPlatoonFrontPosition(oPlatoon), aiBrain, false, false):GetPosition(), math.min(iSearchRange - 5, 10), 0, oMAA, true, true, 5)
                    if bDebugMessages == true then
                        local oNearestEnemyAirUnit = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyAirNearby], GetPlatoonFrontPosition(oPlatoon), aiBrain, false, false)
                        LOG(sFunctionRef..': Nearest enemy air unit='..oNearestEnemyAirUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestEnemyAirUnit)..'; position='..repru(oNearestEnemyAirUnit:GetPosition())..'; Platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))..'; Setting temporary move target='..repru(oPlatoon[reftTemporaryMoveTarget])..'; Platoon action='..oPlatoon[refiCurrentAction])
                    end
                end
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function UpdatePlatoonActionForNearbyEnemies(oPlatoon, bAlreadyHaveAttackActionFromOverseer)
    --Decides what to do based on what enemies the platoon has recorded as being nearby
    --assumes RecordNearbyEnemyData has already been run
    --A number of different things get considered here - whether ACU is low on health and should run; whether we're underwater and can't hit the unit; whether we should issue an overcharge command; whether (for ACU) our shot is blocked; whether we should kite the enemy; and then the more conventional 'do we attack or run' based on enemy threat
    if bAlreadyHaveAttackActionFromOverseer == nil then bAlreadyHaveAttackActionFromOverseer = false end
    local iExistingAction = oPlatoon[refiCurrentAction]
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdatePlatoonActionForNearbyEnemies'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --ACU run away if low on health (regardless of whether enemies are in range, although put here since at some point will want T1 arti micro)
    local sPlatoonName = oPlatoon:GetPlan()
    local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
    local bProceed = true
    --if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) and EntityCategoryContains(M27UnitInfo.refCategoryIndirectT2Plus - categories.EXPERIMENTAL - M27UnitInfo.refCategorySniperBot, oPlatoon[refoFrontUnit].UnitId) and GetGameTimeSeconds() >= 1380 and oPlatoon[refiEnemyStructuresInRange] > 0 and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryPD * categories.TECH3, oPlatoon[reftEnemyStructuresInRange])) == false then bDebugMessages = true end
    --if oPlatoon[refbACUInPlatoon] == true and GetGameTimeSeconds() >= 600 and aiBrain:GetArmyIndex() == 5 then bDebugMessages = true M27Config.M27ShowUnitNames = true end
    --if sPlatoonName == 'M27Defender' and oPlatoon[refiPlatoonCount] == 7 and GetGameTimeSeconds() >= 570 then bDebugMessages = true end
    --if sPlatoonName == 'M27ScoutAssister' and oPlatoon[refiPlatoonCount] <= 2 then bDebugMessages = true end
    --if sPlatoonName == 'M27RAS' and oPlatoon[refiPlatoonCount] == 8 and GetGameTimeSeconds() >= 2400 then bDebugMessages = true end
    --if sPlatoonName == 'M27Skirmisher' and M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) and GetGameTimeSeconds() >= 300 and EntityCategoryContains(M27UnitInfo.refCategorySniperBot, oPlatoon[refoFrontUnit].UnitId) and oPlatoon[refiPlatoonCount] == 9 then bDebugMessages = true M27Config.M27ShowUnitNames = true M27Config.M27ShowEnemyUnitNames = true end
    --if sPlatoonName == 'M27ScoutAssister' and oPlatoon[refiPlatoonCount] == 2 then bDebugMessages = true end
    --if (oPlatoon:GetPlan() == 'M27GroundExperimental' or oPlatoon[refoFrontUnit].UnitId == 'xsl0401') then bDebugMessages = true end
    --if sPlatoonName == 'M27MAAAssister' and GetGameTimeSeconds() >= 240 and aiBrain:GetArmyIndex() == 4 and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true M27Config.M27ShowUnitNames = true end
    --if sPlatoonName == 'M27LargeAttackForce' then bDebugMessages = true end
    --if sPlatoonName == 'M27IntelPathAI' then bDebugMessages = true end
    --if sPlatoonName == 'M27IndirectDefender' then bDebugMessages = true end
    --if sPlatoonName == 'M27IndirectSpareAttacker' and (oPlatoon[refoFrontUnit] == 'dal0310' or oPlatoon[refiPlatoonCount] == 15) then bDebugMessages = true end
    --if sPlatoonName == 'M27MexRaiderAI' and oPlatoon[refiPlatoonCount] == 2 and GetGameTimeSeconds() >= 270 then bDebugMessages = true end
    --if sPlatoonName == 'M27MexLargerRaiderAI' and oPlatoon[refiPlatoonCount] == 2 and aiBrain:GetArmyIndex() == 2 and GetGameTimeSeconds() >= 420 then bDebugMessages = true end
    --if sPlatoonName == 'M27EscortAI' and oPlatoon[refiPlatoonCount] == 21 then bDebugMessages = true end
    --if sPlatoonName == 'M27CombatPatrolAI' and oPlatoon[refiPlatoonCount] == 4 and aiBrain:GetArmyIndex() == 4 and GetGameTimeSeconds() >= 720 then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauLandCombat' then bDebugMessages = true end
    --if sPlatoonName == 'M27MobileStealth' then bDebugMessages = true end
    --if sPlatoonName == 'M27MobileShield' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end


    if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonName..oPlatoon[refiPlatoonCount]..': Start of code at time '..GetGameTimeSeconds()..'; platoon action='..(oPlatoon[refiCurrentAction] or 'nil')..' Enemies in range='..oPlatoon[refiEnemiesInRange]..'; Structures in range='..oPlatoon[refiEnemyStructuresInRange]..'; platoon front position='..(oPlatoon[refoFrontUnit].UnitId or 'nil')..(M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit]) or 'nil')) end


    if sPlatoonName == 'M27MobileShield' then
        if M27Utilities.IsTableEmpty(GetSupportTargetLocation(oPlatoon)) or M27Utilities.GetDistanceBetweenPositions(GetSupportTargetLocation(oPlatoon), GetPlatoonFrontPosition(oPlatoon)) <= 60 then
            --Do nothing - either have no support platoon so something has gone wrong, or are near enough to our support platoon that we should ignore nearby enemies
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with mobile shield platoon, support target location is either nil or <=60, support location='..repru((GetSupportTargetLocation(oPlatoon) or {'nil'}))..'; Platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))) end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with mobile shield platoon that is far from support location, support target location='..repru(GetSupportTargetLocation(oPlatoon))..'; Platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))..'; distance='..M27Utilities.GetDistanceBetweenPositions(GetSupportTargetLocation(oPlatoon), GetPlatoonFrontPosition(oPlatoon))) end
            --Are far away from the unit we shoudl be shielding, so avoid nearby enemies with a combat threat
            local iEnemyThreat = 0
            if oPlatoon[refiEnemiesInRange] > 0 then
                iEnemyThreat = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemiesInRange], true, nil, nil, false, false)
            end
            if iEnemyThreat <= 50 then
                --Are there enmy PD in range?
                if oPlatoon[refiEnemyStructuresInRange] > 0 then
                    local tNearbyPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD, oPlatoon[reftEnemyStructuresInRange])
                    if M27Utilities.IsTableEmpty(tNearbyPD) == false then iEnemyThreat = iEnemyThreat + 300 end
                end
            end

            if iEnemyThreat > 50 then
                --Run from enemy
                oPlatoon[refiCurrentAction] = refActionRun
                if bDebugMessages == true then LOG(sFunctionRef..': iEnemyThreat='..iEnemyThreat..'( PD value is hardcoded); will run since distance to our support position='..M27Utilities.GetDistanceBetweenPositions(GetSupportTargetLocation(oPlatoon), GetPlatoonFrontPosition(oPlatoon))) end
            end

        end
        --Mobile shield normal platoon - will be assisting a unit so dont care about whether are nearby enemies, instead only care if shield is failing (handled via separate logic)
    elseif sPlatoonName == 'M27MobileStealth' then
        --Not interest in most threat logic in this function ,but do want to run if we wont be helping friendly units
        --Run if enemy within 26 of us, or if any enemy nearby and no friendly combat unit is within our stealth range and we are far from the unit we are meant to be stealthing

        function GetDistanceToSupportUnit(oPlatoon)
            local iDistToSupportUnit = 10000
            if oPlatoon[refoPlatoonOrUnitToEscort] then
                if oPlatoon[refoPlatoonOrUnitToEscort].UnitId then
                    if M27UnitInfo.IsUnitValid(oPlatoon[refoPlatoonOrUnitToEscort]) then iDistToSupportUnit = M27Utilities.GetDistanceBetweenPositions(oPlatoon[refoPlatoonOrUnitToEscort]:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) end
                else
                    if aiBrain:PlatoonExists(oPlatoon[refoPlatoonOrUnitToEscort]) then
                        iDistToSupportUnit = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon[refoPlatoonOrUnitToEscort]), GetPlatoonFrontPosition(oPlatoon))
                    end
                end
            end
            return iDistToSupportUnit
        end

        if oPlatoon[refiEnemiesInRange] > 0 then
            local oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon))
            local iDistToEnemy = M27Utilities.GetDistanceBetweenPositions(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
            if iDistToEnemy <= 30 then
                oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
            else
                --Enemies nearby but not very close - is the unit we're assisting close?
                if GetDistanceToSupportUnit(oPlatoon) >= 20 then
                    oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                elseif M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon[refoPlatoonOrUnitToEscort]), oNearestEnemy:GetPosition()) + 8 >= iDistToEnemy then
                    oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Dist to support unit='..GetDistanceToSupportUnit(oPlatoon)..'; iDistToEnemy='..iDistToEnemy) end
            end
        end
        if not(oPlatoon[refiCurrentAction]) and oPlatoon[refiEnemyStructuresInRange] then
            local tNearbyPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD, oPlatoon[reftEnemyStructuresInRange])
            if M27Utilities.IsTableEmpty(tNearbyPD) == false then
                local oNearestPD = M27Utilities.GetNearestUnit(tNearbyPD, GetPlatoonFrontPosition(oPlatoon))
                local iDistToEnemy = M27Utilities.GetDistanceBetweenPositions(oNearestPD:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                if iDistToEnemy <= 30 then
                    oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                elseif GetDistanceToSupportUnit(oPlatoon) >= 20 then
                    oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                elseif M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon[refoPlatoonOrUnitToEscort]), oNearestPD:GetPosition()) + 8 >= iDistToEnemy then
                    oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Dist to support unit='..GetDistanceToSupportUnit(oPlatoon)..'; iDistToEnemyPD='..iDistToEnemy) end
            end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking action for nearby enemies for mobile stealth, Current action='..(oPlatoon[refiCurrentAction] or 'nil')) end
    else
        --First do special 'run away' logic for units that the normal threat based and kiting approaches might not work properly for:

        --ACU RunAway logic (highest priority):
        if oPlatoon[refbACUInPlatoon] == true then
            local oACU = oPlatoon[reftBuilders][1]
            if bDebugMessages == true then LOG(sFunctionRef..': ACU in platoon, will consider if should run. Strategy='..(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] or 'nil')..'; Include ACU in all out attack='..tostring(aiBrain[M27Overseer.refbIncludeACUInAllOutAttack] or false)) end

            if M27Conditions.ACUShouldRunFromBigThreat(aiBrain) then
                if bDebugMessages == true then LOG(sFunctionRef..': ACU should run from a big threat') end
                oPlatoon[refiCurrentAction] = refActionReturnToBase
                if oACU and M27Conditions.CanUnitUseOvercharge(aiBrain, oACU) == true then
                    M27UnitMicro.GetOverchargeExtraAction(aiBrain, oPlatoon, oACU)
                end
                bProceed = false
            else
                --Are we turtling and near the chokepoint with at least 3 nearby T2 PD?  If so stay here
                if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), aiBrain[M27MapInfo.reftChokepointBuildLocation]) <= 15 and not(M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFirebaseUnitsByFirebaseRef][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]])) and table.getsize(aiBrain[M27EngineerOverseer.reftFirebaseUnitsByFirebaseRef][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]]) >= 3 then
                    --Ignore enemies
                    if bDebugMessages == true then LOG(sFunctionRef..': Are turtling and are near firebase so wont proceed with normal low health checks') end
                    bProceed = false
                elseif aiBrain[M27Overseer.refiDefaultStrategy] == M27Overseer.refStrategyTurtle and not(M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFirebaseUnitsByFirebaseRef][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]])) and table.getsize(aiBrain[M27EngineerOverseer.reftFirebaseUnitsByFirebaseRef][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]]) >= 8 and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), aiBrain[M27MapInfo.reftChokepointBuildLocation]) <= 15 and M27Logic.IsTargetUnderShield(aiBrain, oPlatoon[refoFrontUnit], 8000, false, false, false) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Arent turtling at the moment but are near firebase with lots of units and under a shield so will ignore normal low health checks') end
                    bProceed = false
                else
                    --Are we underwater without a gun upgrade? then consider getting an upgrade if we dont need any torp bombers, enemy either doesnt have air control or lacks t2 navy, and our ACU doesnt have gun
                    if not(aiBrain[M27Overseer.refiDefaultStrategy] == M27Overseer.refStrategyTurtle or aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyACUKill or aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyAirDominance) and M27UnitInfo.IsUnitUnderwater(oACU) and not(M27Conditions.DoesACUHaveUpgrade(aiBrain, oACU)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Underwater with no upgrade, will decide if want to get an upgrade') end
                        DecideWhetherToGetACUUpgrade(aiBrain, oPlatoon)
                        if bDebugMessages == true then LOG(sFunctionRef..': Action after checking if want upgrade='..(oPlatoon[refiCurrentAction] or 'nil')) end
                    end
                    if not(oPlatoon[refiCurrentAction]) then

                        --Run back to base if low health (unless are already near our base); reset movement path if regained health
                        if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyACUKill and aiBrain[M27Overseer.refbIncludeACUInAllOutAttack] and M27UnitInfo.IsUnitValid(aiBrain[M27Overseer.refoACUKillTarget]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Are trying to kill enemy ACU with our ACU so want to attack and ignore normal retreat logic') end
                            oPlatoon[refiCurrentAction] = refActionKillACU
                            bProceed = false
                        else
                            local iHealthToRunOn = aiBrain[M27Overseer.refiACUHealthToRunOn] or 5250
                            local iCurrentHealth = oACU:GetHealth()
                            --If have mobile shield coverage treat health as being 2k more than it is
                            if M27Conditions.HaveNearbyMobileShield(oPlatoon) then
                                iCurrentHealth = iCurrentHealth + 2000
                            end
                            if oPlatoon[refbNeedToHeal] == true then
                                --If worried about air snipe then only do this if ACU is within 75 of an air rally point or 150 of base
                                local bCapHealthToRunOn = true
                                if aiBrain[M27Overseer.refbACUVulnerableToAirSnipe] then
                                    local tAirRallyPoint = M27AirOverseer.GetAirRallyPoint(aiBrain)
                                    if M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), tAirRallyPoint) >= 75 and M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) >= 150 then
                                        bCapHealthToRunOn = false
                                    end
                                end
                                if bCapHealthToRunOn then
                                    iHealthToRunOn = math.max(6250, math.min(iHealthToRunOn + 750, oACU:GetMaxHealth() * 0.98))
                                else
                                    iHealthToRunOn = math.max(6250, iHealthToRunOn)
                                end
                            end
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Checking if ACU health is low enough that it should run.  refbNeedToHeal=' .. tostring(oPlatoon[refbNeedToHeal]) .. '; iHealthToRunOn=' .. iHealthToRunOn .. '; iCurrentHealth=' .. iCurrentHealth .. '; M27Overseer.iACUEmergencyHealthPercentThreshold=' .. M27Overseer.iACUEmergencyHealthPercentThreshold .. '; ACU health %=' .. M27UnitInfo.GetUnitHealthPercent(oACU))
                            end
                            if iCurrentHealth <= iHealthToRunOn then
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': ACU health is <= health to run on, so will say it needs to heal')
                                end
                                oPlatoon[refbNeedToHeal] = true
                                --If very low health run back to base, otherwise run back to nearest rally point
                                if M27UnitInfo.GetUnitHealthPercent(oACU) <= M27Overseer.iACUEmergencyHealthPercentThreshold then

                                    --Are we either within close dist to base, or close to a firebase?
                                    local iDistToFirebase
                                    if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFirebaseUnitsByFirebaseRef]) == false then iDistToFirebase = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27Logic.GetNearestFirebase(aiBrain, GetPlatoonFrontPosition(oPlatoon), true)) end
                                    --Are we already close to the base?
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': ACU needs to run, will check how close we are to base; Distance to base=' .. M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) .. '; M27Overseer.iDistanceFromBaseToBeSafe=' .. M27Overseer.iDistanceFromBaseToBeSafe..'; iDistToFirebase='..(iDistToFirebase or 'nil'))
                                    end
                                    if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) > M27Overseer.iDistanceFromBaseToBeSafe or (iDistToFirebase and iDistToFirebase <= 100 and iDistToFirebase >= 15) then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Will return to base; will check if want to use overcharge')
                                        end
                                        oPlatoon[refiCurrentAction] = refActionReturnToBase
                                        --Consider adding overcharge
                                        if oACU and M27Conditions.CanUnitUseOvercharge(aiBrain, oACU) == true then
                                            M27UnitMicro.GetOverchargeExtraAction(aiBrain, oPlatoon, oACU)
                                        end
                                        bProceed = false
                                    else
                                        --Do we have any T2 PD nearby that we can retreat behind?
                                        local tNearbyT2PD = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT2PlusPD, GetPlatoonFrontPosition(oPlatoon), 50, 'Ally')
                                        if M27Utilities.IsTableEmpty(tNearbyT2PD) == false then
                                            local oNearestPD
                                            local iNearestPDDist = 10000
                                            local iCurDist
                                            for iUnit, oUnit in tNearbyT2PD do
                                                if oUnit:GetFractionComplete() == 1 then
                                                    iCurDist = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition())
                                                    if iCurDist < iNearestPDDist then
                                                        iNearestPDDist = iCurDist
                                                        oNearestPD = oUnit
                                                    end
                                                end
                                            end
                                            if oNearestPD then
                                                oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                                                oPlatoon[reftTemporaryMoveTarget] = M27Utilities.MoveInDirection(oNearestPD:GetPosition(), M27Utilities.GetAngleFromAToB(oNearestPD:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]), 15, true)
                                                bProceed = false
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have a T2 PD nearby so will retreat behind that. Setting temporary move target accordingly to '..repru(oPlatoon[reftTemporaryMoveTarget])) end
                                            end
                                        end
                                        --Proceed with normal logic
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Are close to base and not near a firebase so will just do normal logic as if run now we lose our base anyway')
                                        end
                                    end
                                else

                                    --Are we close to the nearest rally point?  If facing air threat then want to retreat to base though
                                    local tNearestRallyPoint
                                    if bDebugMessages == true then LOG(sFunctionRef..': If are vulnerable to an air snipe and are more than 150 from base, will look for rally point nearest air rally point.  Dist to air rally point='..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27AirOverseer.GetAirRallyPoint(aiBrain))..'; Dist to base='..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])..'; aiBrain[M27Overseer.refbACUVulnerableToAirSnipe]='..tostring(aiBrain[M27Overseer.refbACUVulnerableToAirSnipe] or false)) end
                                    if aiBrain[M27Overseer.refbACUVulnerableToAirSnipe] and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) >= 150 then
                                        if aiBrain[M27AirOverseer.refbHaveAirControl] then
                                            --Do we have at least 4 AirAA units available?
                                            local iAirAAAvailable = 0
                                            if M27Utilities.IsTableEmpty(aiBrain[M27AirOverseer.reftAvailableAirAA]) == false then
                                                iAirAAAvailable = table.getn(aiBrain[M27AirOverseer.reftAvailableAirAA])
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': iAirAAAvailable='..iAirAAAvailable..'; Is table of available airaa empty='..tostring(M27Utilities.IsTableEmpty(aiBrain[M27AirOverseer.reftAvailableAirAA]))..'; aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat]='..aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat]) end
                                            if iAirAAAvailable >= 4 and aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat] >= 1200 then
                                                oPlatoon[refiCurrentAction] = refActionGoToRallyPointNearAir
                                                if bDebugMessages == true then LOG(sFunctionRef..': Basing rally point on the one nearest the air rally point') end
                                            else
                                                oPlatoon[refiCurrentAction] = refActionReturnToBase
                                                if bDebugMessages == true then LOG(sFunctionRef..': Dont have much available AirAA so will return to base to be safe') end
                                            end
                                        else
                                            oPlatoon[refiCurrentAction] = refActionReturnToBase
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will return to base') end
                                        end
                                        bProceed = false

                                        if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] > 0 then
                                            --Consider adding overcharge
                                            if oACU and M27Conditions.CanUnitUseOvercharge(aiBrain, oACU) == true then
                                                M27UnitMicro.GetOverchargeExtraAction(aiBrain, oPlatoon, oACU)
                                            end
                                        end

                                    else
                                        tNearestRallyPoint = M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit])


                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Not at emergency health yet, will see if have reached the nearest rally point yet; distance to it=' .. M27Utilities.GetDistanceBetweenPositions(tNearestRallyPoint, GetPlatoonFrontPosition(oPlatoon)))
                                        end
                                        if M27Utilities.GetDistanceBetweenPositions(tNearestRallyPoint, GetPlatoonFrontPosition(oPlatoon)) > 5 then

                                            --Are we close to the nearest rally point, with >=75% health, and close to our base? then dont set an action to run (as it may be e.g. we are just running to be prudent due to high eco)
                                            local iDistToBase = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Will go to nearest rally point unless we are close to base with decent health, checking if want to overcharge. M27UnitInfo.GetUnitHealthPercent(oACU)=' .. M27UnitInfo.GetUnitHealthPercent(oACU) .. '; Dist to base=' .. M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) .. '; Dist wanted=' .. math.min(150, math.max(M27Overseer.iDistanceFromBaseToBeSafe, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.25)) .. '; Dist to rally=' .. M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit]))..'; iDistToBase='..iDistToBase)
                                            end

                                            if M27UnitInfo.GetUnitHealthPercent(oACU) >= 0.8 and (iDistToBase <= math.min(150, math.max(M27Overseer.iDistanceFromBaseToBeSafe, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.25)) or M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tNearestRallyPoint) <= 20) and (oPlatoon[refiEnemyStructuresInRange] == 0 or M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryT2PlusPD, oPlatoon[reftEnemyStructuresInRange]))) then
                                                --Do nothing - proceed with normal logic
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef .. ': Have decent health, are near rally point and base, so will ignore the order to retreat and carry on with normal logic')
                                                end
                                                bProceed = true
                                            elseif iDistToBase <= math.min(35, math.max(M27Overseer.iDistanceFromBaseToBeSafe, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.25)) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Are near base so will proceed with normal logic') end
                                                bProceed = true
                                            else
                                                oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                                                --Consider adding overcharge
                                                if oACU and M27Conditions.CanUnitUseOvercharge(aiBrain, oACU) == true then
                                                    M27UnitMicro.GetOverchargeExtraAction(aiBrain, oPlatoon, oACU)
                                                end
                                                bProceed = false
                                            end
                                        else
                                            --Proceed with normal logic
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Are close to rally point so hopefully a bit safer now so will proceed with normal nearby enemy logic rather tahn running')
                                            end
                                            bProceed = true
                                        end
                                    end
                                end
                            else
                                oPlatoon[refbNeedToHeal] = false

                            end
                        end
                    else
                        bProceed = false
                    end
                end
            end

            --Always run if in protect ACU mode
            if bProceed == true then
                if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyProtectACU then
                    bProceed = false
                    oPlatoon[refiCurrentAction] = refActionRun
                    if bDebugMessages == true then LOG(sFunctionRef..': Are in protect ACU mode so will run') end
                elseif M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) > M27Overseer.iDistanceFromBaseToBeSafe then
                    if M27UnitInfo.GetUnitHealthPercent(oACU) <= 0.8 and oPlatoon[refiThreatWhenRetreatToRallyOrBase] >= M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits]) then
                        bProceed = false
                        oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont have more threat than when we last had to retreat to rally/base so will do a temporary retreat') end
                    else
                        --If we are ahead on eco and significant number of enemy threats, and we dont have mobile shield coverage or personal shield, then also consider retreating
                        if not(aiBrain[M27EconomyOverseer.refbBehindOnEco]) then
                            local iUpgradeCount = M27UnitInfo.GetNumberOfUpgradesObtained(oACU)
                            if iUpgradeCount <= 2 and oPlatoon[refiEnemiesInRange] >= (10 + iUpgradeCount) then
                                local iCurShield, iMaxShield = M27UnitInfo.GetCurrentAndMaximumShield(oPlatoon[refoFrontUnit], false)
                                if iCurShield <= 2000 then
                                    --Do we have mobile shield coverage?
                                    if not(M27Conditions.HaveNearbyMobileShield(oPlatoon)) then
                                        --Does the enemy have at least 500 combat threat and 5+ combat units? if so then retreat
                                        if M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemiesInRange]) >= 500 + iUpgradeCount * 300 then
                                            local tEnemyDFCombatUnits = EntityCategoryFilterDown(M27UnitInfo.refCategoryLandCombat, oPlatoon[reftEnemiesInRange])
                                            if M27Utilities.IsTableEmpty(tEnemyDFCombatUnits) == false and table.getn(tEnemyDFCombatUnits) >= 5 then
                                                bProceed = false
                                                oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                                if bDebugMessages == true then LOG(sFunctionRef..': Worried ACU might be overwhelmed so will temporarily retreat as we are ahead on eco') end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end

                end
            end

            --If not in ACU kill mode, and enemy ACU has upgrade, then prioritise getting an upgrade on our ACU unelss we're really close to enemy mexes that we can kill
            if bProceed and M27Team.tTeamData[aiBrain.M27Team][M27Team.refbEnemyTeamHasUpgrade] and M27UnitInfo.GetNumberOfUpgradesObtained(oACU) == 0 then
                local bNearbyEnemyMex = false
                local tNearbyEnemyMexes
                if oPlatoon[refiEnemyStructuresInRange] > 0 then
                    tNearbyEnemyMexes = EntityCategoryFilterDown(M27UnitInfo.refCategoryMex, oPlatoon[reftEnemyStructuresInRange])
                    if M27Utilities.IsTableEmpty(tNearbyEnemyMexes) == false and M27Utilities.GetDistanceBetweenPositions(M27Utilities.GetNearestUnit(tNearbyEnemyMexes, GetPlatoonFrontPosition(oPlatoon)):GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= 30 then
                        bNearbyEnemyMex = true
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy upgrading, do we have nearby enemy mex='..tostring(bNearbyEnemyMex)) end
                if not(bNearbyEnemyMex) then
                    bProceed = false
                    DecideWhetherToGetACUUpgrade(aiBrain, oPlatoon)
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy upgrading or has upgrade so want to get one, action after checking whether to get ACU upgrade as earlier action='..(oPlatoon[refiCurrentAction] or 'nil')..'; if no action then will retreat to nearest rally point') end
                    if not(oPlatoon[refiCurrentAction]) then oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint end
                end
            end




            --If have decided to run, retreat underwater if is water nearby on the way towards our base
            if bProceed == false and oPlatoon[refbNeedToHeal] and (oPlatoon[refiCurrentAction] == refActionRun or oPlatoon[refiCurrentAction] == refActionGoToNearestRallyPoint or oPlatoon[refiCurrentAction] == refActionGoToRallyPointNearAir or oPlatoon[refiCurrentAction] == refActionReturnToBase) then
                if oPlatoon[refiEnemiesInRange] > 0 and aiBrain:GetMapWaterRatio() >= 0.02 and M27UnitInfo.GetUnitHealthPercent(oACU) <= 0.75 and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) >= 100 then
                    --ACU wants to run, doesnt have great health, and has mobile enemies in range, while map has water on it - consider if want to retreat to water instead
                    --if GetGameTimeSeconds() >= 780 then bDebugMessages = true end

                    --Have we taken torp damage recently?
                    if not(oACU[M27Overseer.refoUnitDealingUnseenDamage]) or not(EntityCategoryContains(categories.ANTINAVY + categories.OVERLAYANTINAVY,oACU[M27Overseer.refoUnitDealingUnseenDamage].UnitId)) then
                        --Is there water near us that we can path to without obstruction, when considering locations that wont take us further from our base?

                        local iWaterSearchInterval = 8
                        local iMaxWaterSearchRange = iWaterSearchInterval * 6 --48
                        local tPlatoonPosition = GetPlatoonFrontPosition(oPlatoon)
                        local iBaseAngle = M27Utilities.GetAngleFromAToB(tPlatoonPosition, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                        local tPossibleLocation
                        local iAmountToBeUnderwater = oACU:GetBlueprint().SizeY
                        if bDebugMessages == true then LOG(sFunctionRef..': Will see if we have any water nearby that we can retreat to') end
                        local bFoundUnderwaterPosition = false
                        local iSegmentGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, tPlatoonPosition)


                        for iSearchDistance = iMaxWaterSearchRange, iWaterSearchInterval, -iWaterSearchInterval do
                            for iAngleAdjust = 0, 70, 35 do
                                for iAngleFactor = -1, 1, 1 do
                                    tPossibleLocation = M27Utilities.MoveInDirection(tPlatoonPosition, iBaseAngle + iAngleAdjust * iAngleFactor, iSearchDistance, true)
                                    tPossibleLocation[2] = GetTerrainHeight(tPossibleLocation[1], tPossibleLocation[3])
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Will draw location in red, terrain height='..GetTerrainHeight(tPossibleLocation[1], tPossibleLocation[3])..'; surface height='..GetSurfaceHeight(tPossibleLocation[1], tPossibleLocation[3]))
                                        M27Utilities.DrawLocation(tPossibleLocation, false, 2, 250, nil)
                                    end
                                    if M27MapInfo.IsUnderwater(tPossibleLocation, false, iAmountToBeUnderwater) then
                                        --Have somewhere to move to that is underwater, check if we can path there without obstruction
                                        bFoundUnderwaterPosition = true
                                        for iDistToWater = 2, math.floor(iSearchDistance / 2) * 2, 2 do
                                            if not(iSegmentGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, M27Utilities.MoveInDirection(tPlatoonPosition, iBaseAngle + iAngleAdjust * iAngleFactor, iDistToWater, true))) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': We cant path in a straight line there so will abort') end
                                                bFoundUnderwaterPosition = false
                                                break
                                            end
                                        end
                                        if bFoundUnderwaterPosition then
                                            oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                                            oPlatoon[reftTemporaryMoveTarget] = {tPossibleLocation[1], tPossibleLocation[2], tPossibleLocation[3]}
                                            oPlatoon[refbHavePreviouslyRun] = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will send ACU to temporary location that is underwater instead of retreating') end
                                        end
                                    end
                                    if iAngleAdjust == 0 then break end
                                    if bFoundUnderwaterPosition then break end
                                end
                                if bFoundUnderwaterPosition then break end
                            end
                            if bFoundUnderwaterPosition then break end
                        end
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iACUHealth='..oPlatoon[refoFrontUnit]:GetHealth()..'; finished checking if should run due to low health, bProceed='..tostring(bProceed)) end
            if bProceed == true then
                local bACUNeedsToRun = false
                --Have we recently taken damage from an unseen source?
                if bDebugMessages == true then
                    local iLastTimeTakenDamage = oACU[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage]
                    if iLastTimeTakenDamage == nil then iLastTimeTakenDamage = 0 end
                    LOG(sFunctionRef..': Checking last time ACU took unseen damage, iLastTimeTakenDamage='..iLastTimeTakenDamage..'; CurGameTime='..GetGameTimeSeconds())
                end

                if oACU[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage] and GetGameTimeSeconds() - oACU[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage] <= 25 then
                    local oUnseenDamageDealer = oACU[M27Overseer.refoUnitDealingUnseenDamage]
                    if oUnseenDamageDealer and not(oUnseenDamageDealer.Dead) and oUnseenDamageDealer.GetUnitId then
                        if M27Logic.GetUnitMaxGroundRange({oUnseenDamageDealer}) >= 35 or EntityCategoryContains(M27UnitInfo.refCategoryTorpedoLandAndNavy, oUnseenDamageDealer.UnitId) then
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU taken unseem damage from a unit with a range of at least 35 so want to run unless in ACU attack mode and enemy ACU has low health') end

                            bACUNeedsToRun = true
                        end
                    end
                end
                local tEnemyT2PlusPD
                if bACUNeedsToRun == false then
                    local bHaveMostMexes = false
                    if table.getn(M27EngineerOverseer.GetUnclaimedMexes(aiBrain, M27UnitInfo.refPathingTypeAmphibious, M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]), true, false, true)) < table.getn(M27MapInfo.tMexByPathingAndGrouping[M27UnitInfo.refPathingTypeAmphibious][M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])]) * 0.4 then
                        bHaveMostMexes = true
                    end
                    --Are we significantly outnumbered in threat and/or up against alot of T2+ PD and not near our base? (or T1 PD if we dont have gun)
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if ACU significantly outnumbered or lots of T2 PD nearby (or T1 if we dont have gun)') end
                    local iEnemyThreatRating = 0
                    --if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) > M27Overseer.iDistanceFromBaseToBeSafe then
                    local iCurShield, iMaxShield, iMaxHealth
                    if oPlatoon[refiEnemyStructuresInRange] > 0 then
                        local iPDSearchCategory
                        local bDoesACUHaveGun = M27Conditions.DoesACUHaveGun(aiBrain, false, oACU)
                        if bDoesACUHaveGun then iPDSearchCategory = M27UnitInfo.refCategoryT2PlusPD
                        else
                            iPDSearchCategory = M27UnitInfo.refCategoryPD
                        end
                        tEnemyT2PlusPD = EntityCategoryFilterDown(iPDSearchCategory, oPlatoon[reftEnemyStructuresInRange])

                        --Opti: First check we have nearby T2 PD (even if out of range of it), as if none then no point doing more intensive checks
                        if M27Utilities.IsTableEmpty(tEnemyT2PlusPD) == false then
                            local tEnemyFixedShields = EntityCategoryFilterDown(M27UnitInfo.refCategoryFixedShield, oPlatoon[reftEnemyStructuresInRange])
                            local iPDThreshold = 3
                            if bDoesACUHaveGun then
                                if M27Conditions.DoesACUHaveBigGun(aiBrain) then iPDThreshold = 5 end
                            else
                                iPDThreshold = 1 --If we dont have gun then want to run from all PD
                            end
                            if iPDThreshold > 1 then
                                iCurShield, iMaxShield = M27UnitInfo.GetCurrentAndMaximumShield(oACU)
                                iMaxHealth = 1
                                if M27UnitInfo.GetUnitHealthPercent(oACU) > 0 then iMaxHealth = oACU:GetHealth() / M27UnitInfo.GetUnitHealthPercent(oACU) end
                                if bDebugMessages == true then LOG(sFunctionRef..': ACU shield curhealth='..iCurShield..'; shield maxhealth='..iMaxShield..'; ACU health='..iMaxHealth) end
                                iMaxHealth = iMaxShield + iMaxHealth

                                if iMaxHealth >= 18000 and (iCurShield + oACU:GetHealth()) / iMaxHealth >= 0.75 then
                                    if iMaxHealth >= 30000 then
                                        iPDThreshold = iPDThreshold + 2
                                    else iPDThreshold = iPDThreshold + 1
                                    end
                                elseif iCurShield <= 1000 and oACU:GetHealth() <= 9000 then
                                    if oACU:GetHealth() <= 7000 then iPDThreshold = 1
                                    else iPDThreshold = math.min(2, iPDThreshold)
                                    end
                                end


                                if iPDThreshold > 1 then
                                    --If we have nearby T2+ indirect then reduce threshold to 1
                                    if M27Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryIndirectT2Plus, GetPlatoonFrontPosition(oPlatoon), 60, 'Ally')) then
                                        iPDThreshold = 1
                                    end
                                end
                            end
                            --Reduce threshold if we have most mexes on the map


                            if bHaveMostMexes then iPDThreshold = math.max(1, iPDThreshold - 1) end
                            if bDebugMessages == true then LOG(sFunctionRef..': iPDThreshold after increasing for health and big gun and reduing for low health='..iPDThreshold) end

                            --Reduce threshold if enemy ACU nearby
                            if M27Utilities.GetDistanceBetweenPositions(aiBrain[M27Overseer.reftLastNearestACU], GetPlatoonFrontPosition(oPlatoon)) <= 60 and not(aiBrain[M27Overseer.refbIncludeACUInAllOutAttack]) then
                                iPDThreshold = math.max(1, iPDThreshold - 2)
                            end
                            --Reduce threshold if enemy has shields
                            if M27Utilities.IsTableEmpty(tEnemyFixedShields) == false then
                                iPDThreshold = math.max(1, iPDThreshold - math.min(2, table.getn(tEnemyFixedShields), table.getn(tEnemyT2PlusPD)))
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iPDThreshold after checking for nearby ACU='..iPDThreshold..'; Nearest ACU distance='..aiBrain[M27Overseer.refiLastNearestACUDistance]..'; aiBrain[M27Overseer.refbIncludeACUInAllOutAttack]='..tostring(aiBrain[M27Overseer.refbIncludeACUInAllOutAttack])..'; Size of enemy T2PD table='..table.getn(tEnemyT2PlusPD)) end

                            if table.getn(tEnemyT2PlusPD) >= math.max(1, iPDThreshold) then
                                --How many PD would be in-range if we get within range of the nearest PD (T1 or otherwise)
                                --First reduce PD threshold by 1 as more dangerous if enemy PD close by even if not in range of us
                                if iPDThreshold >= 3 then iPDThreshold = iPDThreshold - 1 end
                                local iPDInRange = 0
                                local iPlatoonMaxRange = oPlatoon[refiPlatoonMaxRange]
                                local tNearbyPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD, oPlatoon[reftEnemyStructuresInRange])
                                local oNearestPD = M27Utilities.GetNearestUnit(tNearbyPD, GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                local tPositionToBeInRange = GetPositionAtOrNearTargetInPathingGroup(GetPlatoonFrontPosition(oPlatoon), oNearestPD:GetPosition(), iPlatoonMaxRange - 2, 0, oPlatoon[refoFrontUnit], true, true, 1)
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Have too many PD near ACU so will consider running, first will calculate how many will be able to hit ACU if it gets in range of the nearest one; iPlatoonMaxRange='..iPlatoonMaxRange..'; will draw the position to be in range in blue')
                                    M27Utilities.DrawLocation(tPositionToBeInRange, nil, 1, 100)
                                end
                                local tT3PDInRange = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD * categories.TECH3, tEnemyT2PlusPD)
                                if M27Utilities.IsTableEmpty(tT3PDInRange) == false then
                                    iPDInRange = iPDInRange + table.getn(tT3PDInRange) * 3
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have T3 PD in range so will treat them as being 3x normal number; iPDInRange='..iPDInRange) end
                                end
                                if iPDInRange < iPDThreshold then --(no point carrying on checking how many PD if are at the threshold)
                                    local iPDSearchRange = 52
                                    local tT2PDInRange = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryPD * categories.TECH2, tPositionToBeInRange, iPDSearchRange, 'Enemy')
                                    if M27Utilities.IsTableEmpty(tT2PDInRange) == false then
                                        for iT2PDInRange, oT2PDInRange in tT2PDInRange do
                                            if oT2PDInRange:GetFractionComplete() >= 0.8 then
                                                iPDInRange = iPDInRange + table.getn(tT2PDInRange)
                                                if bDebugMessages == true then LOG(sFunctionRef..': iPDInRange after checking for T2='..iPDInRange) end
                                            end
                                        end
                                    end
                                    --Also consider unseen T2 PD
                                    if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftUnseenPD]) == false then
                                        for iPD, oPD in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftUnseenPD] do
                                            if M27Utilities.GetDistanceBetweenPositions(oPD:GetPosition(), tPositionToBeInRange) <= iPDSearchRange then
                                                --No need to worry about double-counting, as get units around point wont have picked this up
                                                iPDInRange = iPDInRange + 1
                                            end
                                        end
                                    end
                                end

                                if iPDInRange >= iPDThreshold then
                                    bACUNeedsToRun = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU against too many PD htat would be in range of it; iPDInRange='..iPDInRange..'; iPDThreshold='..iPDThreshold..'; tEnemyT2PlusPD size='..table.getn(tEnemyT2PlusPD)) end
                                    --Are we cloaked and enemy has no omni and no spy planes, and we are still at least 10 away from the nearest PD?
                                    if oACU:HasEnhancement('CloakingGenerator') then
                                        --Are we already close to the nearest PD and there are fewer than 8?
                                        local bEnemyHasOmni = false
                                        local tPotentialOmniUnits = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryUnitsWithOmni, GetPlatoonFrontPosition(oPlatoon), 225, 'Enemy')
                                        local iEnemyOmniRange
                                        local iEnemyDistToUs
                                        if M27Utilities.IsTableEmpty(tPotentialOmniUnits) == false then
                                            for iUnit, oUnit in tPotentialOmniUnits do
                                                iEnemyDistToUs = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition())
                                                iEnemyOmniRange = oUnit:GetBlueprint().Intel.OmniRadius
                                                if EntityCategoryContains(categories.AIR, oUnit.UnitId) then iEnemyOmniRange = iEnemyOmniRange + 100
                                                elseif EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:HasEnhancement('EnhancedSensors') then iEnemyOmniRange = math.max(iEnemyOmniRange, 80)
                                                    else
                                                        iEnemyOmniRange = iEnemyOmniRange + 20
                                                    end
                                                end

                                                if iEnemyDistToUs <= (iEnemyOmniRange or 20) then
                                                    bEnemyHasOmni = true
                                                    break
                                                end
                                            end
                                        end
                                        if bEnemyHasOmni == false then
                                            local iNearestPD = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetNearestUnit(tEnemyT2PlusPD, GetPlatoonFrontPosition(oPlatoon), aiBrain):GetPosition())
                                            if bDebugMessages == true then LOG(sFunctionRef..': iNearestPD='..iNearestPD..'; iPDInRange='..iPDInRange..'; Platoon front unit health percent='..M27UnitInfo.GetUnitHealthPercent(oPlatoon[refoFrontUnit])) end
                                            if iNearestPD <= 22 or iPDInRange <= 8 and iNearestPD <= 40 or M27UnitInfo.GetUnitHealthPercent(oPlatoon[refoFrontUnit]) >= 0.99 then
                                                --Almost in range of the PD so dont run now
                                                if bDebugMessages == true then LOG(sFunctionRef..': Almost in range of enemy PD or 99% health so wont run now') end
                                                bACUNeedsToRun = false
                                            end
                                        end
                                    end
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Will only have iPDInRange='..iPDInRange..'; so dont need to run')
                                end
                            end
                        end
                    end
                    if bACUNeedsToRun == false and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) > M27Overseer.iDistanceFromBaseToBeSafe then
                        if oPlatoon[refiEnemiesInRange] > 0 then iEnemyThreatRating = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemiesInRange], true) end
                        local iEnemyStructureThreatRating = 0
                        if oPlatoon[refiEnemyStructuresInRange] > 0 then iEnemyStructureThreatRating = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemyStructuresInRange], true) end
                        if not(M27Conditions.DoesACUHaveGun(aiBrain, false)) then iEnemyThreatRating = iEnemyThreatRating + iEnemyStructureThreatRating end
                        if iEnemyThreatRating + iEnemyStructureThreatRating > 0 then
                            local iOurThreatRating = 0
                            if bDebugMessages == true then
                                --Reproduce every unit in tFriendlyNearbyCombatUnits:
                                LOG('Considering if enemy overall threat is too great; Size of oPlatoon[reftFriendlyNearbyCombatUnits]='..table.getn(oPlatoon[reftFriendlyNearbyCombatUnits])..'; about to list out every unit')
                                for iUnit, oUnit in oPlatoon[reftFriendlyNearbyCombatUnits] do
                                    LOG('iUnit='..iUnit..'; oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit))
                                end
                            end
                            if M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyFatboyCount] > 0 then
                                --Cap threat rating for fatboys to 5k threat
                                local tFriendlyFatboys = EntityCategoryFilterDown(M27UnitInfo.refCategoryFatboy, oPlatoon[reftFriendlyNearbyCombatUnits])
                                if M27Utilities.IsTableEmpty(tFriendlyFatboys) then
                                    iOurThreatRating = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftFriendlyNearbyCombatUnits], false)
                                else
                                    iOurThreatRating = M27Logic.GetCombatThreatRating(aiBrain, EntityCategoryFilterDown(categories.ALLUNITS - M27UnitInfo.refCategoryFatboy, oPlatoon[reftFriendlyNearbyCombatUnits]), false)
                                    iOurThreatRating = iOurThreatRating + 5000 * table.getn(tFriendlyFatboys)
                                end

                            else
                                iOurThreatRating = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftFriendlyNearbyCombatUnits], false)
                            end
                            local iACUThreat = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits])
                            local iACUUpgradeCount = M27UnitInfo.GetNumberOfUpgradesObtained(oACU)
                            local iThreatCap = iACUThreat + 1500
                            if iACUUpgradeCount >= 3 then iThreatCap = iThreatCap + 2000 end
                            if bDebugMessages == true then LOG(sFunctionRef..': iOurThreatRating before cap='..iOurThreatRating..'; ACU threat out of this='..iACUThreat..'; iACUUpgradeCount='..iACUUpgradeCount..'; iThreatCap='..iThreatCap) end
                            iOurThreatRating = math.min(iOurThreatRating, iThreatCap)
                            local iEnemyThreatRatioToRunOn = 1.1
                            local iMinPercentOfMexesWanted = (1 / M27Overseer.iPlayersAtGameStart) * 0.7
                            local iMexesWeHave = aiBrain[M27Overseer.refiAllMexesInBasePathingGroup] - aiBrain[M27Overseer.refiUnclaimedMexesInBasePathingGroup]
                            if iMexesWeHave <= aiBrain[M27Overseer.refiAllMexesInBasePathingGroup] * iMinPercentOfMexesWanted then
                                iEnemyThreatRatioToRunOn = 0.9
                                --Can take on a greater threat with overcharge, while if enemy ACU is near and we are behind on eco we may want to try and push for a kill
                                if aiBrain:GetEconomyStored('ENERGY') >= 6000 or aiBrain[M27Overseer.refbEnemyACUNearOurs] then iEnemyThreatRatioToRunOn = 0.8 end
                            elseif bHaveMostMexes or iMexesWeHave >= aiBrain[M27Overseer.refiAllMexesInBasePathingGroup] * (1 / M27Overseer.iPlayersAtGameStart) then iEnemyThreatRatioToRunOn = 1.3
                            end


                            if bDebugMessages == true then LOG(sFunctionRef..': iOurThreatRating='..iOurThreatRating..'; iEnemyThreatRating='..iEnemyThreatRating..'; will run if our threat rating less than enemy threat * iEnemyThreatRatioToRunOn. iEnemyThreatRatioToRunOn='..iEnemyThreatRatioToRunOn..'; iEnemyThreatRating * iEnemyThreatRatioToRunOn='..iEnemyThreatRating * iEnemyThreatRatioToRunOn..'; bHaveMostMexes='..tostring(bHaveMostMexes)..'; aiBrain[M27Overseer.refiUnclaimedMexesInBasePathingGroup]='..aiBrain[M27Overseer.refiUnclaimedMexesInBasePathingGroup]..'; aiBrain[M27Overseer.refiAllMexesInBasePathingGroup]='..aiBrain[M27Overseer.refiAllMexesInBasePathingGroup]..'; M27Overseer.iPlayersAtGameStart='..M27Overseer.iPlayersAtGameStart..'; iMinPercentOfMexesWanted='..iMinPercentOfMexesWanted..'; iMexesWeHave='..iMexesWeHave..'; actual size of mexes we own='..aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryMex)) end

                            if iOurThreatRating <= iEnemyThreatRating * iEnemyThreatRatioToRunOn or (bHaveMostMexes and iOurThreatRating <= (iEnemyThreatRating * 2)) or (bHaveMostMexes and iOurThreatRating < iEnemyStructureThreatRating) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy threat level is high enough we want to run, unless most of it is in structure threat; iEnemyStructureThreatRating='..iEnemyStructureThreatRating..'; iEnemyThreatRating='..iEnemyThreatRating..'; aiBrain[M27Overseer.refiUnclaimedMexesInBasePathingGroup]='..aiBrain[M27Overseer.refiUnclaimedMexesInBasePathingGroup]..'; aiBrain[M27Overseer.refiAllMexesInBasePathingGroup]='..aiBrain[M27Overseer.refiAllMexesInBasePathingGroup]..'; M27Overseer.iPlayersAtGameStart='..M27Overseer.iPlayersAtGameStart..'; aiBrain[M27Overseer.refiAllMexesInBasePathingGroup] * ((M27Overseer.iPlayersAtGameStart - 1) / M27Overseer.iPlayersAtGameStart + 0.1)='..aiBrain[M27Overseer.refiAllMexesInBasePathingGroup] * ((M27Overseer.iPlayersAtGameStart - 1) / M27Overseer.iPlayersAtGameStart + 0.1)) end
                                bACUNeedsToRun = true
                                --Run if enemy has a larger threat unless we have really bad mexes and need to try and push

                                if iOurThreatRating > iEnemyThreatRating * 1.25 or (aiBrain[M27Overseer.refiEnemyHighestTechLevel] <= 2 and aiBrain[M27Overseer.refiUnclaimedMexesInBasePathingGroup] >= aiBrain[M27Overseer.refiAllMexesInBasePathingGroup] * iMinPercentOfMexesWanted and M27Utilities.GetDistanceBetweenPositions(aiBrain[M27Overseer.reftLastNearestACU], GetPlatoonFrontPosition(oPlatoon)) >= 32) then
                                    --Dont run if most of the threat is structures and we arent in range of enemy PD (or if we are in range of PD, the enemy mobile threat is even less)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Our threat rating is more tahn 1.25 of the enemy mobile threat rating, or enemy is only at T2 and we want to try and gain map control with our ACU and their ACU isnt nearby') end

                                    bACUNeedsToRun = false
                                    if iOurThreatRating < iEnemyThreatRating * 3 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy still has notable threat so will run if we dont have high health.  HealthRatio='..M27UnitInfo.GetUnitHealthPercent(oPlatoon[refoFrontUnit])) end
                                        if (oPlatoon[refoFrontUnit]:GetHealth() + (iCurShield or 0)) / (iMaxHealth or oPlatoon[refoFrontUnit]:GetBlueprint().Defense.MaxHealth) < 0.8 then
                                            if iOurThreatRating <= iEnemyThreatRating then
                                                if bDebugMessages == true then LOG(sFunctionRef..': ACU needs to run as it has less than 80% health including its shield') end
                                                bACUNeedsToRun = true
                                            else
                                                for iStructure, oStructure in oPlatoon[reftEnemyStructuresInRange] do
                                                    if M27UnitInfo.IsUnitValid(oStructure) and EntityCategoryContains(categories.DIRECTFIRE, oStructure.UnitId) then
                                                        if M27Utilities.GetDistanceBetweenPositions(oStructure:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= (M27Logic.GetUnitMaxGroundRange({ oStructure }) + 5) then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Need to run as are within 5 of the range of enemy PD and we have <80% health') end
                                                            bACUNeedsToRun = true
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    --end
                end

                --Also run if enemy has air units near our ACU and it doesnt have nearby MAA support and we need air units
                if not(bACUNeedsToRun) and ((aiBrain[M27AirOverseer.refiAirAANeeded] > 0 or aiBrain[M27AirOverseer.refbFarBehindOnAir]) or aiBrain[M27AirOverseer.refbMercySightedRecently]) then

                    local iEnemyAirSearchRange = 90
                    if aiBrain[M27AirOverseer.refbMercySightedRecently] then iEnemyAirSearchRange = 118 end
                    local tNearbyEnemyAir = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryAirNonScout, GetPlatoonFrontPosition(oPlatoon), iEnemyAirSearchRange, 'Enemy')
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking for nearby enemy air threats to ACU, is tNearbyEnemyAir empty='..tostring(M27Utilities.IsTableEmpty(tNearbyEnemyAir))) end
                    if M27Utilities.IsTableEmpty(tNearbyEnemyAir) == false then
                        if aiBrain[M27AirOverseer.refbMercySightedRecently] and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryMercy, tNearbyEnemyAir)) == false then
                            bACUNeedsToRun = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy air contains mercies so will run regardless of if we have nearby MAA') end
                        else
                            --Are we underwater with no enemy torp bombers?
                            if not(M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit]) and (aiBrain[M27AirOverseer.reftEnemyAirFactoryByTech][2] + aiBrain[M27AirOverseer.reftEnemyAirFactoryByTech][3]) == 0 and aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] <= 2000 and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryTorpBomber, tNearbyEnemyAir))) then
                                if bDebugMessages == true then LOG(sFunctionRef..': AirAA Needed='..aiBrain[M27AirOverseer.refiAirAANeeded]..'; ACU health='..M27UnitInfo.GetUnitHealthPercent(oPlatoon[refoFrontUnit])..' is enemy air table excluding airaa empty='..tostring(M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryAirNonScout - M27UnitInfo.refCategoryAirAA, tNearbyEnemyAir)))) end
                                if (aiBrain[M27AirOverseer.refiAirAANeeded] > 2 or aiBrain[M27AirOverseer.refbFarBehindOnAir]) and (M27UnitInfo.GetUnitHealthPercent(oPlatoon[refoFrontUnit]) <= 0.65 or M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryAirNonScout - M27UnitInfo.refCategoryAirAA, tNearbyEnemyAir)) == false or M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) / aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] >= 0.4) then
                                    --Do we have nearby ground AA?
                                    local tNearbyGroundAA = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryMAA, GetPlatoonFrontPosition(oPlatoon), 50, 'Ally')
                                    if M27Utilities.IsTableEmpty(tNearbyGroundAA) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Nearby enemy air, and we dont have nearby MAA; Will run if a significant threat that we cant deal with with our air force, or if we are low on health. aiBrain[M27AirOverseer.refiAirAANeeded]='..aiBrain[M27AirOverseer.refiAirAANeeded]) end
                                        bACUNeedsToRun = true
                                    else
                                        local iNearbyAirToGroundThreat = M27Logic.GetAirThreatLevel(aiBrain, tNearbyEnemyAir, false, false, false, true, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iNearbyAirToGroundThreat='..iNearbyAirToGroundThreat..'; Our ground AA threat='..M27Logic.GetAirThreatLevel(aiBrain, tNearbyGroundAA, false, false, true, false, false)) end
                                        if iNearbyAirToGroundThreat > 800 or iNearbyAirToGroundThreat > 3 * M27Logic.GetAirThreatLevel(aiBrain, tNearbyGroundAA, false, false, true, false, false) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to run due to enemy air') end
                                            bACUNeedsToRun = true
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                if not(bACUNeedsToRun) then
                    --Do we have a significant number of enemies nearby, are far from base, and have enemies inbetween us and our base? Then retreat unless have at least 3 upgrades
                    local iDistToOurBase = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                    if oPlatoon[refiEnemiesInRange] >= 6 and iDistToOurBase >= aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.45 then
                        local tGroundThreats = EntityCategoryFilterDown(M27UnitInfo.refCategoryLandCombat, oPlatoon[reftEnemiesInRange])
                        if M27Utilities.IsTableEmpty(tGroundThreats) == false then
                            local iAngleToOurBase = M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                            for iUnit, oUnit in tGroundThreats do
                                if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) < iDistToOurBase then
                                    if M27Utilities.GetAngleDifference(iAngleToOurBase, M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition())) <= 70 then
                                        bACUNeedsToRun = true
                                        break
                                    end
                                end
                            end
                        end
                    end

                end


                --Override - if ACU has stealth+high health, or cloak, and not in enemy omni range, then ignore need to run
                if bACUNeedsToRun and not(oPlatoon[refbNeedToHeal]) and (oACU:HasEnhancement('CloakingGenerator') or (oACU:HasEnhancement('StealthGenerator') and M27UnitInfo.GetUnitHealthPercent(oACU) >= 0.95 and not(aiBrain[M27AirOverseer.refbMercySightedRecently]))) then
                    if bDebugMessages == true then LOG(sFunctionRef..': ACU has stealth or cloak so considering whether it should ignore the call to run') end
                    if not(M27Conditions.IsLocationNearEnemyOmniRange(aiBrain, GetPlatoonFrontPosition(oPlatoon), 20)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Not in enemy omni range so wont run') end
                        bACUNeedsToRun = false
                    elseif oACU:HasEnhancement('CloakingGenerator') then
                        --Are we already close to the nearest PD?
                        if oPlatoon[refiEnemyStructuresInRange] > 0 and M27Utilities.IsTableEmpty(tEnemyT2PlusPD) == false and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetNearestUnit(tEnemyT2PlusPD, GetPlatoonFrontPosition(oPlatoon), aiBrain):GetPosition()) <= 40 then
                            --Almost in range of the PD so dont run now
                            bACUNeedsToRun = false
                        end
                    end
                    if not(bACUNeedsToRun) and oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] > 0 then
                        --Are either cloaked, or have no mobile enemies within 20 of us
                        if oACU:HasEnhancement('CloakingGenerator') or oPlatoon[refiEnemiesInRange] == 0 or M27Utilities.GetDistanceBetweenPositions(M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain):GetPosition(), GetPlatoonFrontPosition(oPlatoon)) > 20 and not(M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit])) then
                            if oACU and M27Conditions.CanUnitUseOvercharge(aiBrain, oACU) == true then M27UnitMicro.GetOverchargeExtraAction(aiBrain, oPlatoon, oACU) end
                            bProceed = false
                            --Are we underwater?
                            GetUnderwaterActionForLandUnit(oPlatoon)
                            if not(oPlatoon[refiCurrentAction]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Are cloaked or have no mobile enemies within 20 of us and no action after checking underwater actions so will attack') end
                                oPlatoon[refiCurrentAction] = refActionAttack
                            end
                        end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if too many PD or enemy threat nearby, bACUNeedsToRun='..tostring(bACUNeedsToRun)) end
                if bACUNeedsToRun == true then
                    --If have stealth or cloak, and no big enemy threats, do a temporary retreat
                    if (oACU:HasEnhancement('CloakingGenerator') or oACU:HasEnhancement('StealthGenerator')) and M27Utilities.GetDistanceBetweenPositions(M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon)), GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit]) > 50 then
                        if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyNukeLaunchers]) and M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyLandExperimentals]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have cloak or stealth so want to do temporary retreat') end
                            oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                            oPlatoon[refbHavePreviouslyRun] = true
                        else
                            oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                            oPlatoon[refbHavePreviouslyRun] = true
                        end
                    else
                        --Are we close to the nearest rally point, with >=75% health, and close to our base? then dont set an action to run (as it may be e.g. we are just running to be prudent due to high eco)
                        if M27UnitInfo.GetUnitHealthPercent(oACU) >= 0.75 and (M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) <= math.min(150, math.max(M27Overseer.iDistanceFromBaseToBeSafe, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase]*0.25)) or M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit])) <= 30) then
                            --Do nothing
                        else
                            oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                            oPlatoon[refbHavePreviouslyRun] = true
                        end
                    end
                    --Add in overcharge
                    if oACU and M27Conditions.CanUnitUseOvercharge(aiBrain, oACU) == true then M27UnitMicro.GetOverchargeExtraAction(aiBrain, oPlatoon, oACU) end
                    bProceed = false
                else
                    --If taken damage from unseen T1/T2 DF unit recently and dont want to run, and that unit is within 2 of our range, then move closer to the unit
                    if oACU[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage] and GetGameTimeSeconds() - oACU[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage] <= 25 then
                        local oUnseenDamageDealer = oACU[M27Overseer.refoUnitDealingUnseenDamage]
                        if oUnseenDamageDealer and not(oUnseenDamageDealer.Dead) and oUnseenDamageDealer.GetUnitId then
                            if EntityCategoryContains(categories.LAND * categories.DIRECTFIRE, oUnseenDamageDealer.UnitId) then
                                if M27Utilities.GetDistanceBetweenPositions(oUnseenDamageDealer:GetPosition(), oACU:GetPosition()) <= 35 and not(M27Utilities.CanSeeUnit(aiBrain, oUnseenDamageDealer, true)) then

                                    oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                                    oPlatoon[reftTemporaryMoveTarget] = {}
                                    oPlatoon[reftTemporaryMoveTarget][1], oPlatoon[reftTemporaryMoveTarget][2], oPlatoon[reftTemporaryMoveTarget][3] = oUnseenDamageDealer:GetPositionXYZ()
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU has taken damage from unseen direct fire unit recently that is within 35 of the ACU, so ACU will move towards the unit, to position '..repru(oPlatoon[reftTemporaryMoveTarget])) end
                                    bProceed = false
                                end
                            end
                        end
                    end
                end
            end
        elseif sPlatoonName == 'M27GroundExperimental' and EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId) then
            --Run if against enemy experimental or 5+ T2 arti or low shield
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a fatboy, will run if lots of enemy T2 arti or a low shield') end

            local bExperimentalWithinRange = false
            if oPlatoon[refiEnemiesInRange] > 0 then
                local tLandExperimentals = EntityCategoryFilterDown(M27UnitInfo.refCategoryLandExperimental, oPlatoon[reftEnemiesInRange])
                if M27Utilities.IsTableEmpty(tLandExperimentals) == false then
                    for iUnit, oUnit in tLandExperimentals do
                        if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) < 98 then
                            bExperimentalWithinRange = true
                            break
                        end
                    end
                end
            end
            if bExperimentalWithinRange then
                oPlatoon[refiCurrentAction] = refActionKitingRetreat
                --oPlatoon[refbHavePreviouslyRun] = true
            else
                local iFriendlyExperimental = 0 --friendly combat units will include our own units
                if M27Utilities.IsTableEmpty(oPlatoon[reftFriendlyNearbyCombatUnits]) == false then
                    local tFriendlyExperimentals = EntityCategoryFilterDown(M27UnitInfo.refCategoryFatboy, oPlatoon[reftFriendlyNearbyCombatUnits])
                    if M27Utilities.IsTableEmpty(tFriendlyExperimentals) == false then
                        for iExperimental, oExperimental in tFriendlyExperimentals do
                            if M27Utilities.GetDistanceBetweenPositions(oExperimental:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= 40 then
                                iFriendlyExperimental = iFriendlyExperimental + 1
                            end
                        end
                    end
                end

                --T2 arti in range?
                local bRunFromArti = false
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy structures in range, total number='..oPlatoon[refiEnemyStructuresInRange]..'; iFriendlyExperimental='..iFriendlyExperimental) end
                if oPlatoon[refiEnemyStructuresInRange] > 0 then
                    local tT2Arti = EntityCategoryFilterDown(M27UnitInfo.refCategoryFixedT2Arti, oPlatoon[reftEnemyStructuresInRange])
                    if M27Utilities.IsTableEmpty(tT2Arti) == false and table.getn(tT2Arti) >= 4 then
                        local iArtiThatCanHitUs = 0
                        local iClosestDist = 10000
                        local iCurDist
                        local oClosestT2Arti = M27Utilities.GetNearestUnit(tT2Arti, GetPlatoonFrontPosition(oPlatoon))
                        local tLikelyLocationIfAttack = M27Utilities.MoveInDirection(oClosestT2Arti:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestT2Arti:GetPosition(), GetPlatoonFrontPosition(oPlatoon)), oPlatoon[refiPlatoonMaxRange], false)
                        iClosestDist = M27Utilities.GetDistanceBetweenPositions(oClosestT2Arti:GetPosition(), GetPlatoonFrontPosition(oPlatoon))

                        if bDebugMessages == true then LOG(sFunctionRef..': DIst to closest T2 Arti='..iClosestDist..'; size of tT2Arti='..table.getn(tT2Arti)) end

                        for iUnit, oUnit in tT2Arti do
                            iCurDist = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition())

                            if iCurDist <= 135 then --given margin for error given both size of fatboy and firing variance of t2 arti
                                iArtiThatCanHitUs = iArtiThatCanHitUs + 1
                            elseif iClosestDist > oPlatoon[refiPlatoonMaxRange] and M27Utilities.GetDistanceBetweenPositions(tLikelyLocationIfAttack, oUnit:GetPosition()) <= 135 then
                                iArtiThatCanHitUs = iArtiThatCanHitUs + 1
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering arti '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; Dist to likely location to attack='..M27Utilities.GetDistanceBetweenPositions(tLikelyLocationIfAttack, oUnit:GetPosition())..'; oPlatoon[refiPlatoonMaxRange]='..oPlatoon[refiPlatoonMaxRange]..'; iArtiThatCanHitUs='..iArtiThatCanHitUs) end
                        end

                        if iClosestDist > 100 then
                            --sandbox testing: If against 6 T1 pgen assisted klink hammers and 1 UEF T3 shield, then can kill the shield but then have to retreat and are likely to die.  Will therefore treat threshold for running as 5 to be ultra-cautious given they might be able to build more shields or T2 arti (or have more that we havent scouted)
                            local iMaxArtiToTryAndFight = math.min(12, 3 * iFriendlyExperimental + 4)

                            if iArtiThatCanHitUs > iMaxArtiToTryAndFight then
                                bRunFromArti = true
                            else
                                if not(M27Logic.IsTargetUnderShield(aiBrain, oClosestT2Arti, 100, false, false, true)) then
                                    iMaxArtiToTryAndFight = iMaxArtiToTryAndFight - 2
                                    if iArtiThatCanHitUs > iMaxArtiToTryAndFight then
                                        bRunFromArti = true
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iMaxArtiToTryAndFight after factoring in if they are shielded='..iMaxArtiToTryAndFight..'; iArtiThatCanHitUs='..iArtiThatCanHitUs..'; bRunFromArti='..tostring(bRunFromArti)..'; iFriendlyExperimental='..iFriendlyExperimental) end

                        end
                    end
                end
                if bRunFromArti then
                    oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                    oPlatoon[refbHavePreviouslyRun] = true
                else
                    --Low shield?
                    local iCurShield, iMaxShield = M27UnitInfo.GetCurrentAndMaximumShield(oPlatoon[refoFrontUnit])
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have a low shield. iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
                    if iMaxShield > 10000 then --redundancy to make sure we're dealing with fatboy
                        local iShieldPercentWanted = 0.15
                        if oPlatoon[refbHavePreviouslyRun] then iShieldPercentWanted = 0.2 end
                        --Retreat when taking even a small amount of damage if lack intel
                        if not(M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refiPlatoonMaxRange], true)) then iShieldPercentWanted = iShieldPercentWanted + 0.6 end
                        if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': iShieldPercentWanted='..iShieldPercentWanted..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end

                        if iCurShield < iMaxShield * iShieldPercentWanted then
                            if iShieldPercentWanted >= 0.3 then --Are running because we lack intel
                                aiBrain[reftSkirmisherPlatoonWantingIntel][oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]] = oPlatoon
                            end
                            --Do we have friendly experimental? If so do temporary retreat
                            if iFriendlyExperimental > 1 then
                                oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                --oPlatoon[refbHavePreviouslyRun] = true
                            else
                                --Is this just due to power stall? If so only do temporary retreat
                                if oPlatoon[refoFrontUnit].MyShield and oPlatoon[refoFrontUnit]:GetHealth() > math.max(iCurShield, iMaxShield*0.2) then
                                    oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                    --oPlatoon[refbHavePreviouslyRun] = true
                                else
                                    oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                                    oPlatoon[refbHavePreviouslyRun] = true
                                end
                            end
                        end
                    end

                    --PD about to get in range of us and we arent underwater?
                    if not(oPlatoon[refiCurrentAction]) and oPlatoon[refiEnemyStructuresInRange] > 1 and not(M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit])) then
                        local tNearbyPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD, oPlatoon[reftEnemyStructuresInRange])
                        if M27Utilities.IsTableEmpty(tNearbyPD) == false then
                            local iBestPDRange = M27Logic.GetUnitMaxGroundRange(tNearbyPD)
                            local iNearestPD = M27Utilities.GetDistanceBetweenPositions(M27Utilities.GetNearestUnit(tNearbyPD, GetPlatoonFrontPosition(oPlatoon)):GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                            if iNearestPD < iBestPDRange + 10 then
                                oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                if bDebugMessages == true then LOG(sFunctionRef..': About to get within range of enemy PD so will retreat, iNearestPD distance='..iNearestPD..'; iBestPDRange='..iBestPDRange) end
                            end

                        end
                    end
                    if not(oPlatoon[refiCurrentAction]) then
                        if bDebugMessages == true then LOG(sFunctionRef..': No action yet for fatboy, will set kiting flag based on how much enemy DF threat is nearby') end
                        SetIfPlatoonCanKite(oPlatoon)
                        if oPlatoon[refiEnemiesInRange] >= 2 and not(oPlatoon[refbKiteEnemies]) then
                            local tNearbyEnemyDangerousLand = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandCombat * categories.TECH3, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refiPlatoonMaxRange] - 8, 'Enemy')
                            if M27Utilities.IsTableEmpty(tNearbyEnemyDangerousLand) == false then
                                local iNearbyT3Plus = table.getn(tNearbyEnemyDangerousLand)
                                if bDebugMessages == true then LOG(sFunctionRef..': Deciding whether to turn on kiting for fatboy, iNearbyT3Plus='..iNearbyT3Plus..'; Combat threat rating='..M27Logic.GetCombatThreatRating(aiBrain, tNearbyEnemyDangerousLand)) end
                                if iNearbyT3Plus >= 5 or M27Logic.GetCombatThreatRating(aiBrain, tNearbyEnemyDangerousLand) >= 3000 then
                                    oPlatoon[refbKiteEnemies] = true
                                end
                            end
                        end
                    end

                end
            end
            if oPlatoon[refiCurrentAction] then bProceed = false end
            if bDebugMessages == true then LOG(sFunctionRef..': End of custom fatboy logic for this function; will proceed to normal logic if no action. oPlatoon[refiCurrentAction]='..(oPlatoon[refiCurrentAction] or 'nil')) end
        elseif sPlatoonName == 'M27GroundExperimental' then
            --Non-fatboy land experimental - do we have a low range (<60)? If so then run from large numbers of ravagers and T2 PD
            --Also dont run if have T3+ mobile combat units within our range (or risk being kited to death)
            --Ignore above if we are underwater though
            if not(M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit])) then
                if oPlatoon[refiEnemiesInRange] > 0 then
                    local tEnemyT3PlusCombat = EntityCategoryFilterDown(M27UnitInfo.refCategoryLandCombat * categories.TECH3 + M27UnitInfo.refCategoryExperimentalLevel + M27UnitInfo.refCategoryIndirectT3, oPlatoon[reftEnemiesInRange])
                    if M27Utilities.IsTableEmpty(tEnemyT3PlusCombat) == false then
                        local tNearbyEnemyExperimental = EntityCategoryFilterDown(categories.EXPERIMENTAL, tEnemyT3PlusCombat)
                        --Enemy experimentals - consider their range, and attack if are in range of them
                        local iEnemyRange, iEnemyDist
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy experimentals in range empty='..tostring(M27Utilities.IsTableEmpty(tNearbyEnemyExperimental))) end
                        if M27Utilities.IsTableEmpty(tNearbyEnemyExperimental) == false then
                            for iUnit, oUnit in tNearbyEnemyExperimental do
                                iEnemyRange = M27Logic.GetUnitMaxGroundRange({oUnit})
                                iEnemyDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iEnemyRange='..iEnemyRange..'; iEnemyDist='..iEnemyDist..'; Our max range='..oPlatoon[refiPlatoonMaxRange]) end
                                if iEnemyDist - 4 < math.max(iEnemyRange, oPlatoon[refiPlatoonMaxRange]) and (oPlatoon[refiPlatoonMaxRange] + 10 >= iEnemyRange or iEnemyRange <= 70 or iEnemyDist <= 70 or iEnemyDist + 20 < iEnemyRange) then
                                    oPlatoon[refiCurrentAction] = refActionAttack
                                    if bDebugMessages == true then LOG(sFunctionRef..': Too close to enemy experimental so will attack') end
                                    break
                                end
                            end
                        end
                        if not(oPlatoon[refiCurrentAction]) then
                            tEnemyT3PlusCombat = EntityCategoryFilterDown(categories.TECH3, tEnemyT3PlusCombat)
                            if M27Utilities.IsTableEmpty(tEnemyT3PlusCombat) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have nearby enemy T3, will see if we are in range of the closest one. Dist to T3='..M27Utilities.GetDistanceBetweenPositions(M27Utilities.GetNearestUnit(tEnemyT3PlusCombat, GetPlatoonFrontPosition(oPlatoon), aiBrain):GetPosition(), GetPlatoonFrontPosition(oPlatoon))..'; Our range='..oPlatoon[refiPlatoonMaxRange]) end
                                if M27Utilities.GetDistanceBetweenPositions(M27Utilities.GetNearestUnit(tEnemyT3PlusCombat, GetPlatoonFrontPosition(oPlatoon), aiBrain):GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= oPlatoon[refiPlatoonMaxRange] then
                                    oPlatoon[refiCurrentAction] = refActionAttack
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are in range so will attack') end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Have nearby enemy experimental or T3 unit, action after checking if we are in range='..(oPlatoon[refiCurrentAction] or 'nil')) end
                    end
                end

                local iFriendlyExperimental = 0
                if M27Utilities.IsTableEmpty(oPlatoon[reftFriendlyNearbyCombatUnits]) == false then
                    local tFriendlyExperimentals = EntityCategoryFilterDown(M27UnitInfo.refCategoryLandExperimental, oPlatoon[reftFriendlyNearbyCombatUnits])
                    if M27Utilities.IsTableEmpty(tFriendlyExperimentals) == false then
                        iFriendlyExperimental = iFriendlyExperimental + table.getn(tFriendlyExperimentals)
                    end
                end

                if oPlatoon[refiEnemyStructuresInRange] > 5 * iFriendlyExperimental then
                    if oPlatoon[refiPlatoonMaxRange] < 60 then
                        --If we get in range of the nearest enemy PD, how many PD will be able to hit us?
                        local tEnemyPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD, oPlatoon[reftEnemyStructuresInRange])
                        if M27Utilities.IsTableEmpty(tEnemyPD) == false then
                            local oNearestPD = M27Utilities.GetNearestUnit(tEnemyPD, GetPlatoonFrontPosition(oPlatoon), aiBrain)
                            local iDistanceToNearestPD = M27Utilities.GetDistanceBetweenPositions(oNearestPD:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                            --Dont run if we are almost in range
                            if iDistanceToNearestPD > (oPlatoon[refiPlatoonMaxRange] + 5) then
                                local tExpectedPosition = M27Utilities.MoveInDirection(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), oNearestPD:GetPosition()), iDistanceToNearestPD - oPlatoon[refiPlatoonMaxRange], true)
                                local tInRangePD = {}
                                local iInRangePD = 0
                                local iCurDistance
                                local iCurRange
                                for iUnit, oUnit in tEnemyPD do
                                    iCurDistance = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tExpectedPosition)
                                    iCurRange = M27Logic.GetUnitMaxGroundRange({ oUnit})
                                    if iCurDistance <= iCurRange then
                                        iInRangePD = iInRangePD + 1
                                        tInRangePD[iInRangePD] = oUnit
                                    end
                                end
                                local iThreatOfInRangePD = M27Logic.GetCombatThreatRating(aiBrain, tInRangePD)
                                if iThreatOfInRangePD * 0.65 / iFriendlyExperimental > M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits]) then
                                    oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                                    oPlatoon[refbHavePreviouslyRun] = true
                                end
                            end
                        end
                        if not(oPlatoon[refiCurrentAction]) and oPlatoon[refiEnemyStructuresInRange] >= 10 then
                            --Does the enemy have significant amount of buildings to destroy?
                            if oPlatoon[refiEnemyStructuresInRange] >= 30 or M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemyStructuresInRange], false, nil, nil, false, true, false) >= 10000 then
                                oPlatoon[refiCurrentAction] = refActionAttack
                                if bDebugMessages == true then LOG(sFunctionRef..': Lots of buildings nearby so will attack') end
                            end
                        end
                    end
                end
            end
        elseif oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] then
            aiBrain[reftSkirmisherPlatoonWantingIntel][sPlatoonName..oPlatoon[refiPlatoonCount]] = nil
        end

        --If underwater unit then check for navy units here (aren't checking all the time as only want to include enemy actions re them if are underwater - dont want units chasing them into the water; navy already gets included in nearbyenemies for overwater units
        local iNearbyEnemies = oPlatoon[refiEnemyStructuresInRange] + oPlatoon[refiEnemiesInRange]
        local tPlatoonPos = GetPlatoonFrontPosition(oPlatoon)
        local tEnemyNavyIfUnderwater
        if iNearbyEnemies == 0 and oPlatoon[refbPlatoonHasUnderwaterLand] == true then
            tEnemyNavyIfUnderwater = aiBrain:GetUnitsAroundPoint(categories.NAVAL * categories.MOBILE, tPlatoonPos, oPlatoon[refiEnemySearchRadius], 'Enemy')
            if M27Utilities.IsTableEmpty(tEnemyNavyIfUnderwater) == false then iNearbyEnemies = table.getn(tEnemyNavyIfUnderwater) end
        end
        local bDontConsiderFurtherOrders = false
        local bWillWinAttack = false
        local bHaveRunRecently = false

        if oPlatoon[refiCurrentAction] then
            if bDebugMessages == true then LOG(sFunctionRef..': Have determined platoon action from the above so wont proceed, action='..oPlatoon[refiCurrentAction]) end
            bProceed = false
            if oPlatoon[refbPlatoonHasUnderwaterLand] == true and not(oPlatoon[refiCurrentAction] == refActionRun or oPlatoon[refiCurrentAction] == refActionReturnToBase or oPlatoon[refiCurrentAction] == refActionGoToNearestRallyPoint) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have an underwater unit, about to run code to check for underwater action') end
                GetUnderwaterActionForLandUnit(oPlatoon)
            end
        end

        if bProceed then
            --T2 arti avoidance logic for specified platoons - for now will just try with skirmishers, combat patrol and ACU
            --NOTE: If expanding platoons that this applies to, then also update logic for recording enemies, as it has code to increase the search range if T2 arti are identified
            --Dont do this if t2 arti is close to our base
            if ((oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] or sPlatoonName == 'M27CombatPatrolAI' or oPlatoon[refbACUInPlatoon]) and M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyArtiToAvoid]) == false) then
                --if oPlatoon[refbACUInPlatoon] then bDebugMessages = true end
                local iArtiSearchRange = 135
                if oPlatoon[refbRecentlyRunFromT2Arti] and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) >= 75 then
                    iArtiSearchRange = math.max(iArtiSearchRange + 75, oPlatoon[refiEnemySearchRadius] + 10, oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures] + 10)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if T2 arti we want to avoid. iArtiSearchRange='..iArtiSearchRange..'; have we recnetly run from t2 arti='..tostring(oPlatoon[refbRecentlyRunFromT2Arti])..'; our platoon dist to our base='..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) end
                local oNearbyArti

                for iArti, oArti in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyArtiToAvoid] do
                    if bDebugMessages == true and M27UnitInfo.IsUnitValid(oArti) then LOG(sFunctionRef..': Considering oArti='..oArti.UnitId..M27UnitInfo.GetUnitLifetimeCount(oArti)..' owned by '..oArti:GetAIBrain().Nickname..'; Distance to platoon='..M27Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), GetPlatoonFrontPosition(oPlatoon))) end
                    if M27UnitInfo.IsUnitValid(oArti) and M27Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= iArtiSearchRange then
                        if M27Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) >= 175 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Platoon '..sPlatoonName..oPlatoon[refiPlatoonCount]..'Has nearby t2 arti '..oArti.UnitId..M27UnitInfo.GetUnitLifetimeCount(oArti)..' owned by '..oArti:GetAIBrain().Nickname..' so want to retreat') end
                            oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                            bProceed = false
                            oNearbyArti = oArti

                            break
                        end
                    end
                end

                --If ACU in platoon then refine the above to only retreat if significant enemy threat

                if not(bProceed) then
                    --Want to avoid the arti
                    local bIgnoreArti = false
                    if oPlatoon[refbACUInPlatoon] then
                        if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearbyArti:GetPosition()) < 50 then
                            bIgnoreArti = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Are close to the T2 arti so will ignore it') end
                        elseif oPlatoon[reftBuilders][1]:HasEnhancement('CloakingGenerator') and (M27UnitInfo.GetUnitHealthPercent(oPlatoon[reftBuilders][1]) >= 0.9 or (oPlatoon[reftBuilders][1][M27Overseer.reftACURecentHealth][math.floor(GetGameTimeSeconds() - 1)] or oPlatoon[reftBuilders][1][M27Overseer.reftACURecentHealth][math.floor(GetGameTimeSeconds() - 2)] or oPlatoon[reftBuilders][1][M27Overseer.reftACURecentHealth][math.floor(GetGameTimeSeconds() - 3)]) >= oPlatoon[reftBuilders][1][M27Overseer.reftACURecentHealth][math.floor(GetGameTimeSeconds() - 21)]) then
                            bIgnoreArti = true
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU is cloaked') end
                        else
                            local tEnemyDFThreatNearArti = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryDFTank, oNearbyArti:GetPosition(), 50, 'Enemy')
                            local iNearbyDFThreat = 0
                            if M27Utilities.IsTableEmpty(tEnemyDFThreatNearArti) == false then
                                iNearbyDFThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemyDFThreatNearArti)
                            end
                            if iNearbyDFThreat <= 1250 or iNearbyDFThreat <= M27Logic.GetCombatThreatRating(oPlatoon[reftDFUnits]) then
                                bIgnoreArti = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Insufficient DF threat around enemy so wont avoid the T2 arti after all') end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if ACU should ignore T2 arti. bProceed='..tostring(bProceed)..'; oPlatoon[refiCurrentAction]='..(oPlatoon[refiCurrentAction] or 'nil')) end
                    if bIgnoreArti then
                        bProceed = true
                        oPlatoon[refiCurrentAction] = nil
                    else
                        if not(oPlatoon[refbRecentlyRunFromT2Arti]) then
                            oPlatoon[refbRecentlyRunFromT2Arti] = true
                            M27Utilities.DelayChangeVariable(oPlatoon, refbRecentlyRunFromT2Arti, false, 40)
                            if bDebugMessages == true then LOG(sFunctionRef..': Will run from T2 arti, setting flag that we have recently run to true. oPlatoon[refbRecentlyRunFromT2Arti]='..tostring(oPlatoon[refbRecentlyRunFromT2Arti])) end
                        end
                    end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Considering if should proceed, oPlatoon[refiCurrentAction]='..(oPlatoon[refiCurrentAction] or 'nil')..'; bProceed='..tostring(bProceed)..'; iNearbyEnemies='..iNearbyEnemies) end
        if iNearbyEnemies > 0 then
            local iEnemyMaxRange = 18 --Assumed - will update for kiting logic later

            if bProceed == true then
                --Intel specific - just run unless only structures and known to be hostile, or have a seraphim scout and against enemy non-sera scout or engi, or against non-sera scout/engi and have friendly combat units nearby:
                if oPlatoon[M27PlatoonTemplates.refbRunFromAllEnemies] == true then
                    if bDebugMessages == true then LOG(sFunctionRef..': Platoon is flagged to run from all enemies, will see if enemies to run away from') end
                    if oPlatoon[refiEnemiesInRange] > 0 then
                        --Are any enemy units >5 inside our intel range (if M27ScoutAssister or M27MAAAssister, then this is increased to 10)?
                        local bCloseThreat = false
                        if sPlatoonName == 'M27MAAAssister' and not(aiBrain[M27AirOverseer.refbMercySightedRecently]) then
                            bCloseThreat = true
                        else

                            local iMinIntelRange = 40
                            local iIntelRange
                            local tPlatoonUnits = oPlatoon:GetPlatoonUnits()
                            --if sPlatoonName == 'M27MAAAssister' then iIntelRange = 40 else
                            for iCurUnit, oUnit in tPlatoonUnits do
                                if not(oUnit.Dead) then
                                    iIntelRange = oUnit:GetBlueprint().Intel.RadarRadius
                                    break
                                end
                            end
                            --end
                            if iIntelRange < iMinIntelRange then iIntelRange = iMinIntelRange end
                            --function GetUnitSpeedData(tUnits, aiBrain, bNeedToHaveBlipOrVisual, iReturnType, iOptionalSpeedThreshold)
                            local iPlatoonSpeed = M27Logic.GetUnitSpeedData(tPlatoonUnits, aiBrain, false, 1)
                            local iDistanceWithinIntelBeforeRun = 5
                            if iPlatoonSpeed > 3.5 then iDistanceWithinIntelBeforeRun = 10 end
                            local iMaxMobileThreat = 0
                            if oPlatoon[refiPlatoonThreatValue] > 11 then
                                iMaxMobileThreat = 11
                            else
                                if M27Utilities.IsTableEmpty(oPlatoon[reftFriendlyNearbyCombatUnits]) == false then iMaxMobileThreat = 11 end
                            end


                            local tMobileUnitsInIntelRange = aiBrain:GetUnitsAroundPoint(categories.MOBILE, tPlatoonPos, iIntelRange - iDistanceWithinIntelBeforeRun, 'Enemy')
                            --GetCombatThreatRating(aiBrain, tUnits, bUseBlip, iMassValueOfBlipsOverride)
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of mobile units in intel range of iIntelRange='..iIntelRange..' less iDistanceWithinIntelBeforeRun='..iDistanceWithinIntelBeforeRun..' empty='..tostring(M27Utilities.IsTableEmpty(tMobileUnitsInIntelRange))) end
                            if not(tMobileUnitsInIntelRange == nil) then
                                if table.getn(tMobileUnitsInIntelRange) > 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': sPlatoonName='..sPlatoonName..oPlatoon[refiPlatoonCount]..': mobile units in intel range='..table.getn(tMobileUnitsInIntelRange)..'; Combat threat of these='..M27Logic.GetCombatThreatRating(aiBrain, tMobileUnitsInIntelRange, true, 50)..'; iMaxMobileThreat='..iMaxMobileThreat..'; Distance to nearest unit='..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetNearestUnit(tMobileUnitsInIntelRange, GetPlatoonFrontPosition(oPlatoon)):GetPosition())) end
                                    local iEnemyThreatRating = M27Logic.GetCombatThreatRating(aiBrain, tMobileUnitsInIntelRange, true, 50)
                                    if iEnemyThreatRating > iMaxMobileThreat then
                                        bCloseThreat = true
                                    elseif iEnemyThreatRating > 0 and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetNearestUnit(tMobileUnitsInIntelRange, GetPlatoonFrontPosition(oPlatoon)):GetPosition()) <= 8 then
                                        bCloseThreat = true
                                    else
                                        --still return true if structure in range that has a threat:
                                        if oPlatoon[refiEnemyStructuresInRange] > 0 then
                                            --GetCombatThreatRating(aiBrain, tUnits, bUseBlip, iMassValueOfBlipsOverride)
                                            if M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemyStructuresInRange], true) > iMaxMobileThreat then
                                                bCloseThreat = true
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': sPlatoonName='..sPlatoonName..oPlatoon[refiPlatoonCount]..': enemy threat='..M27Logic.GetCombatThreatRating(aiBrain, tMobileUnitsInIntelRange, true, 50)..'; bCloseThreat='..tostring(bCloseThreat)) end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Have enemies in intel range; bCloseThreat='..tostring(bCloseThreat)..'; if true then will temporarily retreat unless are a MAA that wants to protect its platoon and the platoon is nearby') end
                        if bCloseThreat == true then
                            --Have enemies in intel range - run away (but not too far)
                            if bDebugMessages == true then LOG(sFunctionRef..': sPlatoonName='..sPlatoonName..oPlatoon[refiPlatoonCount]..':  setting platoon action to run away, unless MAA that needs to protect experimental/ACU from air threat; platoon air attack range='..(oPlatoon[M27PlatoonTemplates.refiAirAttackRange] or 'nil')..'; Have air control='..tostring(aiBrain[M27AirOverseer.refbHaveAirControl] or false)..'; Is platoon or unit to escort nil='..tostring(oPlatoon[refoPlatoonOrUnitToEscort] == nil)) end
                            oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                            if sPlatoonName == 'M27MAAAssister' and oPlatoon[M27PlatoonTemplates.refiAirAttackRange] and (oPlatoon[refoSupportHelperUnitTarget] or oPlatoon[refoSupportHelperPlatoonTarget]) and not(aiBrain[M27AirOverseer.refbHaveAirControl]) then
                                --Is the platoon/unit we are escorting within 90 of us, and does it have an enemy air to ground threat near it, or we lack air control?
                                local tEscortingPlatoonOrUnitPosition = GetPlatoonFrontPosition(oPlatoon[refoSupportHelperUnitTarget] or oPlatoon[refoSupportHelperPlatoonTarget])

                                if bDebugMessages == true then LOG(sFunctionRef..': Distance to assisting unit position from platoon from position='..M27Utilities.GetDistanceBetweenPositions(tEscortingPlatoonOrUnitPosition, GetPlatoonFrontPosition(oPlatoon))..'; Is escorting positoin underwater='..tostring(M27MapInfo.IsUnderwater(tEscortingPlatoonOrUnitPosition, false))) end
                                local iDistFromAssistanceTarget = M27Utilities.GetDistanceBetweenPositions(tEscortingPlatoonOrUnitPosition, GetPlatoonFrontPosition(oPlatoon))
                                if tEscortingPlatoonOrUnitPosition and iDistFromAssistanceTarget <= 100 and (not(M27MapInfo.IsUnderwater(tEscortingPlatoonOrUnitPosition, false)) or M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit]) == M27UnitInfo.refPathingTypeAmphibious) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are we far behidn on air and enemy has an air to ground threat? aiBrain[M27AirOverseer.refbFarBehindOnAir]='..tostring(aiBrain[M27AirOverseer.refbFarBehindOnAir] or false)..'; aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat]='..(aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat] or 'nil')) end

                                    local bIgnoreRetreat = false
                                    local iDistToBase = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                    local iAssistanceTargetDistToBase = M27Utilities.GetDistanceBetweenPositions(tEscortingPlatoonOrUnitPosition, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])

                                    if iDistFromAssistanceTarget <= 7 or iDistToBase < iAssistanceTargetDistToBase then

                                        if aiBrain[M27AirOverseer.refbFarBehindOnAir] and aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat] >= 200 then
                                            --local tEnemyAirToGroundThreats = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryAirNonScout - M27UnitInfo.refCategoryAirAA, tEscortingPlatoonOrUnitPosition, math.max(30, oPlatoon[M27PlatoonTemplates.refiAirAttackRange]), 'Enemy')
                                            --if M27Utilities.IsTableEmpty(tEnemyAirToGroundThreats) == false and M27Logic.GetAirThreatLevel(aiBrain, tEnemyAirToGroundThreats, false, false, false, true, true, nil, nil, nil, nil, false) >= 350 then
                                            --Want to help out even though we might die, so dont run away from the unit we're escorting
                                            bIgnoreRetreat = true

                                        elseif aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat] >= 50 or aiBrain[M27AirOverseer.refbFarBehindOnAir] or aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] >= 500 then
                                            local tEnemyAirUnits = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryAirNonScout, tEscortingPlatoonOrUnitPosition, math.max(60, oPlatoon[M27PlatoonTemplates.refiAirAttackRange]), 'Enemy')
                                            if M27Utilities.IsTableEmpty(tEnemyAirUnits) == false then -- and M27Logic.GetAirThreatLevel(aiBrain, tEnemyAirToGroundThreats, false, false, false, true, true, nil, nil, nil, nil, false) >= 50 then
                                                --Want to help out even though we might die, so dont run away from the unit we're escorting
                                                bIgnoreRetreat = true
                                            end
                                        end
                                    end
                                    if bIgnoreRetreat then
                                        --If there are dangerous ground units, then we only want to ignore the retreat if we are behind the unit we are assisting - approximate by checking if we are closer to our base
                                        oPlatoon[refiCurrentAction] = nil
                                        bDontConsiderFurtherOrders = true
                                    end
                                end
                            end
                        else
                            --if oPlatoon[refiPlatoonThreatValue] >= 11 and M27Utilities.IsTableEmpty(tMobileUnitsInIntelRange) == false then
                            --if bDebugMessages == true then LOG(sFunctionRef..': Platoon threat value='..oPlatoon[refiPlatoonThreatValue]..'; have mobile units in intel range, will attack') end
                            --oPlatoon[refiCurrentAction] = refActionAttack
                            --else
                            --Do nothing
                            bDontConsiderFurtherOrders = true
                            --end
                        end
                    else
                        --Only have structures nearby - only run if know are dangerous:
                        if M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemyStructuresInRange], true) > 0 then
                            oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                        end
                    end
                else

                    --============Non-Intel logic--------

                    --=========Underwater platoon unit logic (higher priority than kiting and overcharge)
                    if bDebugMessages == true then LOG(sFunctionRef..': About to check for underwater if platoon has underwater unit in it') end
                    if oPlatoon[refbPlatoonHasUnderwaterLand] == true then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have an underwater unit, about to run code to check for underwater action') end
                        GetUnderwaterActionForLandUnit(oPlatoon)
                        if bDebugMessages == true then LOG(sFunctionRef..': Action after checking for underwater actions='..(oPlatoon[refiCurrentAction] or 'nil')) end
                    end
                    --Soemtimes may already ahve had action (e.g. from override) before running the logic, so this checks if action has changed following underwater logic
                    if not(oPlatoon[refiCurrentAction] == iExistingAction) then bDontConsiderFurtherOrders = true end

                    --fatboy - run from lots of T2+ mobile units
                    if not(bDontConsiderFurtherOrders) and sPlatoonName == 'M27GroundExperimental' and EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId) then
                        --Siginficant enemy mobile threat? (uses different threshold to conventional 'do we have more mass than nearby enemy' calc done later)
                        if not(oPlatoon[refiCurrentAction]) then
                            local tEnemyCombatUnitsActuallyInRange = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandCombat - categories.TECH1 + M27UnitInfo.refCategoryIndirectT2Plus + categories.COMMAND, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refiPlatoonMaxRange], 'Enemy')
                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby T2+ mobile land threats empty='..tostring(M27Utilities.IsTableEmpty(tEnemyCombatUnitsActuallyInRange))..'; Intel coverage='..M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oPlatoon), nil, true)) end
                            if M27Utilities.IsTableEmpty(tEnemyCombatUnitsActuallyInRange) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Size of table of enemy land units='..table.getn(tEnemyCombatUnitsActuallyInRange)..'; mass value='..M27Logic.GetCombatThreatRating(aiBrain, tEnemyCombatUnitsActuallyInRange, true, nil, nil, false, true)) end
                                if table.getn(tEnemyCombatUnitsActuallyInRange) >= 15 or M27Logic.GetCombatThreatRating(aiBrain, tEnemyCombatUnitsActuallyInRange, true, nil, nil, false, true) >= 3000 then
                                    --Temporary retreat to try and kite enemy threat
                                    oPlatoon[refiCurrentAction] = refActionKitingRetreat
                                    bDontConsiderFurtherOrders = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will do kiting retreat') end
                                end
                            end
                        end

                        --If no significant enemy threat and enemy structures in range then attack
                        if not(oPlatoon[refiCurrentAction]) and oPlatoon[refiEnemyStructuresInRange] then oPlatoon[refiCurrentAction] = refActionAttack end

                    end

                    if bDontConsiderFurtherOrders == false then
                        --ACU - finish building t1 mex, and reclaim even if enemies in range, provided none are in combat range

                        if oPlatoon[refbACUInPlatoon] then
                            --Finish building mex if almost done
                            if oPlatoon[reftBuilders][1]:IsUnitState('Building') or oPlatoon[reftBuilders][1]:IsUnitState('Repairing') and oPlatoon[reftBuilders][1].GetFocusUnit and oPlatoon[reftBuilders][1]:GetWorkProgress() >= 0.75 then
                                local oBuilding = oPlatoon[reftBuilders][1]:GetFocusUnit()
                                if bDebugMessages == true then LOG(sFunctionRef..': ACU is building or reparing oBuilding='..oBuilding.UnitId..M27UnitInfo.GetUnitLifetimeCount(oBuilding)..'; Fraction complete='..oBuilding:GetFractionComplete()) end
                                if M27UnitInfo.IsUnitValid(oBuilding) and EntityCategoryContains(M27UnitInfo.refCategoryStructure * categories.TECH1 - M27UnitInfo.refCategoryPower, oBuilding.UnitId) and oBuilding:GetFractionComplete() < 1 and oBuilding:GetFractionComplete() >= 0.75 then
                                    --Keep building
                                    oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                    oPlatoon[refoConstructionToAssist] = oBuilding
                                    if bDebugMessages == true then LOG(sFunctionRef..': Almost complete with construction so will complete even if nearby enemies') end
                                end
                            end


                            --Consider combat reclaiming of wrecks if dont have much mass and arent within range of an enemy
                            if not(oPlatoon[refiCurrentAction]) and (oPlatoon[reftBuilders][1]:IsUnitState('Reclaiming') and (aiBrain:GetEconomyStoredRatio('MASS') <= 0.2 or aiBrain:GetEconomyStored('MASS') <= 300))
                                    or (aiBrain:GetEconomyStoredRatio('MASS') <= 0.1 or aiBrain:GetEconomyStored('MASS') <= 200) then

                                -- (aiBrain:GetEconomyStoredRatio('MASS') <= 0.1 or aiBrain:GetEconomyStored('MASS') <= 200) then
                                local iHighestEnemyRange = 0

                                local iNearestEnemyDistance = 10000
                                local oNearestEnemyUnit
                                if oPlatoon[refiEnemiesInRange] > 0 then
                                    iHighestEnemyRange = M27Logic.GetUnitMaxGroundRange(oPlatoon[reftEnemiesInRange])
                                    oNearestEnemyUnit = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon))
                                    iNearestEnemyDistance = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearestEnemyUnit:GetPosition())
                                end
                                if oPlatoon[refiEnemyStructuresInRange] > 0 then
                                    iHighestEnemyRange = math.max(iHighestEnemyRange, M27Logic.GetUnitMaxGroundRange(oPlatoon[reftEnemyStructuresInRange]))
                                    oNearestEnemyUnit = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon))
                                    iNearestEnemyDistance = math.min(iNearestEnemyDistance, M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearestEnemyUnit:GetPosition()))
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Will consider getting reclaim even if are in combat. iHighestEnemyRange='..iHighestEnemyRange..'; iNearestEnemyDistance='..iNearestEnemyDistance) end

                                --Consider getting reclaim provided nearest enemy more than 3 out of both our and their possible range
                                if iNearestEnemyDistance > 3 + math.max(oPlatoon[refiPlatoonMaxRange], iHighestEnemyRange) then
                                    DetermineActionForNearbyReclaim(oPlatoon, true)
                                    if oPlatoon[refiCurrentAction] then bDontConsiderFurtherOrders = true end
                                end
                            end
                        end



                        if not(bDontConsiderFurtherOrders) then
                            --======ACU Enemy units cant be hit - BLOCKED LOGIC-------
                            --local iPlatoonMaxRange
                            if oPlatoon[refbACUInPlatoon] == true then
                                --iPlatoonMaxRange = M27Logic.GetDFAndT1ArtiUnitMinOrMaxRange(oPlatoon:GetPlatoonUnits(), 2)
                                local bShotIsBlockedForAnyUnit = oPlatoon[reftBuilders][1][M27UnitInfo.refbLastShotBlocked]
                                local bShotBlockedForCurTarget = oPlatoon[reftBuilders][1][M27UnitInfo.refbLastShotBlocked]
                                local bShotIsBlockedForAllUnits = false
                                local iClosestUnitWhereShotNotBlocked = 1000
                                local iClosestMobileUnit = 1000
                                local oClosestMobileUnit
                                local oClosestUnitWhereShotNotBlocked
                                local sEnemyRef, sEnemyCountRef, iCurDistance
                                local tACUPosition = GetPlatoonFrontPosition(oPlatoon)
                                local oACU = M27Utilities.GetACU(aiBrain)
                                if bDebugMessages == true then LOG(sFunctionRef..': About to check if any nearby enemies are blocked. Is shot blocked for front unit='..tostring(oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked])) end
                                --Do we have a current target, and if so is the shot blocked?
                                local iWeaponCount = oACU:GetWeaponCount()
                                local oWeapon
                                local oCurTarget



                                if not(bShotBlockedForCurTarget) then
                                    for i = 1, iWeaponCount do
                                        oWeapon = oACU:GetWeapon(i)
                                        if oWeapon.GetCurrentTarget and oWeapon.RangeCategory == 'UWRC_DirectFire' then
                                            oCurTarget = oWeapon:GetCurrentTarget()
                                            if oCurTarget and not(oCurTarget.Dead) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': oCurTarget='..oCurTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oCurTarget)) end
                                                bShotBlockedForCurTarget = M27Logic.IsShotBlocked(oACU, oCurTarget)
                                                if bShotBlockedForCurTarget then
                                                    bShotIsBlockedForAnyUnit = true
                                                    if bDebugMessages == true then
                                                        LOG(sFunctionRef..': Will draw red circle at target that is blocked')
                                                        M27Utilities.DrawLocation(oCurTarget:GetPosition(), nil, 2, 100)
                                                    end
                                                end
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef..': Found a target for ACUs current weapon, checking if shot is blocked. bShotBlockedForCurTarget='..tostring(bShotBlockedForCurTarget))
                                                    M27Utilities.DrawLocation(oCurTarget:GetPosition())
                                                end
                                                break
                                            end
                                        end
                                    end
                                end

                                if bShotBlockedForCurTarget == true then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked for cur target') end
                                    bShotIsBlockedForAllUnits = true --changed back to false by below
                                    for iEnemyType = 1, 2 do
                                        if iEnemyType == 1 then sEnemyRef = reftEnemiesInRange sEnemyCountRef = refiEnemiesInRange
                                        else sEnemyRef = reftEnemyStructuresInRange sEnemyCountRef = refiEnemyStructuresInRange end
                                        if oPlatoon[sEnemyCountRef] > 0 then
                                            for iUnit, oUnit in oPlatoon[sEnemyRef] do
                                                if not(oUnit.Dead) then
                                                    iCurDistance = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tACUPosition)
                                                    if iCurDistance <= oPlatoon[refiPlatoonMaxRange] then
                                                        local bUnitExists = false
                                                        --if iEnemyType == 1 then bUnitExists = true
                                                        --elseif oUnit.GetFractionComplete and oUnit:GetFractionComplete() > 0 then bUnitExists = true end
                                                        --if bUnitExists == true then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': iUnit='..iUnit..': Is within range of platoon, iCurDistance='..iCurDistance..' checking if its blocked') end
                                                        if M27Logic.IsShotBlocked(oACU, oUnit) == false then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': iUnit='..iUnit..': Shot is not blocked') end
                                                            bShotIsBlockedForAllUnits = false
                                                            if iCurDistance < iClosestUnitWhereShotNotBlocked then
                                                                iClosestUnitWhereShotNotBlocked = iCurDistance
                                                                oClosestUnitWhereShotNotBlocked = oUnit
                                                            end

                                                        else
                                                            if bDebugMessages == true then LOG(sFunctionRef..': iUnit='..iUnit..': Shot is blocked') end
                                                            --bShotIsBlockedForAnyUnit = true
                                                            if iEnemyType == 1 then
                                                                if iClosestMobileUnit > iCurDistance then
                                                                    iClosestMobileUnit = iCurDistance
                                                                    oClosestMobileUnit = oUnit
                                                                end
                                                            end
                                                        end
                                                        --end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                else
                                    bShotIsBlockedForAnyUnit = false
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if nearby units are blocked, bShotIsBlockedForAllUnits='..tostring(bShotIsBlockedForAllUnits)..'; bShotIsBlockedForAnyUnit='..tostring(bShotIsBlockedForAnyUnit)) end
                                --Update action if some or all units nearby are blocked
                                if bShotBlockedForCurTarget == true then
                                    if bShotIsBlockedForAllUnits == true and oPlatoon[refiReclaimers] > 0 then

                                        local iBuildDistance = oPlatoon[reftReclaimers][1]:GetBlueprint().Economy.MaxBuildDistance
                                        if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked for all units. iBuildDistance='..iBuildDistance..'; iClosestMobileUnit='..iClosestMobileUnit) end
                                        if iClosestMobileUnit <= (iBuildDistance + 1) and M27UnitInfo.IsUnitValid(oClosestMobileUnit) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Units are blocked but in build range so will reclaim') end
                                            oPlatoon[refoNearbyReclaimTarget] = oClosestMobileUnit
                                            oPlatoon[refiCurrentAction] = refActionReclaimTarget
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked so will move to nearest enemy') end
                                            oPlatoon[refiCurrentAction] = refActionMoveDFToNearestEnemy
                                        end
                                        bDontConsiderFurtherOrders = true
                                        --elseif bShotIsBlockedForAnyUnit == true then
                                    elseif not(bShotIsBlockedForAllUnits) and oClosestUnitWhereShotNotBlocked then
                                        oPlatoon[refiCurrentAction] = refActionAttackSpecificUnit
                                        oPlatoon[refoTemporaryAttackTarget] = oClosestUnitWhereShotNotBlocked
                                        if not(M27UnitInfo.IsUnitValid(oClosestUnitWhereShotNotBlocked)) then M27Utilities.ErrorHandler('Invalid unit') end
                                    end
                                end
                                if bDebugMessages == true then
                                    if oPlatoon[refiCurrentAction] == nil then LOG('Action after checking for blocked units is nil')
                                    else LOG('Action after checking for blocked units='..oPlatoon[refiCurrentAction]) end
                                end
                            end
                        end
                        --Check we dont already have an action:
                        if oPlatoon[refiCurrentAction] == nil then bDontConsiderFurtherOrders = false
                        else --Already have an action - only consider remaining logic if were assigned action by overseer override
                            if bDebugMessages == true then LOG(sFunctionRef..': Have got an action assigned so wont consider further orders such as kiting unless it was an action from the overseer') end
                            if bAlreadyHaveAttackActionFromOverseer == true and oPlatoon[refiCurrentAction] == iExistingAction then bDontConsiderFurtherOrders = false end
                        end
                        if bDontConsiderFurtherOrders == false then
                            --=========KITING LOGIC-------------
                            if oPlatoon[refiEnemiesInRange] > 0 or (oPlatoon[refiEnemyStructuresInRange] > 0 and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.DIRECTFIRE + categories.INDIRECTFIRE, oPlatoon[reftEnemyStructuresInRange])) == false) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have mobile enemies in range, will consider kiting action. oPlatoon[refbKiteEnemies]='..tostring(oPlatoon[refbKiteEnemies])) end
                                if oPlatoon[refbKiteEnemies] == true then
                                    --Default to attack move if front unit last shot not blocked, and default to not attack moving if last shot blocked
                                    if oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] then
                                        oPlatoon[M27PlatoonTemplates.refbAttackMove] = false
                                    else
                                        if M27PlatoonTemplates.PlatoonTemplate[sPlatoonName][M27PlatoonTemplates.refbAttackMove] then
                                            oPlatoon[M27PlatoonTemplates.refbAttackMove] = true
                                        end
                                    end

                                    if oPlatoon[refbACUInPlatoon] == true or oPlatoon[refiDFUnits] > 0 or (oPlatoon[refiIndirectUnits] > 0 and EntityCategoryContains(categories.EXPERIMENTAL + categories.TECH1, oPlatoon[refoFrontUnit])) then
                                        if bDebugMessages == true then LOG(sFunctionRef..sPlatoonName..': Considering kiting action; iEnemiesInRange='..oPlatoon[refiEnemiesInRange]) end
                                        --Get nearest enemy
                                        local tPlatoonPosition = GetPlatoonFrontPosition(oPlatoon)
                                        local tNearbyPD = {}
                                        local oNearestPD

                                        if oPlatoon[refiEnemyStructuresInRange] > 0 then
                                            tNearbyPD = EntityCategoryFilterDown(categories.DIRECTFIRE, oPlatoon[reftEnemyStructuresInRange])
                                            if M27Utilities.IsTableEmpty(tNearbyPD) == false then
                                                oNearestPD = M27Utilities.GetNearestUnit(tNearbyPD, tPlatoonPosition, aiBrain, true)
                                            end
                                        end
                                        local oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], tPlatoonPosition, aiBrain, true)
                                        if oNearestEnemy or oNearestPD then
                                            local iNearestEnemyDistance = 1000
                                            local iNearestPDDistance = 1000
                                            local tNearestPD, tNearestEnemy


                                            if oNearestPD then
                                                tNearestPD = oNearestPD:GetPosition()
                                                iNearestPDDistance = M27Utilities.GetDistanceBetweenPositions(tNearestPD, tPlatoonPosition)
                                                iEnemyMaxRange = math.max(iEnemyMaxRange, M27Logic.GetDFAndT1ArtiUnitMinOrMaxRange(tNearbyPD, 2, true))
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have nearby PD, iMaxRange after considering this='..iEnemyMaxRange) end
                                            end
                                            if oNearestEnemy then
                                                iEnemyMaxRange = math.max(iEnemyMaxRange, M27Logic.GetDFAndT1ArtiUnitMinOrMaxRange(oPlatoon[reftEnemiesInRange], 2, true))
                                                tNearestEnemy = oNearestEnemy:GetPosition()
                                                iNearestEnemyDistance = M27Utilities.GetDistanceBetweenPositions(tNearestEnemy, tPlatoonPosition)
                                                if bDebugMessages == true then LOG(sFunctionRef..': tNearestEnemy='..repru(tNearestEnemy)..'; tPlatoonPosition='..repru(tPlatoonPosition)..'; oNearestEnemy='..oNearestEnemy.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestEnemy)..'; Platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))..'; Platoon front unit='..oPlatoon[refoFrontUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit])) end
                                            end
                                            if oNearestPD and iNearestPDDistance < iNearestEnemyDistance then
                                                oNearestEnemy = oNearestPD
                                            end
                                            --CanSeeUnit(aiBrain, oUnit, bTrueIfOnlySeeBlip)
                                            --[[if oNearestEnemy == oNearestPD then
                                                --Dont need CanSeeUnit, as in reality will have visual effect from enemy PD that is distinctive such that will know if there's an enemy PD nearby
                                                iEnemyMaxRange = M27Logic.GetDFAndT1ArtiUnitMinOrMaxRange({oNearestEnemy}, 2, true)
                                            else
                                                if M27Utilities.CanSeeUnit(aiBrain, oNearestEnemy, false) then iEnemyMaxRange = M27Logic.GetDFAndT1ArtiUnitMinOrMaxRange({oNearestEnemy}, 2, true) end
                                            end--]]



                                            if bDebugMessages == true then LOG(sFunctionRef..sPlatoonName..': iPlatoonMaxRange='..oPlatoon[refiPlatoonMaxRange]..'; iEnemyMaxRange='..iEnemyMaxRange) end
                                            if oPlatoon[refiPlatoonMaxRange] >= iEnemyMaxRange then --if have same max range may still be benefit to kiting if enemy lacks intel
                                                if oNearestEnemy == oNearestPD then
                                                    bDontConsiderFurtherOrders = true
                                                    oPlatoon[refiCurrentAction] = refActionMoveJustWithinRangeOfNearestPD
                                                    if sPlatoonName == 'M27GroundExperimental' then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Are experimental so will attack') end
                                                        oPlatoon[refiCurrentAction] = refActionAttack
                                                    end
                                                else
                                                    --GetIntelCoverageOfPosition(aiBrain, tTargetPosition, iMinCoverageWanted)
                                                    --    --Look for the nearest intel coverage for tTargetPosition
                                                    --    --if iMinCoverageWanted isn't specified then will return the highest amount, otherwise returns true/false

                                                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': Dont have nearby PD; iNearestEnemyDistance='..iNearestEnemyDistance..'; oPlatoon[refiPlatoonMaxRange]='..oPlatoon[refiPlatoonMaxRange]..'; Intel coverage (relevant for skirmishers)='..M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oPlatoon), nil, false)) end
                                                    if iNearestEnemyDistance > oPlatoon[refiPlatoonMaxRange] then
                                                        --If are a skirmisher then only move closer if we have decent intel coverage
                                                        if not(oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic]) then
                                                            bDontConsiderFurtherOrders = true
                                                            oPlatoon[refiCurrentAction] = refActionMoveDFToNearestEnemy
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy is further than our max range, so want to move to the nearest enemy') end
                                                            --Do we want to attack-move instead of move?
                                                            if oPlatoon[M27PlatoonTemplates.refbAttackMove] or oPlatoon[refiIndirectUnits] > 0 then oPlatoon[refiCurrentAction] = refActionAttack end
                                                        else
                                                            --Are a skirmisher platoon - do we have enough intel?
                                                            local iCoverageWanted = math.max(oPlatoon[refiPlatoonMaxRange] - 5, math.min(iNearestEnemyDistance, oPlatoon[refiPlatoonMaxRange]), math.min(iNearestEnemyDistance + 3, iEnemyMaxRange + 5, aiBrain[M27Overseer.refiHighestMobileLandEnemyRange] + 3))
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Skirmisher kiting logic - iCoverageWanted='..iCoverageWanted..'; Intel coverage='..M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oPlatoon), nil, false)..'; Nearest unit state='..M27Logic.GetUnitState(oNearestEnemy)..'; Nearest enemy facing angle='..M27UnitInfo.GetUnitFacingAngle(oNearestEnemy)..'; Angle from nearest enemy to platoon='..M27Utilities.GetAngleFromAToB(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon))..'; Angle dif='..M27Utilities.GetAngleDifference(M27UnitInfo.GetUnitFacingAngle(oNearestEnemy), M27Utilities.GetAngleFromAToB(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon)))..'; Front unit speed='..oPlatoon[refoFrontUnit]:GetBlueprint().Physics.MaxSpeed..'; Nearest enemy speed='..oNearestEnemy:GetBlueprint().Physics.MaxSpeed) end
                                                            if M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oPlatoon), iCoverageWanted, false) then
                                                                local iEnemyAngleFacingDif = M27Utilities.GetAngleDifference(M27UnitInfo.GetUnitFacingAngle(oNearestEnemy), M27Utilities.GetAngleFromAToB(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon)))
                                                                if oPlatoon[refiPlatoonMaxRange] - iEnemyMaxRange <= 8 and oNearestEnemy:IsUnitState('Moving') and iNearestEnemyDistance - 1.5 - math.max(2, oPlatoon[refoFrontUnit]:GetBlueprint().Physics.MaxSpeed, oNearestEnemy:GetBlueprint().Physics.MaxSpeed) < oPlatoon[refiPlatoonMaxRange] and iEnemyAngleFacingDif <= 50 then
                                                                    bDontConsiderFurtherOrders = true

                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have good intel and not yet in range of enemy we outrange, but are lamost in range so want to turn around so we are ready to run unless enemy almost here in which case want to run') end
                                                                    if iNearestEnemyDistance - 1.25 <= oPlatoon[refiPlatoonMaxRange] then --Tradeoff between survivability and fighting as can be up to a 4s delay with hoplites when testing vs UEF guncom
                                                                        oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Doing temporary retreat as enemy almost within our range') end
                                                                    else
                                                                        oPlatoon[refiCurrentAction] = refActionTurnAwayFromEnemy
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy not in range yet so just want to turn around so are ready to retreat') end
                                                                    end
                                                                    oPlatoon[refbFasterRefreshNextCycle] = true

                                                                else
                                                                    bDontConsiderFurtherOrders = true
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have sufficient intel so will attack nearest enemy unless nearest enemy is almost in range and enemy is close to our range and moving and facing near us') end
                                                                    oPlatoon[refiCurrentAction] = refActionAttack
                                                                    oPlatoon[M27PlatoonTemplates.refbAttackMove] = true --may have been set back to false from kiting retreat action
                                                                    --If enemy is nearby then flag to refresh more frequently
                                                                    if oPlatoon[refiPlatoonMaxRange] - iEnemyMaxRange <= 10 and iNearestEnemyDistance - oPlatoon[refiPlatoonMaxRange] <= 6 then
                                                                        oPlatoon[refbFasterRefreshNextCycle] = true
                                                                    end
                                                                end
                                                            else
                                                                --Dont have intel so retreat
                                                                bDontConsiderFurtherOrders = true
                                                                oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Skirmisher platoon that lacks sufficient intel so will fall back temporarily') end
                                                                aiBrain[reftSkirmisherPlatoonWantingIntel][sPlatoonName..oPlatoon[refiPlatoonCount]] = oPlatoon
                                                            end
                                                        end
                                                    else
                                                        local iIntelCoverage
                                                        --If ACU in platoon, then check if it has a scout assigned that is close enough (for CPU performance reasons only want to call getintelcoverage if we dont)
                                                        if oPlatoon[refbACUInPlatoon] and oPlatoon[refoFrontUnit] and M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit][M27Overseer.refoScoutHelper]) then iIntelCoverage = oPlatoon[refoFrontUnit][M27Overseer.refoScoutHelper]:GetBlueprint().Intel.RadarRadius - M27Utilities.GetDistanceBetweenPositions(oPlatoon[refoFrontUnit][M27Overseer.refoScoutHelper]:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) end
                                                        if not(iIntelCoverage) or iIntelCoverage < math.max(iEnemyMaxRange, 22) then iIntelCoverage = M27Logic.GetIntelCoverageOfPosition(aiBrain, tPlatoonPosition, nil) end
                                                        if bDebugMessages == true then LOG(sFunctionRef..sPlatoonName..': We outrange nearest enemy, checking our intel coverage, iIntelCoverage='..iIntelCoverage..'; iEnemyMaxRange='..(iEnemyMaxRange or 'nil')..'; iNearestEnemyDistance='..iNearestEnemyDistance) end
                                                        if iIntelCoverage >= math.max(iEnemyMaxRange, 22) then --ACU has range of 22 (no gun) and vision of 26, so want to have intel coverage of at least this before consider other actions
                                                            local iDistanceInsideOurRange = oPlatoon[refiPlatoonMaxRange] - iNearestEnemyDistance
                                                            local iPrevDistanceInsideOurRange = oPlatoon[refiPrevNearestEnemyDistance]
                                                            oPlatoon[refiPrevNearestEnemyDistance] = iDistanceInsideOurRange
                                                            local iDistToConsiderIfTheyAreRunningAway = 5
                                                            if oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] then iDistToConsiderIfTheyAreRunningAway = 0 end
                                                            if EntityCategoryContains(categories.STRUCTURE, oNearestEnemy.UnitId) or (oNearestEnemy:GetBlueprint().Physics.MaxSpeed - oPlatoon[refoFrontUnit]:GetBlueprint().Physics.MaxSpeed) <= 0.95 or (EntityCategoryContains(categories.COMMAND, oNearestEnemy.UnitId) and oNearestEnemy:IsUnitState('Upgrading')) then iDistToConsiderIfTheyAreRunningAway = math.min(4.5, math.max(oPlatoon[refoFrontUnit]:GetBlueprint().Physics.MaxSpeed, 2.5)) end
                                                            if bDebugMessages == true then LOG(sFunctionRef..sPlatoonName..': iDistanceInsideOurRange='..iDistanceInsideOurRange..'; iDistToConsiderIfTheyAreRunningAway='..iDistToConsiderIfTheyAreRunningAway..'; Dist to enemy='..M27Utilities.GetDistanceBetweenPositions(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon))) end
                                                            if iDistanceInsideOurRange > iDistToConsiderIfTheyAreRunningAway then
                                                                bDontConsiderFurtherOrders = true
                                                                oPlatoon[refiCurrentAction] = refActionKitingRetreat
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy too far inside our range so will do kiting retreat') end
                                                            else
                                                                if iDistanceInsideOurRange > 0 and (iPrevDistanceInsideOurRange == nil or iPrevDistanceInsideOurRange < iDistanceInsideOurRange) then --Enemy getting close
                                                                    bDontConsiderFurtherOrders = true
                                                                    oPlatoon[refiCurrentAction] = refActionKitingRetreat
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy inside our range and getting closer so doing kiting retreat') end
                                                                else
                                                                    --Skirmisher platoon - require 40 intel to not retreat
                                                                    if oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] and iIntelCoverage < math.min(40, oPlatoon[refiPlatoonMaxRange]) then
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Skirmisher platoon, iIntelCoverage='..iIntelCoverage..'; platoon max range='..oPlatoon[refiPlatoonMaxRange]) end
                                                                        bDontConsiderFurtherOrders = true
                                                                        oPlatoon[refiCurrentAction] = refActionKitingRetreat
                                                                        aiBrain[reftSkirmisherPlatoonWantingIntel][sPlatoonName..oPlatoon[refiPlatoonCount]] = oPlatoon
                                                                    else
                                                                        --Have decent intel, and possible that enemy is getting away; move towards them unless their facing is towards us
                                                                        if M27Utilities.GetAngleDifference(M27UnitInfo.GetUnitFacingAngle(oNearestEnemy), M27Utilities.GetAngleFromAToB(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon))) >= 50 then
                                                                            bDontConsiderFurtherOrders = true
                                                                            if oPlatoon[refiIndirectUnits] > 0 or oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] then
                                                                                oPlatoon[refiCurrentAction] = refActionAttack
                                                                            else
                                                                                oPlatoon[refiCurrentAction] = refActionMoveDFToNearestEnemy
                                                                            end
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Think enemy may be getting away so will move towards them, action='..oPlatoon[refiCurrentAction]..'; Indirect units='..oPlatoon[refiIndirectUnits]..'; Skirmisher treat logic='..tostring(oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic])) end
                                                                        else
                                                                            bDontConsiderFurtherOrders = true
                                                                            oPlatoon[refiCurrentAction] = refActionKitingRetreat
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy is facing near us so assuming theyre not moving away so will do kiting retreat') end
                                                                        end
                                                                    end

                                                                end
                                                            end
                                                            --Dont do kiting retreat if closest enemy isnt moving towards us
                                                            if oPlatoon[refiCurrentAction] == refActionKitingRetreat and iDistanceInsideOurRange < 7 then
                                                                --Dont kite if the nearest enemy unit is stationery and not attacking, instead just attack it if no enemy indirect fire units nearby
                                                                if M27Utilities.IsTableEmpty(M27Utilities.EntityCategoryFilterDown(M27UnitInfo.refCategoryIndirect, oPlatoon[reftEnemiesInRange])) then
                                                                    local oNearestMobileEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                                                    if not(oNearestMobileEnemy:IsUnitState('Moving')) and not(oNearestMobileEnemy:IsUnitState('Attacking')) and not(oNearestMobileEnemy:IsUnitState('Guarding')) and not(oNearestMobileEnemy:IsUnitState('Patrolling')) then
                                                                        --Nearest unit isnt moving so can just attack
                                                                        oPlatoon[refiCurrentAction] = refActionAttack
                                                                    end
                                                                end
                                                            end
                                                        elseif oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] then
                                                            --We lack sufficient intel so want to retreat
                                                            aiBrain[reftSkirmisherPlatoonWantingIntel][sPlatoonName..oPlatoon[refiPlatoonCount]] = oPlatoon
                                                            oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have much intel coverage and are skirmisher retreat logic so will temoprarily retreat') end
                                                        end
                                                    end
                                                end
                                            else
                                                --We either dont outrange enemy or dont know if we do - revert to normal logic
                                                --If we are a skirmisher platoon then retreat to nearest rally if the enemy outranges us
                                                if oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] and iEnemyMaxRange > oPlatoon[refiPlatoonMaxRange] then
                                                    oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy platoon outranges us and we are using skirmisher retreat logic so will go to nearest rally point') end
                                                end
                                                --bDontConsiderFurtherOrders = true
                                                --oPlatoon[refiCurrentAction] = refActionMoveDFToNearestEnemy
                                            end
                                            --Kiting override - if have >=3 unit closer to enemy than us in different platoons, then want to just attack rather than running away
                                            if oPlatoon[refiCurrentAction] == refActionKitingRetreat and M27UnitInfo.IsUnitValid(oNearestEnemy) and not(oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic]) then
                                                local iCloserAllyCount = 0
                                                local tCloserAllies = aiBrain:GetUnitsAroundPoint(categories.LAND * categories.DIRECTFIRE + categories.LAND * categories.INDIRECTFIRE, tPlatoonPosition, iNearestEnemyDistance, 'Ally')
                                                if M27Utilities.IsTableEmpty(tCloserAllies) == false then
                                                    local iCloserAllyCount = table.getn(tCloserAllies)
                                                    if iCloserAllyCount >= 3 then --in reality 2 as ACU should be included
                                                        iCloserAllyCount = 0
                                                        local iCurDist
                                                        for iUnit, oUnit in tCloserAllies do
                                                            if oUnit.PlatoonHandle and not(oPlatoon == oUnit.PlatoonHandle) then
                                                                iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemy:GetPosition())
                                                                if iCurDist < (iNearestEnemyDistance - 2) then
                                                                    iCloserAllyCount = iCloserAllyCount + 1
                                                                end
                                                            end
                                                        end
                                                        if iCloserAllyCount >= 3 then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Have at least 3 closer allies so will attack') end
                                                            oPlatoon[refiCurrentAction] = refActionAttack
                                                        end
                                                    end
                                                end
                                            end
                                            --Further kiting override - if about to fire a shot, are a sniperbot, and enemy not that far in our range, then attack instead of kiting retreat
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if should override a retreat with an attack if we are about to fire.  Current action='..(oPlatoon[refiCurrentAction] or 'nil')..'; Is our front a unit a sniper bot='..tostring(EntityCategoryContains(M27UnitInfo.refCategorySniperBot, oPlatoon[refoFrontUnit].UnitId))..'; iNearestEnemyDistance='..iNearestEnemyDistance..'; iEnemyMaxRange='..iEnemyMaxRange..'; oPlatoon[refiPlatoonMaxRange]='..oPlatoon[refiPlatoonMaxRange]..'; Time between shots='..1 / M27UnitInfo.GetDFRateOfFire(oPlatoon[refoFrontUnit])..'; Time since last fired='..GetGameTimeSeconds() - (oPlatoon[refoFrontUnit][M27UnitInfo.refiTimeLastFired] or 0)..'; was last shot blocked='..tostring(oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] or false)) end
                                            if oPlatoon[refiCurrentAction] == refActionKitingRetreat and EntityCategoryContains(M27UnitInfo.refCategorySniperBot, oPlatoon[refoFrontUnit].UnitId)then
                                                --Is the enemy within our range, but not too far within?
                                                if iNearestEnemyDistance > iEnemyMaxRange + 6 and iNearestEnemyDistance > oPlatoon[refiPlatoonMaxRange] - 20 and oPlatoon[refiPlatoonMaxRange] >= iNearestEnemyDistance and not(oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked]) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy still within a range that we could consider attacking instead of doing kiting retreat. iNearestEnemyDistance='..iNearestEnemyDistance..'; Our range='..oPlatoon[refiPlatoonMaxRange]..'; time since last fired shot='..GetGameTimeSeconds() - (oPlatoon[refoFrontUnit][M27UnitInfo.refiTimeLastFired] or 0)) end
                                                    local iTimeBetweenShots = 1 / M27UnitInfo.GetDFRateOfFire(oPlatoon[refoFrontUnit])
                                                    if iTimeBetweenShots >= 2 and GetGameTimeSeconds() - (oPlatoon[refoFrontUnit][M27UnitInfo.refiTimeLastFired] or 0) >= (iTimeBetweenShots - 1.25) then
                                                        --Are about to be able to shoot at enemy so want to attack for now
                                                        oPlatoon[refiCurrentAction] = refActionAttack
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will override with an attack order') end
                                                    end
                                                end
                                            end

                                            --Attack-move for skirmishers if outrange enemy
                                            if oPlatoon[refiCurrentAction] == refActionAttack and oPlatoon[refiPlatoonMaxRange] >= iEnemyMaxRange and oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] and not(M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit])) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to attack with skirmisher platoon, we have same or grater range than enemy, so will flag that we want to attack-move') end
                                                oPlatoon[M27PlatoonTemplates.refbAttackMove] = true --Will factor in if shot is blocked as part of platoon move

                                            end
                                            --If attack-moving and have a sniperbot then attackspecific target instead if enemies are in range
                                            if oPlatoon[refiCurrentAction] == refActionAttack and EntityCategoryContains(M27UnitInfo.refCategorySniperBot - categories.EXPERIMENTAL, oPlatoon[refoFrontUnit].UnitId) and not(oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked]) and iNearestEnemyDistance <= oPlatoon[refiPlatoonMaxRange] then
                                                oPlatoon[refiCurrentAction] = refActionCoordinatedAttack
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will use a coordinated attack') end
                                            end
                                        end

                                    end
                                end
                                if bDebugMessages == true then if oPlatoon[refiCurrentAction]==nil then LOG(sFunctionRef..sPlatoonName..': Action after running kiting logic is nil')
                                else LOG(sFunctionRef..sPlatoonName..': Action after running kiting logic='..oPlatoon[refiCurrentAction])end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': No nearby enemies, will check if want to use overcharge and if have nearby naval surface threats') end
                                --ACU action for nearby naval units when no ground threats - move towards them to get in range
                                if oPlatoon[refbACUInPlatoon] == true and M27Conditions.CanUnitUseOvercharge(aiBrain, M27Utilities.GetACU(aiBrain)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Can use overcharge; about to check if have nearby naval units in which case will move towards them so are in range') end
                                    local tNearbyNavy = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryNavalSurface, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refiPlatoonMaxRange] + 8, 'Enemy')
                                    if M27Utilities.IsTableEmpty(tNearbyNavy) == false then
                                        local oNearestNavy = M27Utilities.GetNearestUnit(tNearbyNavy, GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                        local iDistToMove = math.max(4, M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearestNavy:GetPosition()) - oPlatoon[refiPlatoonMaxRange] + 4)
                                        local iAngleToMove = M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), oNearestNavy:GetPosition())
                                        local tPositionToMove = M27Utilities.MoveInDirection(GetPlatoonFrontPosition(oPlatoon), iAngleToMove, iDistToMove)
                                        local iCurLandPathing = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeLand, GetPlatoonFrontPosition(oPlatoon))
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have nearby naval units; iDistToMove='..iDistToMove..'; iCurLandPathing='..iCurLandPathing..'; tPositionToMove='..repru(tPositionToMove)) end
                                        if iCurLandPathing == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeLand, tPositionToMove) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Land can path to a position that is closer to the naval unit so will move there') end
                                            oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                                            oPlatoon[reftTemporaryMoveTarget] = tPositionToMove
                                            if bDebugMessages == true then LOG(sFunctionRef..': Setting temporary move target to '..repru(oPlatoon[reftTemporaryMoveTarget])) end
                                        end
                                    end
                                end
                            end
                            if oPlatoon[refbKiteEnemies] == true then
                                if oPlatoon[refiCurrentAction] == nil then
                                    if oPlatoon[refbKitingLogicActive] == true then
                                        --Were previously kiting, now have no action re kiting - e.g. enemy destroyed, or run away; reissue movement path if no nearby structures either
                                        if bDebugMessages == true then LOG(sFunctionRef..': Kiting logic has no action, but previously did; reissuing movement path if no enemies nearby') end
                                        if oPlatoon[refiEnemyStructuresInRange] + oPlatoon[refiEnemiesInRange] == 0 then
                                            oPlatoon[refiCurrentAction] = refActionReissueMovementPath
                                        end
                                    end
                                    oPlatoon[refbKitingLogicActive] = false
                                else
                                    oPlatoon[refbKitingLogicActive] = true
                                end
                            end
                        else
                            --Already have an action from running or units blocked
                            bDontConsiderFurtherOrders = true
                        end
                    end
                end
            else
                if not(oPlatoon[refiCurrentAction]) then oPlatoon[refiCurrentAction] = refActionTemporaryRetreat end --redundancy for if we wont proceed with normal logic about if we can attack but havent given any other order
            end





            --=================ACU Overcharge logic (still OC if are running away):
            if oPlatoon[refbACUInPlatoon] == true then
                if bDebugMessages == true then LOG(sFunctionRef..' about to see if can overcharge') end
                --Assumes ACU will be in table of builders - check if only have 1, in which case should be ACU
                local oPlayerACU = M27Utilities.GetACU(aiBrain) --check in case ACU dies and causes crash
                if oPlatoon[reftBuilders][1] then if M27Conditions.CanUnitUseOvercharge(aiBrain, oPlatoon[reftBuilders][1]) == true then M27UnitMicro.GetOverchargeExtraAction(aiBrain, oPlatoon, oPlatoon[reftBuilders][1]) end end
            end
            --if oPlatoon[refbKitingLogicActive] == true and not(oPlatoon[refiCurrentAction] == nil) then bDontConsiderFurtherOrders = true end



            if oPlatoon[refiCurrentAction] == nil and not(oPlatoon[M27PlatoonTemplates.refbRunFromAllEnemies]) then bDontConsiderFurtherOrders = false
            else
                if bAlreadyHaveAttackActionFromOverseer == true and oPlatoon[refiCurrentAction] == iExistingAction then bDontConsiderFurtherOrders = false
                else bDontConsiderFurtherOrders = true
                end
            end

            if bProceed == true and bDontConsiderFurtherOrders == false then
                --Have we recently given a move DF untis order? If so then dont override it for a while unless have reacehd destination as likely gave the order as were stuck
                if bDebugMessages == true then
                    if oPlatoon[refiEnemyStructuresInRange] > 0 then
                        LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': EnemyStructuresInRange='..oPlatoon[refiEnemyStructuresInRange]..'; Platoon location='..GetPlatoonFrontPosition(oPlatoon)[1]..'-'..GetPlatoonFrontPosition(oPlatoon)[3]..'; location of first enemy structure='..oPlatoon[reftEnemyStructuresInRange][1]:GetPosition()[1]..'-'..oPlatoon[reftEnemyStructuresInRange][1]:GetPosition()[3]..'; first structure='..oPlatoon[reftEnemyStructuresInRange][1].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[reftEnemyStructuresInRange][1]))
                        LOG(sFunctionRef..': Distance to 1st structure (may not be nearest structure)='..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[reftEnemyStructuresInRange][1]:GetPosition()))
                        LOG(sFunctionRef..': Platoon max range='..M27Logic.GetUnitMaxGroundRange(oPlatoon[reftCurrentUnits]))
                        local oNearestEnemyStructure = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon))
                        LOG(sFunctionRef..': Nearest enemy structure='..oNearestEnemyStructure.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestEnemyStructure)..'; Dist to us='..M27Utilities.GetDistanceBetweenPositions(oNearestEnemyStructure:GetPosition(), GetPlatoonFrontPosition(oPlatoon)))
                    end
                end


                local bDontChangeCurrentAction = false
                if not(oPlatoon[reftPrevAction][10] == nil) then
                    if oPlatoon[reftPrevAction][1] == refActionMoveDFToNearestEnemy then
                        if bDebugMessages == true then LOG(sFunctionRef..': prev action was for DF units to move to nearest enemy, so wont consider changing unless we are an escort platoon') end
                        if not(oPlatoon[refoEscortingPlatoon]) then
                            bDontChangeCurrentAction = true
                            for iPrevAction = 1, 10 do
                                if not(oPlatoon[reftPrevAction][iPrevAction] == refActionMoveDFToNearestEnemy) then
                                    --Haven't been targetting DF for 10 cycles yet, so dont change
                                    break
                                end
                                if iPrevAction == 10 then
                                    --Have been targetting DF for 10 cycles now
                                    bDontChangeCurrentAction = false
                                end
                            end
                            if bDontChangeCurrentAction then
                                --Check if have reached the target:
                                local tDFUnits = EntityCategoryFilterDown(categories.DIRECTFIRE, oPlatoon[reftCurrentUnits])
                                if tDFUnits == nil then bDontChangeCurrentAction = false
                                else
                                    if table.getn(tDFUnits) == 0 then bDontChangeCurrentAction = false
                                    elseif M27Utilities.IsTableEmpty(oPlatoon[reftTemporaryMoveTarget]) == false then
                                        if M27Utilities.GetDistanceBetweenPositions(M27Utilities.GetAveragePosition(tDFUnits), oPlatoon[reftTemporaryMoveTarget]) <= 10 then bDontChangeCurrentAction = false end
                                    end
                                end
                            end
                        end
                    end
                end
                --[[if oPlatoon[refbACUInPlatoon] == true and not(oPlatoon[refiCurrentAction] == nil) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have already determined action for ACU platoon, so dont want to proceed with normal logic for determining action') end
                    bDontChangeCurrentAction = true
                end--]]

                --Fatboy and megalith - just want to attack if nearby enemies
                if sPlatoonName == 'M27GroundExperimental' and EntityCategoryContains(M27UnitInfo.refCategoryFatboy + M27UnitInfo.refCategorySniperBot, oPlatoon[refoFrontUnit].UnitId) then
                    bDontChangeCurrentAction = true
                    bProceed = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Have fatboy or megalith so will ignore normal threat based logic since megalith cant kite and fatboy is best if firing at enemy rather than running before it meets the threat') end
                    if not(oPlatoon[refiCurrentAction]) then
                        --Do we have significant threat enemies or are outranged by enemies? Then attack
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont have an action for platoon, considering if want to attack') end
                        if oPlatoon[refiEnemyStructuresInRange] > 0 and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH2 + categories.TECH3 + categories.EXPERIMENTAL, oPlatoon[reftEnemyStructuresInRange])) == false then
                            oPlatoon[refiCurrentAction] = refActionAttack
                        elseif oPlatoon[refiEnemiesInRange] > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Combat threat of enemies in range='..M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemiesInRange], true)..'; Range of enemies='..M27Logic.GetUnitMaxGroundRange(oPlatoon[reftEnemiesInRange])) end
                            if M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemiesInRange], true) >= 2500 then
                                oPlatoon[refiCurrentAction] = refActionAttack
                            elseif M27Logic.GetUnitMaxGroundRange(oPlatoon[reftEnemiesInRange]) >= oPlatoon[refiPlatoonMaxRange] - 5 then
                                oPlatoon[refiCurrentAction] = refActionAttack
                            end
                        end
                    end
                else
                    if oPlatoon[refiCurrentAction] == nil then bDontChangeCurrentAction = false
                    else
                        if bAlreadyHaveAttackActionFromOverseer == true and oPlatoon[refiCurrentAction] == iExistingAction then bDontChangeCurrentAction = false
                        else bDontChangeCurrentAction = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Have an action now, refiCurrentAction='..oPlatoon[refiCurrentAction]) end
                    end
                end
                --Note - reason why might still want to consider action is if overseer has given an override action saying to attack as a general order; the below should then hopefully get more optimal commands for how to attack


                --=======normal determining action for enemies
                if bDebugMessages == true then LOG(sFunctionRef..': Finished considering special cases, now check if should use core logic, bDontChangeCurrentAction='..tostring(bDontChangeCurrentAction)) end
                if bDontChangeCurrentAction == false then
                    if oPlatoon[refbACUInPlatoon] == true then
                        if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] > 0 and oPlatoon[refiCurrentAction] == nil then
                            oPlatoon[refiCurrentAction] = refActionAttack
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling ACU to attack') end
                            --v30 - ACU would ignore enemy ACU and try to start building a mex because of the below logic, so have commented out for now

                            --[[if bDebugMessages == true then LOG(sFunctionRef..': About to issue attack order to ACU as bDontChangeCurrentAction is false, unless have previously run; oPlatoon[refbHavePreviouslyRun]='..tostring(oPlatoon[refbHavePreviouslyRun])) end
                            if oPlatoon[refbHavePreviouslyRun] == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Havent previously run so will attack') end
                                oPlatoon[refiCurrentAction] = refActionAttack
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Have previously run so dont actually want to attack')
                            end--]]
                        end
                    else
                        if oPlatoon[M27PlatoonTemplates.refbAlwaysAttack] == true then
                            --Dont care about threat etc. with this AI - just attack - only exception is if up against multiple T2+ PD and we arent an experimental, as dont want to feed enemy kills
                            local bAttack = true
                            if oPlatoon[refiEnemyStructuresInRange] >= 2 and not(sPlatoonName == 'M27GroundExperimental') then
                                local tEnemyT2PlusPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryT2PlusPD, oPlatoon[reftEnemyStructuresInRange])
                                if M27Utilities.IsTableEmpty(tEnemyT2PlusPD) == false then
                                    local iEnemyT2PlusPD = table.getn(tEnemyT2PlusPD)
                                    if iEnemyT2PlusPD >= 2 then
                                        --Do we have indirect fire units nearby?
                                        local tNearbyMML = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryIndirectT2Plus, GetPlatoonFrontPosition(oPlatoon), oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures])
                                        if M27Utilities.IsTableEmpty(tNearbyMML) == false then
                                            bAttack = false
                                        else
                                            if oPlatoon[refiCurrentUnits] < iEnemyT2PlusPD * 15 then
                                                local tT3PlusUnits = EntityCategoryFilterDown(categories.TECH3 + categories.EXPERIMENTAL, oPlatoon[reftCurrentUnits])
                                                if M27Utilities.IsTableEmpty(tT3PlusUnits) == true then
                                                    bAttack = false
                                                else
                                                    local iT3PlusUnits = table.getn(tT3PlusUnits)
                                                    if iT3PlusUnits < iEnemyT2PlusPD then
                                                        if M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.EXPERIMENTAL, tT3PlusUnits)) == true then
                                                            bAttack = false
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            if bAttack == true then
                                if bDebugMessages == true then LOG(sFunctionRef..': Are using always attack AI; Dont have too many nearby PD so will attack') end
                                oPlatoon[refiCurrentAction] = refActionAttack
                            else oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                            end
                        else
                            --Is the ACU nearby?
                            local tNearbyACU
                            local bProtectACU = false
                            if M27Utilities.IsTableEmpty(oPlatoon[reftFriendlyNearbyCombatUnits]) == false then
                                tNearbyACU = EntityCategoryFilterDown(categories.COMMAND, oPlatoon[reftFriendlyNearbyCombatUnits])
                                if M27Utilities.IsTableEmpty(tNearbyACU) == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU is nearby so will see if can hold back or if it needs help') end
                                    --Case where always want to - enemy unit within 25 of ACU
                                    local oACU = tNearbyACU[1]
                                    local oACUPlatoon = oACU.PlatoonHandle
                                    local iNearestUnitDistance = oACUPlatoon[refiACUNearestEnemy]
                                    if iNearestUnitDistance == nil then iNearestUnitDistance = 10000 end
                                    --[[local tACUPosition = oACU:GetPosition()

                                    if oACUPlatoon == nil then oACUPlatoon = oPlatoon end
                                    local oMobileEnemyNearestACU, oStructureNearestACU
                                    local iNearestUnitDistance = 10000
                                    if oACUPlatoon[refiEnemiesInRange] > 0 then
                                        oMobileEnemyNearestACU = M27Utilities.GetNearestUnit(oACUPlatoon[reftEnemiesInRange], tACUPosition, aiBrain, true)
                                        if oMobileEnemyNearestACU then iNearestUnitDistance = M27Utilities.GetDistanceBetweenPositions(oMobileEnemyNearestACU:GetPosition(), tACUPosition) end
                                    end
                                    if oACUPlatoon[refiEnemyStructuresInRange] > 0 then
                                        oStructureNearestACU = M27Utilities.GetNearestUnit(oACUPlatoon[reftEnemyStructuresInRange], tACUPosition, aiBrain, true)
                                        if oStructureNearestACU then iNearestUnitDistance = math.min(iNearestUnitDistance, M27Utilities.GetDistanceBetweenPositions(oStructureNearestACU:GetPosition(), tACUPosition)) end
                                    end --]]
                                    local iACUHealthPercent = M27UnitInfo.GetUnitHealthPercent(oACU)
                                    if iACUHealthPercent <= 0.25 then
                                        bProtectACU = true
                                    elseif iACUHealthPercent < 0.7 then
                                        --Is the nearest enemy to the ACU able to attack it based on max enemy range?
                                        if iNearestUnitDistance <= 20 then
                                            bProtectACU = true
                                        elseif iNearestUnitDistance <= math.max(30, iEnemyMaxRange + 2) and oACUPlatoon[refiCurrentAction] == refActionRun then
                                            bProtectACU = true
                                        end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Have just considered whether we have a friendly ACU nearby and if so if it needs protecting; bProtectACU='..tostring(bProtectACU)) end
                            if bProtectACU == true then
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to protect the ACU so will attack') end
                                oPlatoon[refiCurrentAction] = refActionAttack
                            else
                                --INDIRECT FIRE PD ATTACKER PLATOON LOGIC
                                local oNearestMobileUnit = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                local iEnemyMobileRange = M27Logic.GetDFAndT1ArtiUnitMinOrMaxRange(oPlatoon[reftEnemiesInRange], 2, true)
                                if sPlatoonName == 'M27IndirectDefender' or sPlatoonName == 'M27IndirectSpareAttacker' then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a dedicated indirect fire platoon, will consider if want to attack or run') end
                                    local bAttackACU = false
                                    if oPlatoon[refiEnemiesInRange] > 0 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile enemy units in range, will see ifa ny of them is an upgrading ACU') end
                                        --Is there an enemy ACU upgrading in-range but no mobile units <=30 of distance between us and the enemy ACU?
                                        local tEnemyACUs = EntityCategoryFilterDown(categories.COMMAND, oPlatoon[reftEnemiesInRange])
                                        local bACUUpgrading = false
                                        local oNearestUpgradingACU, iCurACUDistance
                                        local iNearestUpgradingACUDistance = 10000
                                        if M27Utilities.IsTableEmpty(tEnemyACUs) == false then
                                            for iACU, oACU in tEnemyACUs do
                                                if oACU:IsUnitState('Upgrading') then
                                                    bACUUpgrading = true
                                                    iCurACUDistance = M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                                    if iCurACUDistance < iNearestUpgradingACUDistance then
                                                        iNearestUpgradingACUDistance = iCurACUDistance
                                                        oNearestUpgradingACU = oACU
                                                    end
                                                end
                                            end
                                        end
                                        if bACUUpgrading == true then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Have an upgrading ACU nearyb, will attack it') end

                                            local iNearestMobileUnit = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearestMobileUnit:GetPosition())
                                            if iNearestMobileUnit > 30 and (iEnemyMobileRange < oPlatoon[refiPlatoonMaxRange] or iNearestMobileUnit < (oPlatoon[refiPlatoonMaxRange] - 5)) then
                                                local oNearestStructure, iNearestStructure
                                                if oPlatoon[refiEnemyStructuresInRange] > 0 then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': refiEnemyStructuresInRange='..oPlatoon[refiEnemyStructuresInRange]) end
                                                    oNearestStructure = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                                    if oNearestStructure == nil then M27Utilities.ErrorHandler('Nearest structure is nil') iNearestStructure = 1000
                                                    else
                                                        iNearestStructure = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearestStructure:GetPosition())
                                                    end
                                                else iNearestStructure = 1000
                                                end
                                                if iNearestStructure > iNearestUpgradingACUDistance then
                                                    bAttackACU = true
                                                    oPlatoon[refiCurrentAction] = refActionAttackSpecificUnit
                                                    oPlatoon[refoTemporaryAttackTarget] = oNearestUpgradingACU
                                                    if not(M27UnitInfo.IsUnitValid(oNearestUpgradingACU)) then M27Utilities.ErrorHandler('Invalid oNearestUpgradingACU unit') end
                                                end
                                            end
                                        end
                                    end
                                    --No upgrading ACU or nearby enemies so want to retreat:
                                    if not(bAttackACU) then
                                        local iFrontUnitRange = oPlatoon[refiPlatoonMaxRange] --M27UnitInfo.GetUnitIndirectRange(oPlatoon[refoFrontUnit])
                                        if bDebugMessages == true then LOG(sFunctionRef..': No upgrading ACU in range, if have nearby structures will attack them, if nearby enemies and no T3 mobile arti will run. iFrontUnitRange='..iFrontUnitRange) end

                                        if oNearestMobileUnit then
                                            --Are enemy mobile units about to get in range of us?
                                            local iNearestMobileEnemy = M27Utilities.GetDistanceBetweenPositions(oNearestMobileUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will retreat if enemies too near and are within our range. iNearestMobileEnemy='..iNearestMobileEnemy..'; Platoon max range='..oPlatoon[refiPlatoonMaxRange]..'; iEnemyMobileRange='..iEnemyMobileRange) end
                                            if iNearestMobileEnemy < oPlatoon[refiPlatoonMaxRange] and iNearestMobileEnemy <= math.max(oPlatoon[refiPlatoonMaxRange] + 8, iEnemyMobileRange + 8, oPlatoon[refiPlatoonMaxRange] * 0.7) then
                                                oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                                if bDebugMessages == true then LOG(sFunctionRef..': Will temoprarily retreat from enemies') end

                                            end
                                        end
                                        --Are we in range of enemy PD that we outrange? If so then retreat
                                        if not(oPlatoon[refiCurrentAction] == refActionTemporaryRetreat) and oPlatoon[refiEnemyStructuresInRange] > 0 then
                                            local tNearbyEnemyPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD, oPlatoon[reftEnemyStructuresInRange])
                                            if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby PD empty='..tostring(M27Utilities.IsTableEmpty(tNearbyEnemyPD))) end
                                            if M27Utilities.IsTableEmpty(tNearbyEnemyPD) == false then
                                                local iMaxPDRange = M27Logic.GetUnitMaxGroundRange(tNearbyEnemyPD)
                                                if bDebugMessages == true then LOG(sFunctionRef..': iMaxPDRange='..iMaxPDRange..'; Platoon max range='..oPlatoon[refiPlatoonMaxRange]) end
                                                if iMaxPDRange < oPlatoon[refiPlatoonMaxRange] then
                                                    local oNearestPD = M27Utilities.GetNearestUnit(tNearbyEnemyPD, GetPlatoonFrontPosition(oPlatoon))
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Nearest PD distance to front position='..M27Utilities.GetDistanceBetweenPositions(oNearestPD:GetPosition(), GetPlatoonFrontPosition(oPlatoon))..'; nearest PD='..oNearestPD.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestPD)) end
                                                    --Note: If below dist increase is too high then risk MMLs never grouping up to attack (i.e. front MML gets too close trying to hit shield/TMD, so causes whole platoon to retreat, meaning rear MMLs never end up getting closer)
                                                    if iMaxPDRange + 3.3 > M27Utilities.GetDistanceBetweenPositions(oNearestPD:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) then
                                                        oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                                        if bDebugMessages == true then LOG(sFunctionRef..': within 3.5 of being in range of enemy PD that we outrange so want to retreat temporarily') end
                                                    end
                                                elseif oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] then
                                                    --We are outranged by enemy so go to nearest rally point
                                                    oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Are outranged by enemy PD so will retreat to nearest rally point') end

                                                end
                                            end
                                            local oNearestEnemyCombatBuilding
                                        end


                                        if not(oPlatoon[refiCurrentAction] == refActionTemporaryRetreat) and not(oPlatoon[refiCurrentAction] == refActionGoToNearestRallyPoint) then
                                            if oPlatoon[refiEnemyStructuresInRange] > 0 and M27Utilities.GetDistanceBetweenPositions(M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain, nil, nil):GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= iFrontUnitRange then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have nearby enemy structures, and platoon is in range of them, so will attack') end
                                                oPlatoon[refiCurrentAction] = refActionAttack
                                            elseif oPlatoon[refiEnemiesInRange] > 0 and oPlatoon[refiIndirectUnits] > 0 and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryIndirectT2Below, oPlatoon[reftIndirectUnits])) == false and M27Utilities.GetDistanceBetweenPositions(M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain, nil, nil):GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= iFrontUnitRange then
                                                oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have mobile enemies in range, no structures in range, and we have no T3 mobile arti in our platoon, so will temporarily fall back') end
                                            else
                                                --Are there still structures near our end destination?  If not then disband (defender only)
                                                if sPlatoonName == 'M27IndirectDefender' and M27Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure, oPlatoon[reftMovementPath][table.getn(oPlatoon[reftMovementPath])], oPlatoon[refiEnemySearchRadius], 'Enemy')) == true then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': No structures around end destination') end
                                                    oPlatoon[refiCurrentAction] = refActionDisband
                                                else
                                                    --Do we have an escort that still has units in it (if not then there may be nearby enemies even if we cant see them)
                                                    --if (oPlatoon[refiCurrentEscortThreat] or 0) <= (oPlatoon[refiEscortThreatWanted] or 0) * 0.5 or oPlatoon[refiEnemiesInRange] >= 5 then
                                                    --Do we have intel coverage?  If not then retreat MMLs (but dont worry for T1 arti or T3 non-Aeon Arti)
                                                    local bRetreatNotAttack = false
                                                    local iIntelCoverageWanted = math.min(40, iFrontUnitRange * 0.9)
                                                    if EntityCategoryContains(categories.TECH2, oPlatoon[refoFrontUnit]) and iFrontUnitRange <= 60 then iIntelCoverageWanted = math.min(iIntelCoverageWanted, 35) end


                                                    if not(M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oPlatoon), iIntelCoverageWanted)) and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryIndirect * categories.TECH2 + M27UnitInfo.refCategoryT3MML + M27UnitInfo.refCategoryT3MobileArtillery * categories.AEON + M27UnitInfo.refCategoryShieldDisruptor, oPlatoon[reftIndirectUnits])) == false and (oPlatoon[refiEnemyStructuresInRange] == 0 or M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain):GetPosition()) > oPlatoon[refiPlatoonMaxRange] + 10) then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Have MML or Aeon mobile arti so will retreat from enemies as either dont have sufficient escort, or dont have intel coverage, and nearest structure isnt close. Intel coverage='..M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oPlatoon), nil, false)) end
                                                        bRetreatNotAttack = true
                                                    else
                                                        --[[--Likely have non-Aeon T3 mobile arti in platoon so retreat if enemy is near or we are near a firebase, otherwise attack due to deploy time
                                                        if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFirebasePosition]) == false then
                                                            local iDistToFirebase
                                                            for iFirebaseRef, tFirebaseLocation in aiBrain[M27EngineerOverseer.reftFirebasePosition] do
                                                                iDistToFirebase = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tFirebaseLocation)
                                                                if iDistToFirebase <= 70 and iDistToFirebase >= 5 and (iDistToFirebase >= 30 or M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)) < M27Utilities.GetDistanceBetweenPositions(tFirebaseLocation, M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain))) then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Are near a firebase so will stay here') end
                                                                    bRetreatNotAttack = true
                                                                    break
                                                                end
                                                            end
                                                        end--]]
                                                        --Is the enemy mobile unit at least 15 within our range?
                                                        if oPlatoon[refiEnemiesInRange] > 0 then
                                                            local iRetreatThreshold = math.max(iFrontUnitRange - 20, math.min(iFrontUnitRange * 0.7, iFrontUnitRange - 8))
                                                            for iUnit, oUnit in oPlatoon[reftEnemiesInRange] do
                                                                if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition()) <= iRetreatThreshold then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': iRetreatThreshold='..iRetreatThreshold..'; Distance of oUnit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to platoon='..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition())) end
                                                                    bRetreatNotAttack = true
                                                                    break
                                                                end
                                                            end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': bRetreatNotAttack='..tostring(bRetreatNotAttack)) end
                                                    end
                                                    if bRetreatNotAttack then oPlatoon[refiCurrentAction] = refActionTemporaryRetreat else oPlatoon[refiCurrentAction] = refActionAttack end
                                                    --end
                                                end
                                            end
                                        end
                                    end
                                else
                                    --ESCORT PLATOON LOGIC
                                    --For escorts dont want to run away if up against a larger threat and the unit we are escorting is nearby, as in some cases htem attacking might be enough to save the unit they're escorting
                                    --However, if up against enemy PD then do want to fall back
                                    if sPlatoonName == 'M27EscortAI' then
                                        if bDebugMessages == true then LOG(sFunctionRef..': We are an escort platoon so considering best action for the escort to take') end
                                        if oPlatoon[refiEnemyStructuresInRange] > 0 and M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemyStructuresInRange], false) > 100 then
                                            --Run back to indirect fire units
                                            if oPlatoon[refoPlatoonOrUnitToEscort] then
                                                local iNearestEnemyUnit = 10000
                                                local tPlatoonToEscortPosition = GetPlatoonFrontPosition(oPlatoon[refoPlatoonOrUnitToEscort])
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef..': tPlatoonToEscortPosition='..repru(tPlatoonToEscortPosition))
                                                    if oPlatoon[refoPlatoonOrUnitToEscort].GetUnitId then LOG('Are escorting unit with ID='..oPlatoon[refoPlatoonOrUnitToEscort].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoPlatoonOrUnitToEscort]))
                                                    elseif oPlatoon[refoPlatoonOrUnitToEscort].GetPlan then LOG('Are escorting a platoon with plan='..oPlatoon[refoPlatoonOrUnitToEscort]:GetPlan()..oPlatoon[refoPlatoonOrUnitToEscort][refiPlatoonCount]..' and current units='..oPlatoon[refoPlatoonOrUnitToEscort][refiCurrentUnits])
                                                    else
                                                        M27Utilities.ErrorHandler('Are escorting a unit that is neither a unit nor a platoon')
                                                        --oPlatoon[refiCurrentAction] = refActionReturnToBase
                                                    end
                                                end
                                                if oPlatoon[refoPlatoonOrUnitToEscort][refiEnemiesInRange] > 0 then
                                                    local oNearestEnemyUnit = M27Utilities.GetNearestUnit(oPlatoon[refoPlatoonOrUnitToEscort][reftEnemiesInRange], tPlatoonToEscortPosition, aiBrain, true)
                                                    if oNearestEnemyUnit then iNearestEnemyUnit = M27Utilities.GetDistanceBetweenPositions(oNearestEnemyUnit:GetPosition(), tPlatoonToEscortPosition) end
                                                end
                                                if iNearestEnemyUnit <= 25 then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': iNearestEnemyUnit<=25 so will attack') end
                                                    oPlatoon[refiCurrentAction] = refActionAttack
                                                else
                                                    oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy unit isnt within 25 of indirect platoon so moving to temporary position instead') end
                                                    if iNearestEnemyUnit <= 35 then
                                                        oPlatoon[reftTemporaryMoveTarget] = tPlatoonToEscortPosition
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy unit is within 30 so Setting temporary move target so we are moving to the front of the platoon='..repru(tPlatoonToEscortPosition)) end
                                                    else
                                                        --Go behind the indirect fire units so we dont get in the way/cause our indirect fire units to slowly creep forwards
                                                        local iDistanceBehindEscortedPlatoon = math.min(12, math.max(5, oPlatoon[refiCurrentUnits] / 2))
                                                        oPlatoon[reftTemporaryMoveTarget] = M27Utilities.MoveTowardsTarget(tPlatoonToEscortPosition, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], iDistanceBehindEscortedPlatoon, 0)
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy unit is more than 35 from escorted platoon so setting temporary move target so will get a position behind the escorted platoon; tPlatoonToEscortPosition='..repru(tPlatoonToEscortPosition)..'; position to move to='..repru(oPlatoon[reftTemporaryMoveTarget])) end
                                                    end
                                                end
                                            else
                                                oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                                            end
                                        else
                                            --Are there mobile enemies near the unit that we are escorting? If so then attack unless dealing with our ACU and it doesnt need help
                                            if oPlatoon[refoPlatoonOrUnitToEscort][refiEnemiesInRange] > 0 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Are mobile enemies near the unit that we are escorting.  Will attack unless ACU was nearby (as already considered earlier if we wanted to help it)') end
                                                if M27Utilities.IsTableEmpty(tNearbyACU) and not(oPlatoon[refoPlatoonOrUnitToEscort][refbACUInPlatoon]) and not((oPlatoon[refoPlatoonOrUnitToEscort].UnitId and EntityCategoryContains(categories.COMMAND, oPlatoon[refoPlatoonOrUnitToEscort].UnitId))) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Our ACU isnt nearby so wont attack') end
                                                    oPlatoon[refiCurrentAction] = refActionAttack
                                                end
                                            else
                                                --Are there enemies near us that are closer to our base than the escorting platoon? If so then ok to attack them as well
                                                if oPlatoon[refiEnemiesInRange] > 0 and M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], aiBrain, true):GetPosition()) < M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon[refoPlatoonOrUnitToEscort]), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Are enemies near us that are closer to our base than the escorting platoon so will attack') end
                                                    oPlatoon[refiCurrentAction] = refActionAttack
                                                else
                                                    --No action (so should just move back to the escort unit
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering escort specific logic. action='..(oPlatoon[refiCurrentAction] or 'nil')) end
                                    else
                                        --(no longer assume will lose if more enemies as might have ACU in platoon)
                                        --                  if oPlatoon[refiEnemiesInRange] - oPlatoon[refiCurrentUnits] <= 5 or oPlatoon[refiEnemiesInRange] <= oPlatoon[refiCurrentUnits]*1.5 then
                                        --Normal NON-ESCORT LOGIC
                                        --Are there lots of T2+ PD nearby? If so run (even if we have a similar threat) unless we're already in range
                                        local bRunFromPD = false
                                        local bInRangeOfT2PlusPD = false
                                        local bNearbyT2PlusPD
                                        local oNearestPD
                                        local tEnemyT2PlusPD
                                        if oPlatoon[refiEnemyStructuresInRange] > 0 then
                                            tEnemyT2PlusPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryT2PlusPD, oPlatoon[reftEnemyStructuresInRange])
                                            if M27Utilities.IsTableEmpty(tEnemyT2PlusPD) == false then
                                                bNearbyT2PlusPD = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have T2 PD within the enemy structures in range, will see if we have nearby T1 indirect fire units for calculating our range, and then attack if we are almost within range') end
                                                local iMaxRangeToUse = math.max(15, oPlatoon[refiPlatoonMaxRange]) --M27Logic.GetUnitMaxGroundRange({ oPlatoon[refoFrontUnit] })) --striker has range of 18
                                                --if table.getn(tEnemyT2PlusPD) >= 3 then
                                                --Are we already within range of any of the PD?

                                                --Do we have T1 indirect fire units in the platoon?
                                                --[[if oPlatoon[refiIndirectUnits] > 0 and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryIndirectT2Plus, oPlatoon[reftIndirectUnits])) == true then
                                                    --Have t1 indirect fire in platoon, check if the nearest one is close to platoon front posiiton
                                                    local oNearestIndirectUnit = M27Utilities.GetNearestUnit(oPlatoon[reftIndirectUnits], GetPlatoonFrontPosition(oPlatoon), aiBrain, false, true)
                                                    if M27UnitInfo.IsUnitValid(oNearestIndirectUnit) and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearestIndirectUnit:GetPosition()) <= 4 then
                                                        iMaxRangeToUse = math.max(iMaxRangeToUse, M27UnitInfo.GetUnitIndirectRange(oNearestIndirectUnit))
                                                    end
                                                end--]]
                                                --else iMaxRangeToUse = math.max(iMaxRangeToUse, M27Logic.GetDFAndT1ArtiUnitMinOrMaxRange({oPlatoon[refoFrontUnit]}, 2, true)) end
                                                oNearestPD = M27Utilities.GetNearestUnit(tEnemyT2PlusPD, GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                                if oNearestPD and M27Utilities.GetDistanceBetweenPositions(oNearestPD:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= iMaxRangeToUse + 3 then
                                                    bInRangeOfT2PlusPD = true

                                                    if oPlatoon[refiPlatoonMaxRange] > M27Logic.GetUnitMaxGroundRange(tEnemyT2PlusPD) then bRunFromPD = true end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Are in range of enemy T2PlusPD, will run if we outrange the PD. oPlatoon[refiPlatoonMaxRange]='..oPlatoon[refiPlatoonMaxRange]..'; T2PluasPDRange='..M27Logic.GetUnitMaxGroundRange(tEnemyT2PlusPD)) end
                                                else
                                                    if table.getn(tEnemyT2PlusPD) >= 3 and oPlatoon[refiPlatoonMassValue] <= 10000 then
                                                        bRunFromPD = true
                                                        if oPlatoon[refiPlatoonMaxRange] > M27Logic.GetUnitMaxGroundRange(tEnemyT2PlusPD) then bRunFromPD = false end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': At least 3 T2Plus enemy PD in range, will run unless we outrange them (since per above they shouldnt be able to hit us). bRunFromPD='..tostring(bRunFromPD)..'; oPlatoon[refiPlatoonMaxRange]='..oPlatoon[refiPlatoonMaxRange]..'; GetUnitMaxGroundRange(tEnemyT2PlusPD)='..M27Logic.GetUnitMaxGroundRange(tEnemyT2PlusPD)) end
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Distance to nearest PD='..M27Utilities.GetDistanceBetweenPositions(oNearestPD:GetPosition(), GetPlatoonFrontPosition(oPlatoon))..'; Size of enemy T2+ Pd table='..table.getn(tEnemyT2PlusPD)..'; bRunFromPD='..tostring(bRunFromPD)..'; bInRangeOfT2PlusPD='..tostring(bInRangeOfT2PlusPD)) end
                                                --end
                                            end
                                        end
                                        if bRunFromPD == true then
                                            oPlatoon[refiCurrentAction] = refActionRun
                                        elseif bInRangeOfT2PlusPD == true then --If we've just got in range of T2 PD then better to fight and die than try to run
                                            if bDebugMessages == true then LOG(sFunctionRef..': Our weapon is in range of enemy T2 PD so might as well fight') end
                                            oPlatoon[refiCurrentAction] = refActionAttack
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Not running from PD, will consider if we will win battle. EnemiesInRange='..oPlatoon[refiEnemiesInRange]..'; refiEnemyStructuresInRange='..oPlatoon[refiEnemyStructuresInRange]) end

                                            --Are we likely to win a battle? consider all units near platoon position, unless we're a single unit raider platoon
                                            local iOurThreatRating = 0
                                            if sPlatoonName == 'M27MexRaiderAI' and oPlatoon[refiCurrentUnits] <= 1 then
                                                --Microbot raiders - dont want to attack with other units, better ot avoid fights and try and find engineers
                                                iOurThreatRating = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits])
                                            else
                                                --Normal logic - dont want to include friendly ACU in threat rating unless it is attacking
                                                iOurThreatRating = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftFriendlyNearbyCombatUnits], false)
                                                if not(oPlatoon[refbACUInPlatoon]) and M27Utilities.IsTableEmpty(oPlatoon[reftFriendlyNearbyCombatUnits]) == false then
                                                    local tNearbyFriendlyACU = EntityCategoryFilterDown(categories.COMMAND, oPlatoon[reftFriendlyNearbyCombatUnits])
                                                    if M27Utilities.IsTableEmpty(tNearbyFriendlyACU) == false then
                                                        for iFriendlyACU, oFriendlyACU in tNearbyFriendlyACU do
                                                            --Is the friendly ACU closer to our start than us? (if not then assume it's already helping the fight)
                                                            if M27Utilities.GetDistanceBetweenPositions(oFriendlyACU:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) < M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) then
                                                                --Is ACU part of a platoon that is attacking? If so still include its threat
                                                                local iACUAction = oFriendlyACU.PlatoonHandle[refiCurrentAction]
                                                                if bDebugMessages == true then LOG(sFunctionRef..': ACU action='..(iACUAction or 'nil')) end
                                                                if not(iACUAction) or not(iACUAction == refActionAttack or iACUAction == refActionMoveDFToNearestEnemy or iACUAction == refActionMoveJustWithinRangeOfNearestPD or iACUAction == refActionAttackSpecificUnit or iACUAction == refActionKillACU) then
                                                                    iOurThreatRating = iOurThreatRating - M27Logic.GetCombatThreatRating(aiBrain, { oFriendlyACU}, false)
                                                                end
                                                            end
                                                        end
                                                    end

                                                    if sPlatoonName == 'M27GroundExperimental' and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryMonkeylord, oPlatoon[reftFriendlyNearbyCombatUnits])) == false then
                                                        iOurThreatRating = iOurThreatRating * 0.9
                                                    end
                                                end
                                            end
                                            if M27Conditions.HaveNearbyMobileShield(oPlatoon) then iOurThreatRating = iOurThreatRating + math.min(iOurThreatRating * 0.5, oPlatoon[refoSupportingShieldPlatoon][refiPlatoonMassValue] * 0.5) end

                                            local iEnemyThreatRating = 0
                                            local iEnemyMobileThreatRating = 0

                                            if oPlatoon[refiEnemiesInRange] > 0 then
                                                iEnemyMobileThreatRating = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemiesInRange], false, nil) --Will have had visibility to be in enemiesinrange
                                                --If enemy has a fatboy whose fraction complete is 1 then adjust threat based on its distance
                                                if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyLandExperimentals]) == false then
                                                    local tEnemyFatboys = EntityCategoryFilterDown(M27UnitInfo.refCategoryFatboy, oPlatoon[reftEnemiesInRange])
                                                    if M27Utilities.IsTableEmpty(tEnemyFatboys) == false then
                                                        local iTimeUntilInRangeOfFatboy = 0
                                                        local iOurSpeed = oPlatoon[refoFrontUnit]:GetBlueprint().Physics.MaxSpeed
                                                        local iFatboySpeed
                                                        local iDistToFatboy
                                                        local iFatCurShield, iFatMaxShield
                                                        local iExtraThreatFactor
                                                        for iFatboy, oFatboy in tEnemyFatboys do
                                                            if oFatboy:GetFractionComplete() == 1 then
                                                                iFatCurShield, iFatMaxShield = M27UnitInfo.GetCurrentAndMaximumShield(oFatboy, true)
                                                                if iFatCurShield > iFatMaxShield * 0.25 then
                                                                    iDistToFatboy = M27Utilities.GetDistanceBetweenPositions(oFatboy:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                                                    iFatboySpeed = oFatboy:GetBlueprint().Physics.MaxSpeed
                                                                    iTimeUntilInRangeOfFatboy = (iDistToFatboy - oPlatoon[refiPlatoonMaxRange]) / math.max(0.1, iOurSpeed - iFatboySpeed)
                                                                    if iTimeUntilInRangeOfFatboy > 5 then
                                                                        iExtraThreatFactor = math.min(1.5, iTimeUntilInRangeOfFatboy / 30)
                                                                        iEnemyMobileThreatRating = iEnemyMobileThreatRating + iExtraThreatFactor * M27Logic.GetCombatThreatRating(aiBrain, { oFatboy }, false, nil) --Will have had visibility to be in enemiesinrange
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': Have enemy fatboy, distance to us='..iDistToFatboy..'; Our speed='..iOurSpeed..'; Their speed='..iFatboySpeed..'; Time until in range='..iTimeUntilInRangeOfFatboy..'; iExtraThreatFactor='..iExtraThreatFactor) end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                                iEnemyThreatRating = iEnemyMobileThreatRating
                                            end
                                            if oPlatoon[refiEnemyStructuresInRange] > 0 then

                                                local iEnemyStructureThreat = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemyStructuresInRange], false) --WIll have had visibility already to get to this point so can set to false
                                                --Adjust for shields and ignore T1 PD in certain cases (main focus is to stop experimentals running from a shielded base that has minimal threat in it)
                                                if iEnemyStructureThreat >= 2000 and oPlatoon[refiPlatoonMaxRange] >= 30 and oPlatoon[refiPlatoonMassValue] >= 2000 then
                                                    local tEnemyShields = EntityCategoryFilterDown(M27UnitInfo.refCategoryFixedShield, oPlatoon[reftEnemyStructuresInRange])
                                                    local iMaxShieldThreat = 0
                                                    local iShieldThreatToUse = 0
                                                    if M27Utilities.IsTableEmpty(tEnemyShields) == false then
                                                        iMaxShieldThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemyShields, false)
                                                    end
                                                    local iT2PDThreat = 0
                                                    if M27Utilities.IsTableEmpty(tEnemyT2PlusPD) == false then
                                                        iT2PDThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemyT2PlusPD, false)
                                                    end
                                                    if iMaxShieldThreat > 0 then
                                                        --Cap shield threat based on enemy non-shield threat
                                                        iShieldThreatToUse = math.min(iMaxShieldThreat, 7500, math.max(500, (iT2PDThreat + iEnemyMobileThreatRating)))
                                                    end

                                                    --Revise structure threat based on above
                                                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyStructureThreat pre adjust='..iEnemyStructureThreat..'; iT2PDThreat='..iT2PDThreat..'; iMaxShieldThreat='..iMaxShieldThreat..'; iShieldThreatToUse='..iShieldThreatToUse..'; iEnemyMobileThreatRating='..iEnemyMobileThreatRating) end
                                                    iEnemyStructureThreat = math.max(0, (iEnemyStructureThreat - iT2PDThreat - iMaxShieldThreat) * 0.2) + iT2PDThreat + iShieldThreatToUse
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Structure threat post adjust='..iEnemyStructureThreat) end
                                                end
                                                iEnemyThreatRating = iEnemyThreatRating + iEnemyStructureThreat
                                            end
                                            if ((not(bNearbyT2PlusPD) or sPlatoonName == 'M27GroundExperimental') and iOurThreatRating * 0.95 >= iEnemyThreatRating) or (bNearbyT2PlusPD and iOurThreatRating * 0.7 >= iEnemyThreatRating) then
                                                bWillWinAttack = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': our threat is better than theirs; iEnemyThreatRating='..iEnemyThreatRating..'; iOurThreatRating='..iOurThreatRating) end
                                            elseif oPlatoon[refbACUInPlatoon] and iOurThreatRating >= 0.75 * iEnemyMobileThreatRating then
                                                local oACU = oPlatoon[reftBuilders][1]
                                                --Consider enemies that outrange us, provided enemey ACU isn't inbetween us and a T2 PD
                                                if bDebugMessages == true then LOG(sFunctionRef..': ACU platoon so will co9nsider enemies that can attack us only if we outrange most of them, subject to broader threat rating. bNearbyT2PlusPD='..tostring(bNearbyT2PlusPD)..'; aiBrain[M27Overseer.refbEnemyACUNearOurs]='..tostring(aiBrain[M27Overseer.refbEnemyACUNearOurs])..'; Dist to enemy ACU='..M27Utilities.GetDistanceBetweenPositions(aiBrain[M27Overseer.reftLastNearestACU], GetPlatoonFrontPosition(oPlatoon))) end
                                                local bRunFromSinglePD = false
                                                if not(bNearbyT2PlusPD and oNearestPD and aiBrain[M27Overseer.refbEnemyACUNearOurs] and M27Utilities.GetDistanceBetweenPositions(aiBrain[M27Overseer.reftLastNearestACU], GetPlatoonFrontPosition(oPlatoon)) <= M27Utilities.GetDistanceBetweenPositions(oNearestPD:GetPosition(), GetPlatoonFrontPosition(oPlatoon))) then
                                                    local iACUHealthPercent = M27UnitInfo.GetUnitHealthPercent(oACU)
                                                    if iACUHealthPercent <= 0.75 then
                                                        bRunFromSinglePD = true
                                                    elseif iACUHealthPercent <= 0.98 then
                                                        local iCurTime = math.floor(GetGameTimeSeconds())
                                                        if (oACU[M27Overseer.reftACURecentHealth][iCurTime-1] or oACU[M27Overseer.reftACURecentHealth][iCurTime-2] or oACU[M27Overseer.reftACURecentHealth][iCurTime-3]) and oACU[M27Overseer.reftACURecentHealth][iCurTime-20] and (oACU[M27Overseer.reftACURecentHealth][iCurTime-1] or oACU[M27Overseer.reftACURecentHealth][iCurTime-2] or oACU[M27Overseer.reftACURecentHealth][iCurTime-3]) < oACU[M27Overseer.reftACURecentHealth][iCurTime-20] then
                                                            bRunFromSinglePD = true
                                                        end
                                                    end
                                                end
                                                if not(bRunFromSinglePD) then


                                                    local tEnemiesThatOutrangeUs = {}
                                                    local iEnemiesThatOutrangeUs = 0
                                                    local iRangeThreshold = oPlatoon[refiPlatoonMaxRange] - 3
                                                    local tACUPos = GetPlatoonFrontPosition(oPlatoon)
                                                    local iUnitCurRange
                                                    for iUnit, oUnit in oPlatoon[reftEnemiesInRange] do
                                                        iUnitCurRange = M27Logic.GetDFAndT1ArtiUnitMinOrMaxRange({oUnit}, nil, true)
                                                        if iUnitCurRange >= iRangeThreshold then
                                                            iEnemiesThatOutrangeUs = iEnemiesThatOutrangeUs + 1
                                                            tEnemiesThatOutrangeUs[iEnemiesThatOutrangeUs] = oUnit
                                                        elseif M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tACUPos) <= iUnitCurRange then
                                                            iEnemiesThatOutrangeUs = iEnemiesThatOutrangeUs + 1
                                                            tEnemiesThatOutrangeUs[iEnemiesThatOutrangeUs] = oUnit
                                                        end
                                                    end
                                                    if bDebugMessages == true then
                                                        LOG(sFunctionRef..': ACU in platoon so will consider if we outrange most of the threat. iOurThreatRating='..iOurThreatRating..'; iEnemiesThatOutrangeUs='..iEnemiesThatOutrangeUs)
                                                        if iEnemiesThatOutrangeUs > 0 then LOG(sFunctionRef..': Threat of enemies that outrange us='..M27Logic.GetCombatThreatRating(aiBrain, tEnemiesThatOutrangeUs, true)) end
                                                    end
                                                    if iEnemiesThatOutrangeUs == 0 or iOurThreatRating * 0.55 >= M27Logic.GetCombatThreatRating(aiBrain, tEnemiesThatOutrangeUs, true) then
                                                        bWillWinAttack = true
                                                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': ACU should hopefully win the fight if ignore units that it significantly outranges that arent in range of it') end
                                                    end
                                                end
                                            end

                                            --end
                                            if bWillWinAttack == true then
                                                --Check aren't already running away from a threat (and we think we'll win just because some of enemy have dropped out of intel range
                                                if oPlatoon[refbHavePreviouslyRun] == true then
                                                    --we've previously run away - check how recently:
                                                    local iMaxCyclesToCheck = 20
                                                    local iCyclesToCheck = table.getn(oPlatoon[reftPrevAction])
                                                    if iCyclesToCheck >= 1 then
                                                        for iRunCycle = 1, iCyclesToCheck do
                                                            if not(oPlatoon[reftPrevAction][iRunCycle] == nil) then
                                                                if oPlatoon[reftPrevAction][iRunCycle] == refActionRun then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have previously run, in the previous cycle'..iRunCycle) end
                                                                    bHaveRunRecently = true
                                                                    break
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': bWillWinAttack='..tostring(bWillWinAttack)..'; iOurThreatRating='..iOurThreatRating..'; iEnemyThreatRating='..iEnemyThreatRating) end
                                            if bWillWinAttack == true then
                                                if bDebugMessages == true then LOG(sFunctionRef..': We will win the attack, considering if we want to attack. bHaveRunRecently='..tostring(bHaveRunRecently)..'; oPlatoon[refiCurrentUnits]='..oPlatoon[refiCurrentUnits]..'; oPlatoon[refiEnemyStructuresInRange]='..oPlatoon[refiEnemyStructuresInRange]) end
                                                if bHaveRunRecently == false then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': will win attack and havent previously run') end
                                                    --Large attack AI - Check we're not about to run after a small number of units with a massive attack force
                                                    if oPlatoon[refiCurrentUnits] >= 18 then
                                                        local bDontChaseEnemy = false
                                                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': - Large attack so considering if small number of enemies nearby') end
                                                        if oPlatoon[refiCurrentUnits] >= 10 then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..' - Large attack AI - we have at least 10 units') end
                                                            if oPlatoon[refiEnemyStructuresInRange] == 0 then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..' - Large attack AI - no structures in range. aiBrain[refiSearchRangeForEnemyStructures]='..aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]) end
                                                                if oPlatoon[refiEnemiesInRange] <= 3 then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': - Large attack AI - <=3 enemy units') end
                                                                    --Only 3 mobile enemies and no structures in range, and we have a large attack force; check if we're faster
                                                                    if M27Utilities.IsTableEmpty(oPlatoon[reftEnemiesInRange]) == true then
                                                                        M27Utilities.ErrorHandler(sFunctionRef..': Platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Have no structures in range, but also no enemies in range')
                                                                    else
                                                                        local iPossibleEnemySpeed = M27Logic.GetUnitMinSpeed(oPlatoon[reftEnemiesInRange], aiBrain, true)
                                                                        if iPossibleEnemySpeed == nil then
                                                                            --Dont know how fast any of the enemy is, so dont chase
                                                                            bDontChaseEnemy = true
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': - Large attack AI - dont know enemy speed, wont chase') end
                                                                        else
                                                                            local iOurMinSpeed = M27Logic.GetUnitMinSpeed(oPlatoon[reftCurrentUnits], aiBrain, false)
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': - Large attack AI - Know enemy speed, iOurMinSpeed='..iOurMinSpeed..'; iPossibleEnemySpeed='..iPossibleEnemySpeed) end
                                                                            if iOurMinSpeed < iPossibleEnemySpeed then bDontChaseEnemy = true end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': - Large attack AI - bDontChaseEnemy='..tostring(bDontChaseEnemy)) end
                                                        if bDontChaseEnemy == false then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Ok to chase enemy so action is attack') end
                                                            oPlatoon[refiCurrentAction] = refActionAttack
                                                        end
                                                    else
                                                        --Raider AI/small platoons - dont want to attack structures unless we're a larger raiding group since will spend too long trying to kill a mex
                                                        if oPlatoon[refbACUInPlatoon] == false and oPlatoon[refiCurrentUnits] < aiBrain[M27Overseer.refiIgnoreMexesUntilThisManyUnits] then
                                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': MexRaider custom: refiCurrentUnits='..oPlatoon[refiCurrentUnits]) end
                                                            if oPlatoon[refiCurrentUnits] >= 5 then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': We have at least 5 units so will attack') end
                                                                oPlatoon[refiCurrentAction] = refActionAttack
                                                            else --Smaller platoon, so only attack mobile enemies and not structures:
                                                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Checking if are enemies in range') end
                                                                if oPlatoon[refiEnemiesInRange] > 0 then
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': iEnemiesInRange='..oPlatoon[refiEnemiesInRange]) end
                                                                    oPlatoon[refiCurrentAction] = refActionAttack
                                                                end
                                                            end
                                                        else
                                                            --Other attack AI - just attack enemy if we'll win (dont worry about chasing small groups)
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Think we can win so will attack') end
                                                            oPlatoon[refiCurrentAction] = refActionAttack
                                                        end
                                                    end
                                                else
                                                    --Do nothing - will already have assigned a run away command in a previous cycle, dont need to change things now
                                                    --Exception for experimental platoons - still attack if have friendly land experimental nearby.  If it's an M27 experimental that is running away then have it clear its run away flag and have a movement path set to our position so it will consider helping us
                                                    if sPlatoonName == 'M27GroundExperimental' then
                                                        if M27Utilities.IsTableEmpty(oPlatoon[reftFriendlyNearbyCombatUnits]) == false then
                                                            local tNearbyExperimental = EntityCategoryFilterDown(M27UnitInfo.refCategoryLandExperimental - M27UnitInfo.refCategoryFatboy, oPlatoon[reftFriendlyNearbyCombatUnits])
                                                            if M27Utilities.IsTableEmpty(tNearbyExperimental) == false and table.getn(tNearbyExperimental) >= 2 then
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Are an experimental with nearby friendly experimentals so will clear any order to run and will attack always, and will override any movement path that would have had us retreating so we will attack.  Will do the same for the friendly experimentals if they are M27 experimentals') end
                                                                oPlatoon[refiCurrentAction] = refActionAttack
                                                                oPlatoon[refbHavePreviouslyRun] = false
                                                                oPlatoon[M27PlatoonTemplates.refbAlwaysAttack] = true
                                                                --Update our movement path
                                                                if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) > M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) then
                                                                    oPlatoon[reftMovementPath] = {}
                                                                    oPlatoon[reftMovementPath][1] = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                                                                    oPlatoon[refiCurrentPathTarget] = 1
                                                                end


                                                                for iNearbyExperimental, oNearbyExperimental in tNearbyExperimental do
                                                                    if oNearbyExperimental:GetAIBrain().M27AI then
                                                                        --Change flag for the platoons to make them always attack
                                                                        oNearbyExperimental.PlatoonHandle[refbHavePreviouslyRun] = false
                                                                        oNearbyExperimental.PlatoonHandle[M27PlatoonTemplates.refbAlwaysAttack] = true
                                                                        local oCurBrain = oNearbyExperimental:GetAIBrain()
                                                                        --If the platoon's movement path is closer to enemy base than the unit, then have it change to nearest enemy base
                                                                        if M27Utilities.GetDistanceBetweenPositions(oNearbyExperimental:GetPosition(), M27MapInfo.PlayerStartPoints[oCurBrain.M27StartPositionNumber]) > M27Utilities.GetDistanceBetweenPositions(oNearbyExperimental.PlatoonHandle[reftMovementPath][oNearbyExperimental.PlatoonHandle[refiCurrentPathTarget]], M27MapInfo.PlayerStartPoints[oCurBrain.M27StartPositionNumber]) then
                                                                            oNearbyExperimental.PlatoonHandle[reftMovementPath] = {}
                                                                            oNearbyExperimental.PlatoonHandle[reftMovementPath][1] = M27MapInfo.GetPrimaryEnemyBaseLocation(oCurBrain)
                                                                            oNearbyExperimental.PlatoonHandle[refiCurrentPathTarget] = 1
                                                                        end


                                                                        --[[--Amalgamate into this platoon so they attack together - didnt seem to work, presumably need to trnasfer ownership
                                                                        if not(oNearbyExperimental.PlatoonHandle == oPlatoon) then
                                                                            MergePlatoons(oPlatoon, oNearbyExperimental.PlatoonHandle)
                                                                            --Reset our flag for having run as we have extra experimentals now
                                                                            oPlatoon[refbHavePreviouslyRun] = false
                                                                        end--]]
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            else
                                                --Will lose attack - run unless already near base/chokepoint
                                                if bDebugMessages == true then LOG(sFunctionRef..': We will lose the attack so need to run unless we are already near our base') end
                                                local bChokepointsCovered = M27Conditions.AreAllChokepointsCoveredByTeam(aiBrain)
                                                local bLastResortAttack = false
                                                if oPlatoon[refiEnemiesInRange] > 0 and (M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) <= aiBrain[M27AirOverseer.refiBomberDefenceCriticalThreatDistance] - 10 or (bChokepointsCovered and not(oPlatoon[refbACUInPlatoon]) and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), aiBrain[M27MapInfo.reftClosestChokepoint]) <= 40)) then
                                                    --We are near base - is the enemy also nearby?

                                                    local oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon))
                                                    if M27Utilities.GetDistanceBetweenPositions(oNearestEnemy:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) <= math.min(50, aiBrain[M27AirOverseer.refiBomberDefenceCriticalThreatDistance]) or (bChokepointsCovered and M27Utilities.GetDistanceBetweenPositions(oNearestEnemy:GetPosition(), aiBrain[M27MapInfo.reftClosestChokepoint]) <= 40) then
                                                        bLastResortAttack = true
                                                    end
                                                end
                                                if bLastResortAttack then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Near chokepoint so wont run') end
                                                    oPlatoon[refiCurrentAction] = refActionAttack
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Not near base/chokepoint so will run') end
                                                    oPlatoon[refiCurrentAction] = refActionRun
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        else
            oPlatoon[refiPrevNearestEnemyDistance] = nil
            --If skirmisher platoon then still consider running if lack intel
            if oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] then
                if bDebugMessages == true then LOG(sFunctionRef..': No nearby enemies but are a skirmisher platoon so will check our intel coverage if we arent near base. Intel coverage='..M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oPlatoon), nil, false)..'; Platoon max range='..oPlatoon[refiPlatoonMaxRange]) end
                if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) >= 40 and not(M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oPlatoon), math.min(oPlatoon[refiPlatoonMaxRange], 40), false)) then
                    --Dont have intel coverage
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have intel coverage so will temporarily retreat') end
                    oPlatoon[refiCurrentAction] = refActionTemporaryRetreat
                    aiBrain[reftSkirmisherPlatoonWantingIntel][sPlatoonName..oPlatoon[refiPlatoonCount]] = oPlatoon
                end
            end
        end
        --Ignore an action to attack if we cant path to the nearest enemy/building unless dealing with indirect fire platoon
        if oPlatoon[refiCurrentAction] == refActionAttack and oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] > 0 and oPlatoon[refiIndirectUnits] == 0 and M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) then
            local bCanPath = false
            local oNearestStructure
            if oPlatoon[refiEnemyStructuresInRange] > 0 then oNearestStructure = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain, nil, nil) end
            local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoFrontUnit])
            local iPlatoonGroup = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))
            if oNearestStructure and iPlatoonGroup == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oNearestStructure:GetPosition()) then
                bCanPath = true
            end
            if not(bCanPath) and oPlatoon[refiEnemiesInRange] > 0 then
                local oNearestMobileUnit = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain, nil, nil)
                if oNearestMobileUnit and iPlatoonGroup == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oNearestMobileUnit:GetPosition()) then
                    bCanPath = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Order was to attack, have checked if can path to nearest structure or mobile enemy; bCanPath='..tostring(bCanPath)) end
            if not(bCanPath) then
                if bDebugMessages == true then LOG(sFunctionRef..': Ignoring order to attack as we may not be able to path there') end
                oPlatoon[refiCurrentAction] = nil
            end
        end

    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function MergeNearbyPlatoons(oBasePlatoon)
    --Merges nearby platoons, and updates current platoons current units. Returns true if have merged platoons
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MergeNearbyPlatoons'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oBasePlatoon:GetPlan() == 'M27AttackNearestUnits' and oBasePlatoon[refiPlatoonCount] == 86 then bDebugMessages = true end
    --if oBasePlatoon:GetPlan() == 'M27Skirmisher' then bDebugMessages = true end
    local oPlatoonToMergeInto
    if oBasePlatoon[M27PlatoonTemplates.refbAmalgamateIntoEscort] then oPlatoonToMergeInto = oBasePlatoon[refoEscortingPlatoon]
    else oPlatoonToMergeInto = oBasePlatoon end
    if oPlatoonToMergeInto and (oPlatoonToMergeInto[refiPlatoonMergeCount] or 0) < 5 then
        if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..': Start of code') end
        local iMergeRefreshPoint = 15 --Once get to the xth cycle will refresh
        local refiMergeCycleCount = 'M27MergeCycleCount'
        local bHavePlatoonToMergeInto
        local iMergeCycleCount = oPlatoonToMergeInto[refiMergeCycleCount]
        if iMergeCycleCount == nil then iMergeCycleCount = 1
        else iMergeCycleCount = iMergeCycleCount + 1 end


        if iMergeCycleCount >= iMergeRefreshPoint then
            local iMaxGroundPlatoonSize = (oPlatoonToMergeInto[M27PlatoonTemplates.refiPlatoonAmalgamationMaxSize] or 5)
            if iMaxGroundPlatoonSize == nil then
                M27Utilities.ErrorHandler('No max size specified for amalgamation - will default to 10.  PlatoonToMergeInto='..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount], true)
                iMaxGroundPlatoonSize = 10
            end
            if oPlatoonToMergeInto[refiCurrentUnits] < iMaxGroundPlatoonSize then
                local aiBrain = (oPlatoonToMergeInto[refoBrain] or oPlatoonToMergeInto:GetBrain())
                local iSearchDistance = (oPlatoonToMergeInto[M27PlatoonTemplates.refiPlatoonAmalgamationRange] or 10)
                local tMergeIntoPlatoonPosition = GetPlatoonFrontPosition(oPlatoonToMergeInto)
                if M27Utilities.IsTableEmpty(tMergeIntoPlatoonPosition) == false then
                    local tCurPlatoonPos, iCurDistance
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': '..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..': About to check for nearby platoons to merge into this; drawing circle for merge range of '..iSearchDistance)
                        M27Utilities.DrawLocation(tMergeIntoPlatoonPosition, false, 2, 20, iSearchDistance)
                    end
                    --Cycle through all platoons, see if any of the desired type, and if so if they're close enough to this platoon
                    if M27Utilities.IsTableEmpty(oPlatoonToMergeInto[M27PlatoonTemplates.reftPlatoonsToAmalgamate]) == false then
                        local tAllPlatoons = aiBrain:GetPlatoonsList()
                        local sCurPlan, bMergePlatoon
                        local iMaxUnitsBeforeIgnore = math.min(10, iMaxGroundPlatoonSize - oPlatoonToMergeInto[refiCurrentUnits])
                        if iMaxUnitsBeforeIgnore > 0 then
                            for iPlatoon, oPlatoon in tAllPlatoons do
                                bMergePlatoon = false
                                if oPlatoon.GetPlan and oPlatoon[refiCurrentUnits] <= iMaxUnitsBeforeIgnore and (oPlatoon[refiCurrentUnits] or 0) < (oPlatoonToMergeInto[refiCurrentUnits] or 0) and (oPlatoon[refiPlatoonMergeCount] or 0) < 5 then --dont merge a platoon that already has 10+ units in it as have issues with platoons constantly cycling
                                    if bDebugMessages == true then LOG(sFunctionRef..':'..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..': Found a possible platoon, iPlatoon='..iPlatoon..'; platoon name='..oPlatoon:GetPlan()) end
                                    if not(oPlatoon == oPlatoonToMergeInto) then
                                        if not(oPlatoon[refiCurrentAction] == refActionDisband) then
                                            sCurPlan = oPlatoon:GetPlan()
                                            if bDebugMessages == true then LOG(sFunctionRef..':'..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount]..'iPlatoon='..iPlatoon..'; sCurPlan='..sCurPlan..' About to see if platoon plan is one of the ones we can merge into') end
                                            for iMergeType, sMergePlan in oPlatoonToMergeInto[M27PlatoonTemplates.reftPlatoonsToAmalgamate] do
                                                if bDebugMessages == true then LOG('Currently looking to see if its equal to sMergePlan='..sMergePlan) end
                                                if sCurPlan == sMergePlan then
                                                    bMergePlatoon = true break
                                                end
                                            end
                                        end
                                    end
                                end

                                if bMergePlatoon == true then
                                    tCurPlatoonPos = GetPlatoonFrontPosition(oPlatoon)
                                    if M27Utilities.IsTableEmpty(tCurPlatoonPos) == false then
                                        iCurDistance = M27Utilities.GetDistanceBetweenPositions(tCurPlatoonPos, tMergeIntoPlatoonPosition)
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': '..oPlatoonToMergeInto:GetPlan()..oPlatoonToMergeInto[refiPlatoonCount])
                                            LOG('(cont): Found a valid platoon to merge into this one, iPlatoon='..(iPlatoon or 'nil')..'; platoon name='..(oPlatoon:GetPlan() or 'nil')..(oPlatoon[refiPlatoonCount] or 'nil')..'; Checking distance, iCurDistance='..(iCurDistance or 'nil')..'; oPlatoon units='..(oPlatoon[refiCurrentUnits] or 'nil')..'; Platoon to merge into units='..(oPlatoonToMergeInto[refiCurrentUnits] or 'nil'))
                                        end
                                        if iCurDistance <= iSearchDistance then
                                            MergePlatoons(oPlatoonToMergeInto, oPlatoon)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            iMergeCycleCount = 0
        end
        oPlatoonToMergeInto[refiMergeCycleCount] = iMergeCycleCount
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)

    --(Decided wont update platoon unit data this cycle, as if wait then next cycle it will force a refresh due to the change in units)
end

function CombineNearbyPlatoonsOfType(aiBrain, sPlanToCombine)

    --e..g used for skirmishers - Called once have a certain number of skirmishers, will combine skirmishers that are near each other so have up to 6 per platoon
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CombineNearbyPlatoonsOfType'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local iSkirmisherCount = 0
    for iPlatoon, oPlatoon in aiBrain:GetPlatoonsList() do
        if oPlatoon.GetPlan and oPlatoon:GetPlan() == sPlanToCombine then
            iSkirmisherCount = iSkirmisherCount + 1
        end
    end
    if iSkirmisherCount >= 20 then
        local iUnitsBeforeMerge
        local iMergesWanted = 5
        if bDebugMessages == true then LOG(sFunctionRef..': iSkirmisherCount='..iSkirmisherCount..'; will cycle through every platoon and see if can merge any of them') end
        for iPlatoon, oPlatoon in aiBrain:GetPlatoonsList() do
            if oPlatoon.GetPlan and oPlatoon[M27PlatoonTemplates.refiPlatoonAmalgamationMaxSize] and oPlatoon[refoFrontUnit] and oPlatoon[refiCurrentUnits] > 0 and oPlatoon:GetPlan() == sPlanToCombine then
                if oPlatoon[refiCurrentUnits] < oPlatoon[M27PlatoonTemplates.refiPlatoonAmalgamationMaxSize] then
                    oPlatoon[M27PlatoonTemplates.reftPlatoonsToAmalgamate] = {sPlanToCombine}
                    iUnitsBeforeMerge = oPlatoon[refiCurrentUnits]
                    MergeNearbyPlatoons(oPlatoon)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just told oPlatoon='..(oPlatoon:GetPlan() or 'nil')..' to merge into a nearby platoon if there is one. Units before merge='..(iUnitsBeforeMerge or 'nil')..'; Units after merge='..(oPlatoon[refiCurrentUnits] or 'nil')..'; Max merges wanted='..(iMergesWanted or 'nil')) end
                    if not(oPlatoon[refiCurrentUnits] == iUnitsBeforeMerge) then
                        --Must have merged something
                        iMergesWanted = iMergesWanted - 1
                        if bDebugMessages == true then LOG(sFunctionRef..': Successfully merged platoons, iMergesWanted='..iMergesWanted) end
                        if iMergesWanted <= 0 then break end
                    end
                end
            end
        end
    end
end

function GetSupportTargetLocation(oPlatoon)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetSupportTargetLocation'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    --if oPlatoon:GetPlan() == 'M27MobileShield' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end

    local tSupportLocation
    if M27Utilities.IsTableEmpty(oPlatoon[reftLocationToGuard]) == false then
        tSupportLocation = oPlatoon[reftLocationToGuard]
        if bDebugMessages == true then LOG(sFunctionRef..': Have location to guard='..repru(tSupportLocation)) end
    elseif oPlatoon[refoSupportHelperUnitTarget] and M27UnitInfo.IsUnitValid(oPlatoon[refoSupportHelperUnitTarget]) then
        tSupportLocation = oPlatoon[refoSupportHelperUnitTarget]:GetPosition()
        if bDebugMessages == true then LOG(sFunctionRef..': Have valid support helper unit target='..oPlatoon[refoSupportHelperUnitTarget].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoSupportHelperUnitTarget])..'; location='..repru(tSupportLocation)) end
    elseif oPlatoon[refoSupportHelperPlatoonTarget] and oPlatoon[refoSupportHelperPlatoonTarget][refiCurrentUnits] > 0 then
        tSupportLocation = GetPlatoonFrontPosition(oPlatoon[refoSupportHelperPlatoonTarget])
        if bDebugMessages == true then LOG(sFunctionRef..': Have valid support helper unit target platoon='..oPlatoon[refoSupportHelperPlatoonTarget]:GetPlan()..oPlatoon[refoSupportHelperPlatoonTarget][refiPlatoonCount]..'; location='..repru(tSupportLocation)) end
    elseif oPlatoon[refoPlatoonOrUnitToEscort] then
        if oPlatoon[refoPlatoonOrUnitToEscort].UnitId and M27UnitInfo.IsUnitValid(oPlatoon[refoPlatoonOrUnitToEscort]) then
            tSupportLocation = oPlatoon[refoPlatoonOrUnitToEscort]:GetPosition()
            if bDebugMessages == true then LOG(sFunctionRef..': Have valid support helper unit escort='..oPlatoon[refoPlatoonOrUnitToEscort].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoPlatoonOrUnitToEscort])..'; location='..repru(tSupportLocation)) end
        elseif oPlatoon[refoPlatoonOrUnitToEscort][refiCurrentUnits] > 0 then
            tSupportLocation = GetPlatoonFrontPosition(oPlatoon[refoPlatoonOrUnitToEscort])
            if bDebugMessages == true then LOG(sFunctionRef..': Have valid support escort target platoon='..oPlatoon[refoPlatoonOrUnitToEscort]:GetPlan()..oPlatoon[refoPlatoonOrUnitToEscort][refiPlatoonCount]..'; location='..repru(tSupportLocation)) end
        elseif bDebugMessages == true then
            LOG(sFunctionRef..': Have platoon or unit to escort recorded, but doesnt appear to be valid; will give details in log if it has platoon handle or unit id')
            if oPlatoon[refoPlatoonOrUnitToEscort].GetPlan then LOG(sFunctionRef..': Escort is a platoon with plan='..oPlatoon[refoPlatoonOrUnitToEscort]:GetPlan()..(oPlatoon[refoPlatoonOrUnitToEscort][refiPlatoonCount] or 'nil')..'; units in platoon='..(oPlatoon[refoPlatoonOrUnitToEscort][refiCurrentUnits] or 'nil')) end
            if oPlatoon[refoPlatoonOrUnitToEscort].UnitId then LOG(sFunctionRef..': Escort is a unit with ID='..oPlatoon[refoPlatoonOrUnitToEscort].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoPlatoonOrUnitToEscort])) end
            LOG(sFunctionRef..': reprs of refoPlatoonOrUnitToEscort]'..reprs(oPlatoon[refoPlatoonOrUnitToEscort]))
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': No escort or helper assigned')
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return tSupportLocation
end

function DoesPlatoonStillHaveSupportTarget(oPlatoon)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesPlatoonStillHaveSupportTarget'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon:GetPlan() == 'M27MobileShield' then bDebugMessages = true end
    local bStillHaveTarget = true

    if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Start of code') end

    if not(oPlatoon[refoSupportHelperUnitTarget]) and not(oPlatoon[refoSupportHelperPlatoonTarget]) and not(oPlatoon[refoPlatoonOrUnitToEscort]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have a valid unit or platoon target') end
        bStillHaveTarget = false
    else
        if oPlatoon[refoSupportHelperPlatoonTarget] or oPlatoon[refoPlatoonOrUnitToEscort] then
            bStillHaveTarget = false
            local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
            local bPlatoonStillExists = false
            local oTargetPlatoon
            if bDebugMessages == true then LOG(sFunctionRef..': Have a helperplatoon target or a platoon/unit to escort, will check if theyre still valid') end
            local bShieldPlatoon = false
            local bStealthPlatoon = false
            if oPlatoon:GetPlan() == 'M27MobileShield' then bShieldPlatoon = true
            elseif oPlatoon:GetPlan() == 'M27MobileStealth' then bStealthPlatoon = true
            end
            if oPlatoon[refoSupportHelperPlatoonTarget] and aiBrain:PlatoonExists(oPlatoon[refoSupportHelperPlatoonTarget]) then
                bPlatoonStillExists = true
                oTargetPlatoon = oPlatoon[refoSupportHelperPlatoonTarget]
            elseif oPlatoon[refoPlatoonOrUnitToEscort] and M27PlatoonFormer.PlatoonOrUnitNeedingEscortIsStillValid(aiBrain, oPlatoon[refoPlatoonOrUnitToEscort], bShieldPlatoon, bStealthPlatoon) == true then
                bPlatoonStillExists = true
                oTargetPlatoon = oPlatoon[refoPlatoonOrUnitToEscort]
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bPlatoonStillExists='..tostring(bPlatoonStillExists)) end
            if bPlatoonStillExists == true then
                --Check it has units in it
                if oTargetPlatoon.GetPlan and oTargetPlatoon.GetPlatoonPosition then
                    if oTargetPlatoon[refiCurrentUnits] > 0 or M27Utilities.IsTableEmpty(oTargetPlatoon:GetPlatoonUnits()) == false then
                        bStillHaveTarget = true
                    end
                else
                    --Are we dealing with a unit?
                    if oTargetPlatoon.GetUnitId then
                        bStillHaveTarget = true --Alreayd checked if dead as part of PlatoonOrUnitNeedingEscortIsStillValid
                    end
                end
                --[[if bPlatoonStillExists == true then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a platoon target and it either has units or no prev actionbut platoon either doesnt exist or doesnt have any current units, will make sure platoon has no units in it') end
                    bStillHaveTarget = true
                    if not(oTargetPlatoon.GetPlan) or not(oTargetPlatoon.GetPlatoonPosition) then M27Utilities.ErrorHandler('Have a target platoon but it doesnt have a plan and/or platoon position')
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Platoon does exist and has a plan') end
                        local tTargetPlatoonUnits = oTargetPlatoon:GetPlatoonUnits()
                        if M27Utilities.IsTableEmpty(tTargetPlatoonUnits) == false then
                            for iUnit, oUnit in tTargetPlatoonUnits do
                                if not(oUnit.Dead) and oUnit.GetUnitId then
                                    if M27Utilities.IsTableEmpty(oPlatoon[refoSupportHelperPlatoonTarget][reftCurrentUnits]) == true then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will temporarily update the supporting platoon unit details to record the first alive unit') end
                                        oPlatoon[refoSupportHelperPlatoonTarget][reftCurrentUnits] = {}
                                        oPlatoon[refoSupportHelperPlatoonTarget][reftCurrentUnits][1] = oUnit
                                        oPlatoon[refoSupportHelperPlatoonTarget][refiCurrentUnits] = 1
                                        break
                                    else
                                        M27Utilities.ErrorHandler('Target platoon has current units in a table, but no value for how many current units it has')
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Platoon has units in it, so may just be a delay with setting the curunits value') end
                            bStillHaveTarget = true
                        end
                    end
                end--]]
            end
        elseif oPlatoon[refoSupportHelperUnitTarget].Dead == true then
            if bDebugMessages == true then
                LOG(sFunctionRef..': Were trying to help a unit but that unit is dead now')
                LOG(sFunctionRef..': Unit ID that were trying to help='..oPlatoon[refoSupportHelperUnitTarget].UnitId)
                local iUniqueCount = M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoSupportHelperUnitTarget])
                LOG(sFunctionRef..': Unit count that were trying to help='..iUniqueCount)
                if oPlatoon[refoSupportHelperUnitTarget] == M27Utilities.GetACU(oPlatoon:GetBrain()) then
                    LOG(sFunctionRef..': Were trying to help ACU; ACU.Dead='..tostring(M27Utilities.GetACU(oPlatoon:GetBrain()).Dead))
                    M27Utilities.ErrorHandler('Assisting unit but that unit is dead and is an ACU')
                end
            end
            bStillHaveTarget = false
        end

        if bDebugMessages == true then
            LOG(sFunctionRef..': bStillHaveTarget='..tostring(bStillHaveTarget))
            if bStillHaveTarget == true then
                local iHelperUnitCount = M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoSupportHelperUnitTarget])
                if oPlatoon[refoSupportHelperUnitTarget] then LOG(sFunctionRef..': refoSupportHelperUnitTarget='..oPlatoon[refoSupportHelperUnitTarget].UnitId..iHelperUnitCount) end
                if oPlatoon[refoSupportHelperPlatoonTarget] then LOG(sFunctionRef..': refoSupportHelperPlatoonTarget='..oPlatoon[refoSupportHelperPlatoonTarget]:GetPlan()..oPlatoon[refoSupportHelperPlatoonTarget][refiPlatoonCount]) end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bStillHaveTarget='..tostring(bStillHaveTarget)) end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return bStillHaveTarget
end

function UpdateEscortDetails(oPlatoonOrUnitToBeEscorted)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateEscortDetails'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local sPlatoonName, aiBrain
    local bAbort = false
    if oPlatoonOrUnitToBeEscorted.GetUnitId then
        if oPlatoonOrUnitToBeEscorted.Dead then bAbort = true
        else
            sPlatoonName = oPlatoonOrUnitToBeEscorted.UnitId
            aiBrain = (oPlatoonOrUnitToBeEscorted[refoBrain] or oPlatoonOrUnitToBeEscorted:GetAIBrain())
        end
    else
        sPlatoonName = oPlatoonOrUnitToBeEscorted:GetPlan()
        aiBrain = (oPlatoonOrUnitToBeEscorted[refoBrain] or oPlatoonOrUnitToBeEscorted:GetBrain())
    end

    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoonOrUnitToBeEscorted[refiPlatoonCount]..': Start of function, Updating details for platoon; bAbort='..tostring(bAbort)) end
    if bAbort == false then
        local iEscortSizeDefaultFactor = 1
        local bEscortingLowHealthACU = false
        if oPlatoonOrUnitToBeEscorted[refbACUInPlatoon] and M27UnitInfo.GetUnitHealthPercent(M27Utilities.GetACU(aiBrain)) <= M27Overseer.iACUEmergencyHealthPercentThreshold then bEscortingLowHealthACU = true end
        local oEscortingPlatoon = oPlatoonOrUnitToBeEscorted[refoEscortingPlatoon]
        --Get larger escort if we're escorting the ACU (factor in nearby enemies and ACU upgrades when deciding how large an escort to send)
        if bEscortingLowHealthACU then oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted] = 100000
        else

            if oPlatoonOrUnitToBeEscorted[refbACUInPlatoon] then
                oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted] = math.max(2000, oPlatoonOrUnitToBeEscorted[refiPlatoonMassValue] * iEscortSizeDefaultFactor, M27Logic.GetCombatThreatRating(aiBrain, {M27Utilities.GetACU(aiBrain)}, false, nil, nil, false, false))
                if oPlatoonOrUnitToBeEscorted[refiEnemiesInRange] > 0 then
                    oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted] = math.max(oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted], M27Logic.GetCombatThreatRating(aiBrain, oPlatoonOrUnitToBeEscorted[reftEnemiesInRange]))
                end
            else oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted] = oPlatoonOrUnitToBeEscorted[refiPlatoonMassValue] * iEscortSizeDefaultFactor end
        end

        oPlatoonOrUnitToBeEscorted[refiCurrentEscortThreat] = 0
        if bDebugMessages == true then
            LOG(sFunctionRef..': oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted]='..oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted]..'; oPlatoonOrUnitToBeEscorted[refiPlatoonMassValue]='..oPlatoonOrUnitToBeEscorted[refiPlatoonMassValue]..'; iEscortSizeDefaultFactor='..iEscortSizeDefaultFactor)
            if oEscortingPlatoon then
                LOG('Have escorting platoon with plan, will check its threat. oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted]='..oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted])
                if oEscortingPlatoon[refiPlatoonThreatValue] then
                    LOG('Escorting platoon threat value='..oEscortingPlatoon[refiPlatoonThreatValue])
                end
            end
        end
        if oEscortingPlatoon and oEscortingPlatoon[refiPlatoonThreatValue] then
            if oEscortingPlatoon[refiPlatoonThreatValue] - oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted] > 60 and oEscortingPlatoon[refiPlatoonThreatValue] > oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted] * 1.5 then
                if aiBrain:PlatoonExists(oEscortingPlatoon) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Threat value of escorting platoon pre removal of spare units='..oEscortingPlatoon[refiPlatoonThreatValue]) end
                    M27Overseer.RemoveSpareUnits(oEscortingPlatoon, oPlatoonOrUnitToBeEscorted[refiEscortThreatWanted] * 1.2, 0, 0, nil, true)
                end
            end
            --The remove units from platoon function includes an update of the platoon values so the platoon threat value should be updated now:
            oPlatoonOrUnitToBeEscorted[refiCurrentEscortThreat] = oEscortingPlatoon[refiPlatoonThreatValue]
            if bDebugMessages == true then LOG(sFunctionRef..': Threat value of escorting platoon='..oPlatoonOrUnitToBeEscorted[refiCurrentEscortThreat]) end

        end
        if oPlatoonOrUnitToBeEscorted[refiNeedingEscortUniqueCount] == nil then
            if aiBrain[refiNeedingEscortUniqueCount] == nil then
                aiBrain[refiNeedingEscortUniqueCount] = 1
                aiBrain[reftPlatoonsOrUnitsNeedingEscorts] = {}
            else aiBrain[refiNeedingEscortUniqueCount] = aiBrain[refiNeedingEscortUniqueCount] + 1
            end
            oPlatoonOrUnitToBeEscorted[refiNeedingEscortUniqueCount] = aiBrain[refiNeedingEscortUniqueCount]
            aiBrain[reftPlatoonsOrUnitsNeedingEscorts][oPlatoonOrUnitToBeEscorted[refiNeedingEscortUniqueCount]] = oPlatoonOrUnitToBeEscorted
        end
        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoonOrUnitToBeEscorted[refiPlatoonCount]..': End of function, oPlatoonOrUnitToBeEscorted[refiNeedingEscortUniqueCount]='..oPlatoonOrUnitToBeEscorted[refiNeedingEscortUniqueCount]..'; size of aibrain of tables='..table.getn(aiBrain[reftPlatoonsOrUnitsNeedingEscorts])) end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function SetIfPlatoonCanKite(oPlatoon)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetIfPlatoonCanKite'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon.GetPlan and oPlatoon:GetPlan() == 'M27Skirmisher' then bDebugMessages = true end
    oPlatoon[refbKiteEnemies] = false
    if oPlatoon[refbACUInPlatoon] then oPlatoon[refbKiteEnemies] = true
    elseif oPlatoon[refiCurrentUnits] > 0 and (oPlatoon[refiDFUnits] > 0 or oPlatoon[refiIndirectUnits] > 0) then
        if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Plaoton range='..oPlatoon[refiPlatoonMaxRange]..'; Mass value='..oPlatoon[refiPlatoonMassValue]..'; DF units='..oPlatoon[refiDFUnits]) end
        if oPlatoon.GetPlan and not(oPlatoon:GetPlan() == 'M27GroundExperimental') and (oPlatoon[refiPlatoonMassValue] or 0) <= 10000 then
            local iMaxPlatoonRange = oPlatoon[refiPlatoonMaxRange]
            local bAllWeaponsNeedToUnpack
            local oBP
            if iMaxPlatoonRange and iMaxPlatoonRange > 22 then
                --Do we have any units that cant fire while retreating?
                oPlatoon[refbKiteEnemies] = true
                if bDebugMessages == true then LOG(sFunctionRef..': Set that platoon can kite enemies, will now consider if have any units that cant kite and change flag to false if there are any') end
                if oPlatoon[refiDFUnits] > 0 then
                    for iUnit, oUnit in oPlatoon[reftDFUnits] do
                        if M27UnitInfo.IsUnitValid(oUnit) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' has any weapons that are salved to body or turret') end
                            oBP = oUnit:GetBlueprint()
                            if M27Utilities.IsTableEmpty(oBP.Weapon) == false then
                                bAllWeaponsNeedToUnpack = true
                                for iWeapon, tWeapon in oBP.Weapon do
                                    if not(tWeapon.WeaponUnpacks) then bAllWeaponsNeedToUnpack = false end
                                    if tWeapon.SlavedToBody or tWeapon.SlavedToTurret then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Weapon is slaved to body or turret so will set can kite to false') end
                                        oPlatoon[refbKiteEnemies] = false
                                        break
                                    end
                                end
                                if bAllWeaponsNeedToUnpack then
                                    oPlatoon[refbKiteEnemies] = false
                                    break
                                end
                            end
                        end
                        if not(oPlatoon[refbKiteEnemies]) then break end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Can platoon kite enemies='..tostring(oPlatoon[refbKiteEnemies] or false)) end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function RecordPlatoonUnitsByType(oPlatoon, bPlatoonIsAUnit)
    --Update oPlatoon's unittable and count variables

    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPlatoonUnitsByType'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local sPlatoonName, aiBrain
    local bAbort = false
    if bPlatoonIsAUnit == true then
        if oPlatoon.GetUnitId and not(oPlatoon.Dead) then
            sPlatoonName = oPlatoon.UnitId
            aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetAIBrain())
            oPlatoon[refiPlatoonCount] = oPlatoon.M27LifetimeUnitCount
            if oPlatoon[refiPlatoonCount] == nil then oPlatoon[refiPlatoonCount] = 0 end
        else
            bAbort = true
        end
    else
        sPlatoonName = oPlatoon:GetPlan()
        aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
        if oPlatoon[M27PlatoonTemplates.refbSingletonPlatoon] and not(oPlatoon[refbPlatoonUnitDetailsChangedRecently]) and oPlatoon[refiCurrentUnits] == 1 and oPlatoon[reftCurrentUnits][1].PlatoonHandle == oPlatoon and oPlatoon[refiPrevCurrentUnits] == 1 and M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) then
            --ACU specific - dont abort if just been doing upgrade
            bAbort = true --no point refreshing data for ACU platoon or other singleton platoons when they will be the only unit in the platoon
            if oPlatoon[refbACUInPlatoon] and (oPlatoon[reftPrevAction][1] == refActionUpgrade) then bAbort = false end
        end
    end
    if oPlatoon[refiPlatoonCount] == nil then
        if aiBrain[refiLifetimePlatoonCount][sPlatoonName] == nil then aiBrain[refiLifetimePlatoonCount][sPlatoonName] = 1
        else aiBrain[refiLifetimePlatoonCount][sPlatoonName] = aiBrain[refiLifetimePlatoonCount][sPlatoonName] + 1 end
        oPlatoon[refiPlatoonCount] = aiBrain[refiLifetimePlatoonCount][sPlatoonName]
    end
    --if oPlatoon:GetPlan() == 'M27Skirmisher' and oPlatoon[refiPlatoonCount] == 3 and GetGameTimeSeconds() >= 360 then bDebugMessages = true end
    --if sPlatoonName == 'M27MAAAssister' then bDebugMessages = true end
    --if sPlatoonName == 'M27IndirectDefender' and GetGameTimeSeconds() >= 625 then bDebugMessages = true end
    --if sPlatoonName == 'M27CombatPatrolAI' then bDebugMessages = true end
    --if sPlatoonName == 'M27EscortAI' then bDebugMessages = true end
    --if sPlatoonName == 'M27ACUMain' then bDebugMessages = true end
    --if oPlatoon[refbACUInPlatoon] == true and GetGameTimeSeconds() >= 400 and aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyACUKill then bDebugMessages = true end
    --if sPlatoonName == 'M27GroundExperimental' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
    --if sPlatoonName == 'M27LargeAttackForce' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
    --if sPlatoonName == 'M27IndirectSpareAttacker' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end


    if bDebugMessages == true then LOG(sFunctionRef..sPlatoonName..oPlatoon[refiPlatoonCount]..': Start of code at time='..GetGameTimeSeconds()) end

    if bAbort == false then
        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..':bAbort isnt true, so starting to RecordPlatoonUnitsByType') end
        --store previous number for current units (for efficiency purposes):
        if oPlatoon[refiCurrentUnits] == nil then oPlatoon[refiCurrentUnits] = 0 end
        oPlatoon[refiPrevCurrentUnits] = oPlatoon[refiCurrentUnits]
        --Update list of current units:
        if bPlatoonIsAUnit then
            oPlatoon[reftCurrentUnits] = {oPlatoon}
        else
            oPlatoon[reftCurrentUnits] = oPlatoon:GetPlatoonUnits()
        end
        if M27Utilities.IsTableEmpty(oPlatoon[reftCurrentUnits]) == true then
            oPlatoon[refiCurrentUnits] = 0
            oPlatoon[refiDFUnits] = 0
            oPlatoon[refiScoutUnits] = 0
            oPlatoon[refiIndirectUnits] = 0
            oPlatoon[refiBuilders] = 0
            oPlatoon[refiReclaimers] = 0
            oPlatoon[refiUnitsWithShields] = 0
            oPlatoon[refbACUInPlatoon] = false
            oPlatoon[refbHoverInPlatoon] = false
            oPlatoon[refiPlatoonMassValue] = 0
            oPlatoon[refiPlatoonThreatValue] = 0
            oPlatoon[refiCurrentAction] = refActionDisband
            if bDebugMessages == true then LOG(sFunctionRef..': Platoon with name='..sPlatoonName..': units is an empty table so disbanding') end
        else
            --Check for friendly platoons to merge into this one (done every 5 cycles for optimisation purposes):
            if oPlatoon[M27PlatoonTemplates.refiPlatoonAmalgamationRange] then MergeNearbyPlatoons(oPlatoon) end
            local tACUs = EntityCategoryFilterDown(categories.COMMAND, oPlatoon[reftCurrentUnits])
            local bACUInPlatoon = false
            if not(M27Utilities.IsTableEmpty(tACUs)) then
                --local oACU = M27Utilities.GetACU(aiBrain)
                for iUnit, oUnit in tACUs do
                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                        bACUInPlatoon = true
                        break
                    end
                end
            end
            oPlatoon[refbACUInPlatoon] = bACUInPlatoon
            if bACUInPlatoon then
                oPlatoon[refiReclaimers] = 1
                oPlatoon[refiPlatoonMaxRange] = M27UnitInfo.GetUnitMaxGroundRange(M27Utilities.GetACU(aiBrain)) --M27Logic.GetACUMaxDFRange(M27Utilities.GetACU(aiBrain))
            end --Default, as later on the code will treat us as not having any reclaimers if there are nearby enemies
            oPlatoon[refiCurrentUnits] = table.getn(oPlatoon[reftCurrentUnits])
            --Update list of units by type if current unit number has changed or we have dead units in platoon
            local bUpdateByUnitType = false
            if oPlatoon[refbPlatoonUnitDetailsChangedRecently] then bUpdateByUnitType = true
            else
                if oPlatoon[refiPrevCurrentUnits] == nil then bUpdateByUnitType = true
                elseif not(oPlatoon[refiPrevCurrentUnits] == oPlatoon[refiCurrentUnits]) then bUpdateByUnitType = true
                elseif not(M27UnitInfo.IsUnitValid(oPlatoon[refoPathingUnit])) or (not(bPlatoonIsAUnit) and not(oPlatoon[refoPathingUnit].PlatoonHandle == oPlatoon)) then bUpdateByUnitType = true
                --[[else
                    for iUnit, oUnit in oPlatoon[reftCurrentUnits] do --despite having callbacks, some platoons will get errors with units not being alive and the flag for a unit having diedn ot being set to true
                        if not(M27UnitInfo.IsUnitValid(oUnit)) then
                            bUpdateByUnitType = true
                            break
                        end
                    end--]]
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': bUpdateByUnitType='..tostring(bUpdateByUnitType)..'; bACUInPlatoon='..tostring(bACUInPlatoon)..'; oPlatoon[refiPrevCurrentUnits]='..(oPlatoon[refiPrevCurrentUnits] or 'nil')..'; oPlatoon[refbPlatoonUnitDetailsChangedRecently]='..tostring(oPlatoon[refbPlatoonUnitDetailsChangedRecently])..'; oPlatoon[refiCurrentUnits]='..oPlatoon[refiCurrentUnits]..'; Is table of current units empty='..tostring(M27Utilities.IsTableEmpty(oPlatoon[reftCurrentUnits]))) end

            if not(oPlatoon[reftCurrentUnits][1]) then
                M27Utilities.ErrorHandler('First current unit is nil for platoon'..sPlatoonName..oPlatoon[refiPlatoonCount]..', will list out each unit in reftCurrentUnits. oPlatoon[refiCurrentUnits]='..oPlatoon[refiCurrentUnits]..'; table.getn='..table.getn(oPlatoon[reftCurrentUnits]))
                for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                    LOG(sFunctionRef..': iUnit='..iUnit..'; oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit))
                    LOG(sFunctionRef..': Will now do a reprs of it; note one cause of this error is if we set a varaible equal to reftcurrentunits, and then set some of the entires in that to nil.  Reprs='..reprs(oPlatoon[refCurrentUnits]))
                end
            end


                if bUpdateByUnitType == true then
                    oPlatoon[refbPlatoonUnitDetailsChangedRecently] = false
                    if bDebugMessages == true then LOG(sFunctionRef..': Refreshing details of units in platoon as the number of units has changed') end

                    --Need to first check if all current untis are valid as strange bug where sometimes they arent
                    if oPlatoon[refiCurrentUnits] > 0 then
                        local tUnitsToRemove = {}
                        local tNewCurrentUnits = {} --cant rely on getplatoonunits due to bug
                        local bManualTable = false
                        for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Is unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' still valid='..tostring(M27UnitInfo.IsUnitValid(oUnit))) end
                            if not(M27UnitInfo.IsUnitValid(oUnit)) then
                                bManualTable = true
                                break
                            end
                        end
                        if bManualTable then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will manually create a table of platoon units') end
                            for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                                if M27UnitInfo.IsUnitValid(oUnit) then
                                    table.insert(tNewCurrentUnits, oUnit)
                                else
                                    table.insert(tUnitsToRemove, oUnit)
                                end

                            end
                            if M27Utilities.IsTableEmpty(tUnitsToRemove) == false then
                                --Add to army pool
                                RemoveUnitsFromPlatoon(oPlatoon, tUnitsToRemove, false, nil)
                                oPlatoon[reftCurrentUnits] = tNewCurrentUnits
                                oPlatoon[refiCurrentUnits] = 0
                                if M27Utilities.IsTableEmpty(oPlatoon[reftCurrentUnits]) == false then
                                    oPlatoon[refiCurrentUnits] = table.getn(oPlatoon[reftCurrentUnits])
                                else
                                    oPlatoon[reftDFUnits] = nil
                                    oPlatoon[reftScoutUnits] = nil
                                    oPlatoon[reftIndirectUnits] = nil
                                    oPlatoon[reftBuilders] = nil
                                    oPlatoon[reftReclaimers] = nil
                                    oPlatoon[reftUnitsWithShields] = nil
                                    oPlatoon[refiCurrentUnits] = 0
                                    oPlatoon[refiDFUnits] = 0
                                    oPlatoon[refiScoutUnits] = 0
                                    oPlatoon[refiIndirectUnits] = 0
                                    oPlatoon[refiBuilders] = 0
                                    oPlatoon[refiReclaimers] = 0
                                    oPlatoon[refiUnitsWithShields] = 0
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to remove empty='..tostring(M27Utilities.IsTableEmpty(tUnitsToRemove))) end

                    end
                    if oPlatoon[refiCurrentUnits] > 0 then
                        oPlatoon[reftDFUnits] = EntityCategoryFilterDown(categories.DIRECTFIRE + M27UnitInfo.refCategoryFatboy - categories.SCOUT - M27UnitInfo.refCategoryMAA + M27UnitInfo.refCategoryCombatScout - M27UnitInfo.refCategoryShieldDisruptor, oPlatoon[reftCurrentUnits])
                        oPlatoon[reftScoutUnits] = EntityCategoryFilterDown(categories.SCOUT, oPlatoon[reftCurrentUnits])
                        oPlatoon[reftIndirectUnits] = EntityCategoryFilterDown(categories.INDIRECTFIRE + M27UnitInfo.refCategoryShieldDisruptor, oPlatoon[reftCurrentUnits])
                        oPlatoon[reftBuilders] = EntityCategoryFilterDown(categories.CONSTRUCTION, oPlatoon[reftCurrentUnits])
                        oPlatoon[reftReclaimers] = EntityCategoryFilterDown(categories.RECLAIM, oPlatoon[reftCurrentUnits])
                        oPlatoon[reftUnitsWithShields] = EntityCategoryFilterDown(M27UnitInfo.refCategoryMobileLandShield + M27UnitInfo.refCategoryPersonalShield, oPlatoon[reftCurrentUnits])
                        if oPlatoon[reftDFUnits] == nil then
                            oPlatoon[refiDFUnits] = 0
                            --oPlatoon[refbHoverInPlatoon] = false
                        else
                            oPlatoon[refiDFUnits] = table.getn(oPlatoon[reftDFUnits])
                            --oPlatoon[refbHoverInPlatoon] = not(M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.HOVER, oPlatoon[reftDFUnits])))
                        end

                        if oPlatoon[refiPrevCurrentUnits] < oPlatoon[refiCurrentUnits] then
                            if bDebugMessages == true then LOG(sFunctionRef..': Units in platoon has increased so refreshing platoon action unless ACU that is busy') end
                            if not(oPlatoon[refbACUInPlatoon]) or M27Logic.IsUnitIdle(oPlatoon[reftBuilders][1], true, true, true, true) then
                                oPlatoon[refbForceActionRefresh] = true
                            end
                        end

                        oPlatoon[refbHoverInPlatoon] = not(M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.HOVER, oPlatoon[reftCurrentUnits])))
                        if oPlatoon[reftScoutUnits] == nil then oPlatoon[refiScoutUnits] = 0
                        else oPlatoon[refiScoutUnits] = table.getn(oPlatoon[reftScoutUnits]) end
                        if oPlatoon[reftIndirectUnits] == nil then oPlatoon[refiIndirectUnits] = 0
                        else oPlatoon[refiIndirectUnits] = table.getn(oPlatoon[reftIndirectUnits]) end
                        if oPlatoon[reftBuilders] == nil then oPlatoon[refiBuilders] = 0
                        else oPlatoon[refiBuilders] = table.getn(oPlatoon[reftBuilders]) end
                        if oPlatoon[reftReclaimers] == nil then oPlatoon[refiReclaimers] = 0
                        else oPlatoon[refiReclaimers] = table.getn(oPlatoon[reftReclaimers]) end
                        if oPlatoon[reftUnitsWithShields] == nil then oPlatoon[refiUnitsWithShields] = 0 else oPlatoon[refiUnitsWithShields] = table.getn(oPlatoon[reftUnitsWithShields]) end
                        --GetCombatThreatRating(aiBrain, tUnits, bMustBeVisibleToIntelOrSight, iMassValueOfBlipsOverride, iSoloBlipMassOverride, bIndirectFireThreatOnly, bJustGetMassValue)
                        oPlatoon[refiPlatoonThreatValue] = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits], nil, nil)
                        oPlatoon[refiPlatoonMassValue] = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits], nil, nil, false, false, true)
                        --[[if oPlatoon[refbShouldHaveEscort] then oPlatoon[refiPlatoonMassValue] = M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits], nil, nil, false, false, true)
                        else oPlatoon[refiPlatoonMassValue] = oPlatoon[refiPlatoonThreatValue] end--]]
                        if bDebugMessages == true then LOG(sFunctionRef..': Just got mass value for platoon='..oPlatoon[refiPlatoonMassValue]..'; oPlatoon[refbShouldHaveEscort]='..tostring(oPlatoon[refbShouldHaveEscort])) end

                        --Get the front unit in the platoon
                        local oPrevFrontUnit = oPlatoon[refoFrontUnit]
                        if oPlatoon[refiCurrentUnits] == 1 then
                            oPlatoon[refoFrontUnit] = oPlatoon[reftCurrentUnits][1]
                            oPlatoon[refoRearUnit] = oPlatoon[reftCurrentUnits][1]
                        else
                            oPlatoon[refoFrontUnit] = M27Logic.GetUnitNearestEnemy(aiBrain, oPlatoon[reftCurrentUnits])
                            oPlatoon[refoRearUnit] = M27Utilities.GetNearestUnit(oPlatoon[reftCurrentUnits], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], aiBrain, false)
                        end

                        --Shield disruptor prioritisation
                        if oPlatoon[refiIndirectUnits] > 0 then
                            local tDisruptors = EntityCategoryFilterDown(M27UnitInfo.refCategoryShieldDisruptor, oPlatoon[reftIndirectUnits])
                            if M27Utilities.IsTableEmpty(tDisruptors) == false then
                                for iUnit, oUnit in tDisruptors do
                                    if M27UnitInfo.IsUnitValid(oUnit) then
                                        M27UnitInfo.SetUnitTargetPriorities(oUnit, M27UnitInfo.refWeaponPriorityShieldDisruptor)
                                    end
                                end
                            end
                        end

                        --Set platoon range (unless ACU in platoon as we have already done this above)
                        if not(bACUInPlatoon) then
                            --if sPlatoonName == 'M27GroundExperimental' then bDebugMessages = true end
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Platoon='..sPlatoonName..oPlatoon[refiPlatoonCount]..'; DF Units='..oPlatoon[refiDFUnits]..'; oPlatoon[refiIndirectUnits]='..oPlatoon[refiIndirectUnits]..'; CurrentUnits='..oPlatoon[refiCurrentUnits]..'; will list out each unit')
                                if M27Utilities.IsTableEmpty(oPlatoon[reftCurrentUnits]) == false then
                                    for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                                        LOG('iUnit'..iUnit..'='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit))
                                    end
                                end
                            end

                            oPlatoon[refiPlatoonMaxRange] = 2
                            if oPlatoon[refiDFUnits] > 0 then
                                if EntityCategoryContains(categories.DIRECTFIRE, oPlatoon[refoFrontUnit].UnitId) then
                                    oPlatoon[refiPlatoonMaxRange] = math.max(oPlatoon[refiPlatoonMaxRange], M27Logic.GetUnitMaxGroundRange({oPlatoon[refoFrontUnit]}))
                                else
                                    oPlatoon[refiPlatoonMaxRange] = math.max(oPlatoon[refiPlatoonMaxRange], M27Logic.GetUnitMaxGroundRange(oPlatoon[reftCurrentUnits]))
                                end
                                --MOnkeylord - cap range at 30 (range of laser) not the bolters
                                if sPlatoonName == 'M27GroundExperimental' and oPlatoon[refiPlatoonMaxRange] >= 30 and oPlatoon[refoFrontUnit].UnitId == 'url0402' then
                                    oPlatoon[refiPlatoonMaxRange] = 30
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Platoon has DF units, range after checking DF units='..oPlatoon[refiPlatoonMaxRange]) end

                            end
                            if oPlatoon[refiIndirectUnits] > 0 then
                                if oPlatoon[refiDFUnits] == 0 then
                                    oPlatoon[refiPlatoonMaxRange] = math.max(oPlatoon[refiPlatoonMaxRange], M27Logic.GetUnitMaxGroundRange({oPlatoon[refoFrontUnit]}), M27UnitInfo.GetUnitIndirectRange(oPlatoon[refoFrontUnit]))
                                    if bDebugMessages == true then LOG(sFunctionRef..': Platoon has no DF units but has indirect fire units, range after checking DF units='..oPlatoon[refiPlatoonMaxRange]..'; front unit='..oPlatoon[refoFrontUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit])) end
                                elseif EntityCategoryContains(categories.INDIRECTFIRE + M27UnitInfo.refCategoryLongRangeDFLand, oPlatoon[refoFrontUnit].UnitId) then
                                    oPlatoon[refiPlatoonMaxRange] = math.max(oPlatoon[refiPlatoonMaxRange], M27Logic.GetUnitMaxGroundRange({oPlatoon[refoFrontUnit]}), M27UnitInfo.GetUnitIndirectRange(oPlatoon[refoFrontUnit]))
                                    if bDebugMessages == true then LOG(sFunctionRef..': Platoon has DF units but contains indirect or long range DF land, units but has indirect fire units, range after checking DF units='..oPlatoon[refiPlatoonMaxRange]..'; front unit='..oPlatoon[refoFrontUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit])) end
                                else
                                    oPlatoon[refiPlatoonMaxRange] = math.max(oPlatoon[refiPlatoonMaxRange], M27Logic.GetUnitMaxGroundRange({oPlatoon[refoFrontUnit]}), M27UnitInfo.GetUnitIndirectRange(M27Utilities.GetNearestUnit(oPlatoon[reftIndirectUnits], GetPlatoonFrontPosition(oPlatoon), aiBrain)))
                                    if bDebugMessages == true then LOG(sFunctionRef..': Platoon has DF units but no long range DF land, will get range of the indirect fire unit nearest to the platoon front.  Range='..oPlatoon[refiPlatoonMaxRange]) end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Finnished setting platoon max range, iDFUnits='..oPlatoon[refiDFUnits]..'; IndirectUnits='..oPlatoon[refiIndirectUnits]..'; platoon max range='..oPlatoon[refiPlatoonMaxRange]) end
                        end

                        --Do we want to enable kiting (e.g. if longer range unit recently added to platoon)?
                        if not(oPlatoon[refbKiteEnemies]) then
                            SetIfPlatoonCanKite(oPlatoon)
                        end

                        --Refresh the skirmisherretreat flag in case we have switched between defender and non-defender plans
                        if oPlatoon[refiIndirectUnits] > 0 then
                            local bUseSkirmisherRetreatLogic = false
                            if oPlatoon[refbKiteEnemies] and M27PlatoonTemplates.PlatoonTemplate[oPlatoon:GetPlan()][M27PlatoonTemplates.refbSkirmisherRetreatLogic] then bUseSkirmisherRetreatLogic = true end
                            oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] = bUseSkirmisherRetreatLogic
                        end

                        --Does the platoon contain underwater or overwater land units? (for now assumes will only have 1 or the other)
                        if oPlatoon[refiCurrentUnits] > 0 then
                            if oPlatoon[refiDFUnits] > 0 or sPlatoonName == 'M27GroundExperimental' then
                                if oPlatoon[reftPlatoonDFTargettingCategories] == nil then
                                    if sPlatoonName == 'M27GroundExperimental' then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Updating target priority categories as we are an experimental platoon') end
                                        if EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId) then
                                            oPlatoon[reftPlatoonDFTargettingCategories] = M27UnitInfo.refWeaponPriorityOurFatboy
                                        else oPlatoon[reftPlatoonDFTargettingCategories] = M27UnitInfo.refWeaponPriorityOurGroundExperimental
                                        end
                                    else --Default
                                        if bDebugMessages == true then LOG(sFunctionRef..': Not an experimental platoon so will use default target priorities') end
                                        oPlatoon[reftPlatoonDFTargettingCategories] = M27UnitInfo.refWeaponPriorityNormal
                                    end
                                end
                                for iUnit, oUnit in oPlatoon[reftDFUnits] do
                                    if EntityCategoryContains(M27UnitInfo.refCategoryShieldDisruptor, oUnit.UnitId) then
                                        M27UnitInfo.SetUnitTargetPriorities(oUnit, M27UnitInfo.refWeaponPriorityShieldDisruptor)
                                    elseif EntityCategoryContains(M27UnitInfo.refCategorySniperBot, oUnit.UnitId) then
                                        M27UnitInfo.SetUnitTargetPriorities(oUnit, M27UnitInfo.refWeaponPrioritySniperBot)
                                    else
                                        M27UnitInfo.SetUnitTargetPriorities(oUnit, oPlatoon[reftPlatoonDFTargettingCategories])
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Finished setting unit target priorities for all units in platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'; Strategy at this point='..aiBrain[M27Overseer.refiAIBrainCurrentStrategy]) end

                                if sPlatoonName == 'M27GroundExperimental' then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have an experimental platoon, iRange='..oPlatoon[refiPlatoonMaxRange]..'; checking if contains fatboy') end
                                    if oPlatoon[refiPlatoonMaxRange] >= 60 or (M27UnitInfo.IsUnitValid(oPlatoon[reftCurrentUnits][1]) and EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId)) and not(M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit])) then
                                        oPlatoon[M27PlatoonTemplates.refbAttackMove] = true
                                    end
                                end

                            end
                            if bPlatoonIsAUnit == true then
                                oPlatoon[refoPathingUnit] = oPlatoon
                            else
                                oPlatoon[refoPathingUnit] = GetPathingUnit(oPlatoon)
                            end
                            if not(M27UnitInfo.IsUnitValid(oPlatoon[refoPathingUnit])) then
                                --all units must be dead if not got a valid pathing unit
                                oPlatoon[refiCurrentAction] = refActionDisband
                                if bDebugMessages == true then LOG(sFunctionRef..': Pathing unit nil or dead so disbanding') end
                            else
                                oPlatoon[refbPlatoonHasUnderwaterLand] = false
                                oPlatoon[refbPlatoonHasOverwaterLand] = false
                                local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit])
                                if sPathing == M27UnitInfo.refPathingTypeAmphibious then
                                    for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                                        if M27UnitInfo.IsUnitUnderwaterAmphibious(oUnit) == true then
                                            oPlatoon[refbPlatoonHasUnderwaterLand] = true
                                            break
                                        else
                                            oPlatoon[refbPlatoonHasOverwaterLand] = true
                                            break
                                        end
                                    end
                                end
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Platoon has no units in it so will disband') end
                            oPlatoon[refiCurrentAction] = refActionDisband
                        end
                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': iBuilders='..oPlatoon[refiBuilders]..'; iReclaimers='..oPlatoon[refiReclaimers]) end

                        oPlatoon[refiFrontUnitRefreshCount] = 0
                        oPlatoon[refiRearUnitRefreshCount] = 0
                    end
                else

                    if bDebugMessages == true then LOG(sFunctionRef..': No change in platoon size so will just check pathing and front/rear units are still accurate') end

                    --ACU specific - refresh targeting priorities every 10s
                    if oPlatoon[refbACUInPlatoon] and math.floor(GetGameTimeSeconds() / 10) * 10 == math.floor(GetGameTimeSeconds()) then
                        if oPlatoon[reftPlatoonDFTargettingCategories] == nil then
                            if sPlatoonName == 'M27GroundExperimental' then
                                if bDebugMessages == true then LOG(sFunctionRef..': Updating target priority categories as we are an experimental platoon') end
                                if EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId) then
                                    oPlatoon[reftPlatoonDFTargettingCategories] = M27UnitInfo.refWeaponPriorityOurFatboy
                                else oPlatoon[reftPlatoonDFTargettingCategories] = M27UnitInfo.refWeaponPriorityOurGroundExperimental
                                end
                            else --Default
                                if bDebugMessages == true then LOG(sFunctionRef..': Not an experimental platoon so will use default target priorities') end
                                oPlatoon[reftPlatoonDFTargettingCategories] = M27UnitInfo.refWeaponPriorityNormal
                            end
                        end
                        for iUnit, oUnit in oPlatoon[reftDFUnits] do
                            M27UnitInfo.SetUnitTargetPriorities(oUnit, oPlatoon[reftPlatoonDFTargettingCategories])
                        end
                    end

                    --Already checked the pathing unit was valid earlier
                    --[[if not(M27UnitInfo.IsUnitValid(oPlatoon[refoPathingUnit])) then
                        oPlatoon[refoPathingUnit] = GetPathingUnit(oPlatoon)
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Pathing unit is still valid as '..oPlatoon[refoPathingUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoPathingUnit])) end
                    end--]]
                    --No change in platoon units so no need to refresh most variables (other than the front unit if it's been a while since the last refresh)
                    if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) and oPlatoon[refiFrontUnitRefreshCount] <= 9 then
                        --No need to refresh front unit
                        if bDebugMessages == true then LOG(sFunctionRef..': Front unit still valid='..oPlatoon[refoFrontUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit])) end
                        oPlatoon[refiFrontUnitRefreshCount] = oPlatoon[refiFrontUnitRefreshCount] + 1
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Refreshing front unit; refiCurrentUnits='..oPlatoon[refiCurrentUnits]) end
                        if oPlatoon[refiCurrentUnits] > 0 then
                            if oPlatoon[refiCurrentUnits] == 1 then
                                oPlatoon[refoFrontUnit] = oPlatoon[reftCurrentUnits][1]
                            else
                                oPlatoon[refoFrontUnit] = M27Logic.GetUnitNearestEnemy(aiBrain, oPlatoon[reftCurrentUnits])
                            end
                            oPlatoon[refiFrontUnitRefreshCount] = 0
                        end
                    end

                    if oPlatoon[refoRearUnit] and not(oPlatoon[refoRearUnit].Dead) and oPlatoon[refoRearUnit].GetUnitId and oPlatoon[refiRearUnitRefreshCount] <= 9 then
                        --No need to refresh front unit
                        oPlatoon[refiRearUnitRefreshCount] = oPlatoon[refiRearUnitRefreshCount] + 1
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Refreshing front unit; refiCurrentUnits='..oPlatoon[refiCurrentUnits]) end
                        if oPlatoon[refiCurrentUnits] > 0 then
                            if oPlatoon[refiCurrentUnits] == 1 then
                                oPlatoon[refoRearUnit] = oPlatoon[refoFrontUnit]
                            else
                                oPlatoon[refoRearUnit] = M27Utilities.GetNearestUnit(oPlatoon[reftCurrentUnits], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], aiBrain, false)
                            end
                            oPlatoon[refiRearUnitRefreshCount] = 0
                        end
                    end

                end
            --Update flag for if special micro active
            if M27Utilities.IsTableEmpty(oPlatoon[reftCurrentUnits]) == false then
                local bActiveMicro = false
                local bOldMicroFlag = oPlatoon[M27UnitInfo.refbSpecialMicroActive]

                for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                    if oUnit[M27UnitInfo.refbSpecialMicroActive] then bActiveMicro = true break end
                end
                oPlatoon[M27UnitInfo.refbSpecialMicroActive] = bActiveMicro
                if bOldMicroFlag and not(bActiveMicro) then ForceActionRefresh(oPlatoon, 2) end
            end

            if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) then
                oPlatoon[reftFrontPosition] = oPlatoon[refoFrontUnit]:GetPosition()

                --Update unit's pathing details
                if not(oPlatoon[refoFrontUnit][M27UnitInfo.refsPathing]) then
                    oPlatoon[refoFrontUnit][M27UnitInfo.refsPathing] = M27UnitInfo.GetUnitPathingType(oPlatoon[refoFrontUnit])
                    oPlatoon[refoFrontUnit][M27UnitInfo.reftPathingGroupCount] = {}
                end
                local iCurPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(oPlatoon[refoFrontUnit][M27UnitInfo.refsPathing], oPlatoon[refoFrontUnit]:GetPosition())
                if not(oPlatoon[refoFrontUnit][M27UnitInfo.reftPathingGroupCount][iCurPathingGroup]) and M27Utilities.IsTableEmpty(oPlatoon[refoFrontUnit][M27UnitInfo.reftPathingGroupCount]) == false and EntityCategoryContains(categories.MOBILE, oPlatoon[refoFrontUnit]) then
                    --Likely pathing error unless the platoon has no other values
                    if bDebugMessages == true then LOG(sFunctionRef..': Platoon '..(sPlatoonName or 'nil')..(oPlatoon[refiPlatoonCount] or 'nil')..': Likely pathing error, will check pathing, cur segment group='..(iCurPathingGroup or 'nil')..'; Front unit='..(oPlatoon[refoFrontUnit].UnitId or 'nil')..(M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit]) or 'nil')..'; Prev segment group counts for unit='..repru((oPlatoon[refoFrontUnit][M27UnitInfo.reftPathingGroupCount] or {'nil'}))..';  FrontUnit[M27Transport.refiAssignedPlateau]='.. (oPlatoon[refoFrontUnit][M27Transport.refiAssignedPlateau] or 'nil')..'; Segment group of start position='..(M27MapInfo.GetSegmentGroupOfLocation(oPlatoon[refoFrontUnit][M27UnitInfo.refsPathing], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) or 'nil')) end
                    if oPlatoon[refoFrontUnit][M27UnitInfo.refiLastPathingGroup] and oPlatoon[refoFrontUnit][M27UnitInfo.reftPathingGroupCount][oPlatoon[refoFrontUnit][M27UnitInfo.refiLastPathingGroup]] >= 2 then
                        if M27MapInfo.RecheckPathingOfLocation(oPlatoon[refoFrontUnit][M27UnitInfo.refsPathing], oPlatoon[refoFrontUnit], oPlatoon[refoFrontUnit]:GetPosition(), oPlatoon[refoFrontUnit][M27UnitInfo.reftLastLocationOfPathingGroup], false) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Pathing has changed') end
                            iCurPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(oPlatoon[refoFrontUnit][M27UnitInfo.refsPathing], oPlatoon[refoFrontUnit]:GetPosition())
                        else
                            M27Utilities.ErrorHandler(sFunctionRef..': Likely pathing error for unit')
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': Prev group had insufficient count so wont recheck pathing')
                    end
                elseif oPlatoon[refoFrontUnit][M27UnitInfo.reftPathingGroupCount][iCurPathingGroup] >= 2 then
                    oPlatoon[refoFrontUnit][M27UnitInfo.reftLastLocationOfPathingGroup] = {}
                    oPlatoon[refoFrontUnit][M27UnitInfo.reftLastLocationOfPathingGroup][1], oPlatoon[refoFrontUnit][M27UnitInfo.reftLastLocationOfPathingGroup][2], oPlatoon[refoFrontUnit][M27UnitInfo.reftLastLocationOfPathingGroup][3] = oPlatoon[refoFrontUnit]:GetPositionXYZ()
                    oPlatoon[refoFrontUnit][M27UnitInfo.refiLastPathingGroup] =  iCurPathingGroup
                end
                oPlatoon[refoFrontUnit][M27UnitInfo.reftPathingGroupCount][iCurPathingGroup] = (oPlatoon[refoFrontUnit][M27UnitInfo.reftPathingGroupCount][iCurPathingGroup] or 0) + 1 --NOTE: AllocateNewUnitToPlatoonFromFactory will increase by 5 when a unit is first created to give a revised starting point

            else
                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Platoon has no valid front unit so will record our start position as the front position') end
                oPlatoon[reftFrontPosition] = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
            end
            if oPlatoon[refoRearUnit] then
                oPlatoon[reftRearPosition] = oPlatoon[refoRearUnit]:GetPosition()
                --Logic for splitting out skrimisher platoons if the yare far apart
                --if oPlatoon:GetPlan() == 'M27Skirmisher' and oPlatoon[refiPlatoonCount] == 9 then bDebugMessages = true end
                if bDebugMessages == true then LOG(sFunctionRef..': If have skirmisher platoon will check if want to consider far away units. CurUnits='..oPlatoon[refiCurrentUnits]..'; Using skirmisher retreat logic='..tostring(oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic])..'; Platoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]) end
                if oPlatoon[refiCurrentUnits] > 1 and oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] and oPlatoon:GetPlan() == 'M27Skirmisher' then
                    ConsiderRemovingFarAwayUnits(oPlatoon)
                end

            else
                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Platoon has no valid rear unit so will record our start position as the rear position') end
                oPlatoon[reftRearPosition] = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
            end

            if bDebugMessages == true then
                M27Utilities.DrawLocation(oPlatoon[reftFrontPosition], nil, 2, 50)
                if oPlatoon[refoFrontUnit] then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..'RecordPlatoonUnitsByType: end of code; oPlatoon[reftFrontPosition]='..repru(oPlatoon[reftFrontPosition])..'; oPlatoon[refoFrontUnit]='..oPlatoon[refoFrontUnit].UnitId..'; iCurrentUnits='..oPlatoon[refiCurrentUnits]..'; iDFUnits='..oPlatoon[refiDFUnits]..'; iScouts='..oPlatoon[refiScoutUnits]..'; iArti='..oPlatoon[refiIndirectUnits]) end
            else if bDebugMessages == true then LOG(sPlatoonName..': No front unit exists') end
            end
            if bDebugMessages == true then
                if oPlatoon[reftReclaimers] == nil then LOG('tReclaimers is nil')
                else LOG('tReclaimers size='..table.getn(oPlatoon[reftReclaimers])) end
                if oPlatoon[reftBuilders] == nil then LOG('tReclaimers is nil')
                else LOG('tBuilders size='..table.getn(oPlatoon[reftBuilders])) end
            end

            --Update details of any escorts
            if bDebugMessages == true then LOG(sFunctionRef..': About to update escort details if flagged to have escort; oPlatoon[refbShouldHaveEscort]='..tostring(oPlatoon[refbShouldHaveEscort])) end
            if oPlatoon[refbShouldHaveEscort] == true then UpdateEscortDetails(oPlatoon) end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef..': refiCurrentUnits='..(oPlatoon[refiCurrentUnits] or 'nil')..'; DFunits='..(oPlatoon[refiDFUnits] or 'nil')..'; Indirect='..(oPlatoon[refiIndirectUnits] or 'nil'))
            if oPlatoon[refoPathingUnit].GetUnitId then
                LOG('oPlatoon[refoPathingUnit]='..oPlatoon[refoPathingUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoPathingUnit])..'oPathingUnit.Dead='..tostring(oPlatoon[refoPathingUnit].Dead))
            else
                LOG('oPlatoon[refoPathingUnit] doesnt have a unit id')
            end
            if oPlatoon[refiIndirectUnits] > 0 and oPlatoon[refiCurrentUnits] > (oPlatoon[refiIndirectUnits] + oPlatoon[refiDFUnits]) then
                LOG('Have indirect fire units in platoon but IF+DF units are less than current units, will list out all current units and all indirect units')
                for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                    if M27UnitInfo.IsUnitValid(oUnit) then
                        LOG('iUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit))
                    else LOG('iUnit '..iUnit..' is invalid')
                    end
                end
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function DetermineActionForNearbyMex(oPlatoon)
    --Double-check we can still build a mex
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineActionForNearbyMex'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 11 and GetGameTimeSeconds() >= 90 and GetGameTimeSeconds() <= 400 then bDebugMessages = true end
    if bDebugMessages == true then LOG(sFunctionRef..': About to check have builders in platoon and get first builder') end
    if oPlatoon[refiBuilders] > 0 then
        local oFirstBuilder
        for _, oBuilder in oPlatoon[reftBuilders] do
            if not(oBuilder.Dead) then
                oFirstBuilder = oBuilder break
            end
        end
        if not(oFirstBuilder==nil) then
            local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
            --Turtle mode - want ACU to get to chokepoint asap so dont want it to build on mexes it comes across if it has ok mass income
            local iMexSearchRange = 18
            if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle then
                if aiBrain[M27EconomyOverseer.refiGrossMassBaseIncome] >= 1.1 then


                    if aiBrain[M27EconomyOverseer.refiGrossMassBaseIncome] >= 1.3 then
                        iMexSearchRange = oFirstBuilder:GetBlueprint().Economy.MaxBuildDistance
                    else
                        iMexSearchRange = 13
                    end
                        --Do nothing
                end
            end
            if not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle) or aiBrain[M27EconomyOverseer.refiGrossMassBaseIncome] <= 1.8 or ((oFirstBuilder:IsUnitState('Building') or oFirstBuilder:IsUnitState('Repairing')) and oFirstBuilder:GetFocusUnit() and EntityCategoryContains(M27UnitInfo.refCategoryMex, oFirstBuilder:GetFocusUnit())) then

            --If we dont have enough power, limit the number of mexes we get
            local bHaveEnoughPower = false


                if not(M27Utilities.IsACU(oFirstBuilder)) or not(M27Conditions.DoesACUHaveBigGun(aiBrain)) then
                    --Initial build order (if dont have enough power)
                    if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= 11 then bHaveEnoughPower = true
                    else
                        local iCurMexes = aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryT1Mex)
                        --Initial build order: Hydro
                        if M27Conditions.HydroNearACUAndBase(aiBrain, true, false) then
                            if iCurMexes < 3 then bHaveEnoughPower = true
                            elseif iCurMexes < 4 then
                                --Sometimes want to get 4 mexes before hydro
                                if M27Utilities.IsTableEmpty(M27MapInfo.tResourceNearStart[aiBrain.M27StartPositionNumber]) == false and table.getn(M27MapInfo.tResourceNearStart[aiBrain.M27StartPositionNumber][1]) <= 5 then
                                    bHaveEnoughPower = true
                                end

                            end
                        else
                            --Initial build order: Non-hydro: 2 pgens, 2 mexes, 2 pgens
                            local iCurPGens = math.max(aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryT1Power), math.floor((aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] - 2)/2))
                            if iCurPGens >= 2 and iCurMexes < 2 then bHaveEnoughPower = true
                            elseif iCurPGens >= 4 and iCurMexes < 4 then bHaveEnoughPower = true
                            end

                            --elseif aiBrain:GetEconomyIncome('MASS') <= 0.2 or (aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryT1Power) >= 4 and aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryT1Mex) < 2) then bHaveEnoughPower = true
                            --elseif (aiBrain:GetEconomyStored('MASS') <= 30 and aiBrain:GetEconomyStored('ENERGY') >= 1400) or (aiBrain:GetEconomyStored('MASS') <= 15 and aiBrain:GetEconomyStored('ENERGY') >= 500 and aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryPower)) >= math.max(4, aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryT1Mex)+1) then bHaveEnoughPower = true

                        end
                    end


                    --If have less tahn 20 power and are more likely to stall power than mass then call logic to build power first
                    if bHaveEnoughPower and not(oFirstBuilder:IsUnitState('Building')) and not(oFirstBuilder:IsUnitState('Repairing')) and aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] < 20 and aiBrain:GetEconomyStored('ENERGY') <= 2000 and aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome] < 0 and (aiBrain:GetEconomyStored('MASS') >= 50 or (aiBrain[M27EconomyOverseer.refiNetMassBaseIncome] > 0 and aiBrain:GetEconomyStored('MASS') >= 15)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Still have lowish power, will see if want to build power first rather than mass') end
                        DetermineIfACUShouldBuildPower(oPlatoon)
                        if oPlatoon[refiCurrentAction] then
                            bHaveEnoughPower = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to build power in priority to mex') end
                        end
                    end

                    if bHaveEnoughPower == true then

                        --Do we have a part-built mex within range or near range?
                        local tNearbyMex = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryMex, GetPlatoonFrontPosition(oPlatoon), iMexSearchRange, 'Ally')
                        if M27Utilities.IsTableEmpty(tNearbyMex) == false then
                            local oNearestPartBuiltMex
                            local iNearestPartBuiltMex = 100000
                            local iCurDistance
                            for iMex, oMex in tNearbyMex do
                                if oMex:GetFractionComplete() < 1 then
                                    iCurDistance = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oMex:GetPosition())
                                    if iCurDistance < iNearestPartBuiltMex then
                                        iNearestPartBuiltMex = iCurDistance
                                        oNearestPartBuiltMex = oMex
                                    end

                                end
                            end
                            if oNearestPartBuiltMex then
                                oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                oPlatoon[refoConstructionToAssist] = oNearestPartBuiltMex
                            end
                        end
                        if not(oPlatoon[refiCurrentAction]) then

                            --Are there any unclaimed mexes nearby:
                            --GetNearestMexToUnit(oBuilder, bCanBeBuiltOnByAlly, bCanBeBuiltOnByEnemy, bCanBeQueuedToBeBuilt, iMaxSearchRangeMod, tStartPositionOverride, tMexesToIgnore)
                            local tNearbyMex = M27MapInfo.GetNearestMexToUnit(oFirstBuilder, false, false, true, M27Overseer.iACUMaxTravelToNearbyMex, nil, nil) --allows a slight detour from current position
                            if bDebugMessages == true then
                                if M27Utilities.IsTableEmpty(tNearbyMex) then LOG(sFunctionRef..': tNearbyMex is empty')
                                else LOG(sFunctionRef..': tNearbyMex='..repru(tNearbyMex)) end
                            end
                            if M27Utilities.IsTableEmpty(tNearbyMex) == false then
                                --Do we already have an action to reclaim? If so then only build mex if are in range
                                local iDistToMex = math.floor(M27Utilities.GetDistanceBetweenPositions(tNearbyMex, oFirstBuilder:GetPosition()))
                                if iDistToMex <= iMexSearchRange and (not(oPlatoon[refiCurrentAction]) or (aiBrain:GetEconomyStored('MASS') >= 20 and iDistToMex <= oPlatoon[reftBuilders][1]:GetBlueprint().MaxBuildDistance)) then
                                    --Is the mex location in range of enemy T2+ PD?
                                    local tEnemyT2PlusPD = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT2PlusPD, tNearbyMex, 53, 'Enemy')
                                    if M27Utilities.IsTableEmpty(tEnemyT2PlusPD) then
                                        tEnemyT2PlusPD = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT3PD, tNearbyMex, 72, 'Enemy')
                                        if M27Utilities.IsTableEmpty(tEnemyT2PlusPD) then
                                            --Are there any unseen T2 PD in range?
                                            local bUnseenPD = false
                                            if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftUnseenPD]) == false then
                                                for iUnit, oUnit in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftUnseenPD] do
                                                    if M27Utilities.GetDistanceBetweenPositions(tNearbyMex, oUnit:GetPosition()) <= 53 then
                                                        bUnseenPD = true
                                                        break
                                                    end
                                                end
                                            end

                                            --If we walk in a straight line to a mex can we path there? (ignore check if mex is within build range), and does anything block a shot there?
                                            local bNoObstructions = true
                                            local iBuildRange = oFirstBuilder:GetBlueprint().Economy.MaxBuildDistance - 2

                                            if iDistToMex <= iBuildRange then
                                                bNoObstructions = true --redundancy
                                                if bDebugMessages == true then LOG(sFunctionRef..': Mex is within build range so can build on it. iDistToMex='..iDistToMex..'; iBuildRange='..iBuildRange) end
                                            else
                                                local iOurBasePathingGroup = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oFirstBuilder:GetPosition())
                                                local tPositionToCheck
                                                local iAngleToMove = M27Utilities.GetAngleFromAToB(oFirstBuilder:GetPosition(), tNearbyMex)
                                                for iDistance = 1, (iDistToMex - iBuildRange) do
                                                    tPositionToCheck = M27Utilities.MoveInDirection(oFirstBuilder:GetPosition(), iAngleToMove, iDistance, false)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Comparing pathing group of builder position='..repru(oFirstBuilder:GetPosition())..' with group '..iOurBasePathingGroup..' to positiontocheck='..repru(tPositionToCheck)..' with group='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, tPositionToCheck)) end
                                                    if not(iOurBasePathingGroup == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, tPositionToCheck)) then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': The position to check is in a different pathing group so have obstructions') end
                                                        bNoObstructions = false
                                                        break
                                                    end
                                                end
                                                if bNoObstructions and iDistToMex > (iBuildRange + 1) then
                                                    --Check if we fire a shot if anything blocks it
                                                    local tStartPosition = GetPlatoonFrontPosition(oPlatoon)
                                                    if M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit]) then tStartPosition[2] = GetSurfaceHeight(tStartPosition[1], tStartPosition[3]) end
                                                    tStartPosition[2] = tStartPosition[2] + 0.1
                                                    if bDebugMessages == true then LOG(sFunctionRef..': About to check if line is blocked from tStartPosition='..repru(tStartPosition)..' to tNearbyMex='..repru({tNearbyMex[1], tNearbyMex[2] + 0.1, tNearbyMex[3]})..'; result='..tostring(M27Logic.IsLineBlocked(aiBrain, tStartPosition, {tNearbyMex[1], tNearbyMex[2] + 0.1, tNearbyMex[3]}, 1))) end
                                                    if M27Logic.IsLineBlocked(aiBrain, tStartPosition, {tNearbyMex[1], tNearbyMex[2] + 0.1, tNearbyMex[3]}, 1) then
                                                        bNoObstructions = false
                                                    end
                                                end

                                                if bDebugMessages == true then LOG(sFunctionRef..': CHecking if can path in a straight line to the nearest mex; iOurBasePathingGroup='..iOurBasePathingGroup..'; bNoObstructions='..tostring(bNoObstructions)) end
                                            end

                                            if bNoObstructions then
                                                oPlatoon[refiCurrentAction] = refActionBuildMex
                                                if oPlatoon[reftNearbyMexToBuildOn] == nil then oPlatoon[reftNearbyMexToBuildOn] = {} end
                                                oPlatoon[reftNearbyMexToBuildOn] = tNearbyMex
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have updated for nearby mex='..repru(oPlatoon[reftNearbyMexToBuildOn])) end
                                            elseif bDebugMessages == true then LOG(sFunctionRef..': Cant path easily to the mex so wont try and build on it')
                                            end
                                        elseif bDebugMessages == true then LOG(sFunctionRef..': Mex has T3 PD near it so wont proceed')
                                        end
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': Mex has T2 PD near it so wont proceed')
                                    end
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Already have an action assigned, and not in range of mex, so will proceed with existing action')
                                end
                            end
                        end
                    end
                end
        end
        else
            oPlatoon[refiBuilders] = 0
        end

    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function DetermineIfACUShouldBuildPower(oPlatoon)
    --Have already called the action to check action for nearby hydro before getting to this point
    local sFunctionRef = 'DetermineIfACUShouldBuildPower'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    --Only call if ACU in platoon
    if oPlatoon:GetPlan() == 'M27ACUMain' then
        local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
        --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 11 and GetGameTimeSeconds() >= 90 and GetGameTimeSeconds() <= 400 then bDebugMessages = true end
        if oPlatoon[reftPrevAction] and oPlatoon[reftPrevAction][1] == refActionBuildInitialPower then
            local oACU = M27Utilities.GetACU(aiBrain)
            if oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') then
                if bDebugMessages == true then LOG(sFunctionRef..': ACU previous action was to build power and its still building or repairing so have it continue to build power') end
                oPlatoon[refiCurrentAction] = refActionBuildInitialPower
            end
        end
        if oPlatoon[refiCurrentAction] == nil then
            local iGrossEnergyWanted = 13
            local iEneryBeforeSecondFac = 11 --Min energy wanted before considering getting second fac in priority
            if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle then
                --Doing from start means ACU wont decide to build power while walking there.  However sometimes that might be beneficial - e.g. if its taking longer than expected for engis to get power up
                --local iDistToChokepoint = M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], aiBrain[M27MapInfo.reftChokepointBuildLocation])
                local iDistToChokepoint = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), aiBrain[M27MapInfo.reftChokepointBuildLocation])

                if iDistToChokepoint <= 120 then
                    if iDistToChokepoint <= 30 then
                        iGrossEnergyWanted = 28
                    elseif iDistToChokepoint <= 50 then
                        iGrossEnergyWanted = 26
                    elseif iDistToChokepoint <= 70 then
                        iGrossEnergyWanted = 24
                    elseif iDistToChokepoint <= 90 then
                        iGrossEnergyWanted = 22
                    elseif iDistToChokepoint <= 110 then
                        iGrossEnergyWanted = 20
                    else iGrossEnergyWanted = 18
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Are in turtle mode, dist tochokepoint from start position='..M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], aiBrain[M27MapInfo.reftChokepointBuildLocation])..'; energy wanted='..iGrossEnergyWanted) end
            elseif aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyLandRush then
                iGrossEnergyWanted = 16
            elseif aiBrain:GetEconomyStoredRatio('Energy') < 0.99 then

                if not(aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithAmphibious]) then
                    iGrossEnergyWanted = 40
                elseif not(aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand]) then --can path to enemy with amphibious but not land
                    if aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] >= 400 then
                        iGrossEnergyWanted = 40
                    else
                        iGrossEnergyWanted = 30
                    end
                elseif aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] >= 600 then
                    iGrossEnergyWanted = 30
                end

            end
            --Get more power if going second air; assuming nearby hydro would want hydro+2 pgens
            if aiBrain[M27Overseer.refiMinLandFactoryBeforeOtherTypes] <= 1 then
                iGrossEnergyWanted = math.max(iGrossEnergyWanted, 16)
                iEneryBeforeSecondFac = 16
            end
            if aiBrain:GetEconomyStoredRatio('MASS') >= 0.1 and not (aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle or aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyLandRush) then
                if aiBrain[M27Overseer.refiMinLandFactoryBeforeOtherTypes] <= 1 then
                    iGrossEnergyWanted = math.min(45, iGrossEnergyWanted + 7)
                end
                --Allow ACU to build power if its still not that far from our base, we have at least 2 factories, are high mass and low power, and dont ahve tech 2
                if aiBrain[M27Overseer.refiOurHighestAirFactoryTech] == 1 and aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] <= (iGrossEnergyWanted + 10) and aiBrain:GetEconomyStoredRatio('MASS') >= 0.2 and (aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.75 or aiBrain[M27EconomyOverseer.refbStallingEnergy]) and aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryAllFactories) >= 2 and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) then
                    iGrossEnergyWanted = math.min(iGrossEnergyWanted + 10, 50)
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iGrossEnergyIncome=' .. aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] .. '; iGrossEnergyWanted=' .. iGrossEnergyWanted)
            end
            if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] <= iGrossEnergyWanted then
                --Do we have enough mass to build?
                if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] <= 13 or ((aiBrain:GetEconomyStored('MASS') >= 50 or aiBrain[M27EconomyOverseer.refiNetMassBaseIncome] >= 0.3) and (not(aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand]) or aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] >= 500 or aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle or M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) <= 50)) then
                    --Only get power if we have <90% energy stored or 3 factories
                    local iCurLandFactories = aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryAllFactories)
                    if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= iEneryBeforeSecondFac and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.9 and iCurLandFactories < math.min(3, aiBrain[M27Overseer.reftiMaxFactoryByType][M27Overseer.refFactoryTypeLand]) then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Have fewer than 3 factories so want to get factory instead')
                        end
                        --Do nothing as want to build factory in next step
                    elseif aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= iEneryBeforeSecondFac and iCurLandFactories == 1 and aiBrain[M27Overseer.reftiMaxFactoryByType][M27Overseer.refFactoryTypeLand] > 1 then
                        --Second land factory so do nothing as will build in next step
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Only have 1 land factory and want more than 1 so will do nothing so we get a land factory')
                        end
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Want more energy, will build unless are far from base')
                        end
                        if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) <= math.min(250, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.4) then
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Near start of game so will build power unless we are near a hydro; NearHydro=' .. tostring(M27Conditions.HydroNearACUAndBase(aiBrain, true, false)) .. '; aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome]=' .. aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] .. '; WOuld expect platoon to have already been given action to build hydro though by this point, unless construction hasnt started')
                            end
                            if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= 10 or not (M27Conditions.HydroNearACUAndBase(aiBrain, true, false)) then
                                oPlatoon[refiCurrentAction] = refActionBuildInitialPower
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Will build pgen')
                                end
                            else
                                --Have nearby hydro not yet built so dont send action to build power as want to help with the hydro
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Dont want to build pgen as want to help with hydro instead')
                                end
                            end

                            --[[if not(M27Conditions.HydroNearACUAndBase(aiBrain, true, false)) then
                                oPlatoon[refiCurrentAction] = refActionBuildInitialPower
                            else
                                --If we already have 1 hydro then build t1 power anyway unless unbuilt hydro is really close to ACU
                                if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= 10 then
                                    local tNearbyHydro = M27MapInfo.GetResourcesNearTargetLocation(GetPlatoonFrontPosition(oPlatoon), 25, false)
                                    if M27Utilities.IsTableEmpty(tNearbyHydro) == false then tNearbyHydro = M27EngineerOverseer.FilterLocationsBasedOnIfUnclaimed(aiBrain, tNearbyHydro, false) end
                                    if M27Utilities.IsTableEmpty(tNearbyHydro) == true then
                                        oPlatoon[refiCurrentAction] = refActionBuildInitialPower
                                    end
                                end
                            end--]]
                        end
                    end
                end
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function DetermineIfACUShouldBuildFactory(oPlatoon)
    --Allows ACU to build land factory in certain cases
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineIfACUShouldBuildFactory'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon[refbACUInPlatoon] == true then --Already have this in the determine platoon action function, and might want to use this function for another unit
    local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
    local iFactoryCount = aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryAllFactories)
    if bDebugMessages == true then LOG(sFunctionRef..': About to see if want to build a land factory. EnergyIncome='..aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome]..'; MassNetIncome='..aiBrain:GetEconomyTrend('MASS')..'Stored energy='..aiBrain:GetEconomyStored('ENERGY')..'; StoredMass='..aiBrain:GetEconomyStored('MASS')..'; LandFactoryCount='..iFactoryCount) end

    if not(M27Conditions.DoesACUHaveBigGun(aiBrain)) and (not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyAirDominance) or M27Utilities.GetACU(aiBrain):IsUnitState('Building')) then
        if oPlatoon[refiEnemiesInRange] == 0 and oPlatoon[refiEnemyStructuresInRange] == 0 and (aiBrain[M27Overseer.refiSearchRangeForEnemyStructures] >= 60 or M27Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryDangerousToLand, GetPlatoonFrontPosition(oPlatoon), 60, 'Enemy'))) then
            --Is the engineer already building and its previous action was to build a land factory or power?
            local bAlreadyBuilding = false
            local bAlreadyTryingToBuild = false
            if oPlatoon[reftPrevAction] and oPlatoon[reftPrevAction][1] == refActionBuildFactory then
                bAlreadyTryingToBuild = true
                local oACU = M27Utilities.GetACU(aiBrain)
                if oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') then
                    oPlatoon[refiCurrentAction] = refActionBuildFactory
                    bAlreadyBuilding = true
                    oPlatoon[refbMovingToBuild] = false
                end
            end
            if bAlreadyBuilding == false then
                local iFactoriesWanted = 3
                if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyEcoAndTech then iFactoriesWanted = 2
                elseif aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle then iFactoriesWanted = 1 end
                --If engineer already actioned building a factory then our ACU may end up moving far back to base to help build it
                if iFactoriesWanted > 2 and M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionBuildLandFactory]) == false and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) > 12 then iFactoriesWanted = math.min(iFactoriesWanted, 2) end
                if iFactoryCount < iFactoriesWanted and iFactoryCount < aiBrain[M27Overseer.reftiMaxFactoryByType][M27Overseer.refFactoryTypeLand] then
                    --Are we closer to enemy than base?
                    local tCurPosition = GetPlatoonFrontPosition(oPlatoon)
                    local iDistanceToEnemy = M27Utilities.GetDistanceBetweenPositions(tCurPosition, M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain))
                    local iDistanceToStart = M27Utilities.GetDistanceBetweenPositions(tCurPosition, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                    if bDebugMessages == true then LOG(sFunctionRef..': iDistanceToEnemy='..iDistanceToEnemy..'; iDistanceToStart='..iDistanceToStart) end
                    if iDistanceToEnemy >= iDistanceToStart then
                        local iStoredEnergy = aiBrain:GetEconomyStored('ENERGY')
                        if bAlreadyTryingToBuild and iStoredEnergy >= 250 and oPlatoon[refbMovingToBuild] == true then
                            oPlatoon[refiCurrentAction] = refActionBuildFactory
                        else
                            if iFactoryCount < 2 then
                                if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= 10 then --Have at least 100 gross energy income per second
                                    if aiBrain:GetEconomyTrend('MASS') >= 0.2 or (aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyLandRush and (aiBrain:GetEconomyStored('MASS') >= 60 or aiBrain[M27EconomyOverseer.refiGrossMassBaseIncome] >= 1.1)) then --At least 2 net mass income per second
                                        if iStoredEnergy >= 250 then
                                            if aiBrain:GetEconomyStored('MASS') >= 20 then
                                                if bDebugMessages == true then LOG(sFunctionRef..': We have the resources to build a land factory so will try to') end
                                                oPlatoon[refiCurrentAction] = refActionBuildFactory
                                            end
                                        end
                                    end
                                end
                            elseif iFactoryCount < 4 then
                                if M27Conditions.DoesACUHaveUpgrade(aiBrain, oPlatoon[reftBuilders][1]) == false then
                                    if aiBrain:GetEconomyTrend('ENERGY') >= 5 then -->=50 energy income
                                        if aiBrain:GetEconomyStored('MASS') >= 400 then
                                            if iStoredEnergy >= 750 then
                                                if aiBrain:GetEconomyTrend('MASS') >= 0.4 then --At least 4 net mass income per second
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build another land fac with ACU to stop overflow') end
                                                    oPlatoon[refiCurrentAction] = refActionBuildFactory
                                                end
                                            end
                                        end
                                    end
                                end
                            elseif iFactoryCount < 6 then
                                if M27Conditions.DoesACUHaveUpgrade(aiBrain, oPlatoon[reftBuilders][1]) == false then
                                    if aiBrain:GetEconomyTrend('ENERGY') >= 5 then -->=50 energy income
                                        if aiBrain:GetEconomyStored('MASS') >= 600 then
                                            if iStoredEnergy >= 1000 then
                                                if aiBrain:GetEconomyTrend('MASS') >= 0.4 then --At least 4 net mass income per second
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build another land fac with ACU to stop overflow') end
                                                    oPlatoon[refiCurrentAction] = refActionBuildFactory
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            if oPlatoon[refiCurrentAction] then oPlatoon[refbMovingToBuild] = true end
                        end
                    end
                end
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    --end
end

--[[function AssignACUInitialBuildOrder(oPlatoon)
    --Gives the ACU an initial build order based on what has been built
    --Initial land factory
    local aiBrain = oPlatoon:GetBrain()
    local iFactoryCount = aiBrain:GetCurrentUnits(categories.STRUCTURE * categories.FACTORY)
    local iMexCount = aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryT1Mex)
    local iActionToAssign
    local tTargetLocation = oACU:GetPosition()
    local bFirstAction = true
    local oACU = M27Utilities.GetACU(aiBrain)
    local iMaxInitialMex = 3
    --Initial factory
    if iFactoryCount < 1 then
        --UpdateEngineerActionTrackers(aiBrain, oEngineer, iActionToAssign, tTargetLocation, bAreAssisting, iConditionNumber)
        --AssignActionToEngineer(aiBrain, oEngineer, iActionToAssign, tActionTargetLocation, oActionTargetObject, iConditionNumber, sBuildingBPRef)
        bFirstAction = false
        iActionToAssign = M27EngineerOverseer.refActionBuildLandFactory
        M27EngineerOverseer.UpdateEngineerActionTrackers(aiBrain, oACU, iActionToAssign, tTargetLocation, false, 0)
        M27EngineerOverseer.AssignActionToEngineer(aiBrain, oACU, iActionToAssign, tTargetLocation, nil, 0)
    end
    if iMexCount < iMaxInitialMex then

    end
end --]]

function DetermineActionForNearbyHydro(oPlatoon)
    --Tries to assist any hydro being constructed
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineActionForNearbyHydro'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local iMaxDistanceToMove = M27Overseer.iACUMaxTravelToNearbyMex
    if bDebugMessages == true then LOG(sFunctionRef..': About to check have builders in platoon and get first builder') end
    if oPlatoon[refiBuilders] > 0 then
        local oFirstBuilder
        for _, oBuilder in oPlatoon[reftBuilders] do
            if not(oBuilder.Dead) then
                oFirstBuilder = oBuilder break
            end
        end
        if not(oFirstBuilder==nil) then
            --Are there any Hydro buildings nearby:
            --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 11 and GetGameTimeSeconds() >= 90 and GetGameTimeSeconds() <= 400 then bDebugMessages = true end

            --GetNearestMexToUnit(oBuilder, bCanBeBuiltOnByAlly, bCanBeBuiltOnByEnemy, bCanBeQueuedToBeBuilt, iMaxSearchRangeMod, tStartPositionOverride, tMexesToIgnore)
            local aiBrain = (oPlatoon[refoBrain] or oFirstBuilder:GetAIBrain())
            local iBuildDistance = oFirstBuilder:GetBlueprint().Economy.MaxBuildDistance
            local tNearbyHydro = aiBrain:GetUnitsAroundPoint(categories.HYDROCARBON, oFirstBuilder:GetPosition(), iMaxDistanceToMove + iBuildDistance, 'Ally')
            if bDebugMessages == true then LOG(sFunctionRef..': Have a builder, seeing if nearby hydro. iMaxDistanceToMove='..iMaxDistanceToMove..'; iBuildDistance='..iBuildDistance..'; Is table of nearby hydro empty='..tostring(M27Utilities.IsTableEmpty(tNearbyHydro))) end
            if M27Utilities.IsTableEmpty(tNearbyHydro) == false then
                --Is this an ACU that has the gun?
                if bDebugMessages == true then LOG(sFunctionRef..': Have a nearby hydro, seeing if ACU has gun') end
                if oFirstBuilder == M27Utilities.GetACU(aiBrain) and M27Conditions.DoesACUHaveGun(aiBrain, true) == true then
                    --do nothing
                else
                    --Is the building still being constructed?
                    local oHydro = tNearbyHydro[1]
                    local tHydroLocation, sLocationRef
                    if oHydro.GetFractionComplete then
                        local iFractionComplete = oHydro:GetFractionComplete()
                        if bDebugMessages == true then LOG(sFunctionRef..': iFractionComplete='..iFractionComplete) end
                        if iFractionComplete < 1 and iFractionComplete > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Building started but not complete, assigning action') end
                            --Is there an engineer already building it?
                            tHydroLocation = oHydro:GetPosition()
                            sLocationRef = M27Utilities.ConvertLocationToReference(tHydroLocation)
                            if aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation] and aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef] and M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef][M27EngineerOverseer.refActionBuildHydro]) == false then
                                for iUniqueRef, oEngi in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef][M27EngineerOverseer.refActionBuildHydro] do
                                    if not(oEngi.Dead) and oEngi.GetPosition then
                                        oPlatoon[refoConstructionToAssist] = oEngi
                                        break
                                    end
                                end
                                if not(oPlatoon[refoConstructionToAssist]) then
                                    M27Utilities.ErrorHandler('Tracker says engi shoudl be building hydro but no living engi could be found, will assist hydro building instead but should investigate')
                                    oPlatoon[refoConstructionToAssist] = oHydro
                                end
                            else
                                oPlatoon[refoConstructionToAssist] = oHydro
                            end
                            oPlatoon[refiCurrentAction] = refActionAssistConstruction

                        end
                    end
                end
            end
        else
            oPlatoon[refiBuilders] = 0
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function DetermineActionForNearbyReclaim(oPlatoon, bIgnoreNearbyEnemies)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineActionForNearbyReclaim'

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
    --if oPlatoon[refbACUInPlatoon] == true and aiBrain:GetArmyIndex() == 7 and GetGameTimeSeconds() >= 480 then bDebugMessages = true end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oPlatoon[refiReclaimers]='..oPlatoon[refiReclaimers]..'; bIgnoreNearbyEnemies='..tostring((bIgnoreNearbyEnemies or false))) end
    if oPlatoon[refiReclaimers] > 0 and (aiBrain[M27EconomyOverseer.refiGrossMassBaseIncome] >= 0.8 or GetGameTimeSeconds() >= 180) then --Have 3 mexes already
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code for '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]) end
        --Check we aren't full with mass

        local bProceed = true
        if oPlatoon[refbACUInPlatoon] then
            if M27Conditions.DoesACUHaveBigGun(aiBrain, oPlatoon[reftReclaimers][1]) then bProceed = false
                --Is this the ACU, are we turtling, and does the ACU yet to have T2 or T3 upgrade, and is far from the chokepoint?
            elseif aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle then
                local oACU = M27Utilities.GetACU(aiBrain)
                if not(oACU:HasEnhancement('AdvancedEngineering')) and not(oACU:HasEnhancement('T3Engineering')) and aiBrain:GetEconomyStored('MASS') >= 150 and M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), aiBrain[M27MapInfo.reftChokepointBuildLocation]) >= 28 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Are turtling, not near chokepoint, dont have upgrade, and have a bit of mass so will ignore reclaim') end
                    bProceed = false
                end
            end
        end
        if bProceed then
            local iSpareStorage
            if aiBrain:GetEconomyStoredRatio('MASS') > 0 then iSpareStorage = aiBrain:GetEconomyStored('MASS') / aiBrain:GetEconomyStoredRatio('MASS')
            else iSpareStorage = 800 end

            if bDebugMessages == true then LOG(sFunctionRef..': iSpareStorage='..iSpareStorage) end

            if iSpareStorage > 50 then --v14 and earlier - was 1 as In some cases will want to finish reclaiming if are already reclaiming; v15: Changed to be 50 as approx (since reclaim at 5*buildpower, so ACU would reclaim up to 50/s)

                if bDebugMessages == true then LOG(sFunctionRef..': About to get first unit with reclaim function') end
                --if oPlatoon[refoNearbyReclaimTarget] == nil then oPlatoon[refoNearbyReclaimTarget] = {} end
                local oFirstReclaimer
                for _, oReclaimer in oPlatoon[reftReclaimers] do
                    if not(oReclaimer.Dead) then
                        oFirstReclaimer = oReclaimer break
                    end
                end
                if oFirstReclaimer and (not(oFirstReclaimer:IsUnitState('Building') or oFirstReclaimer:IsUnitState('Repairing')) or (aiBrain:GetEconomyStored('MASS') == 0 and oFirstReclaimer:GetFocusUnit() and oFirstReclaimer:GetFocusUnit().GetFractionComplete and oFirstReclaimer:GetFocusUnit():GetFractionComplete() >= 0.75 and oFirstReclaimer:GetFocusUnit():GetFractionComplete() < 1)) then
                    --If ACU then will ahve called this before checking for nearby enemies, so check if any within 30
                    local bHaveNearbyEnemies = false
                    if not(bIgnoreNearbyEnemies) then
                        local iHealthLossPerSec = 0
                        local iCurTime = math.floor(GetGameTimeSeconds())
                        local bHaveT2OrT3 = false
                        local iEnemyRangeThreshold = 30
                        if M27Conditions.DoesACUHaveGun(aiBrain, false) then iEnemyRangeThreshold = 40 end
                        if oFirstReclaimer:HasEnhancement('AdvancedEngineering') or oFirstReclaimer:HasEnhancement('T3Engineering') then bHaveT2OrT3 = true end

                        if oPlatoon[refbACUInPlatoon] and EntityCategoryContains(categories.COMMAND, oFirstReclaimer.UnitId) and M27Utilities.IsTableEmpty(oFirstReclaimer[M27Overseer.reftACURecentHealth]) == false and GetGameTimeSeconds() >= 15 then iHealthLossPerSec = ((oFirstReclaimer[M27Overseer.reftACURecentHealth][iCurTime - 10] or oFirstReclaimer[M27Overseer.reftACURecentHealth][iCurTime - 11]) - (oFirstReclaimer[M27Overseer.reftACURecentHealth][iCurTime] or oFirstReclaimer[M27Overseer.reftACURecentHealth][iCurTime-1] or oFirstReclaimer[M27Overseer.reftACURecentHealth][iCurTime-2])) / 10 end
                        if iHealthLossPerSec >= 10 and (iHealthLossPerSec >= 50 or (not(bHaveT2OrT3))) then
                            bHaveNearbyEnemies = true
                        else
                            if oPlatoon[refiEnemyStructuresInRange] > 0 and ((not(bHaveT2OrT3) and M27Conditions.DoesACUHaveGun(aiBrain, false)) or M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryT2PlusPD, oPlatoon[reftEnemyStructuresInRange])) == false) then bHaveNearbyEnemies = true
                            else
                                if oPlatoon[refbACUInPlatoon] and oPlatoon[refiEnemiesInRange] > 0 then
                                    local oNearestMobileEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain, nil)
                                    if oNearestMobileEnemy and M27Utilities.GetDistanceBetweenPositions(oNearestMobileEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= iEnemyRangeThreshold then bHaveNearbyEnemies = true end
                                end
                                if not(bHaveNearbyEnemies) and oPlatoon[refiEnemyStructuresInRange] > 0 then
                                    local oNearestStructure = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain, nil)
                                    if oNearestStructure and M27Utilities.GetDistanceBetweenPositions(oNearestStructure:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= iEnemyRangeThreshold + 5 then
                                        bHaveNearbyEnemies = true
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bHaveNearbyEnemies after checking if any mobile enemies within 30 of us and structures within 35='..tostring(bHaveNearbyEnemies)) end
                        end
                    end
                    if bHaveNearbyEnemies == false then
                        --New approach for v14
                        --Are we in a segment with reclaim or near a segment with reclaim?
                        --IsReclaimNearby(tLocation, iAdjacentSegmentSize, iMinTotal, iMinIndividual)
                        local iMinIndividualReclaim = 4
                        --Will we be wanting more reclaim than this?

                        if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= 46 then
                            local bWantEnergy, bWantMass = M27Conditions.WantEnergyOrMassReclaim(aiBrain)
                            --Dont want ACU to be trying to get individual trees if already ahve high energy income as better uses for its time
                            if bWantEnergy then iMinIndividualReclaim = 50 end
                        end


                        if M27Conditions.IsReclaimNearby(GetPlatoonFrontPosition(oPlatoon), 1, 15, 4) then
                            --check we have reclaim in range of the ACU itself
                            local iMaxRange = oFirstReclaimer:GetBlueprint().Economy.MaxBuildDistance + oFirstReclaimer:GetBlueprint().SizeX - 0.1
                            local oNearestReclaim = M27MapInfo.GetNearestReclaimObject(GetPlatoonFrontPosition(oPlatoon), iMaxRange + 10, 5)
                            if oNearestReclaim and oNearestReclaim.CachePosition and M27Utilities.GetDistanceBetweenPositions(oNearestReclaim.CachePosition, GetPlatoonFrontPosition(oPlatoon)) <= (iMaxRange + math.min(oNearestReclaim:GetBlueprint().SizeX, oNearestReclaim:GetBlueprint().SizeZ)*0.5) then
                                oPlatoon[refiCurrentAction] = refActionReclaimAllNearby
                                oPlatoon[refoNearbyReclaimTarget] = nil
                                if bDebugMessages == true then LOG(sFunctionRef..': Have nearby reclaim, so will try to get') end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Reclaim is close but not in build range') end
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': No nearby reclaim') end
                            --If are enemy walls nearby still run the logic
                            local tNearbyWalls = aiBrain:GetUnitsAroundPoint(categories.WALL, GetPlatoonFrontPosition(oPlatoon), 13, 'Ally')
                            if M27Utilities.IsTableEmpty(tNearbyWalls) == false and table.getn(tNearbyWalls) >= 4 then
                                oPlatoon[refiCurrentAction] = refActionReclaimAllNearby
                                oPlatoon[refoNearbyReclaimTarget] = nil
                            end
                        end

                        --Old approach pre v15 below
                        --[[


                        local oReclaimerBP = oFirstReclaimer:GetBlueprint()

                        local iBuildDistance = oReclaimerBP.Economy.MaxBuildDistance
                        if iBuildDistance <= 5 then iBuildDistance = 5 end
                        if bDebugMessages == true then LOG(sFunctionRef..': Found a reclaimer, about to locate any nearby reclaim; iBuildDistance='..iBuildDistance) end
                        --Do we already have a reclaim target that we're reclaiming?
                        local bAlreadyHaveValidTarget = false
                        local bHaveValidTarget = false
                        local oReclaimTarget
                        local tReclaimLocation = {}

                        if oFirstReclaimer:IsUnitState('Reclaiming') == true then
                            oReclaimTarget = oPlatoon[refoNearbyReclaimTarget]
                            if not(oReclaimTarget == nil) then
                                if oReclaimTarget.MaxMassReclaim > 0 then
                                    if not(oReclaimTarget:BeenDestroyed()) then
                                        tReclaimLocation = oReclaimTarget.CachePosition
                                        if M27Utilities.IsTableEmpty(tReclaimLocation) == false then
                                            if M27Utilities.GetDistanceBetweenPositions(tReclaimLocation, oFirstReclaimer:GetPosition()) <= iBuildDistance then
                                                bAlreadyHaveValidTarget = true
                                                bHaveValidTarget = true
                                            end
                                        end
                                    end
                                end
                            end
                        end

                        if bAlreadyHaveValidTarget == false then
                            --GetNearestReclaim(tLocation, iSearchRadius, iMinReclaimValue)
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have an existing reclaim target so will look for nearest reclaim') end
                            oReclaimTarget = M27MapInfo.GetNearestReclaim(GetPlatoonFrontPosition(oPlatoon), iBuildDistance + 2, 10)

                            if not(oReclaimTarget == nil) and oReclaimTarget.MaxMassReclaim > 0 and not(oReclaimTarget:BeenDestroyed()) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Found a reclaim target, changing action') end
                                oPlatoon[refoNearbyReclaimTarget] = oReclaimTarget
                                bHaveValidTarget = true
                            elseif bDebugMessages == true then
                                LOG(sFunctionRef..': oReclaimTarget is nil or has 0 max mass reclaim or has been destroyed')
                                if oReclaimTarget then LOG('Reclaim target isnt nil; maxmassreclaim='..oReclaimTarget.MaxMassReclaim..'; oReclaimTarget:BeenDestroyed='..tostring(oReclaimTarget:BeenDestroyed())) end
                            end
                        end
                        if bHaveValidTarget == true then
                            if not(oPlatoon[refoNearbyReclaimTarget]) then M27Utilities.ErrorHandler('Thought had valid target but dont') end
                            local bWillOverflowMass = false
                            --Are we overflowing mass (or about to)?
                            --Get reclaim rate: From testing looks like the reclaim per second is roughly 5 * build power
                            local iBuildPower = oReclaimerBP.Economy.BuildRate
                            if iBuildPower == nil then iBuildPower = 5 end
                            local iReclaimRate = 5 * iBuildPower
                            local iMassReclaimed = math.min(oPlatoon[refoNearbyReclaimTarget].MaxMassReclaim, iReclaimRate)
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if will overflow mass, iReclaimRate='..iReclaimRate..'; iMassReclaimed='..iMassReclaimed..'; iBuildPower='..iBuildPower..'; iSpareStorage='..iSpareStorage) end
                            if bAlreadyHaveValidTarget == true then
                                --Finish reclaim unless >=5 mass wasted
                                if iSpareStorage < 50 and iMassReclaimed > (iSpareStorage + 5) then bWillOverflowMass = true end
                            else
                                if iSpareStorage < 50 and iMassReclaimed > iSpareStorage then bWillOverflowMass = true end
                            end
                            if bWillOverflowMass == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': wont overflow mass so proceed with reclaim') end
                                oPlatoon[refiCurrentAction] = refActionReclaimTarget
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Will overflow mass so wont issue action to reclaim') end
                                oPlatoon[refoNearbyReclaimTarget] = nil
                            end
                        end --]]
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find a first reclaimer whose state wasnt busy') end
                    --oPlatoon[refiReclaimers] = 0
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': iSpareStorage='..iSpareStorage) end
            end
            --[[if bDebugMessages == true and oPlatoon[refoNearbyReclaimTarget] then
                if oPlatoon[refiCurrentAction] == nil then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Have a reclaim target but no action')
                else
                    LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Have a reclaim target; action='..oPlatoon[refiCurrentAction]..': mass on reclaim='..oPlatoon[refoNearbyReclaimTarget].MaxMassReclaim)
                    if oPlatoon[refoNearbyReclaimTarget]:BeenDestroyed() then M27Utilities.ErrorHandler('Reclaim has been destroyed') end
                end
            end--]]
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function DecideWhetherToGetACUUpgrade(aiBrain, oPlatoon)
    local sFunctionRef = 'DecideWhetherToGetACUUpgrade'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end

    --if oPlatoon[refbACUInPlatoon] == true and GetGameTimeSeconds() >= 490 then bDebugMessages = true end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    local oACU = M27Utilities.GetACU(aiBrain)
    if not(oACU[M27UnitInfo.refbFullyUpgraded]) and (not(M27MapInfo.bNoRushActive) or M27MapInfo.iNoRushTimer - GetGameTimeSeconds() <= 120) then
        if bDebugMessages == true then LOG(sFunctionRef..': ACU not fully upgraded; does ACU have enhancement blastattack='..tostring(M27Utilities.GetACU(aiBrain):HasEnhancement('BlastAttack'))) end
        if not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle) and not(oACU:HasEnhancement('AdvancedEngineering')) and not(oACU:HasEnhancement('T3Engineering')) and M27Conditions.DoesACUHaveGun(aiBrain, true) == false and not(oACU[M27Overseer.refbACUCantPathAwayFromBase]) then
            if bDebugMessages == true then LOG(sFunctionRef..': ACU doesnt have gun, checking if we want to get the upgrade now') end
            if M27Conditions.WantToGetFirstACUUpgrade(aiBrain) == true then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to get the gun upgrade now') end
                oPlatoon[refiCurrentAction] = refActionUpgrade
            end
        else
            if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle and not(oACU:HasEnhancement('AdvancedEngineering')) and not(oACU:HasEnhancement('T3Engineering')) then
                if M27Conditions.WantToGetFirstACUUpgrade(aiBrain) == true then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to get T2 upgrade as are turtling') end
                    oPlatoon[refiCurrentAction] = refActionUpgrade
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Have gun upgrade or cant path to enemy base, checking if we want to get the next upgrade') end
                local bWantUpgrade, bSafeToUpgrade = M27Conditions.WantToGetAnotherACUUpgrade(aiBrain)
                if bWantUpgrade and bSafeToUpgrade then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to get the next upgrade') end
                    oPlatoon[refiCurrentAction] = refActionUpgrade
                elseif bWantUpgrade and not(bSafeToUpgrade) then
                    --Only reason we're not upgrading is because its not safe - return towards nearest rally point and say we're running away unless are in combat
                    oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                    if M27Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryDangerousToLand, GetPlatoonFrontPosition(oPlatoon), 22, 'Enemy')) then
                        oPlatoon[refbHavePreviouslyRun] = true
                    end
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': ACU is fully upgraded or have norush timer active so wont try and get an upgrade') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of function, ACU action='..(oPlatoon[refiCurrentAction] or 'nil')) end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ConsiderConstructionForACU(aiBrain, oPlatoon, oACU) --Intended to be run when ACU has T2+ upgrade
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderConstructionForACU'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)


    --if oPlatoon[refbACUInPlatoon] == true and aiBrain:GetArmyIndex() == 2 and GetGameTimeSeconds() >= 360 then bDebugMessages = true end


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end


    if oACU:HasEnhancement('AdvancedEngineering') or oACU:HasEnhancement('T3Engineering') then
        --if GetGameTimeSeconds() >= 600 and aiBrain:GetArmyIndex() == 2 then bDebugMessages = true end
        if bDebugMessages == true then LOG(sFunctionRef..': ACU has access to T2 tech, if strategy is turtle will consider what to build. aiBrain[M27Overseer.refiAIBrainCurrentStrategy]='..aiBrain[M27Overseer.refiAIBrainCurrentStrategy]..'; M27Logic.IsTargetUnderShield(aiBrain, oACU, 8000, nil, false, false)='..tostring(M27Logic.IsTargetUnderShield(aiBrain, oACU, 8000, nil, false, false))) end
        --First check if we want emergency AA to be built
        if oPlatoon[refiEnemiesInRange] == 0 then
            local tNearbyEnemyThreat = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryBomber + M27UnitInfo.refCategoryGunship + M27UnitInfo.refCategoryTransport, oACU:GetPosition(), 50, 'Enemy')
            if M27Utilities.IsTableEmpty(tNearbyEnemyThreat) == false then
                --Do we have nearby AA building?
                local tNearbyAABuilding = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructureAA, oACU:GetPosition(), 35, 'Ally')
                local oBuildingToAssist
                local bHaveNearbyAA = false
                if bDebugMessages == true then LOG(sFunctionRef..': Have nearby enemy air threat, is table of nearby aa buildings empty='..tostring(M27Utilities.IsTableEmpty(tNearbyAABuilding))) end
                if M27Utilities.IsTableEmpty(tNearbyAABuilding) == false then
                    bHaveNearbyAA = true
                    for iUnit, oUnit in tNearbyAABuilding do
                        if oUnit:GetFractionComplete() < 1 then oBuildingToAssist = oUnit break end
                    end
                end
                if oBuildingToAssist then
                    oPlatoon[refiCurrentAction] = refActionAssistConstruction
                    oPlatoon[refoConstructionToAssist] = oBuildingToAssist
                    if bDebugMessages == true then LOG(sFunctionRef..': Have AA building to assist that is under construction='..oBuildingToAssist.UnitId..M27UnitInfo.GetUnitLifetimeCount(oBuildingToAssist)) end
                elseif not(bHaveNearbyAA) then
                    oPlatoon[refiCurrentAction] = refActionBuildStructure
                    if M27Logic.GetAirThreatLevel(aiBrain, tNearbyEnemyThreat, true, false, false, true, true, nil, nil, nil, nil, true) >= 400 then
                        oPlatoon[refiStructureCategoryToBuild] = M27UnitInfo.refCategoryStructureAA
                    else
                        oPlatoon[refiStructureCategoryToBuild] = M27UnitInfo.refCategoryStructureAA * categories.TECH1
                    end
                    oPlatoon[reftStructureLocationToBuild] = M27Utilities.MoveInDirection(oACU:GetPosition(), M27Utilities.GetAngleFromAToB(oACU:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]), math.min(oACU:GetBlueprint().Economy.MaxBuildDistance - 3, 5), true)
                end
            end
        end

        if aiBrain[M27Overseer.refiDefaultStrategy] == M27Overseer.refStrategyTurtle and not(oPlatoon[refiCurrentAction]) then
            local tFirebasePosition = aiBrain[M27MapInfo.reftChokepointBuildLocation]
            local iDistToFirebase = M27Utilities.GetDistanceBetweenPositions(tFirebasePosition, oACU:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': Default strat is to turtle. iDistToFirebase='..iDistToFirebase) end
            if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle or M27Logic.IsTargetUnderShield(aiBrain, oACU, 8000, nil, false, false) or iDistToFirebase <= 5 then

                if iDistToFirebase <= 30 or (iDistToFirebase <= 60 and oPlatoon[refiEnemiesInRange] >= 6 and M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) < M27Utilities.GetDistanceBetweenPositions(tFirebasePosition, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) then
                    local tNearbyPD = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryPD, oACU:GetPosition(), math.max(25, 50 - iDistToFirebase), 'Ally')
                    local iNearbyT2PlusPD = 0
                    local iNearbyT1PD = 0
                    local iNearbyFirebaseRef
                    local oUnderConstructionPD
                    local iT2PDNearToEnemy = 0
                    local iDistToEnemy = M27Utilities.GetDistanceBetweenPositions(aiBrain[M27MapInfo.reftChokepointBuildLocation], M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain))

                    if M27Utilities.IsTableEmpty(tNearbyPD) == false then
                        for iPD, oPD in tNearbyPD do
                            if not(iNearbyFirebaseRef) then iNearbyFirebaseRef = oPD[M27EngineerOverseer.refiAssignedFirebase] end
                            if oPD:GetFractionComplete() == 1 then
                                if EntityCategoryContains(categories.TECH1, oPD.UnitId) then
                                    iNearbyT1PD = iNearbyT1PD + 1
                                else
                                    iNearbyT2PlusPD = iNearbyT2PlusPD + 1
                                    if M27Utilities.GetDistanceBetweenPositions(oPD:GetPosition(), M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)) < iDistToEnemy then iT2PDNearToEnemy = iT2PDNearToEnemy + 1 end
                                end

                            else
                                if iDistToFirebase <= 30 or EntityCategoryContains(categories.TECH2 + categories.TECH3, oPD.UnitId) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': iDistToFirebase='..iDistToFirebase..'; oPD='..oPD.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPD)..'; will set this as under construction PD') end
                                    oUnderConstructionPD = oPD
                                end
                            end
                        end
                    end

                    local iNearestEnemy = 10000
                    local oNearestEnemy
                    local tNearbyEnemyCombat
                    --Use either existing units identified, or all units if no units nearby (as search range likely less than 150)
                    if oPlatoon[refiEnemiesInRange] > 0 then tNearbyEnemyCombat = EntityCategoryFilterDown(M27UnitInfo.refCategoryLandCombat, oPlatoon[reftEnemiesInRange])
                    else tNearbyEnemyCombat = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandCombat, GetPlatoonFrontPosition(oPlatoon), 150, 'Enemy')
                    end
                    if M27Utilities.IsTableEmpty(tNearbyEnemyCombat) == false then
                        oNearestEnemy = M27Utilities.GetNearestUnit(tNearbyEnemyCombat, GetPlatoonFrontPosition(oPlatoon), aiBrain)
                        iNearestEnemy = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearestEnemy:GetPosition())
                    end
                    local bReclaimInstead = false

                    if iNearestEnemy <= 9.5 and not(oNearestEnemy:IsUnitState('Attached')) and not(EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oNearestEnemy.UnitId)) and (iNearestEnemy <= 8 or not(oNearestEnemy:IsUnitState('Moving'))) then
                        bReclaimInstead = true
                        local oBeingBuilt
                        if oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') then
                            oBeingBuilt = oACU:GetFocusUnit()
                            if oBeingBuilt:GetFractionComplete() < 1 and oBeingBuilt:GetFractionComplete() >= 0.7 then
                                bReclaimInstead = false
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': bReclaimInstead='..tostring(bReclaimInstead)..'; iNearestEnemy='..iNearestEnemy..'; ACU unit state='..M27Logic.GetUnitState(oACU)) end
                    if bReclaimInstead then
                        oPlatoon[refiCurrentAction] = refActionReclaimTarget
                        oPlatoon[refoNearbyReclaimTarget] = oNearestEnemy
                    else

                        if (oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing')) and M27UnitInfo.IsUnitValid(oACU:GetFocusUnit()) and oACU:GetFocusUnit():GetFractionComplete() >= 0.25 and EntityCategoryContains(categories.SHIELD, oACU:GetFocusUnit()) then
                            local oShieldBeingBuilt = oACU:GetFocusUnit()
                            oPlatoon[refiCurrentAction] = refActionAssistConstruction
                            oPlatoon[refoConstructionToAssist] = oShieldBeingBuilt
                        else

                            if bDebugMessages == true then LOG(sFunctionRef..': Are near the firebase. iNearbyT2PlusPD='..iNearbyT2PlusPD..'; iNearestEnemy='..iNearestEnemy..'; iDistToFirebase='..iDistToFirebase..'; iNearbyFirebaseRef='..(iNearbyFirebaseRef or 'nil')) end
                            if oUnderConstructionPD or (iNearbyT2PlusPD <= math.min(8, math.max(4, aiBrain[M27Overseer.refiTotalEnemyShortRangeThreat] / 400)) and (iNearbyT2PlusPD < 4 or iNearestEnemy <= 150) and (iNearbyT2PlusPD < 2 or (iNearestEnemy <= 45 and iDistToFirebase <= 30) or (iNearbyT2PlusPD <= 6 and iNearestEnemy <=55) or (iNearbyT2PlusPD < 5 and iT2PDNearToEnemy <= 0 and iNearestEnemy <= 80 and aiBrain[M27Overseer.refiTotalEnemyShortRangeThreat] >= 3500) or (iT2PDNearToEnemy <= 1 and M27Conditions.HaveLowMass(aiBrain) == false and iNearestEnemy <= 80 and aiBrain[M27Overseer.refiTotalEnemyShortRangeThreat] >= 3500) or not(iNearbyFirebaseRef))) then
                                --Do we have a PD under construction? (although have 'should assist construction' action before, that only triggers if have sufficient resources)
                                if oUnderConstructionPD then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have under construction PD so will assist this, PD='..oUnderConstructionPD.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnderConstructionPD)..' at position '..repru(oUnderConstructionPD:GetPosition())) end
                                    oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                    oPlatoon[refoConstructionToAssist] = oUnderConstructionPD
                                else
                                    --Do we have nearby enemies? If so then just build here
                                    oPlatoon[refiCurrentAction] = refActionBuildStructure

                                    local bBuildBehindACU = false
                                    if iNearbyT2PlusPD <= 1 and iNearestEnemy <= (95 - iNearbyT2PlusPD) then
                                        --Dont build behind if only up against weak units (land scouts etc.)
                                        if oPlatoon[refiEnemiesInRange] > 4 or M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.INDIRECTFIRE + categories.DIRECTFIRE * categories.TECH2 + categories.DIRECTFIRE * categories.TECH3, oPlatoon[reftEnemiesInRange])) == false or M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftEnemiesInRange], true, nil, nil, nil, nil) >= 120 then
                                            bBuildBehindACU = true
                                        end
                                    end

                                    if iNearbyT1PD <= 1 and iNearestEnemy <= 25 then
                                        oPlatoon[refiStructureCategoryToBuild] = M27UnitInfo.refCategoryPD * categories.TECH1
                                        if bDebugMessages == true then LOG(sFunctionRef..': Near enemy want t1 pd') end
                                        bBuildBehindACU = false
                                    else
                                        --Do we want PD or T2 arti more urgently?
                                        if bBuildBehindACU or iDistToFirebase > 30 or iNearbyT2PlusPD <= 3 or aiBrain[M27Overseer.refiTotalEnemyLongRangeThreat] > 0 then
                                            oPlatoon[refiStructureCategoryToBuild] = M27UnitInfo.refCategoryPD * categories.TECH2
                                            if bDebugMessages == true then LOG(sFunctionRef..': Nearby enemy, Want T2 PD') end
                                        else
                                            --Are there indirect fire or surface naval units nearby? If so want 1 T2 arti to every 2 T2 PD
                                            local tNearbyEnemyLongRange = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLongRangeMobile + M27UnitInfo.refCategoryFrigate, oACU:GetPosition(), 135, 'Enemy')
                                            if M27Utilities.IsTableEmpty(tNearbyEnemyLongRange) then
                                                oPlatoon[refiStructureCategoryToBuild] = M27UnitInfo.refCategoryPD * categories.TECH2
                                                if bDebugMessages == true then LOG(sFunctionRef..': Enemy doesnt have long range so want T2 PD') end
                                            else
                                                local iNearbyT2Arti = 0
                                                local oUnderConstructionArti
                                                local tNearbyT2Arti = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryFixedT2Arti, oACU:GetPosition(), 50, 'Ally')
                                                if M27Utilities.IsTableEmpty(tNearbyT2Arti) == false then
                                                    for iUnit, oUnit in tNearbyT2Arti do
                                                        if oUnit:GetFractionComplete() < 1 then
                                                            oUnderConstructionArti = oUnit
                                                        else
                                                            iNearbyT2Arti = iNearbyT2Arti + 1
                                                        end
                                                    end
                                                end
                                                if iNearbyT2Arti == 0 or iNearbyT2Arti < iNearbyT2PlusPD * 0.6 then
                                                    if oUnderConstructionArti then
                                                        oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                                        oPlatoon[refoConstructionToAssist] = oUnderConstructionPD
                                                    else
                                                        oPlatoon[refiStructureCategoryToBuild] = M27UnitInfo.refCategoryFixedT2Arti
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Dont have arti being built so want to build our own. iNearbyT2Arti='..iNearbyT2Arti..'; iNearbyT2PlusPD='..iNearbyT2PlusPD..'; Long range enemy table empty?='..tostring(M27Utilities.IsTableEmpty(tNearbyEnemyLongRange))) end
                                                    end
                                                end

                                            end
                                        end
                                    end

                                    if oPlatoon[refiCurrentAction] == refActionBuildStructure then
                                        if bBuildBehindACU then
                                            oPlatoon[reftStructureLocationToBuild] = M27Utilities.MoveInDirection(oACU:GetPosition(), M27Utilities.GetAngleFromAToB(oACU:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]), math.min(oACU:GetBlueprint().Economy.MaxBuildDistance - 0.5, 5), true)
                                        else
                                            --Are we near to the chokepoint/ if so pick this as the place to build
                                            if iDistToFirebase <= 30 then
                                                oPlatoon[reftStructureLocationToBuild] = {aiBrain[M27MapInfo.reftChokepointBuildLocation][1], aiBrain[M27MapInfo.reftChokepointBuildLocation][2], aiBrain[M27MapInfo.reftChokepointBuildLocation][3]}
                                            else
                                                --Build towards the chokepoint
                                                oPlatoon[reftStructureLocationToBuild] = M27Utilities.MoveInDirection(oACU:GetPosition(), M27Utilities.GetAngleFromAToB(oACU:GetPosition(), aiBrain[M27MapInfo.reftChokepointBuildLocation]), oACU:GetBlueprint().Economy.MaxBuildDistance - 0.5, true)
                                            end


                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will build T2 PD or arti. bBuildBehindACU='..tostring(bBuildBehindACU)..'; Location to build='..repru(oPlatoon[reftStructureLocationToBuild])) end
                                    end
                                end
                            elseif iDistToFirebase <= 30 then
                                --Do we have reclaim nearby and are mass stalling?
                                if aiBrain:GetEconomyStored('MASS') == 0 then DetermineActionForNearbyReclaim(oPlatoon) end
                                if bDebugMessages == true then LOG(sFunctionRef..': If are mass stalling will check for nearby reclaim. aiBrain:GetEconomyStored(MASS)='..aiBrain:GetEconomyStored('MASS')..'; Platoona ction after checking for nearby reclaim='..(oPlatoon[refiCurrentAction] or 'nil')) end
                                if not(oPlatoon[refiCurrentAction]) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Already have 3 T2 PD at firebase. Checking if enough resources to help with fortification. M27Conditions.HaveLowMass(aiBrain)='..tostring(M27Conditions.HaveLowMass(aiBrain))..'; Energy income='..aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome]..'; Energy stored='..aiBrain:GetEconomyStoredRatio('ENERGY')..'; Time of last energy stall='..GetGameTimeSeconds() - (aiBrain[M27EconomyOverseer.refiLastEnergyStall] or -100)) end

                                    --Do we have building or repairing unit state with a previous action to build?
                                    if (oACU:IsUnitState('Building') or (oACU:IsUnitState('Repairing') and oACU:GetFocusUnit():GetFractionComplete() < 1)) and (oPlatoon[reftPrevAction][1] == refActionBuildStructure or oPlatoon[reftPrevAction][1] == refActionAssistConstruction) then
                                        oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                        oPlatoon[refoConstructionToAssist] = oACU:GetFocusUnit()
                                        if bDebugMessages == true then LOG(sFunctionRef..'ACU is building or repairing and prev action was to assist or construct, so will assist construction on ACU current focus target, oPlatoon[refoConstructionToAssist]='..oPlatoon[refoConstructionToAssist].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoConstructionToAssist])) end
                                    else
                                        --is there a firebase type unit under construction nearby?  Only consider shields, PD and T2 Arti
                                        local iCategoriesToConsider
                                        --Adjust nearest enemy based on lower of dist to ACU and dist to firebase
                                        if oNearestEnemy then iNearestEnemy = math.min(iNearestEnemy, M27Utilities.GetDistanceBetweenPositions(oNearestEnemy:GetPosition(), aiBrain[M27MapInfo.reftChokepointBuildLocation])) end
                                        if iNearestEnemy <= 100 then iCategoriesToConsider = M27UnitInfo.refCategoryPD + M27UnitInfo.refCategoryFixedShield + M27UnitInfo.refCategoryFixedT2Arti
                                        else iCategoriesToConsider = M27UnitInfo.refCategoryFirebaseSuitable
                                        end


                                        local tNearbyBuildings = aiBrain:GetUnitsAroundPoint(iCategoriesToConsider, aiBrain[M27MapInfo.reftChokepointBuildLocation], 50, 'Ally')
                                        local oNearestBuildingUnderConstruction


                                        if M27Utilities.IsTableEmpty(tNearbyBuildings) == false then
                                            local iNearestDistance = 10000
                                            local iCurDistance
                                            local sPathing = M27UnitInfo.GetUnitPathingType(oACU)
                                            local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(sPathing, aiBrain[M27MapInfo.reftChokepointBuildLocation])
                                            for iUnit, oUnit in tNearbyBuildings do
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit is under construction, oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()) end
                                                if oUnit:GetFractionComplete() < 1 then
                                                    iCurDistance = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), aiBrain[M27MapInfo.reftChokepointBuildLocation])
                                                    if iCurDistance < iNearestDistance and  M27MapInfo.GetSegmentGroupOfLocation(sPathing, oUnit:GetPosition()) == iPathingGroupWanted then
                                                        iNearestDistance = iCurDistance
                                                        oNearestBuildingUnderConstruction = oUnit
                                                    end
                                                end
                                            end
                                        end
                                        if oNearestBuildingUnderConstruction then
                                            oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                            oPlatoon[refoConstructionToAssist] = oNearestBuildingUnderConstruction
                                            if bDebugMessages == true then LOG(sFunctionRef..': Part complete buildilng nearby which will assist. oNearestBuildingUnderConstruction='..oNearestBuildingUnderConstruction.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestBuildingUnderConstruction)) end
                                        else

                                            --Does the firebase want fortification and we have enough resources to help it?
                                            if bDebugMessages == true then LOG(sFunctionRef..': Are there enemies near the firebase or do we have enough resources to help? iNearestEnemy='..iNearestEnemy..'; aiBrain:GetEconomyStoredRatio(ENERGY)='..aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.9..'; HaveLowMass='..tostring(M27Conditions.HaveLowMass(aiBrain))) end
                                            if (iNearestEnemy <= 120 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.9) or (not(M27Conditions.HaveLowMass(aiBrain)) and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.99 and aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome] > 0 and not((GetGameTimeSeconds() - (aiBrain[M27EconomyOverseer.refiLastEnergyStall] or -100)) <= 1)) then
                                                --UEF specific - build ravager if enemy likely within range of it (or will be soon) and dont already have at least 5
                                                if EntityCategoryContains(categories.UEF * categories.COMMAND, oPlatoon[refoFrontUnit]) and oPlatoon[refoFrontUnit]:HasEnhancement('T3Engineering') then
                                                    local tNearbyRavagers = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryPD * categories.TECH3, GetPlatoonFrontPosition(oPlatoon), 40, 'Ally')
                                                    if M27Utilities.IsTableEmpty(tNearbyRavagers) or (iNearestEnemy <= 90 and table.getn(tNearbyRavagers) < math.min(10, math.max(2, math.ceil(aiBrain[M27EconomyOverseer.refiGrossMassBaseIncome]) / 20))) then
                                                        oPlatoon[refiCurrentAction] = refActionBuildStructure
                                                        oPlatoon[refiStructureCategoryToBuild] = M27UnitInfo.refCategoryPD * categories.TECH3
                                                        oPlatoon[reftStructureLocationToBuild] = aiBrain[M27MapInfo.reftChokepointBuildLocation]
                                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU has T3 upgrade, and are nearby enemies, so will build ravager') end
                                                    end
                                                end
                                                if not(oPlatoon[refiCurrentAction]) then

                                                    --Have enough resources to help with construction
                                                    M27EngineerOverseer.RefreshListOfFirebases(aiBrain, true)
                                                    --Do we want to fortify the chokepoint firebase?
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Have just refreshed firebases.  Is list of firebases wanting fortification empty='..tostring((M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFirebasesWantingFortification]) or false))..'; Does the chokepoint firebase want fortification='..tostring(aiBrain[M27EngineerOverseer.reftFirebasesWantingFortification][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]] or false)..'; firebase chokepoint ref='..(aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef] or 'nil')) end
                                                    if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFirebasesWantingFortification]) == false and aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef] and aiBrain[M27EngineerOverseer.reftFirebasesWantingFortification][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]] then
                                                        --First double-check we arent building this nearby (as above checks might only be checking some categories if we had nearby enemies)
                                                        local tUnitsWanted = aiBrain:GetUnitsAroundPoint(aiBrain[M27EngineerOverseer.refiFirebaseCategoryWanted][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]], tFirebasePosition, 50, 'Ally')
                                                        if M27Utilities.IsTableEmpty(tUnitsWanted) == false then
                                                            for iUnit, oUnit in tUnitsWanted do
                                                                if oUnit:GetFractionComplete() < 1 then oNearestBuildingUnderConstruction = oUnit break end
                                                            end
                                                        end
                                                        if oNearestBuildingUnderConstruction then
                                                            oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                                            oPlatoon[refoConstructionToAssist] = oNearestBuildingUnderConstruction
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Part complete buildilng when checking for firebase fortification category, will assist. oNearestBuildingUnderConstruction='..oNearestBuildingUnderConstruction.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestBuildingUnderConstruction)) end
                                                        else

                                                            local iACUTechLevel = 2
                                                            if oACU:HasEnhancement('T3Engineering') then iACUTechLevel = 3 end
                                                            local bACUCanHelpFortify = true
                                                            if iACUTechLevel <= 2 then
                                                                local iCategoryWanted = aiBrain[M27EngineerOverseer.refiFirebaseCategoryWanted][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]]
                                                                if not(iCategoryWanted and M27Utilities.DoesCategoryContainCategory(M27UnitInfo.ConvertTechLevelToCategory(iACUTechLevel) + categories.TECH1, iCategoryWanted, false)) then bACUCanHelpFortify = false end
                                                            end
                                                            if bDebugMessages == true then LOG(sFunctionRef..': iACUTechLevel='..iACUTechLevel..'; bACUCanHelpFortify='..tostring(bACUCanHelpFortify)) end
                                                            if bACUCanHelpFortify then
                                                                oPlatoon[refiCurrentAction] = refActionBuildStructure
                                                                oPlatoon[refiStructureCategoryToBuild] = aiBrain[M27EngineerOverseer.refiFirebaseCategoryWanted][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]]
                                                                --Are we trying to build a non-PD building and have nearby enemies? If so adjust the build location unless the build location is under shield
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to build whatever is assigned to the firebase to be built. Is the firebase position under a shield='..tostring(M27Logic.IsLocationUnderFriendlyFixedShield(aiBrain, tFirebasePosition))) end
                                                                if not(M27Logic.IsLocationUnderFriendlyFixedShield(aiBrain, tFirebasePosition)) then
                                                                    --Do we have a nearby shield? If so then make build location this
                                                                    local tNearbyShields = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryFixedShield, tFirebasePosition, 30, 'Ally')
                                                                    local oNearestShield
                                                                    if M27Utilities.IsTableEmpty(tNearbyShields) == false then
                                                                        oNearestShield = M27Utilities.GetNearestUnit(tNearbyShields, tFirebasePosition, aiBrain)
                                                                    end
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid nearby shield?='..tostring(M27UnitInfo.IsUnitValid(oNearestShield))) end
                                                                    if oNearestShield then
                                                                        oPlatoon[reftStructureLocationToBuild] = oNearestShield:GetPosition()
                                                                    else
                                                                        --No nearby shield - if only 1 T2 PD nearer the enemy base than the build location, then build to cover the second closest PD
                                                                        if bDebugMessages == true then LOG(sFunctionRef..': iT2PDNearToEnemy='..iT2PDNearToEnemy..'; Are we trying to buidl a shield='..tostring(M27Utilities.DoesCategoryContainCategory(categories.SHIELD, oPlatoon[refiStructureCategoryToBuild], true))) end
                                                                        if iT2PDNearToEnemy <= 1 and M27Utilities.DoesCategoryContainCategory(categories.SHIELD, oPlatoon[refiStructureCategoryToBuild], true) then
                                                                            local tNearestEnemy
                                                                            if oNearestEnemy then tNearestEnemy = oNearestEnemy:GetPosition()
                                                                            else
                                                                                tNearestEnemy = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                                                                            end
                                                                            local oPDNearestEnemy
                                                                            local oSecondPDNearestEnemy
                                                                            local iCurDist
                                                                            local iClosestDist = 10000
                                                                            local iSecondClosestDist = 10000
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': tFirebasePosition='..repru(tFirebasePosition)..'; tNearestEnemy='..repru(tNearestEnemy)) end
                                                                            for iUnit, oUnit in EntityCategoryFilterDown(categories.TECH2 + categories.TECH3, tNearbyPD) do
                                                                                iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tNearestEnemy)
                                                                                if iCurDist < iClosestDist then
                                                                                    if oPDNearestEnemy then iSecondClosestDist = iClosestDist oSecondPDNearestEnemy = oPDNearestEnemy end
                                                                                    iClosestDist = iCurDist
                                                                                    oPDNearestEnemy = oUnit
                                                                                elseif iCurDist < iSecondClosestDist then
                                                                                    iSecondClosestDist = iCurDist
                                                                                    oSecondPDNearestEnemy = oUnit
                                                                                end
                                                                            end
                                                                            if not(oSecondPDNearestEnemy) then oSecondPDNearestEnemy = oPDNearestEnemy end
                                                                            if oSecondPDNearestEnemy then
                                                                                if bDebugMessages == true then LOG(sFunctionRef..': oSecondPDNearestEnemy='..oSecondPDNearestEnemy.UnitId..M27UnitInfo.GetUnitLifetimeCount(oSecondPDNearestEnemy)..'; position='..repru(oSecondPDNearestEnemy:GetPosition())) end
                                                                                oPlatoon[reftStructureLocationToBuild] = M27Utilities.MoveInDirection(oSecondPDNearestEnemy:GetPosition(), M27Utilities.GetAngleFromAToB(tFirebasePosition, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]), 6, true)
                                                                            else
                                                                                oPlatoon[reftStructureLocationToBuild] = M27Utilities.MoveInDirection(tFirebasePosition, M27Utilities.GetAngleFromAToB(tFirebasePosition, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]), 10, true)
                                                                            end
                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Location to try and build at='..repru(oPlatoon[reftStructureLocationToBuild])) end
                                                                        else
                                                                            oPlatoon[reftStructureLocationToBuild] = {tFirebasePosition[1], tFirebasePosition[2], tFirebasePosition[3]}
                                                                        end
                                                                    end
                                                                else
                                                                    oPlatoon[reftStructureLocationToBuild] = {tFirebasePosition[1], tFirebasePosition[2], tFirebasePosition[3]}

                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will get ACU to help build') end
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    --Consider overcharge as well
    if oPlatoon[refiCurrentAction] and oPlatoon[reftBuilders][1] and M27Conditions.CanUnitUseOvercharge(aiBrain, oPlatoon[reftBuilders][1]) == true then
        M27UnitMicro.GetOverchargeExtraAction(aiBrain, oPlatoon, oPlatoon[reftBuilders][1])
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, action='..(oPlatoon[refiCurrentAction] or 'nil')) end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetACUUpgradeWanted(aiBrain, oACU)
    --Returns nil if cantr find anything
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetACUUpgradeWanted'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --Assumes have already decided want to get an upgrade
    local sUpgradeID
    if not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle) and M27Conditions.DoesACUHaveGun(aiBrain, true) == false and not(oACU[M27Overseer.refbACUCantPathAwayFromBase]) then
        if bDebugMessages == true then LOG(sFunctionRef..': ACU doesnt have gun upgrade yet so will get this') end
        local bAeonWithoutRange = false
        if M27UnitInfo.GetUnitFaction(oACU) == M27UnitInfo.refFactionAeon and not(oACU:HasEnhancement('CrysalisBeam')) then bAeonWithoutRange = true end
        --Get gun upgrade
        local bUpgradeGivesRangeBoost
        local sAltUpgrade
        for sEnhancement, tEnhancement in oACU:GetBlueprint().Enhancements do
            if bDebugMessages == true then LOG(sFunctionRef..': sEnhancement='..sEnhancement..'; Prerequisite='..(tEnhancement.Prerequisite or 'nil')..'; Considering if its one of our priority gun upgrades. tEnhancement='..repru(tEnhancement)) end
            --[[if bAeonWithoutRange then
                if sEnhancement == 'CrysalisBeam' then
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                    return sEnhancement
                end
            else--]]
            if (not(tEnhancement.Prerequisite) or oACU:HasEnhancement(tEnhancement.Prerequisite)) and tEnhancement.BuildCostMass > 1 then
                if bDebugMessages == true then LOG(sFunctionRef..': We can build the enhancement so will see if it is in the list of gun upgrades') end
                --We can build the upgrade and it shouldnt be a 'remove upgrade' one
                for iGunEnhancement, sGunEnhancement in M27Conditions.tGunUpgrades do
                    if sEnhancement == sGunEnhancement and not (oACU:HasEnhancement(sGunEnhancement)) then
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Have a valid gun upgrade; will see if it increases range; if not will keep looking to see if there are any that increase range. sEnhancement=' .. sEnhancement .. '; NewMaxRadius=' .. (tEnhancement.NewMaxRadius or 'nil'))
                        end
                        if tEnhancement.NewMaxRadius then
                            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                            return sEnhancement
                        else
                            sAltUpgrade = sEnhancement
                        end
                    end
                end
            end
            --end
        end
        if not(sAltUpgrade) then
            --Find the cheapest upgrade that boosts either rate of fire or range
            local iLowestMassCost = 1000000
            for sUpgrade, tUpgrade in oACU:GetBlueprint().Enhancements do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering sUpgrade='..sUpgrade..'; tUpgrade='..reprs(tUpgrade)) end
                if tUpgrade.NewMaxRadius or tUpgrade.NewRateOfFire then
                    if tUpgrade.BuildCostMass < iLowestMassCost and not(tUpgrade.Prerequisite) then
                        sAltUpgrade = sUpgrade
                        iLowestMassCost = tUpgrade.BuildCostMass
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a new preferred upgrade '..sUpgrade..'; iLowestMassCost='..iLowestMassCost) end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the cheapest gun improving upgrade, sAltUpgrade='..(sAltUpgrade or 'nil')) end
        end
        if sAltUpgrade then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': sAltUpgrade=' .. sAltUpgrade)
            end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return sAltUpgrade
        else
            M27Utilities.ErrorHandler('Failed to find a gun upgrade for ACU')
        end
    else
        --Turtle or cant move from base
        local iFactionRef = M27UnitInfo.GetUnitFaction(oACU)
        local tUpgradesWanted = {}

        if oACU[M27Overseer.refbACUCantPathAwayFromBase] or aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle then
            --Dont want to get gun, instead want to focus just on defensive upgrades
            if iFactionRef == M27UnitInfo.refFactionUEF then
                --Want t2, then T3, then personal shield/stealth/nano
                tUpgradesWanted = { 'AdvancedEngineering', 'T3Engineering', 'Shield' }
            elseif iFactionRef == M27UnitInfo.refFactionCybran then
                tUpgradesWanted = { 'AdvancedEngineering', 'T3Engineering', 'StealthGenerator' }
            elseif iFactionRef == M27UnitInfo.refFactionAeon then
                tUpgradesWanted = { 'AdvancedEngineering', 'EnhancedSensors', 'T3Engineering', 'Shield' }
            elseif iFactionRef == M27UnitInfo.refFactionSeraphim then
                tUpgradesWanted = { 'AdvancedEngineering', 'T3Engineering', 'DamageStabilization' }
            else
                M27Utilities.ErrorHandler('Dont recognise the ACU faction so wont be getting any further upgrades', true)
            end

        else
            --Already have a gun upgrade; decide what we want next


            --NOTE: If any upgrades conflict, need to add in code to remove the conflicting upgrade first, and also to not get the earlier ugprade after we have removed it
            if iFactionRef == M27UnitInfo.refFactionUEF then
                --Want t2 and then personal shield
                tUpgradesWanted = { 'AdvancedEngineering', 'Shield' }
            elseif iFactionRef == M27UnitInfo.refFactionCybran then
                if aiBrain[M27AirOverseer.refbEnemyHasOmniVision] then
                    tUpgradesWanted = {'ResourceAllocation'}
                else
                    --Are any of the enemy Aeon? If so then want to also get RAS due to risk they build a GC
                    local bEnemyIsAeon = false
                    for iBrain, oBrain in aiBrain[M27Overseer.toEnemyBrains] do
                        if oBrain:GetFactionIndex() == M27UnitInfo.refFactionAeon then
                            bEnemyIsAeon = true
                            break
                        end
                    end
                    if bEnemyIsAeon then
                        tUpgradesWanted = {'ResourceAllocation'}
                    else
                        tUpgradesWanted = { 'StealthGenerator', 'FAF_SelfRepairSystem', 'CloakingGenerator', 'MicrowaveLaserGenerator' }
                    end
                end
            elseif iFactionRef == M27UnitInfo.refFactionAeon then
                tUpgradesWanted = { 'Shield', 'FAF_CrysalisBeamAdvanced' }
            elseif iFactionRef == M27UnitInfo.refFactionSeraphim then
                --Want damagestabilization before blast attack, as blast attack removes advanced engineering; dont want advanced engineering if we already have blast attack
                --[[if oACU:HasEnhancement('BlastAttack') then
                    tUpgradesWanted = nil
                else--]]
                tUpgradesWanted = { 'AdvancedEngineering', 'DamageStabilization', 'DamageStabilizationAdvanced', 'BlastAttack' }
                --end
            else
                M27Utilities.ErrorHandler('Dont recognise the ACU faction so wont be getting any further upgrades', true)
            end
        end

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': ACU has gun; tUpgradesWanted=' .. repru(tUpgradesWanted) .. '; iFactionRef=' .. iFactionRef)
        end
        local bHaveLaterUpgrade
        if tUpgradesWanted then
            for iUpgrade, sPossibleUpgrade in tUpgradesWanted do
                --Do we already have the upgrade?
                if not (oACU:HasEnhancement(sPossibleUpgrade)) then
                    bHaveLaterUpgrade = false
                    --Does ACU have another enhancement which lists this as a prerequisite?
                    local oACUBP = oACU:GetBlueprint()
                    for iBPUpgrade, tBPUpgrade in oACUBP.Enhancements do
                        if tBPUpgrade.Prerequisite then
                            if tBPUpgrade.Prerequisite == sPossibleUpgrade then
                                sUpgradeWithThisAsPreRequisite = iBPUpgrade
                                if oACU:HasEnhancement(iBPUpgrade) then
                                    bHaveLaterUpgrade = true
                                    break
                                end
                            elseif oACU:HasEnhancement(iBPUpgrade) then
                                if bDebugMessages == true then LOG(sFunctionRef..': ACU has enhancement with prerequisite, iBPUpgrade='..iBPUpgrade..'; Prerequisite='..tBPUpgrade.Prerequisite..'; oACUBP.Enhancements[tBPUpgrade.Prerequisite].Prerequisite='..(oACUBP.Enhancements[tBPUpgrade.Prerequisite].Prerequisite or 'nil')..'; sPossibleUpgrade='..sPossibleUpgrade) end
                                if oACUBP.Enhancements[tBPUpgrade.Prerequisite].Prerequisite == sPossibleUpgrade then
                                    bHaveLaterUpgrade = true
                                    break
                                end
                            end
                        end
                    end
                    if bHaveLaterUpgrade == false then
                        --Manually check certain categories
                        --Sera ACU - dont get T2 if we have later upgrade as e.g. we may have removed T2 so we could get blast attack
                        if sPossibleUpgrade == 'AdvancedEngineering' and (oACU:HasEnhancement('DamageStabilizationAdvanced') or oACU:HasEnhancement('BlastAttack')) then
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Dont want to get T2 as already have later upgrades so want gun splash instead if we dont already have it')
                            end
                            bHaveLaterUpgrade = true
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': ACU doesnt have the upgrade ' .. sPossibleUpgrade .. '; bHaveLaterUpgrade=' .. tostring(bHaveLaterUpgrade))
                    end
                    if not (bHaveLaterUpgrade) then
                        --Check we can actually build this enhancement - for compatibility with mods that might remove base game enhancements
                        local bCanGetEnhancement = false
                        for sEnhancement, tEnhancement in oACU:GetBlueprint().Enhancements do
                            if sEnhancement == sPossibleUpgrade then
                                bCanGetEnhancement = true
                                break
                            end
                        end

                        if bCanGetEnhancement then
                            sUpgradeID = sPossibleUpgrade
                            break
                        end
                    end
                end
            end
        end
    end
    if sUpgradeID == nil then
        oACU[M27UnitInfo.refbFullyUpgraded] = true
    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return sUpgradeID
end

function RetreatLowHealthShields(oPlatoon, aiBrain)
    --Called by onunitdamage as well as every second on platoon cycle
    --Will retreat either if low health collectively, or if the platoon we're escorting is almost dead

    --Will check that the platoon has prev actions to reduce risk of infinite loop occurring

    --Mobile shield bubbles - will assign to retreating platoon based on collective shield %
    --Units with personal shield - will assign to retreating platoon based on individual unit health and shield %
    local sFunctionRef = 'RetreatLowHealthShields'
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    if aiBrain:PlatoonExists(oPlatoon) then
        local sPlan = oPlatoon:GetPlan()
        if bDebugMessages == true then
            LOG(sFunctionRef..': Start of code for Platoon='..sPlan..(oPlatoon[refiPlatoonCount] or 'nil')..'; GameTime='..GetGameTimeSeconds()..'; oPlatoon[M27Transport.refiAssignedPlateau]='..(oPlatoon[M27Transport.refiAssignedPlateau] or 'nil'))
            if oPlatoon[refoPlatoonOrUnitToEscort].UnitId then LOG(sFunctionRef..': Are escorting a unit, with UnitId='..oPlatoon[refoPlatoonOrUnitToEscort].UnitId) end
        end

        --Ignore this logic for plateau units
        if not(oPlatoon[M27Transport.refiAssignedPlateau] and not(aiBrain[M27MapInfo.refiOurBasePlateauGroup] == oPlatoon[M27Transport.refiAssignedPlateau])) then

            local iTotalMobileShieldCurHealth = 0
            local iTotalMobileShieldMaxHealth = 0
            local iCurShieldHealth, iMaxShieldHealth
            local oBP, sBP
            local tMobileShields = {}
            local iMobileShieldCount = 0
            local tUnitsToRun = {}
            local iUnitsToRun = 0
            local tUnitsToFight = {}
            local iUnitsToFight = 0
            --local aiBrain = oPlatoon:GetBrain()
            local sRetreatingShieldPlatoon = 'M27RetreatingShieldUnits'
            local bHaveChangedPlatoonComposition = false
            local iMaxShieldsBeforeStartCycling = 2 --If have more than this then will start shield cycling
            local iLowShieldPercent = 0.5
            local iOverlappingShield
            local tBasePosition
            local oNearbyBP, sNearbyBP, iOverlappingShieldRangeThreshold
            local iCurDistanceToPlatoonFront
            local iMaxDistanceToPlatoonFront = 20 --If further away than this then wont consider when deciding if we need to retreat
            local iFrontlineMobileShieldCount = 0
            local bConsiderLowShieldIndividually = false

            if M27Utilities.IsTableEmpty(oPlatoon[reftUnitsWithShields]) == false then
                if oPlatoon[reftPrevAction] and oPlatoon[reftPrevAction][2] then
                    if oPlatoon[refbACUInPlatoon] then
                        if M27Utilities.IsACU(oPlatoon[refoFrontUnit]) then
                            iCurShieldHealth, iMaxShieldHealth = M27UnitInfo.GetCurrentAndMaximumShield(oPlatoon[refoFrontUnit])
                            if iCurShieldHealth == 0 and iMaxShieldHealth > 0 then
                                oPlatoon[refiCurrentAction] = refActionRun
                                if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Shield health is 0 so will run') end
                            end
                        end
                    else

                        for iUnit, oUnit in oPlatoon[reftUnitsWithShields] do
                            if not(oUnit.Dead) and oUnit.MyShield then
                                bConsiderLowShieldIndividually = true
                                oBP = oUnit:GetBlueprint()
                                sBP = oUnit.UnitId
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit with shield sBP='..sBP..M27UnitInfo.GetUnitLifetimeCount(oUnit))
                                    if oUnit.PlatoonHandle then LOG(sFunctionRef..': Units platoon handle='..oUnit.PlatoonHandle:GetPlan()..(oUnit.PlatoonHandle[refiPlatoonCount] or 'nil')) end
                                end
                                iCurShieldHealth, iMaxShieldHealth = M27UnitInfo.GetCurrentAndMaximumShield(oUnit)

                                if EntityCategoryContains(M27UnitInfo.refCategoryMobileLandShield, sBP) == true and not(oPlatoon:GetPlan() == sRetreatingShieldPlatoon) then
                                    bConsiderLowShieldIndividually = false
                                    iMobileShieldCount = iMobileShieldCount + 1
                                    tMobileShields[iMobileShieldCount] = oUnit
                                    tBasePosition = oUnit:GetPosition()
                                    iCurDistanceToPlatoonFront = M27Utilities.GetDistanceBetweenPositions(tBasePosition, GetPlatoonFrontPosition(oPlatoon))
                                    if iCurDistanceToPlatoonFront <= iMaxDistanceToPlatoonFront then
                                        iFrontlineMobileShieldCount = iFrontlineMobileShieldCount + 1
                                        iTotalMobileShieldCurHealth = iTotalMobileShieldCurHealth + iCurShieldHealth
                                        iTotalMobileShieldMaxHealth = iTotalMobileShieldMaxHealth + iMaxShieldHealth
                                        --Go through remaining units in platoon and see if they're near this one, have their shield enabled, and have high health on their shield

                                        iOverlappingShield = 0
                                        for iNearbyUnit, oNearbyUnit in oPlatoon[reftUnitsWithShields] do
                                            if not(oNearbyUnit == oUnit) and not(oNearbyUnit.Dead) then
                                                oNearbyBP = oNearbyUnit:GetBlueprint()
                                                sNearbyBP = oNearbyUnit.UnitId
                                                if EntityCategoryContains(M27UnitInfo.refCategoryMobileLandShield, sBP) then
                                                    if oNearbyUnit:GetShieldRatio(true) >= iLowShieldPercent and M27UnitInfo.IsUnitShieldEnabled(oNearbyUnit) and oNearbyUnit.MyShield:GetHealth() >= 1000 then
                                                        iOverlappingShieldRangeThreshold = oNearbyBP.Defense.Shield.ShieldSize * 0.5 - 6
                                                        if M27Utilities.GetDistanceBetweenPositions(oNearbyUnit:GetPosition(), tBasePosition) < iOverlappingShieldRangeThreshold then
                                                            iOverlappingShield = iOverlappingShield + 1
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        if iOverlappingShield > iMaxShieldsBeforeStartCycling and not(sPlan == sRetreatingShieldPlatoon) then
                                            M27UnitInfo.DisableUnitShield(oUnit)
                                        elseif (sPlan == sRetreatingShieldPlatoon or iOverlappingShield < iMaxShieldsBeforeStartCycling) and M27UnitInfo.IsUnitShieldEnabled(oUnit) == false and not(oUnit[M27UnitInfo.refbPaused]) then M27UnitInfo.EnableUnitShield(oUnit)
                                        end
                                    else
                                        --Are we due to get to the front soon?
                                        if iCurDistanceToPlatoonFront >= iMaxDistanceToPlatoonFront * 1.5 then
                                            bConsiderLowShieldIndividually = true
                                        else
                                            if sPlan == sRetreatingShieldPlatoon and M27UnitInfo.IsUnitShieldEnabled(oUnit) == false and not(oUnit[M27UnitInfo.refbPaused]) then M27UnitInfo.EnableUnitShield(oUnit) end
                                        end
                                    end
                                end
                                if bConsiderLowShieldIndividually == true then
                                    if M27UnitInfo.IsUnitShieldEnabled(oUnit) == false and not(oUnit[M27UnitInfo.refbPaused]) then M27UnitInfo.EnableUnitShield(oUnit) end
                                    if iCurShieldHealth <= math.min(100, iMaxShieldHealth * 0.1) and M27UnitInfo.IsUnitShieldEnabled(oUnit) == true then
                                        iUnitsToRun = iUnitsToRun + 1
                                        tUnitsToRun[iUnitsToRun] = oUnit
                                    elseif iCurShieldHealth >= iMaxShieldHealth * 0.9 then --WARNING: Careful when changing this -
                                        iUnitsToFight = iUnitsToFight + 1
                                        tUnitsToFight[iUnitsToFight] = oUnit
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' has personal shield; iUnitsToRun='..iUnitsToRun..'; iUnitsToFight='..iUnitsToFight..'; iCurShieldHealth='..iCurShieldHealth..'; iMaxShieldHealth='..iMaxShieldHealth) end
                                end
                            end
                        end
                        if iMobileShieldCount > 0 then
                            --Are we assisting something that should no longer be assisted?
                            local bStopAssistingPlatoon = false
                            if oPlatoon and oPlatoon[refoPlatoonOrUnitToEscort] then
                                if not(oPlatoon[refoPlatoonOrUnitToEscort][refbACUInPlatoon]) and M27PlatoonFormer.DoesPlatoonOrUnitWantAnotherMobileShield(oPlatoon[refoPlatoonOrUnitToEscort], 0, true) == false then
                                    bStopAssistingPlatoon = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Want to stop assisting platoon') end
                                end
                            end
                            if bStopAssistingPlatoon then
                                bHaveChangedPlatoonComposition = true
                                M27PlatoonFormer.CreatePlatoon(aiBrain, sRetreatingShieldPlatoon, tMobileShields)
                                oPlatoon[refiCurrentAction] = refActionDisband
                            else
                                if iFrontlineMobileShieldCount > 0 then
                                    if iTotalMobileShieldCurHealth < iTotalMobileShieldMaxHealth * iLowShieldPercent and not(sPlan==sRetreatingShieldPlatoon) then
                                        bHaveChangedPlatoonComposition = true
                                        M27PlatoonFormer.CreatePlatoon(aiBrain, sRetreatingShieldPlatoon, tMobileShields)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Created new retreating shield platoon') end
                                    elseif sPlan == sRetreatingShieldPlatoon and iTotalMobileShieldCurHealth > iTotalMobileShieldMaxHealth * 0.95 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Platoon has mobile shields that have recovered so reassigning by disbanding platoon') end
                                        oPlatoon[refiCurrentAction] = refActionDisband
                                    end
                                end
                            end
                        end
                        if iUnitsToRun > 0 and not(sPlan == sRetreatingShieldPlatoon) then
                            bHaveChangedPlatoonComposition = true
                            M27PlatoonFormer.CreatePlatoon(aiBrain, sRetreatingShieldPlatoon, tUnitsToRun)
                            if bDebugMessages == true then LOG(sFunctionRef..': Created new platoon '..sRetreatingShieldPlatoon..'; for tUnitsToRun which have a size of'..table.getn(tUnitsToRun)) end
                        elseif sPlan == sRetreatingShieldPlatoon and iUnitsToFight > 0 then
                            bHaveChangedPlatoonComposition = true
                            RemoveUnitsFromPlatoon(oPlatoon, tUnitsToFight, false, nil)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have units to fight that are in a retreating platoon so removing them from that platoon') end
                        end

                        if bHaveChangedPlatoonComposition then
                            if bDebugMessages == true then LOG(sFunctionRef..': Platoon has changed so will update its trackers') end
                            RecordPlatoonUnitsByType(oPlatoon)
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..':'..sPlan..(oPlatoon[refiPlatoonCount] or 'nil')..': Platoon doesnt have 2+ prev actions so not considering mobile shields due to infinite loop risk') end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': End of code for platoon '..sPlan..(oPlatoon[refiPlatoonCount] or 'nil')..'; iUnitsToFight='..iUnitsToFight..'; iUnitsToRun='..iUnitsToRun..'; iMobileShieldCount='..iMobileShieldCount) end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function RetreatToMobileShields(oPlatoon)
    local sFunctionRef = 'RetreatToMobileShields'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end

    --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 1 then bDebugMessages = true end
    local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())

    --if oPlatoon[refbACUInPlatoon] == true and GetGameTimeSeconds() >= 855 then bDebugMessages = true end

    --If the platoon has a mobile shield assisting platoon whose front units are far away, and arent in retreat, then fall back to it
    if oPlatoon[refoSupportingShieldPlatoon] and oPlatoon[refoSupportingShieldPlatoon][refiUnitsWithShields] > 0 and aiBrain:PlatoonExists(oPlatoon[refoSupportingShieldPlatoon]) then
        local iDistanceToShieldHelper = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), GetPlatoonFrontPosition(oPlatoon[refoSupportingShieldPlatoon]))
        if bDebugMessages == true then LOG(sFunctionRef..': iDistanceToShieldHelper='..iDistanceToShieldHelper..'; is platoon underwater='..tostring(M27MapInfo.IsUnderwater(GetPlatoonFrontPosition(oPlatoon)))) end
        if iDistanceToShieldHelper > 50 and iDistanceToShieldHelper <= 150 and not(oPlatoon[refoSupportingShieldPlatoon]:GetPlan() == 'M27RetreatingShieldUnits') and not(M27MapInfo.IsUnderwater(GetPlatoonFrontPosition(oPlatoon))) then
            if bDebugMessages == true then LOG(sFunctionRef..': Telling platoon to move to temporary location to meet up with mobile shield using plan '..oPlatoon[refoSupportingShieldPlatoon]:GetPlan()..oPlatoon[refoSupportingShieldPlatoon][refiPlatoonCount]..' with '..oPlatoon[refoSupportingShieldPlatoon][refiUnitsWithShields]..' units with a shield in it') end
            oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
            if M27Utilities.IsTableEmpty(oPlatoon[refoSupportingShieldPlatoon][reftMovementPath][1]) == true then
                oPlatoon[refoSupportingShieldPlatoon][reftMovementPath] = {}
                oPlatoon[refoSupportingShieldPlatoon][reftMovementPath][1] = GetPlatoonFrontPosition(oPlatoon)
            end

            oPlatoon[reftTemporaryMoveTarget] = GetMergeLocation(oPlatoon[refoSupportingShieldPlatoon], 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Just got merge location; setting temporary move target to result='..repru(oPlatoon[reftTemporaryMoveTarget] or {'nil'})) end
            if M27Utilities.IsTableEmpty(oPlatoon[reftTemporaryMoveTarget]) == true then
                if bDebugMessages == true then LOG(sFunctionRef..': No merge location so will move to shield platoon position instead if we can path there and its not too far away') end
                if iDistanceToShieldHelper <= 150 then
                    if EntityCategoryContains(categories.MOBILE, oPlatoon[refoFrontUnit].UnitId) and oPlatoon[refoFrontUnit]:CanPathTo(GetPlatoonFrontPosition(oPlatoon[refoSupportingShieldPlatoon])) then
                        oPlatoon[reftTemporaryMoveTarget] = GetPlatoonFrontPosition(oPlatoon[refoSupportingShieldPlatoon])
                        if bDebugMessages == true then LOG(sFunctionRef..': Moving to shield platoon, setting temporary move target to '..repru(oPlatoon[reftTemporaryMoveTarget])) end
                    else
                        --cant move to supporting shield platoon so cancel action
                        if bDebugMessages == true then LOG(sFunctionRec..': Cant path to shield platoon so will cancel action') end
                        oPlatoon[refiCurrentAction] = nil
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Supporting shield platoon too far away so will ignore action') end
                    oPlatoon[refiCurrentAction] = nil
                end
            end
        end
    else
        if oPlatoon[refoSupportingShieldPlatoon] and oPlatoon[refoSupportingShieldPlatoon][refiUnitsWithShields] > 0 and not(aiBrain:PlatoonExists(oPlatoon[refoSupportingShieldPlatoon])) then
            if bDebugMessages == true then LOG(sFunctionRef..': Supporting shield platoon no longer exists so clearing it') end
            oPlatoon[refoSupportingShieldPlatoon] = nil
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function DecideWhetherACUShouldAssistConstruction(aiBrain, oPlatoon)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DecideWhetherACUShouldAssistConstruction'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)


    --Do we have enough mass and energy to want to use ACU to build?
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have enough resources for ACU to assist construction.  Have low mass='..tostring(M27Conditions.HaveLowMass(aiBrain))..'; Energy net income='..aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome]..'; Stalling energy='..tostring(aiBrain[M27EconomyOverseer.refbStallingEnergy])) end
    if not(M27Conditions.HaveLowMass(aiBrain)) and aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome] > 0 and aiBrain:GetEconomyStoredRatio('ENERGY') >= 0.9 and not(aiBrain[M27EconomyOverseer.refbStallingEnergy]) then
        if not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle) or M27Utilities.GetACU(aiBrain):HasEnhancement('AdvancedEngineering') or M27Utilities.GetACU(aiBrain):HasEnhancement('T3Engineering') then
            local iBuildRange = (oPlatoon[reftBuilders][1]:GetBlueprint().Economy.MaxBuildDistance or 0)
            if bDebugMessages == true then LOG(sFunctionRef..'Will see if any buildings in our build range that arent yet complete; iBuildRange='..(iBuildRange or 0)) end
            if iBuildRange > 0 then
                local tAllBuildings = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure + categories.EXPERIMENTAL, GetPlatoonFrontPosition(oPlatoon), iBuildRange)
                if M27Utilities.IsTableEmpty(tAllBuildings) == false then
                    for iBuilding, oBuilding in tAllBuildings do
                        if oBuilding:GetFractionComplete() < 1 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have found a building we can assist='..oBuilding.UnitId..M27UnitInfo.GetUnitLifetimeCount(oBuilding)..'; Fraction complete='..oBuilding:GetFractionComplete()) end
                            if not(oBuilding[M27EconomyOverseer.refbWillReclaimUnit]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Not set to reclaim unit so will assist it') end
                                oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                oPlatoon[refoConstructionToAssist] = oBuilding
                                break
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Unti set to be reclaimed so dont want to assist')
                            end
                        end
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Have no buildings nearby')
                end
            else M27Utilities.ErrorHandler('Thought the platoon could help construction but it has no build range; oPlatoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount])
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetNonACUBuilderAction(oPlatoon)
    --E.g. intended for SACUs, but in theory could expand to cover sparkys
    --Emergency base defence
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNonACUBuilderAction'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon:GetPlan() == 'M27RAS' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end

    if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) and oPlatoon.GetBrain then
        if EntityCategoryContains(M27UnitInfo.refCategoryRASSACU, oPlatoon[refoFrontUnit].UnitId) then
            local aiBrain = oPlatoon:GetBrain()
            local iSearchRange = 125
            if EntityCategoryContains(categories.SERAPHIM, oPlatoon[refoFrontUnit].UnitId) then iSearchRange = iSearchRange + 50 end
            iSearchRange = math.min(iSearchRange, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.4)
            if bDebugMessages == true then LOG(sFunctionRef..': iSearchRange='..iSearchRange..'; aiBrain[M27Overseer.refiModDistFromStartNearestThreat]='..aiBrain[M27Overseer.refiModDistFromStartNearestThreat]) end
            if aiBrain[M27Overseer.refiModDistFromStartNearestThreat] <= iSearchRange then
                --Enemies near base - move towards them unelss naval threat
                if GetTerrainHeight(aiBrain[M27Overseer.reftLocationFromStartNearestThreat][1], aiBrain[M27Overseer.reftLocationFromStartNearestThreat][3]) >= M27MapInfo.iMapWaterHeight then
                    oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                    oPlatoon[reftTemporaryMoveTarget] = {aiBrain[M27Overseer.reftLocationFromStartNearestThreat][1], aiBrain[M27Overseer.reftLocationFromStartNearestThreat][2], aiBrain[M27Overseer.reftLocationFromStartNearestThreat][3]}
                    if bDebugMessages == true then LOG(sFunctionRef..': Have enemies near base so will move towards them, setting temporary move target to '..repru(oPlatoon[reftTemporaryMoveTarget])) end
                end
            end
            if not(oPlatoon[refiCurrentAction]) then

                --No nearby enemy threats; do we have engineers actively building emergency defence?
                local oUnitToAssist
                local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoFrontUnit])
                local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))
                for iActionRef, sActionRef in {M27EngineerOverseer.refActionBuildEmergencyPD, M27EngineerOverseer.refActionBuildEmergencyArti, M27EngineerOverseer.refActionFortifyFirebase} do
                    if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][sActionRef]) == false then
                        for iUniqueCount, tSubtable in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][sActionRef] do
                            if M27UnitInfo.IsUnitValid(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]) then
                                --Are we in the same pathing group?
                                if iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(sPathing, tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]:GetPosition()) then
                                    --Are we relatively close?
                                    if M27Utilities.GetDistanceBetweenPositions(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= 100 then
                                        oUnitToAssist = tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
                if oUnitToAssist then
                    if bDebugMessages == true then LOG(sFunctionRef..': Engineer '..oUnitToAssist.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAssist)..' is building emergency defence so will assist it') end
                    oPlatoon[refiCurrentAction] = refActionAssistConstruction
                    oPlatoon[refoConstructionToAssist] = oUnitToAssist
                else
                    --Do we need torp bombers, or bombers for emergency defence?
                    if aiBrain[M27AirOverseer.refiTorpBombersWanted] > 0 or (M27Utilities.IsTableEmpty(aiBrain[M27AirOverseer.reftAvailableBombers]) == true and aiBrain[M27Overseer.refiModDistFromStartNearestThreat] < aiBrain[M27AirOverseer.refiBomberDefenceModDistance] - 30) then
                        local tAirFactories = aiBrain:GetListOfUnits(M27UnitInfo.refCategoryAirFactory, false, true)
                        if M27Utilities.IsTableEmpty(tAirFactories) == false then
                            local iClosestFactory = 10000
                            local iCurDist
                            for iFactory, oFactory in tAirFactories do
                                if not(oFactory[M27FactoryOverseer.refbFactoryTemporaryPauseActive]) then
                                    iCurDist = M27Utilities.GetDistanceBetweenPositions(oFactory:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                    if iCurDist < iClosestFactory and iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oFactory:GetPosition()) then
                                        iClosestFactory = iCurDist
                                        oUnitToAssist = oFactory
                                    end
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain[M27AirOverseer.refiTorpBombersWanted]='..aiBrain[M27AirOverseer.refiTorpBombersWanted]..'; Is table of available bombers empty='..tostring(M27Utilities.IsTableEmpty(aiBrain[M27AirOverseer.reftAvailableBombers]))..'; bomber def range-30='..(aiBrain[M27AirOverseer.refiBomberDefenceModDistance]-30)..'; nearest enemy='..aiBrain[M27Overseer.refiModDistFromStartNearestThreat]) end
                    if oUnitToAssist then
                        oPlatoon[refiCurrentAction] = refActionAssistConstruction
                        oPlatoon[refoConstructionToAssist] = oUnitToAssist
                        if bDebugMessages == true then LOG(sFunctionRef..': Will assist air factory '..oUnitToAssist.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAssist)) end
                    else
                        --Is there reclaim near our base of a significant amount?
                        local tBestReclaimSegment

                        if aiBrain:GetEconomyStoredRatio('MASS') <= 0.3 or M27Conditions.HaveLowMass(aiBrain) then
                            local iMaxSegmentAdjX = math.ceil((iSearchRange / M27MapInfo.iReclaimSegmentSizeX)*0.5)
                            local iMaxSegmentAdjZ = math.ceil((iSearchRange / M27MapInfo.iReclaimSegmentSizeZ)*0.5)
                            local iNearestSegmentDist = 10000
                            local iCurDist
                            local iBaseSegmentX, iBaseSegmentZ = M27MapInfo.GetReclaimSegmentsFromLocation(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                            local iMapHighestSegmentX, iMapHighestSegmentZ = M27MapInfo.GetReclaimSegmentsFromLocation({M27MapInfo.rMapPlayableArea[3], 0, M27MapInfo.rMapPlayableArea[4]})

                            local tCurReclaimSegment
                            for iCurSegmentX = math.max(1, iBaseSegmentX - iMaxSegmentAdjX), math.min(iMapHighestSegmentX, iBaseSegmentX + iMaxSegmentAdjX), 1 do
                                for iCurSegmentZ = math.max(1, iBaseSegmentZ - iMaxSegmentAdjZ), math.min(iMapHighestSegmentZ, iBaseSegmentZ + iMaxSegmentAdjZ), 1 do
                                    if M27MapInfo.tReclaimAreas[iCurSegmentX][iCurSegmentZ][M27MapInfo.refReclaimTotalMass] >= 200 then
                                        tCurReclaimSegment = M27MapInfo.GetReclaimLocationFromSegment(iCurSegmentX, iCurSegmentZ)
                                        iCurDist = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tCurReclaimSegment)
                                        if iCurDist < iNearestSegmentDist then
                                            iNearestSegmentDist = iCurDist
                                            tBestReclaimSegment = {tCurReclaimSegment[1], tCurReclaimSegment[2], tCurReclaimSegment[3]}
                                        end
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Is the table of good reclaim segment near base empty='..tostring(M27Utilities.IsTableEmpty(tBestReclaimSegment))) end
                        if tBestReclaimSegment then
                            oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                            oPlatoon[reftTemporaryMoveTarget] = tBestReclaimSegment
                            if bDebugMessages == true then LOG(sFunctionRef..': Will move to reclaim segment, setting temporary move target to '..repru(oPlatoon[reftTemporaryMoveTarget])) end
                        else
                            --Are we close to overflowing mass and have an experimental <=60% complete nearby?
                            if aiBrain:GetEconomyStoredRatio('MASS') >= 0.3 then
                                local tExperimentalsUnderConstruction = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryExperimentalLevel, GetPlatoonFrontPosition(oPlatoon), 150, 'Ally')
                                if M27Utilities.IsTableEmpty(tExperimentalsUnderConstruction) == false then
                                    local iClosestExperimental = 10000
                                    local iCurDist
                                    for iUnit, oUnit in tExperimentalsUnderConstruction do
                                        if oUnit:GetFractionComplete() < 1 then
                                            iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                            if iCurDist < iClosestExperimental and iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oUnit:GetPosition()) then
                                                iClosestExperimental = iCurDist
                                                oUnitToAssist = oUnit
                                            end
                                        end
                                    end
                                end
                            end

                            if not(oUnitToAssist) then
                                --Do we have any missiles to assist?
                                local tNearbyMissiles = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategorySML + M27UnitInfo.refCategorySMD + M27UnitInfo.refCategoryTML - categories.EXPERIMENTAL, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], iSearchRange, 'Ally')
                                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby missile builders empty='..tostring(M27Utilities.IsTableEmpty(tNearbyMissiles))) end
                                if M27Utilities.IsTableEmpty(tNearbyMissiles) == false then
                                    local iCurDist
                                    local iNearestDist = 10000
                                    for iUnit, oUnit in tNearbyMissiles do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering missile builder '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit:GetWorkProgress()='..oUnit:GetWorkProgress()) end
                                        if oUnit.GetWorkProgress and oUnit:GetWorkProgress() < 1 and (oUnit:GetFractionComplete() < 1 or oUnit:GetWorkProgress() > 0) then
                                            if iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oUnit:GetPosition()) then
                                                iCurDist = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition())
                                                if iCurDist < iNearestDist then
                                                    iNearestDist = iCurDist
                                                    oUnitToAssist = oUnit
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            if oUnitToAssist then
                                oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                oPlatoon[refoConstructionToAssist] = oUnitToAssist
                                if bDebugMessages == true then LOG(sFunctionRef..': Will assist missile builder '..oUnitToAssist.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAssist)) end
                            else
                                --Do we have mass stored and quantum gateway isnt paused?
                                local tQuantumGateways = aiBrain:GetListOfUnits(M27UnitInfo.refCategoryQuantumGateway, false, true)
                                local iCurDist
                                local iNearestDist = 10000
                                if M27Utilities.IsTableEmpty(tQuantumGateways) == false then
                                    for iUnit, oUnit in tQuantumGateways do
                                        if oUnit.GetWorkProgress and oUnit:GetWorkProgress() < 1 and (oUnit:GetFractionComplete() < 1 or oUnit:GetWorkProgress() > 0) then
                                            if iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oUnit:GetPosition()) then
                                                iCurDist = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition())
                                                if iCurDist < iNearestDist then
                                                    iNearestDist = iCurDist
                                                    oUnitToAssist = oUnit
                                                end
                                            end
                                        end
                                    end
                                end
                                if oUnitToAssist then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will assist quantum gateway '..oUnitToAssist.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAssist)..'; unless have low mass in which case will move towards it.  Mass stored='..aiBrain:GetEconomyStored('MASS')) end
                                    if aiBrain:GetEconomyStored('MASS') > 0 and (not(M27Conditions.HaveLowMass(aiBrain)) or aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyEcoAndTech or aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle) then
                                        oPlatoon[refiCurrentAction] = refActionAssistConstruction
                                        oPlatoon[refoConstructionToAssist] = oUnitToAssist
                                    else
                                        oPlatoon[refiCurrentAction] = refActionMoveToTemporaryLocation
                                        oPlatoon[reftTemporaryMoveTarget] = oUnitToAssist:GetPosition()
                                        if bDebugMessages == true then LOG(sFunctionRef..': Setting temporary move target to assist, location='..repru(oPlatoon[reftTemporaryMoveTarget])) end
                                    end
                                else
                                    --No quantum gateway, return to base
                                    oPlatoon[refiCurrentAction] = refActionReturnToBase
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end


function DeterminePlatoonAction(oPlatoon)
    --Record current action as previous action
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DeterminePlatoonAction'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon[refbOverseerAction] == true then bDebugMessages = true end
    if oPlatoon and oPlatoon.GetBrain then
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, checking if platoon still exists') end
        local aiBrain = oPlatoon[refoBrain]
        --if aiBrain and aiBrain.PlatoonExists and aiBrain:PlatoonExists(oPlatoon) then --Removed this check as we do it already as part of the parent function


        local sPlatoonName = oPlatoon:GetPlan()
        --if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) and EntityCategoryContains(M27UnitInfo.refCategoryIndirectT2Plus - categories.EXPERIMENTAL - M27UnitInfo.refCategorySniperBot, oPlatoon[refoFrontUnit].UnitId) and GetGameTimeSeconds() >= 1380 and oPlatoon[refiEnemyStructuresInRange] > 0 and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryPD * categories.TECH3, oPlatoon[reftEnemyStructuresInRange])) == false then bDebugMessages = true end
        --if oPlatoon[refbACUInPlatoon] == true and GetGameTimeSeconds() >= 600 and aiBrain:GetArmyIndex() == 5 then bDebugMessages = true M27Config.M27ShowUnitNames = true end
        --if sPlatoonName == 'M27DefenderAI' and oPlatoon[refiPlatoonCount] == 3 then bDebugMessages = true end
        --if sPlatoonName == 'M27RAS' and oPlatoon[refiPlatoonCount] == 8 and GetGameTimeSeconds() >= 2400 then bDebugMessages = true end
        --if sPlatoonName == 'M27Skirmisher' and M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) and GetGameTimeSeconds() >= 300 and EntityCategoryContains(M27UnitInfo.refCategorySniperBot, oPlatoon[refoFrontUnit].UnitId) and oPlatoon[refiPlatoonCount] == 9 then bDebugMessages = true M27Config.M27ShowUnitNames = true M27Config.M27ShowEnemyUnitNames = true end
        --if sPlatoonName == 'M27AmphibiousDefender' then bDebugMessages = true end
        --if GetGameTimeSeconds() >= 600 and aiBrain:GetArmyIndex() == 2 then bDebugMessages = true end
        --if EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId) then bDebugMessages = true end
        --if sPlatoonName == 'M27MAAAssister' and GetGameTimeSeconds() >= 937 and aiBrain:GetArmyIndex() == 4 and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
        --if sPlatoonName == 'M27AttackNearestUnits' and oPlatoon[refiPlatoonCount] == 86 then bDebugMessages = true end
        --if sPlatoonName == 'M27MexRaiderAI' and oPlatoon[refiPlatoonCount] == 2 and GetGameTimeSeconds() >= 270 then bDebugMessages = true end
        --if sPlatoonName == 'M27ScoutAssister' and oPlatoon[refiPlatoonCount] == 2 then bDebugMessages = true end
        --if sPlatoonName == M27Overseer.sIntelPlatoonRef then bDebugMessages = true end
        --if sPlatoonName == 'M27MAAAssister' then bDebugMessages = true end
        --if sPlatoonName == 'M27LargeAttackForce' then bDebugMessages = true end
        --if sPlatoonName == 'M27IntelPathAI' then bDebugMessages = true end
        --if sPlatoonName == 'M27IndirectDefender' then bDebugMessages = true end
        --if sPlatoonName == 'M27MexLargerRaiderAI' and oPlatoon[refiPlatoonCount] == 2 and aiBrain:GetArmyIndex() == 2 and GetGameTimeSeconds() >= 420 then bDebugMessages = true end
        --if sPlatoonName == 'M27CombatPatrolAI' and oPlatoon[refiPlatoonCount] == 1 and GetGameTimeSeconds() >= 480 and aiBrain:GetArmyIndex() == 3 then bDebugMessages = true end
        --if sPlatoonName == 'M27EscortAI' and oPlatoon[refiPlatoonCount] == 1 and GetGameTimeSeconds() >= 780  then bDebugMessages = true end
        --if sPlatoonName == 'M27RetreatingShieldUnits' then bDebugMessages = true end
        --if sPlatoonName == 'M27MobileShield' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
        --if sPlatoonName == 'M27MobileStealth' then bDebugMessages = true end
        --if sPlatoonName == 'M27IndirectSpareAttacker' and aiBrain:GetArmyIndex() == 10 and GetGameTimeSeconds() >= 940 then bDebugMessages = true end
        --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
        --if sPlatoonName == 'M27PlateauLandCombat' then bDebugMessages = true end

        if bDebugMessages == true then
            LOG(sFunctionRef..': Start of code; GameTime='..GetGameTimeSeconds()..'; Strategy='..aiBrain[M27Overseer.refiAIBrainCurrentStrategy])
            --M27EngineerOverseer.TEMPTEST(aiBrain, 'Determine platoon action - start of code')
            if sPlatoonName == 'M27IndirectDefender' then LOG(sFunctionRef..': Platoon name and count='..sPlatoonName..oPlatoon[refiPlatoonCount]..': refbShouldHaveEscort='..tostring(oPlatoon[refbShouldHaveEscort])) end
        end

        --Update the record of previous platoon actions
        if not(oPlatoon[reftPrevAction][15]==nil) then table.remove(oPlatoon[reftPrevAction], 15) end
        if not(oPlatoon[refiCurrentAction] == nil) then
            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': Current action isnt nil') end
            if oPlatoon[reftPrevAction] == nil then
                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': Prev action table is completely nil so setting it equal to current action') end
                oPlatoon[reftPrevAction] = {oPlatoon[refiCurrentAction]}
                if oPlatoon[reftPrevAction] == nil then
                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': Prev action table is still completely nil') end
                end
            else
                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': Inserting new prev action into table; action to insert='..oPlatoon[refiCurrentAction]) end
                table.insert(oPlatoon[reftPrevAction], 1, oPlatoon[refiCurrentAction])
            end
        else --Dont have a current action so won't make any change; set prev action to whatever was there before
            --Exception - have added in override to make current action nil if it was continue movement path and prev action was new movement path; therefore set prev action to continuemovementpath
            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': Current action is nil') end
            if not(oPlatoon[reftPrevAction] == nil) then
                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': No change to preva ction, inserting the prev action to itself; Action to insert='..oPlatoon[reftPrevAction][1]) end
                if oPlatoon[reftPrevAction][1] == refActionNewMovementPath then
                    table.insert(oPlatoon[reftPrevAction], 1, refActionContinueMovementPath)
                else
                    table.insert(oPlatoon[reftPrevAction], 1, oPlatoon[reftPrevAction][1])
                end

                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': No change to preva ction, inserting the prev action to itself; Finished inserting='..oPlatoon[reftPrevAction][1]) end
            end
        end

        --Update pref targets where we need to track them:
        oPlatoon[refoPrevTemporaryAttackTarget] = oPlatoon[refoTemporaryAttackTarget]
        --Reset flag for whether have reduced refresh rate
        oPlatoon[refbFasterRefreshNextCycle] = false


        --[[if bDebugMessages == true then
            if oPlatoon[reftPrevAction] == nil then
                LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': Prev Action is nil')
            else
                LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': Prev Action is now '..oPlatoon[reftPrevAction][1])
                if table.getn(oPlatoon[reftPrevAction]) > 1 then
                    LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': total prev actions='..table.getn(oPlatoon[reftPrevAction]))
                    if oPlatoon[reftPrevAction][2] == nil then
                        LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': 2nd prev action is nil')
                    else
                        LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': 2nd prev action is '..oPlatoon[reftPrevAction][2])
                    end
                else
                    LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': Only 1 prev action exists')
                end
            end
        end ]]--
        oPlatoon[refiCurrentAction] = nil
        oPlatoon[refiExtraAction] = nil


        --Setup:
        if bDebugMessages == true then LOG(sFunctionRef..sPlatoonName..oPlatoon[refiPlatoonCount]..': about to call RecordPlatoonUnitsByType') end
        RecordPlatoonUnitsByType(oPlatoon)
        if bDebugMessages == true then LOG(sFunctionRef..': Checking platoon has units') end
        if oPlatoon[refiCurrentUnits] == 0 then
            if bDebugMessages == true then LOG('oPlatoon has nil units, so moving to action disband; Platoon ref='..sPlatoonName..oPlatoon[refiPlatoonCount]) end
            oPlatoon[refiCurrentAction] = refActionDisband
        else
            if oPlatoon[refiUnitsWithShields] > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Platoon contains '..oPlatoon[refiUnitsWithShields]..' shielded units, Will check if any of these want to retreat') end
                RetreatLowHealthShields(oPlatoon, aiBrain)
            end
            if oPlatoon[refiCurrentUnits] == 0 then
                if bDebugMessages == true then LOG('oPlatoon has no units after retreating shields, so disbanding; Platoon ref='..sPlatoonName..oPlatoon[refiPlatoonCount]) end
                oPlatoon[refiCurrentAction] = refActionDisband
            else
                local bDoNothing = false
                if oPlatoon[refbACUInPlatoon] and oPlatoon[reftBuilders][1] and oPlatoon[reftBuilders][1][M27UnitInfo.refbOverchargeOrderGiven] then
                    if bDebugMessages == true then LOG(sFunctionRef..': Overcharge action has been given so will do nothing') end
                    bDoNothing = true
                end
                if not(bDoNothing) then
                    --Are we an escort platoon with nothing to escort?
                    if oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] and not(sPlatoonName == 'M27PlateauScout') then--and oPlatoon[reftPrevAction][1] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'is meant to be escorting a unit or platoon, if it doesnt have a valid unit or platoon will disband') end
                        if oPlatoon[refoPlatoonOrUnitToEscort] then
                            if oPlatoon[refoPlatoonOrUnitToEscort].GetUnitId then
                                if oPlatoon[refoPlatoonOrUnitToEscort].Dead then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Escorting a unit that is dead') end
                                    oPlatoon[refiCurrentAction] = refActionDisband
                                end
                            else
                                --Must be a platoon
                                if not(aiBrain:PlatoonExists(oPlatoon[refoPlatoonOrUnitToEscort])) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Were meant to be escorting a platoon but it doesnt exist') end
                                    oPlatoon[refiCurrentAction] = refActionDisband
                                end
                            end
                        elseif oPlatoon[refoSupportHelperPlatoonTarget] then
                            if not(aiBrain:PlatoonExists(oPlatoon[refoSupportHelperPlatoonTarget])) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Were meant to be supporting a platoon but it doesnt exist') end
                                oPlatoon[refiCurrentAction] = refActionDisband
                            end
                        elseif oPlatoon[refoSupportHelperUnitTarget] then
                            if oPlatoon[refoSupportHelperUnitTarget].Dead or not(oPlatoon[refoSupportHelperUnitTarget].GetUnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Supporting a unit that is dead or has no unit id') end
                                oPlatoon[refiCurrentAction] = refActionDisband
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': PlatoonOrUnit to escort or support helper target is nil') end
                            oPlatoon[refiCurrentAction] = refActionDisband
                        end
                    end
                    if not(oPlatoon[refiCurrentAction] == refActionDisband) then



                        --Get details on nearby enemies
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking nearby enemy data and checking if we have an escort platoon. oPlatoon[refiPlatoonMaxRange]='..(oPlatoon[refiPlatoonMaxRange] or 'nil')) end
                        if not(oPlatoon[refiPlatoonMaxRange]) then
                            M27Utilities.ErrorHandler('Platoon '..sPlatoonName..oPlatoon[refiPlatoonCount]..' doesnt have a range set so will update it')
                            if oPlatoon[refiCurrentUnits] > 0 then oPlatoon[refiPlatoonMaxRange] = math.max(2, M27Logic.GetUnitMaxGroundRange(oPlatoon[reftCurrentUnits]))
                            else oPlatoon[refiPlatoonMaxRange] = 2
                            end
                        end
                        if not(oPlatoon[reftCurrentUnits][1]) or not(oPlatoon[reftCurrentUnits][1].GetBlueprint) then
                            M27Utilities.ErrorHandler('Platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..' doesnt have a valid current unit 1.  Is front unit valid='..tostring(M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]))..'; Current units='..oPlatoon[refiCurrentUnits])
                        else
                            local iIntelRange = (oPlatoon[reftCurrentUnits][1]:GetBlueprint().Intel.RadarRadius or 0)
                            local iEnemySearchRadius = math.max(aiBrain[M27Overseer.refiHighestMobileLandEnemyRange] + 10)
                            if oPlatoon[refiPlatoonMassValue] >= 10000 and M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyLandExperimentals]) == false then iEnemySearchRadius = iEnemySearchRadius + 10 end
                            iEnemySearchRadius = math.min(180, math.max(iEnemySearchRadius, oPlatoon[refiPlatoonMaxRange] * 2, 30 + aiBrain[M27Overseer.refiEnemyHighestTechLevel] * 10, iIntelRange)) --Will consider responses if any enemies get within 2 times the max range of platoon
                            if oPlatoon[refiCurrentUnits] == 1 and iEnemySearchRadius < 50 and not(oPlatoon[refbACUInPlatoon]) and (oPlatoon[refoFrontUnit]:GetBlueprint().Physics.MaxSpeed or 0) >= 3.5 then iEnemySearchRadius = 50 end

                            --Check this is also >= intel size:

                            if oPlatoon[M27Transport.refiAssignedPlateau] then iEnemySearchRadius = math.max(iEnemySearchRadius, 100) end
                            RecordNearbyEnemyData(oPlatoon, iEnemySearchRadius)
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished getting nearby enemy data. iEnemySearchRadius='..iEnemySearchRadius..'; iEnemiesInRange='..oPlatoon[refiEnemiesInRange]) end

                            --SPECIAL MODE - attack ACU - ignore most logic for non-skirmishers
                            local bAttackACULogic = false
                            if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyACUKill and not(oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic]) then
                                if oPlatoon[refbACUInPlatoon] then
                                    if aiBrain[M27Overseer.refbIncludeACUInAllOutAttack] then
                                        bAttackACULogic = true
                                        local oACU = oPlatoon[reftBuilders][1]
                                        if not(oACU) then oACU = M27Utilities.GetACU(aiBrain) end
                                        if M27Conditions.CanUnitUseOvercharge(aiBrain, oACU) == true then M27UnitMicro.GetOverchargeExtraAction(aiBrain, oPlatoon, oACU) end
                                    end
                                else
                                    if M27Utilities.IsTableEmpty(GetPlatoonUnitsOrUnitCount(oPlatoon, reftDFUnits, false, false)) == false or M27Utilities.IsTableEmpty(GetPlatoonUnitsOrUnitCount(oPlatoon, reftIndirectUnits, false, false)) == false then
                                        bAttackACULogic = true
                                    end
                                end
                                if bAttackACULogic == true and M27UnitInfo.IsUnitValid(aiBrain[M27Overseer.refoACUKillTarget]) then oPlatoon[refiCurrentAction] = refActionKillACU end
                            end
                            if bAttackACULogic == false then
                                --Escort platoons - if escorting an individual unit as a 'platoon' such as an engineer, then need to update the tracker for that as well
                                if oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] == true and oPlatoon[refoPlatoonOrUnitToEscort] then
                                    if oPlatoon[refoPlatoonOrUnitToEscort].GetUnitId then
                                        --Check the unit we're meant to be escorting is still alive
                                        if oPlatoon[refoPlatoonOrUnitToEscort].Dead then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Unit that were escorting is dead so disbanding') end
                                            oPlatoon[refiCurrentAction] = refActionDisband
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Are escorting a unit and its still alive, will refresh escort details') end
                                            RecordPlatoonUnitsByType(oPlatoon[refoPlatoonOrUnitToEscort], true)
                                            RecordNearbyEnemyData(oPlatoon[refoPlatoonOrUnitToEscort], M27EngineerOverseer.iEngineerMobileEnemySearchRange, true)
                                            UpdateEscortDetails(oPlatoon[refoPlatoonOrUnitToEscort]) -- need to call from the unit itself as well, e.g. engineers call this as part of the action tracker assignment
                                        end
                                    elseif oPlatoon[refoPlatoonOrUnitToEscort].GetPlan then
                                        if not(aiBrain:PlatoonExists(oPlatoon[refoPlatoonOrUnitToEscort])) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Platoon that were escorting no longer exists so disbanding') end
                                            oPlatoon[refiCurrentAction] = refActionDisband
                                        end
                                    else
                                        M27Utilities.ErrorHandler(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..' escorting platoon has a unit or platoon to escort that doesnt have a unitid or platoon handle')
                                        local sPlatoonCount, sUnitsInPlatoon, tFrontPosition
                                        sPlatoonCount = oPlatoon[refoPlatoonOrUnitToEscort][refiPlatoonCount]
                                        if sPlatoonCount == nil then sPlatoonCount = 'nil' end
                                        sUnitsInPlatoon = oPlatoon[refoPlatoonOrUnitToEscort][refiCurrentUnits]
                                        if sUnitsInPlatoon == nil then sUnitsInPlatoon = 'nil' end
                                        tFrontPosition = GetPlatoonFrontPosition(oPlatoon[refoPlatoonOrUnitToEscort])
                                        if tFrontPosition == nil then tFrontPosition = {'nil'} end
                                        LOG('Details of unit or platoon escorting: sPlatoonCount='..sPlatoonCount..'; sUnitsInPlatoon='..sUnitsInPlatoon..'; tFrontPosition='..repru(tFrontPosition))
                                        oPlatoon[refiCurrentAction] = refActionDisband
                                    end
                                end

                                --Special override for start of game:
                                local bStartingBuildOrder = false
                                if oPlatoon[refbACUInPlatoon] == true then
                                    if GetGameTimeSeconds() <= 100 then
                                        local tFactories = aiBrain:GetListOfUnits(categories.CONSTRUCTION * categories.FACTORY, false, true)
                                        local iFactoryCount = 0
                                        if M27Utilities.IsTableEmpty(tFactories) == false then
                                            for iFactory, oFactory in tFactories do
                                                if oFactory.GetFractionComplete and oFactory:GetFractionComplete() == 1 then
                                                    iFactoryCount = iFactoryCount + 1
                                                    break
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': iFactoryCount='..iFactoryCount) end
                                        if iFactoryCount == 0 then
                                            oPlatoon[refiCurrentAction] = refActionBuildFactory
                                            bStartingBuildOrder = true
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Special override for ACU platoon at start of the game (first 100 seconds); bStartingBuildOrder='..tostring(bStartingBuildOrder)) end
                                if bStartingBuildOrder == false then
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': platoon has units, count='..oPlatoon[refiCurrentUnits]) end
                                    if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath]) then
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Platoon has no movement path') end
                                        oPlatoon[refiCurrentAction] = refActionNewMovementPath
                                    else
                                        if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]) == true then
                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Current path target is nil, getting new movement path') end
                                            oPlatoon[refiCurrentAction] = refActionNewMovementPath
                                        else
                                            --INITIAL ACU SPECIFIC ACTIONS
                                            --If ACU on low health or is far from base and are big threats then run; if ACU upgrading then do nothing
                                            if bDebugMessages == true then LOG(sFunctionRef..'; oPlatoon[refbACUInPlatoon]='..tostring(oPlatoon[refbACUInPlatoon])..'; platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))) end
                                            if oPlatoon[refbACUInPlatoon] == true then
                                                local oACU = M27Utilities.GetACU(aiBrain)
                                                local iHealthPercentage = M27UnitInfo.GetUnitHealthPercent(oACU)
                                                local bRun = false

                                                if oACU:IsUnitState('Upgrading') then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU unit state is upgrading') end
                                                    local iUpgradePercent = oACU:GetWorkProgress()
                                                    if iHealthPercentage <= 0.5 and iUpgradePercent < (1 - iHealthPercentage) and M27Conditions.SafeToGetACUUpgrade(aiBrain) == false then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU needs to run as iHealthPercentage='..iHealthPercentage..' and iUpgradePercent='..iUpgradePercent) end
                                                        bRun = true
                                                    else
                                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU shoudl continue with its upgrade') end
                                                        oPlatoon[refiCurrentAction] = refActionUpgrade
                                                    end
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU not upgrading, will see if low health') end
                                                    if iHealthPercentage <= 0.35 or M27Conditions.ACUShouldRunFromBigThreat(aiBrain) then bRun = true end
                                                end
                                                if bRun == true then
                                                    --If are already at chokepoint firebase that has at least 3 T2 PD in it then dont run as may be better off trying to fortify it
                                                    if bDebugMessages == true then LOG(sFunctionRef..': GetPlatoonFrontPosition(oPlatoon)='..repru(GetPlatoonFrontPosition(oPlatoon))..'; aiBrain[M27MapInfo.reftChokepointBuildLocation]='..repru(aiBrain[M27MapInfo.reftChokepointBuildLocation])..'; M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]='..repru(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])..'; Will see if are close enough to chokepoint to ignore the run order') end
                                                    if aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef] and aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle and (M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) < 12 + M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], aiBrain[M27MapInfo.reftChokepointBuildLocation]) and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), aiBrain[M27MapInfo.reftChokepointBuildLocation]) <= 40 and table.getsize(aiBrain[M27EngineerOverseer.reftFirebaseUnitsByFirebaseRef][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]]) >= 3) or M27Logic.IsLocationUnderFriendlyFixedShield(aiBrain, GetPlatoonFrontPosition(oPlatoon)) then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Are turtling and are near chokepoint so will stay by chokepoint') end
                                                        bRun = false
                                                    else

                                                        --Nearby enemy action should already consider running
                                                        if not(M27MapInfo.bNoRushActive) then UpdatePlatoonActionForNearbyEnemies(oPlatoon) end

                                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU needs to run so will set action to return to base') end
                                                        --Below is redundancy, as nearbyenemy action should already tell ACU to run in most cases
                                                        oPlatoon[refbNeedToHeal] = true
                                                        oPlatoon[refbHavePreviouslyRun] = true
                                                        if not(oPlatoon[refiCurrentAction]) then
                                                            if iHealthPercentage <= M27Overseer.iACUEmergencyHealthPercentThreshold then
                                                                oPlatoon[refiCurrentAction] = refActionReturnToBase
                                                            else oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                            if oPlatoon[refiCurrentAction] == nil then
                                                if bDebugMessages == true then LOG(sFunctionRef..': Platoon doesnt have an action yet, will check for whether we have an overseer override action now. oPlatoon[refbOverseerAction]='..tostring((oPlatoon[refbOverseerAction] or false))) end
                                                --Apply overseer override action if there is one
                                                if oPlatoon[refbOverseerAction] == true then
                                                    oPlatoon[refiLastPrevActionOverride] = 0
                                                    local bIgnoreOverseerOverride = false
                                                    oPlatoon[refbOverseerAction] = false
                                                    --first Check if reached final destination (in which case will ignore the override except for scouts)
                                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Overseer action active; checking if reached current or final destination') end
                                                    if HasPlatoonReachedDestination(oPlatoon) == true then
                                                        IncreasePlatoonMovementPath(oPlatoon)
                                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Overseer action active; Have reached current destination, considering if final') end
                                                        if oPlatoon[refiCurrentPathTarget] > table.getn(oPlatoon[reftMovementPath]) then
                                                            if sPlatoonName == M27Overseer.sIntelPlatoonRef then
                                                                oPlatoon[refiCurrentPathTarget] = table.getn(oPlatoon[reftMovementPath])
                                                            else
                                                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Overseer action active; Have reached final destination, getting completion action instead') end
                                                                DeterminePlatoonCompletionAction(oPlatoon)
                                                                bIgnoreOverseerOverride = true
                                                            end
                                                        end
                                                    end
                                                    if bIgnoreOverseerOverride == false then
                                                        oPlatoon[refiCurrentAction] = oPlatoon[refiOverseerAction]
                                                        if oPlatoon[refiCurrentAction] == nil then
                                                            M27Utilities.ErrorHandler(sPlatoonName..oPlatoon[refiPlatoonCount]..': Likely error - Platoon current action is still nil so override flag set without specifying action')
                                                        else
                                                            if bDebugMessages == true then LOG('Overseer action override: Platoon current action is:'..oPlatoon[refiCurrentAction]) end
                                                        end
                                                        --Get more refined enemy targetting commands:
                                                        if oPlatoon[refiCurrentAction] == refActionAttack or oPlatoon[refiCurrentAction] == refActionMoveDFToNearestEnemy then
                                                            --local iPlatoonMaxRange = M27Logic.GetUnitMaxGroundRange(oPlatoon[reftCurrentUnits])
                                                            --local iEnemySearchRadius = math.min(math.max(iPlatoonMaxRange * 2, iPlatoonMaxRange + 5), iPlatoonMaxRange + 25) --Will consider responses if any enemies get within 2 times the max range of platoon
                                                            --RecordNearbyEnemyData(oPlatoon, iEnemySearchRadius)
                                                            local iOriginalAction = oPlatoon[refiCurrentAction]
                                                            if not(M27MapInfo.bNoRushActive) then UpdatePlatoonActionForNearbyEnemies(oPlatoon, true) end
                                                            if oPlatoon[refiCurrentAction] == nil then oPlatoon[refiCurrentAction] = iOriginalAction end
                                                        else
                                                            --Check if last move order was far from current destination
                                                            local tCurMovementTarget
                                                            if oPlatoon[refoFrontUnit] and oPlatoon[refoFrontUnit].GetNavigator then
                                                                local oNavigator = oPlatoon[refoFrontUnit]:GetNavigator()
                                                                if oNavigator and oNavigator.GetCurrentTargetPos then
                                                                    tCurMovementTarget = oNavigator:GetCurrentTargetPos()
                                                                end
                                                            end

                                                            if bDebugMessages == true then LOG(sFunctionRef .. ': Dist between platoon front unit navigation target and movement path=' .. M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], (tCurMovementTarget or {0,0,0}))) end
                                                            if not(tCurMovementTarget) or M27Utilities.GetDistanceBetweenPositions(tCurMovementTarget, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]) >= 20 then
                                                                oPlatoon[refbForceActionRefresh] = true
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Will force a refresh on the platoon as its movement path is far away from the current navigation target') end
                                                            end
                                                        end
                                                    end
                                                    oPlatoon[refiOverseerAction] = nil
                                                else
                                                    oPlatoon[refiLastPrevActionOverride] = oPlatoon[refiLastPrevActionOverride] + 1
                                                    --Check not just had a platoon disband action (in which case wouldve been from other code):
                                                    if not(oPlatoon[reftPrevAction][1] == nil) then
                                                        if oPlatoon[reftPrevAction][1] == refActionDisband then
                                                            if bDebugMessages == true then LOG('Determineplatoon action: Prev action was to disband so making that our current action') end
                                                            oPlatoon[refiCurrentAction] = refActionDisband
                                                        elseif oPlatoon[reftPrevAction][1] == refActionGoToRandomLocationForAWhile and not(oPlatoon[reftPrevAction][10] == refActionGoToRandomLocationForAWhile) then
                                                            oPlatoon[refiCurrentAction] = refActionGoToRandomLocationForAWhile
                                                            if bDebugMessages == true then LOG(sFunctionRef..': oPlatoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'; platoon position='..repru(oPlatoon:GetPlatoonPosition())..'; moving to random point='..repru(oPlatoon[reftTemporaryMoveTarget][1])) end
                                                        end
                                                    end
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking prev action such as disband. oPlatoon[refiCurrentAction]='..(oPlatoon[refiCurrentAction] or 'nil')..'; prev action='..(oPlatoon[reftPrevAction][1] or 'nil')) end

                                                    if oPlatoon[refiCurrentAction] == nil then
                                                        --Still have units in platoon; do basic setup for checks:
                                                        --local iPlatoonMaxRange = M27Logic.GetUnitMaxGroundRange(oPlatoon[reftCurrentUnits])
                                                        --local iEnemySearchRadius = iPlatoonMaxRange * 2 --Will consider responses if any enemies get within 2 times the max range of platoon
                                                        --if iEnemySearchRadius < 40 then iEnemySearchRadius = 40 end
                                                        --Check this is also >= intel size:
                                                        --local iIntelRange = oPlatoon[reftCurrentUnits][1]:GetBlueprint().Intel.RadarRadius
                                                        --if iEnemySearchRadius < iIntelRange then iEnemySearchRadius = iIntelRange end
                                                        --RecordNearbyEnemyData(oPlatoon, iEnemySearchRadius) --needed here for action if stuck to work

                                                        --Go through action determinants in order of priority (highest priority first):
                                                        --Check if platoon is stuck (unless are an intel platoon where would expect to be stationery)
                                                        if not(sPlatoonName == M27Overseer.sIntelPlatoonRef) then UpdatePlatoonActionIfStuck(oPlatoon) end
                                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Finished checking action for if stuck, CurAction='..(oPlatoon[refiCurrentAction] or 'nil')) end
                                                        if oPlatoon[refiCurrentAction] == nil then
                                                            --ACU specific: Get nearby reclaim if no enemies within ACU gun range (even if dont have gun); also consider getting t2 upgrade even if nearby enemies
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Cur action is nil, will check for recliam if are an ACU platoon; oPlatoon[refbACUInPlatoon]='..tostring(oPlatoon[refbACUInPlatoon])..'; oPlatoon[refbConsiderReclaim]='..tostring(oPlatoon[refbConsiderReclaim])) end
                                                            if oPlatoon[refbACUInPlatoon] then
                                                                if oPlatoon[refbConsiderReclaim] == true then
                                                                    DetermineActionForNearbyReclaim(oPlatoon)
                                                                    --Overwrite with getting a mex if have action
                                                                    if oPlatoon[refiCurrentAction] and oPlatoon[refbConsiderMexes] then DetermineActionForNearbyMex(oPlatoon) end
                                                                end
                                                                if bDebugMessages == true then LOG(sFunctionRef..': Action after considering nearby reclaim and mexes='..(oPlatoon[refiCurrentAction] or 'nil')) end
                                                                if not(oPlatoon[refiCurrentAction]) and (aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle or aiBrain[M27Overseer.refiDefaultStrategy] == M27Overseer.refStrategyTurtle) then
                                                                    if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle then DecideWhetherACUShouldAssistConstruction(aiBrain, oPlatoon) end
                                                                    if bDebugMessages == true then LOG(sFunctionRef..': Action after considering if should assist construction='..(oPlatoon[refiCurrentAction] or 'nil')) end
                                                                    if not(oPlatoon[refiCurrentAction]) then
                                                                        ConsiderConstructionForACU(aiBrain, oPlatoon, M27Utilities.GetACU(aiBrain))
                                                                        if not(oPlatoon[refiCurrentAction]) and not(M27Utilities.GetACU(aiBrain):HasEnhancement('AdvancedEngineering')) then
                                                                            DecideWhetherToGetACUUpgrade(aiBrain, oPlatoon)
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                            --if oPlatoon[refiCurrentAction] == nil then
                                                            if not(M27MapInfo.bNoRushActive) and not((oPlatoon[refiCurrentAction] == refActionBuildStructure or oPlatoon[refiCurrentAction] == refActionAssistConstruction)) then UpdatePlatoonActionForNearbyEnemies(oPlatoon) end
                                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Finished getting action for nearby enemies; action='..(oPlatoon[refiCurrentAction] or 'nil')) end
                                                            if oPlatoon[refiCurrentAction] == nil or (oPlatoon[M27PlatoonTemplates.refiAirAttackRange] and aiBrain[M27AirOverseer.refbMercySightedRecently]) then
                                                                --MAA specific - check for nearby air units
                                                                if oPlatoon[M27PlatoonTemplates.refiAirAttackRange] then UpdatePlatoonActionForNearbyAirUnits(oPlatoon)
                                                                elseif oPlatoon[refbACUInPlatoon] and not(oPlatoon[refiCurrentAction]) and oPlatoon[refiEnemiesInRange] == 0 then
                                                                    --Check for underwater action if no nearby enemies as may not have done before
                                                                    GetUnderwaterActionForLandUnit(oPlatoon)
                                                                end
                                                                if oPlatoon[refiCurrentAction] == nil then
                                                                    --if not(sPlatoonName == M27Overseer.sIntelPlatoonRef) then --Dont want completion action for intel when it reaches the target path
                                                                    --Check for nearby reclaim and/or unclaimed mexes if are a builder platoon (e.g. ACU)
                                                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': About to check action for nearby mex, oPlatoon[refbConsiderMexes]='..tostring(oPlatoon[refbConsiderMexes])) end
                                                                    if oPlatoon[refbConsiderMexes] == true then DetermineActionForNearbyMex(oPlatoon) end
                                                                    if oPlatoon[refiCurrentAction] == nil then
                                                                        DetermineActionForNearbyHydro(oPlatoon)
                                                                        if oPlatoon[refiCurrentAction] == nil then
                                                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': About to check action for nearby reclaim if non-ACU platoon, oPlatoon[refbConsiderReclaim]='..tostring(oPlatoon[refbConsiderReclaim])) end
                                                                            --Consider reclaim if non-ACU platoon (ACU platoon considered earlier)
                                                                            if not(oPlatoon[refbACUInPlatoon]) and oPlatoon[refbConsiderReclaim] == true then DetermineActionForNearbyReclaim(oPlatoon) end
                                                                            if oPlatoon[refiCurrentAction] == nil then
                                                                                if oPlatoon[refbACUInPlatoon] == true and not(oPlatoon[M27PlatoonTemplates.refbUsedByThreatDefender]) then
                                                                                    local bACUUnderwater = M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit])
                                                                                    if not(bACUUnderwater) then
                                                                                        DetermineIfACUShouldBuildPower(oPlatoon)
                                                                                        if oPlatoon[refiCurrentAction] == nil then DetermineIfACUShouldBuildFactory(oPlatoon) end
                                                                                    end
                                                                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU is in platoon, action after checking to build power or land factory='..(oPlatoon[refiCurrentAction] or 'nil')) end
                                                                                    if oPlatoon[refiCurrentAction] == nil then
                                                                                        --Have we been assigned a mobile shield defender platoon whose nearest units are far away? If so fall back to meet up with them
                                                                                        RetreatToMobileShields(oPlatoon)
                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU is in platoon, action after checking if want to retreat to meet up with mobile shields='..(oPlatoon[refiCurrentAction] or 'nil')) end
                                                                                        if oPlatoon[refiCurrentAction] == nil then
                                                                                            --Do we want to get an upgrade?
                                                                                            DecideWhetherToGetACUUpgrade(aiBrain, oPlatoon)
                                                                                            if bDebugMessages == true then LOG(sFunctionRef..': Action after checking if want to get an upgrade='..(oPlatoon[refiCurrentAction] or 'nil')) end
                                                                                            --If in turtle mode then already considered if should assist nearby construction
                                                                                            if oPlatoon[refiCurrentAction] == nil and not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle) then
                                                                                                DecideWhetherACUShouldAssistConstruction(aiBrain, oPlatoon)
                                                                                            end
                                                                                        end
                                                                                    end
                                                                                end
                                                                                if oPlatoon[refiCurrentAction] == nil then
                                                                                    if not(oPlatoon[refbACUInPlatoon]) and oPlatoon[refiBuilders] > 0 then
                                                                                        GetNonACUBuilderAction(oPlatoon)
                                                                                    end
                                                                                    if oPlatoon[refiCurrentAction] == nil then
                                                                                        if bDebugMessages == true then LOG(sFunctionRef..': WIll check if platoon has reached its destination') end
                                                                                        --Check if have reached current or final destination (also update refiCurrentUnits and refiCurrentPathTarget):
                                                                                        if HasPlatoonReachedDestination(oPlatoon) == true then
                                                                                            IncreasePlatoonMovementPath(oPlatoon)
                                                                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Platoon has reached current destination; oPlatoon[refiCurrentPathTarget] after reaching destination='..oPlatoon[refiCurrentPathTarget]..'; size of movement path='..table.getn(oPlatoon[reftMovementPath])) end
                                                                                            --Check if reached final destination:
                                                                                            if oPlatoon[refiCurrentPathTarget] > table.getn(oPlatoon[reftMovementPath]) then
                                                                                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': refiCurrentPathTarget='..oPlatoon[refiCurrentPathTarget]..'; movement path table size='..table.getn(oPlatoon[reftMovementPath])..'; have reached final destination') end
                                                                                                DeterminePlatoonCompletionAction(oPlatoon)
                                                                                            else
                                                                                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Not reached final destination, will reissue movement path') end
                                                                                                oPlatoon[refiCurrentAction] = refActionReissueMovementPath
                                                                                                ForceActionRefresh(oPlatoon)
                                                                                            end
                                                                                        end
                                                                                    end
                                                                                end
                                                                            end
                                                                        end
                                                                    end

                                                                    --end
                                                                end
                                                                if oPlatoon[refiCurrentAction] == nil then
                                                                    --[[
                                                                    --Check if deviated from normal action previously and so now need to reset
                                                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': no current action after cehcking if reached destination and for nearby enemies; will resume movement path') end
                                                                    if not(oPlatoon[reftPrevAction][1] == nil) then
                                                                        if oPlatoon[reftPrevAction][1] == refActionAttack or oPlatoon[reftPrevAction][1] == refActionMoveDFToNearestEnemy then
                                                                            --Were previously attacking; if no units nearby then cancel
                                                                            if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] == 0 then
                                                                                oPlatoon[refiCurrentAction] = refActionContinueMovementPath
                                                                            end
                                                                        end
                                                                    end ]]
                                                                    --If not stuck, no nearby enemies (that warrant an action) and not reached destination then continue movement path:
                                                                    oPlatoon[refiCurrentAction] = refActionContinueMovementPath

                                                                end
                                                            end
                                                            --end
                                                        else
                                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Current actoin is:'..oPlatoon[refiCurrentAction]) end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        --Action changes in specific scenarios:

        --Disband if prev action was to disband:
        if oPlatoon[reftPrevAction][1] == refActionDisband then oPlatoon[refiCurrentAction] = refActionDisband end

        --If platoon has been told to continue its movement path, then check if it's reached its destination
        if (oPlatoon[refiCurrentAction] == refActionContinueMovementPath or oPlatoon[refiCurrentAction] == refActionReissueMovementPath) then
            if HasPlatoonReachedDestination(oPlatoon) == true then
                IncreasePlatoonMovementPath(oPlatoon)
                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Platoon has reached current destination; oPlatoon[refiCurrentPathTarget] after reaching destination='..oPlatoon[refiCurrentPathTarget]..'; size of movement path='..table.getn(oPlatoon[reftMovementPath])) end
                --Check if reached final destination:
                if oPlatoon[refiCurrentPathTarget] > table.getn(oPlatoon[reftMovementPath]) then
                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': refiCurrentPathTarget='..oPlatoon[refiCurrentPathTarget]..'; movement path table size='..table.getn(oPlatoon[reftMovementPath])..'; have reached final destination') end
                    DeterminePlatoonCompletionAction(oPlatoon)
                else
                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Not reached final destination, will reissue movement path') end
                    oPlatoon[refiCurrentAction] = refActionReissueMovementPath
                    ForceActionRefresh(oPlatoon)
                end
            else
                --Check if platoon was retreating due to insufficient threat, and if its threat is significantly higher now
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if we are retreating and (if so) if we are stronger than before. oPlatoon[refiThreatWhenRetreatToRallyOrBase]='..(oPlatoon[refiThreatWhenRetreatToRallyOrBase] or 'nil')..'; Cur threat='..M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits])..'; Front unit health %='..M27UnitInfo.GetUnitHealthPercent(oPlatoon[refoFrontUnit])) end
                if oPlatoon[refiThreatWhenRetreatToRallyOrBase] then
                    if (oPlatoon[refbACUInPlatoon] and M27UnitInfo.GetUnitHealthPercent(oPlatoon[reftBuilders][1]) >= 0.9) or M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits]) > 1.25 * oPlatoon[refiThreatWhenRetreatToRallyOrBase] then
                        oPlatoon[refiCurrentAction] = refActionNewMovementPath

                    end
                end
            end
        end




        --Get a new movement path if ACU is returning to base and was running previously
        if oPlatoon[refbACUInPlatoon] and (oPlatoon[refiCurrentAction] == refActionReissueMovementPath or oPlatoon[refiCurrentAction] == refActionContinueMovementPath) then
            if oPlatoon[refbNeedToHeal] == false and oPlatoon[refbHavePreviouslyRun] == true and oPlatoon[reftMovementPath][1] == M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber] then
                oPlatoon[refiCurrentAction] = refActionNewMovementPath
            end
        end

        --==========REFRESH DELAY LOGIC
        --No need to re-issue command if just gave it (will refresh slower instead) - helps both with performance and to guard against stuttering:
        --DEBUG ONLY
        if bDebugMessages == true then
            LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': End of choosing action, will now ignore if action is unchanged from before. Last type of order given to platoon='..(oPlatoon[refiLastOrderType] or 'nil')..'; oPlatoon[M27PlatoonTemplates.refbAttackMove]='..tostring(oPlatoon[M27PlatoonTemplates.refbAttackMove]))
            if oPlatoon[refiCurrentAction] == nil then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': iCurrentAction is nil')
            else LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': iCurrentAction='..oPlatoon[refiCurrentAction]) end

            if oPlatoon[reftPrevAction][1] == nil then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': 1st prev action is nil')
            else LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': 1st prev action='..oPlatoon[reftPrevAction][1]) end
        end

        local bRefreshAction = true
        local iRefreshActionThreshold = -100 --negative value means will refresh by default; If < this then won't refresh (subject to specific logic that might make this to always have a refresh); resets to 0 meaning will be this number + 1 cycles
        --[[if oPlatoon[refbHoverInPlatoon] then
            iRefreshActionThreshold = 5
            if sPlatoonName == 'M27MobileShield' then iRefreshActionThreshold = 3 end
        end--]]
        local bConsideredRefreshAlready = false
        --=======Ignore action in certain cases (e.g. we only just gave that action)
        if oPlatoon[refiCurrentAction] == refActionUpgrade then
            --want to have been wanting to get an upgrade for a while in a row, to account for scenarios where e.g. enemy untis are briefly moving out of our intel range
            iRefreshActionThreshold = 10
            --If underwater then reduce this threshold
            if M27UnitInfo.IsUnitUnderwater(oPlatoon[reftBuilders][1]) and not(M27Conditions.DoesACUHaveUpgrade(aiBrain)) then iRefreshActionThreshold = 2 end
            if bDebugMessages == true then LOG(sFunctionRef..': Want to do upgrade action; will increase refresh action threshold to make sure we want to do this for a while. iRefreshActionThreshold='..iRefreshActionThreshold) end
        end

        --special case for movement paths:
        if oPlatoon[refiCurrentAction] == refActionContinueMovementPath or oPlatoon[refiCurrentAction] == refActionReissueMovementPath then
            if oPlatoon[reftPrevAction][1] == refActionNewMovementPath or oPlatoon[reftPrevAction][1] == refActionReissueMovementPath or oPlatoon[reftPrevAction][1] == refActionContinueMovementPath then
                --Increase refresh threshold
                if bDebugMessages == true then
                    local iCurCycle = oPlatoon[refiRefreshActionCount]
                    if iCurCycle == nil then iCurCycle = 'nil' end
                    LOG(sFunctionRef..': Prev action was new movement path or refresh so only refresh on a much slower basis; oPlatoon[refiRefreshActionCount]='..iCurCycle)
                end
                iRefreshActionThreshold = 10
                if oPlatoon:GetPlan() == 'M27AttackNearestUnits' then iRefreshActionThreshold = 20
                else
                    if oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] == true or oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard] == true then
                        if oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] == true then
                            iRefreshActionThreshold = 2
                        else iRefreshActionThreshold = 20 end
                    end
                end
            end
        end
        if oPlatoon[reftPrevAction][1] == oPlatoon[refiCurrentAction] then
            iRefreshActionThreshold = 5 --redundancy in case forget to add in a later condition
            if bDebugMessages == true then LOG(sFunctionRef..': Cur action is same as prev action, will consider refresh action threshold to use') end
            if oPlatoon[refiCurrentAction] == refActionGoToRandomLocationForAWhile then
                iRefreshActionThreshold = 9
            elseif oPlatoon[refiCurrentAction] == refActionDisband then iRefreshActionThreshold = 0
            elseif oPlatoon[refiCurrentAction] == refActionMoveToTemporaryLocation then
                iRefreshActionThreshold = 9
                local tCurTarget
                if oPlatoon[refoFrontUnit].GetNavigator then
                    local oNavigator = oPlatoon[refoFrontUnit]:GetNavigator()
                    if oNavigator and oNavigator.GetCurrentTargetPos then
                        if M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftTemporaryMoveTarget], oNavigator:GetCurrentTargetPos()) >= 5 then
                            iRefreshActionThreshold = 1
                            if bDebugMessages == true then LOG(sFunctionRef..': Front platoon unit naviagor target='..repru(oNavigator:GetCurrentTargetPos())..'; temp move target='..repru(oPlatoon[reftTemporaryMoveTarget])..'; dist between them='..M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftTemporaryMoveTarget], oNavigator:GetCurrentTargetPos())..'; will reduce refresh rate to 1') end
                        elseif M27Utilities.GetDistanceBetweenPositions(oNavigator:GetCurrentTargetPos(), GetPlatoonFrontPosition(oPlatoon)) <= 2 then iRefreshActionThreshold = 2
                        end
                    end
                end
                --M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftTemporaryMoveTarget],
            else
                if oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] == true or oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard] == true then
                    if oPlatoon[refiCurrentAction] == refActionRun or oPlatoon[refiCurrentAction] == refActionTemporaryRetreat or oPlatoon[refiCurrentAction] == refActionKitingRetreat then
                        iRefreshActionThreshold = 3
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to run or retreat so setting iRefreshActionThreshold='..iRefreshActionThreshold) end
                    else
                        if oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard] == true then iRefreshActionThreshold = 20
                        else
                            iRefreshActionThreshold = 3
                        end
                    end
                else
                    if bDebugMessages == true then LOG('Prev action is same as current action, will set refreshaction to false unless due a refresh') end
                    if oPlatoon[refiCurrentAction] == refActionContinueMovementPath then
                        --Don't refresh if are continuing movement path unless are escorting
                        iRefreshActionThreshold = 50
                        bRefreshAction = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Continuing movement path so refresh threshold is very high at '..iRefreshActionThreshold) end
                    else
                        local bBuildingOrReclaimingLogic = false
                        --Building and reclaiming - base refresh on whether any units are building/reclaiming
                        if oPlatoon[refiCurrentAction] == refActionBuildMex or oPlatoon[refiCurrentAction] == refActionAssistConstruction or oPlatoon[refiCurrentAction] == refActionBuildFactory or oPlatoon[refiCurrentAction] == refActionBuildInitialPower or oPlatoon[refiCurrentAction] == refActionBuildStructure then
                            bBuildingOrReclaimingLogic = true
                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Checking if any buidlers ahve unit state building, otherwise will refresh action') end
                            for iBuilder, oBuilder in oPlatoon[reftBuilders] do
                                --Units can build something by 'repairing' it, so check for both unit states:
                                if bDebugMessages == true then LOG(sFunctionRef..': oBuilder='..oBuilder.UnitId..M27UnitInfo.GetUnitLifetimeCount(oBuilder)..'; Unit state='..M27Logic.GetUnitState(oBuilder)) end
                                if oBuilder:IsUnitState('Building') == true or (oBuilder:IsUnitState('Repairing') and (oBuilder:GetFocusUnit().GetFractionComplete and oBuilder:GetFocusUnit():GetFractionComplete() < 1)) then
                                    --refActionAssistConstruction - check that we have the target we want
                                    if not(oPlatoon[refiCurrentAction] == refActionAssistConstruction or (oBuilder.GetFocusUnit and oBuilder:GetFocusUnit() == oPlatoon[refoConstructionToAssist])) then
                                        oPlatoon[refbMovingToBuild] = false
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Builder is building, so dont refresh action') end
                                        bRefreshAction = false
                                        break
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': Action is to assist construction but our focus unit is different so will refresh action')
                                    end
                                elseif oBuilder:IsUnitState('Guarding') == true then
                                    --might be assisting construction of a unit/building, or just assisting an engineer - bellow will jsut check for the former
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Builder is guarding - check the unit being guarded') end
                                    if oBuilder.GetGuardedUnit then
                                        local oBeingBuilt = oBuilder:GetGuardedUnit()
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Obtained valid reference to guarded unit') end
                                        if oBeingBuilt.GetFractionComplete then
                                            if oBeingBuilt:GetFractionComplete() < 1 then
                                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Builder is assisting something that is being built, so dont refresh action') end
                                                bRefreshAction = false
                                                break
                                            end
                                        end
                                    end
                                elseif oBuilder:IsUnitState('Moving') == true then
                                    iRefreshActionThreshold = 10 --Might be trying to build ontop of current position, unless we arent close to the last build location
                                    if M27Utilities.IsTableEmpty(oPlatoon[reftLastBuildLocation]) == false and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[reftLastBuildLocation]) > 3 then
                                        iRefreshActionThreshold = 0
                                    end
                                else
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Considering whether to ignore refresh - unit state='..M27Logic.GetUnitState(oBuilder)) end
                                end
                            end
                        elseif oPlatoon[refiCurrentAction] == refActionReclaimTarget or oPlatoon[refiCurrentAction] == refActionReclaimAllNearby then
                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Action is to reclaim, First reclaimer in platoon status='..M27Logic.GetUnitState(oPlatoon[reftReclaimers][1])) end
                            bBuildingOrReclaimingLogic = true
                            bRefreshAction = true
                            iRefreshActionThreshold = 1
                            if oPlatoon[refiCurrentAction] == refActionReclaimAllNearby then iRefreshActionThreshold = 0 end --The reclaimallnearby logic already checks if position has moved so dont need a delay

                            if aiBrain:GetEconomyStoredRatio('MASS') <= 0.95 then
                                for iReclaimer, oReclaimer in oPlatoon[reftReclaimers] do
                                    if not(oReclaimer.Dead) then
                                        if oReclaimer:IsUnitState('Reclaiming') == true then
                                            if bDebugMessages == true then LOG(sFunctionRef..sPlatoonName..oPlatoon[refiPlatoonCount]..': Unit is reclaiming so dont want to refresh') end
                                            bRefreshAction = false
                                            break
                                        end
                                    end
                                end
                            end
                            --If unit state is reclaiming but target is a unit (not wreck) on full health or we havent started reclaiming yet, then still refresh
                            if not(bRefreshAction) and (oPlatoon[refbNotStartedReclaimingYet] or (M27UnitInfo.IsUnitValid(oPlatoon[refoNearbyReclaimTarget]) and M27UnitInfo.GetUnitHealthPercent(oPlatoon[refoNearbyReclaimTarget]) == 1)) then
                                iRefreshActionThreshold = 0
                                bRefreshAction = true
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bRefreshAction after checking if unit state is reclaiming='..tostring(bRefreshAction)) end
                        elseif oPlatoon[refiCurrentAction] == refActionAttackSpecificUnit then
                            --Has the unit changed?
                            if oPlatoon[refoTemporaryAttackTarget] == oPlatoon[refoPrevTemporaryAttackTarget] then
                                bRefreshAction = false
                            else
                                bRefreshAction = true
                                oPlatoon[refiRefreshActionCount] = iRefreshActionThreshold --to make sure we refresh
                            end
                        elseif oPlatoon[refiCurrentAction] == refActionMoveInCircle then
                            iRefreshActionThreshold = 4
                        elseif oPlatoon[refiCurrentAction] == refActionTemporaryRetreat or oPlatoon[refiCurrentAction] == refActionKitingRetreat then
                            if not (oPlatoon[refoFrontUnit]:IsUnitState('Moving')) then
                                iRefreshActionThreshold = 2
                            elseif oPlatoon[refoFrontUnit].GetNavigator then
                                local oNavigator = oPlatoon[refoFrontUnit]:GetNavigator()
                                if oNavigator and oNavigator.GetCurrentTargetPos then
                                    local tCurTarget = oNavigator:GetCurrentTargetPos()
                                    if M27Utilities.IsTableEmpty(tCurTarget) == false then
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Distance to navigator target=' .. M27Utilities.GetDistanceBetweenPositions(tCurTarget, GetPlatoonFrontPosition(oPlatoon)))
                                        end
                                        if M27Utilities.GetDistanceBetweenPositions(tCurTarget, GetPlatoonFrontPosition(oPlatoon)) <= 4 then
                                            iRefreshActionThreshold = 2
                                        else
                                            --Was aour last order a move order or is the front unit not moving?
                                            if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) then
                                                if not(oPlatoon[refoFrontUnit]:IsUnitState('Moving')) or (not(oPlatoon[refiLastOrderType] == refiOrderIssueMove) and not(oPlatoon[refiLastOrderType] == refiOrderIssueFormMove)) then
                                                    iRefreshActionThreshold = 2
                                                end
                                            end
                                        end
                                    else
                                        iRefreshActionThreshold = 3
                                    end
                                else
                                    --No navigator target - refresh every 3s to be safe
                                    iRefreshActionThreshold = 3
                                end
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Have a temporary retreat or kiting retreat action; need to check if are getting near our current location and reduce refresh interval if we are')
                                end
                            else
                                iRefreshActionThreshold = 5
                            end
                        elseif oPlatoon[refiCurrentAction] == refActionAttack then
                            if sPlatoonName == 'M27GroundExperimental' then
                                iRefreshActionThreshold = 0 --Wont clear commands if target to attack is different anyway, and experimental likely to kill a target within 1s
                            else
                                iRefreshActionThreshold = 3
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iRefreshActionThreshold after logic for where action is the same as before=' .. iRefreshActionThreshold)
            end
        else
            if oPlatoon[refiCurrentAction] == refActionAssistConstruction and oPlatoon[refiBuilders] > 0 then
                --Check if have any builders who are building
                for iBuilder, oBuilder in oPlatoon[reftBuilders] do
                    --Units can build something by 'repairing' it, so check for both unit states:
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': oBuilder=' .. oBuilder.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oBuilder) .. '; Unit state=' .. M27Logic.GetUnitState(oBuilder))
                    end
                    if oBuilder:IsUnitState('Building') == true or (oBuilder:IsUnitState('Repairing') and (oBuilder:GetFocusUnit().GetFractionComplete and oBuilder:GetFocusUnit():GetFractionComplete() < 1)) then
                        oPlatoon[refbMovingToBuild] = false
                        if bDebugMessages == true then
                            LOG(sPlatoonName .. oPlatoon[refiPlatoonCount] .. ': Builder is building, so dont refresh action')
                        end
                        bRefreshAction = false
                        break
                    end
                end
            end
            if bDebugMessages == true then
                LOG('Prev action is different to current action, so will refresh unless is a movement path special case or assisting building when already assisting; bRefreshAction=' .. tostring(bRefreshAction) .. '; iRefreshActionThreshold=' .. iRefreshActionThreshold)
            end
        end
        if bRefreshAction == true and not(oPlatoon[refiCurrentAction] == refActionDisband) then
            if oPlatoon[refbHoverInPlatoon] and (oPlatoon[reftPrevAction][1] == oPlatoon[refiCurrentAction] or ((oPlatoon[refiCurrentAction] == refActionContinueMovementPath or oPlatoon[refiCurrentAction] == refActionReissueMovementPath) and (oPlatoon[reftPrevAction][1] == refActionContinueMovementPath or oPlatoon[reftPrevAction][1] == refActionReissueMovementPath))) then
                if sPlatoonName == 'M27MobileShield' or sPlatoonName == 'M27MobileStealth' then
                    --Dont increase refresh threshold if shield isnt moving (in case it has reached its destination)
                    if oPlatoon[refoFrontUnit]:IsUnitState('Moving') then
                        iRefreshActionThreshold = iRefreshActionThreshold + 1
                    end
                else
                    iRefreshActionThreshold = iRefreshActionThreshold + 4
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Have hover in platoon so have increased refresh threshold to '..iRefreshActionThreshold) end
            end
            --Reduce refresh threshold if front unit is idle
            if oPlatoon[refoFrontUnit].IsUnitState and M27Logic.IsUnitIdle(oPlatoon[refoFrontUnit]) then
                iRefreshActionThreshold = math.max(1, iRefreshActionThreshold - 8)
            end

            if (oPlatoon[refiRefreshActionCount] or 0) < iRefreshActionThreshold then
                bRefreshAction = false
            end

            if bDebugMessages == true then
                LOG('RefreshCount=' .. (oPlatoon[refiRefreshActionCount] or 'nil') .. '; bRefreshAction=' .. tostring(bRefreshAction) .. '; oPlatoon[refbHoverInPlatoon]=' .. tostring(oPlatoon[refbHoverInPlatoon]))
            end
        end


        --Check for forced refresh:
        if bRefreshAction == false then
            if oPlatoon[refbForceActionRefresh] == true then
                if bDebugMessages == true then
                    LOG(sPlatoonName .. oPlatoon[refiPlatoonCount] .. ': Forced refresh of platoon action activated')
                end
                oPlatoon[refbForceActionRefresh] = false
                oPlatoon[refiGameTimeOfLastRefresh] = GetGameTimeSeconds()
                bRefreshAction = true
            end
        end


        --Action the decision on whether to refresh or not
        if bRefreshAction == true then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': bRefreshAction is true; oPlatoon[refiRefreshActionCount] before reset=' .. (oPlatoon[refiRefreshActionCount] or 'nil') .. '; iRefreshActionThreshold=' .. (iRefreshActionThreshold or 'nil'))
            end
            oPlatoon[refiRefreshActionCount] = 0
            if oPlatoon[refiCurrentAction] == refActionContinueMovementPath then
                oPlatoon[refiCurrentAction] = refActionReissueMovementPath
            end
        else
            if bDebugMessages == true then
                LOG(sPlatoonName .. oPlatoon[refiPlatoonCount] .. ': ' .. sFunctionRef .. ': Ignoring current action as is same as prev action so setting to nil')
            end
            oPlatoon[refiCurrentAction] = nil
            if oPlatoon[refiRefreshActionCount] == nil then
                oPlatoon[refiRefreshActionCount] = 0
            end
            oPlatoon[refiRefreshActionCount] = oPlatoon[refiRefreshActionCount] + (oPlatoon[refiSecondsSinceLastCycle] or 1)
        end

        if bDebugMessages == true then
            --M27EngineerOverseer.TEMPTEST(aiBrain, 'Determineplatoon action - end of code')
            if oPlatoon[refiCurrentAction] == nil then
                LOG(sPlatoonName .. oPlatoon[refiPlatoonCount] .. ': ' .. sFunctionRef .. ': End of code; refiCurrentAction=nil')
            else
                LOG(sPlatoonName .. oPlatoon[refiPlatoonCount] .. ': ' .. sFunctionRef .. ': End of code; refiCurrentAction=' .. oPlatoon[refiCurrentAction] .. '; bRefreshAction=' .. tostring(bRefreshAction))
            end
            if oPlatoon[refiExtraAction] == nil then
                LOG(sPlatoonName .. oPlatoon[refiPlatoonCount] .. ':' .. sFunctionRef .. ': End of code, refiExtraAction is nil')
            else
                LOG(sPlatoonName .. oPlatoon[refiPlatoonCount] .. ':' .. sFunctionRef .. ': End of code, refiExtraAction is ' .. oPlatoon[refiExtraAction])
            end
            LOG('refbHavePreviouslyRun=' .. tostring(oPlatoon[refbHavePreviouslyRun]))
        end
        --end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ReturnToBaseOrRally(oPlatoon, tLocationToReturnTo, iOnlyGoThisFarTowardsBase, bDontClearActions, bUseTemporaryMoveLocation)
    --Resets movement path so it is only going to return to base (meaning it will be treated as reaching final destination when it gets there)
    --iOnlyGoThisFarTowardsBase - if nil then go all the way to base, otherwise go x distance from current position
    --bUseTemporaryMoveLocation - if true then will assign a temporary move location instead of replacing the current move location
    local sFunctionRef = 'ReturnToBaseOrRally'
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local sPlatoonName = oPlatoon:GetPlan()
    --if oPlatoon[refbACUInPlatoon] == true and GetGameTimeSeconds() >= 300 then bDebugMessages = true end
    --if sPlatoonName == 'M27GroundExperimental' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
    --if sPlatoonName == 'M27ScoutAssister' then bDebugMessages = true end
    --if sPlatoonName == 'M27MAAAssister' then bDebugMessages = true end
    --if oPlatoon:GetPlan() == 'M27AttackNearestUnits' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
    --if sPlatoonName == 'M27RAS' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end

    local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
    local iArmyStartNumber = aiBrain.M27StartPositionNumber

    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': 1s loop: Running away - moving to start position; bDontClearActions='..tostring((bDontClearActions or false))) end
    if bDontClearActions == nil then bDontClearActions = false end
    if bDontClearActions == false then
        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
        M27Utilities.IssueTrackedClearCommands(GetPlatoonUnitsOrUnitCount(oPlatoon, reftCurrentUnits, false, true))
    end
    if bUseTemporaryMoveLocation == nil then bUseTemporaryMoveLocation = false end
    oPlatoon:SetPlatoonFormationOverride('GrowthFormation')

    oPlatoon[reftTemporaryMoveTarget] = {}
    if not(bUseTemporaryMoveLocation) then oPlatoon[reftMovementPath] = {} end
    local tNewDestination = {}
    if iOnlyGoThisFarTowardsBase == nil then
        if bDebugMessages == true then LOG(sPlatoonName..': Going to go all the way back to base') end
        tNewDestination = tLocationToReturnTo
    else
        local tPlatoonPosition = GetPlatoonFrontPosition(oPlatoon)
        local iDistToStart = M27Utilities.GetDistanceBetweenPositions(tPlatoonPosition, tLocationToReturnTo)
        if bDebugMessages == true then LOG(sPlatoonName..': iDistToStart='..iDistToStart..'; iOnlyGoThisFarTowardsBase='..iOnlyGoThisFarTowardsBase) end
        if iOnlyGoThisFarTowardsBase >= iDistToStart then tNewDestination = tLocationToReturnTo
        else
            --GetPositionNearTargetInSamePathingGroup(tStartPos, tTargetPos, iDistanceFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions)
            --MoveTowardsTarget(tStartPos, tTargetPos, iDistanceToTravel, iAngle)
            local oPathingUnit = GetPathingUnit(oPlatoon, oPlatoon[refoPathingUnit], true)
            if oPathingUnit and not(oPathingUnit.Dead) then
                --tNewDestination = GetPositionNearTargetInSamePathingGroup(tPlatoonPosition, M27MapInfo.PlayerStartPoints[iArmyStartNumber], iDistToStart - iOnlyGoThisFarTowardsBase, 0, oPathingUnit, 1, true)
                tNewDestination = GetPositionAtOrNearTargetInPathingGroup(tPlatoonPosition, tLocationToReturnTo, iDistToStart - iOnlyGoThisFarTowardsBase, 0, oPathingUnit, false, true, 2)
                --M27Utilities.MoveTowardsTarget(tPlatoonPosition, M27MapInfo.PlayerStartPoints[iArmyStartNumber], iOnlyGoThisFarTowardsBase, 0)
                if tNewDestination == nil then tNewDestination =  tLocationToReturnTo end
                if bDebugMessages == true then LOG(sPlatoonName..': Sent order to only go part of the way back towawrds base, to tNewDestination='..repru(tNewDestination or {'nil'})..'; tLocationToReturnTo (i.e. would have moved towards here)='..repru(tLocationToReturnTo or {'nil'})) end
            else
                if oPlatoon then
                    if bDebugMessages == true then LOG(sPlatoonName..': ReturnToBase: Were returning to base but pathing unit is nil or dead so disbanding') end
                    oPlatoon[refiCurrentAction] = refActionDisband
                end
            end
        end
    end
    PlatoonMove(oPlatoon, tNewDestination)

    if bUseTemporaryMoveLocation == true then
        oPlatoon[reftTemporaryMoveTarget] = tNewDestination
        if bDebugMessages == true then LOG(sFunctionRef..': Setting temporary move target to '..repru(oPlatoon[reftTemporaryMoveTarget])) end
    else
        oPlatoon[reftMovementPath] = {}
        oPlatoon[reftMovementPath][1] = tNewDestination
        oPlatoon[refiCurrentPathTarget] = 1
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    --oPlatoon[refiLastPathTarget] = 1
    --WaitSeconds(2)
end

function ReconsiderTarget(oPlatoon, tTargetDestination, bDontIncreaseCount)
    --Considers if the platoon has tried going to this target multiple times and if it can path to the target easily
    --if bDontIncreaseCount is true then it wont treat the platoon as trying to go to the target destination
    --returns true if need to reconsider target
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReconsiderTarget'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local sLocationRef = M27Utilities.ConvertLocationToReference(tTargetDestination)
    local bReconsider = false
    if not(bDontIncreaseCount) then oPlatoon[reftDestinationCount][sLocationRef] = (oPlatoon[reftDestinationCount][sLocationRef] or 0) + 1
    elseif oPlatoon[reftDestinationCount][sLocationRef] == nil then oPlatoon[reftDestinationCount][sLocationRef] = 0 end
    if oPlatoon[reftDestinationCount][sLocationRef] > 15 then
        bReconsider = true
    elseif oPlatoon[reftDestinationCount][sLocationRef] >= 3 and M27Utilities.GetDistanceBetweenPositions(tTargetDestination, GetPlatoonFrontPosition(oPlatoon)) < math.max(60, (M27Logic.GetUnitMaxGroundRange({ oPlatoon[refoFrontUnit] }) or 0) * 1.5) then
        if M27Utilities.GetDistanceBetweenPositions(tTargetDestination, GetPlatoonFrontPosition(oPlatoon)) <= 1 then
            bReconsider = true
        else
            --If we move in a line to the target, are there any pathing issues? Use front unit rather than pathing unit
            bReconsider = not(M27MapInfo.CanWeMoveInSameGroupInLineToTarget(M27UnitInfo.GetUnitPathingType(oPlatoon[refoFrontUnit]), GetPlatoonFrontPosition(oPlatoon), tTargetDestination))
        end
    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return bReconsider
end

function GetNearestLocationWithFewestVisitations(oPlatoon, tLocationsToChooseFrom, bIncreaseVisitationCount)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestLocationWithFewestVisitations'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    --if oPlatoon:GetPlan() == 'M27PlateauLandCombat' then bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': oPlatoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'; bIncreaseVisitationCount='..tostring(bIncreaseVisitationCount or false)..'; tLocationsToChooseFrom='..repru(tLocationsToChooseFrom or {'nil'})) end
    if M27Utilities.IsTableEmpty(tLocationsToChooseFrom) then
        M27Utilities.ErrorHandler('tLocationsToChooseFrom is empty. oPlatoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount])
    else
        local sLocationRef
        local iCurVisitationCount
        local iMinVisitationCount = 10000
        local iCurDist
        local iMinDist = 10000
        local iClosestPositionRef

        for iLocationRef, tLocation in tLocationsToChooseFrom do
            sLocationRef = M27Utilities.ConvertLocationToReference(tLocation)
            iCurVisitationCount = (oPlatoon[refiLocationVisitationCount][sLocationRef] or 0)
            if iCurVisitationCount < iMinVisitationCount then
                iMinVisitationCount = iCurVisitationCount
                iMinDist = 10000
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering location with sLocationRef'..sLocationRef..'; iCurVisitationCount='..iCurVisitationCount..'; iMinVisitationCount='..iMinVisitationCount) end

            if iCurVisitationCount <= iMinVisitationCount then
                iCurDist = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tLocation)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurDist='..iCurDist..'; iMinDist='..iMinDist) end
                if iCurDist < iMinDist then
                    iMinDist = iCurDist
                    iClosestPositionRef = iLocationRef
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a potential location, sLocationRef='..sLocationRef) end
                end
            end
        end
        if bIncreaseVisitationCount then
            sLocationRef = M27Utilities.ConvertLocationToReference(tLocationsToChooseFrom[iClosestPositionRef])
            oPlatoon[refiLocationVisitationCount][sLocationRef] = (oPlatoon[refiLocationVisitationCount][sLocationRef] or 0) + 1
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Will return iClosestPositionRef='..iClosestPositionRef..'; location='..repru(tLocationsToChooseFrom[iClosestPositionRef])) end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return tLocationsToChooseFrom[iClosestPositionRef]
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return nil
end

function GetPlateauMovementPath(oPlatoon, bDontClearActions)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPlateauMovementPath'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon:GetPlan() == 'M27PlateauIndirect' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
    --if oPlatoon:GetPlan() == 'M27PlateauScout' then bDebugMessages = true end
    if bDebugMessages == true then LOG(sFunctionRef..': Platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Start of code') end
    local iPlateauGroup = oPlatoon[M27Transport.refiAssignedPlateau]
    local bAbort = false
    if M27Utilities.IsTableEmpty(M27MapInfo.tAllPlateausWithMexes[iPlateauGroup]) or M27Utilities.IsTableEmpty(M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMidpoint]) or not(M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMaxRadius]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..' has an assigned plateau which has empty table of mex/midpoint='..(iPlateauGroup or 'nil')) end
        oPlatoon[M27Transport.refiAssignedPlateau] = oPlatoon[refoFrontUnit][M27Transport.refiAssignedPlateau]
        iPlateauGroup = oPlatoon[M27Transport.refiAssignedPlateau]
        if M27Utilities.IsTableEmpty(M27MapInfo.tAllPlateausWithMexes[iPlateauGroup]) or M27Utilities.IsTableEmpty(M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMidpoint]) or M27Utilities.IsTableEmpty(M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMaxRadius]) then
            bAbort = true
            M27Utilities.ErrorHandler('Platoon plateau isnt recognised, will move platoon to a random point around current position')
            if bDebugMessages == true then LOG(sFunctionRef..': Platoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]) end
            oPlatoon[reftMovementPath] = {}
            oPlatoon[refiCurrentPathTarget] = 1
            oPlatoon[reftMovementPath][1] = {GetPlatoonFrontPosition(oPlatoon)[1] + math.random(-5, 5), 0, GetPlatoonFrontPosition(oPlatoon)[3] + math.random(-5, 5)}
            MoveAlongPath(oPlatoon, oPlatoon[reftMovementPath], 1, bDontClearActions)
        end
    end



    local bGetSupportPath = false
    if not(bAbort) then
        if oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] == true or oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard] == true then
            if bDebugMessages == true then LOG(sFunctionRef..': Platoon is flagged as wanting to follow a unit or location, so likely a scout, will check if it needs a target assigning') end
            bGetSupportPath = true
            --Assumes we are dealing with a scout; do we need a target assigning?
            if M27Utilities.IsTableEmpty(oPlatoon[reftLocationToGuard]) and not (DoesPlatoonStillHaveSupportTarget(oPlatoon)) then
                local iRoamingScouts = 0
                local aiBrain = oPlatoon:GetBrain()
                local bAbort = false
                if M27Utilities.IsTableEmpty(aiBrain[M27MapInfo.reftOurPlateauInformation][oPlatoon[M27Transport.refiAssignedPlateau]][M27MapInfo.subrefPlateauScoutPlatoons]) == false then
                    for iPlatoon, oScoutPlatoon in aiBrain[M27MapInfo.reftOurPlateauInformation][oPlatoon[M27Transport.refiAssignedPlateau]][M27MapInfo.subrefPlateauScoutPlatoons] do
                        if not(oScoutPlatoon == oPlatoon) then
                            if aiBrain:PlatoonExists(oScoutPlatoon) then
                                if oScoutPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] == false and not(oScoutPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard]) then
                                    iRoamingScouts = iRoamingScouts + 1
                                end
                            else
                                --Platoon doesnt exist
                                aiBrain[M27MapInfo.reftOurPlateauInformation][oPlatoon[M27Transport.refiAssignedPlateau]][M27MapInfo.subrefPlateauScoutPlatoons][iPlatoon] = nil
                            end
                        end
                    end
                else
                    --Likely error in pathfinding
                    if M27UnitInfo.IsUnitValid(oPlatoon[refoPathingUnit]) then
                        bAbort = M27MapInfo.RecheckPathingOfLocation(M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit]), oPlatoon[refoPathingUnit], GetPlatoonFrontPosition(oPlatoon))
                        bGetSupportPath = false
                    end
                end

                --Do any of the platoons in the plateau need a scout assigned?
                if iRoamingScouts == 0 and not(bAbort) then
                    --Make this a roaming scout
                    oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] = false
                    oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard] = false
                    bGetSupportPath = false
                elseif not(bAbort) then --Already have a roaming scout; check if any land platoons need a scout
                    local iPlateauGroup = oPlatoon[M27Transport.refiAssignedPlateau]
                    local oPlatoonWantingScout
                    for iPlatoonSubref, sPlatoonSubref in {M27MapInfo.subrefPlateauLandCombatPlatoons, M27MapInfo.subrefPlateauIndirectPlatoons, M27MapInfo.subrefPlateauMAAPlatoons} do
                        if M27Utilities.IsTableEmpty(aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][sPlatoonSubref]) == false then
                            for iPlatoon, oPlateauPlatoon in aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][sPlatoonSubref] do
                                if aiBrain:PlatoonExists(oPlateauPlatoon) then
                                    if not(oPlateauPlatoon[M27Overseer.refoScoutHelper]) or (oPlateauPlatoon[M27Overseer.refoScoutHelper][refiCurrentUnits] or 0) == 0 then
                                        oPlatoonWantingScout = oPlateauPlatoon
                                        break
                                    end
                                else
                                    aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][sPlatoonSubref][iPlatoon] = nil
                                end
                            end
                        end
                    end
                    if oPlatoonWantingScout then
                        oPlatoon[refoSupportHelperPlatoonTarget] = oPlatoonWantingScout
                        oPlatoonWantingScout[M27Overseer.refoScoutHelper] = oPlatoon
                    else
                        --Make this a roaming scout
                        oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] = false
                        oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard] = false
                        bGetSupportPath = false
                    end
                end
            end
        end
        if bGetSupportPath then
            if bDebugMessages == true then LOG(sFunctionRef..': Will refresh support movement path') end
            RefreshSupportPlatoonMovementPath(oPlatoon)
        else
            oPlatoon[reftMovementPath] = {}
            oPlatoon[refiCurrentPathTarget] = 1
            local sPlatoonName = oPlatoon:GetPlan()

            local aiBrain = oPlatoon:GetBrain()
            if bDebugMessages == true then LOG(sFunctionRef..': iPlateauGroup='..iPlateauGroup..'; will get plan specific logic for new movement path') end
            if sPlatoonName == 'M27PlateauLandCombat' or sPlatoonName == 'M27PlateauIndirect' then
                --Does the enemy have any buildings on the plateau? If so then target the nearest one

                local tEnemyStructures = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure, M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMidpoint], M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMaxRadius], 'Enemy')
                local oNearestUnit

                if M27Utilities.IsTableEmpty(tEnemyStructures) == false then
                    local iNearestDist = 100000
                    local iCurDist
                    local sPathing = M27UnitInfo.refPathingTypeAmphibious

                    for iUnit, oUnit in tEnemyStructures do
                        if M27MapInfo.GetSegmentGroupOfLocation(sPathing, oUnit:GetPosition()) == iPlateauGroup then
                            iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                            if iCurDist < iNearestDist then
                                iCurDist = iNearestDist
                                oNearestUnit = oUnit
                            end
                        end
                    end
                end
                if oNearestUnit then
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy structures detected so will move to the nearest one') end
                    oPlatoon[reftMovementPath][1] = oNearestUnit:GetPosition()
                else
                    --Get the nearest mex in the plateau with the lowest visitation count
                    if M27Utilities.IsTableEmpty(M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMexes]) == false then
                        oPlatoon[reftMovementPath][1] = GetNearestLocationWithFewestVisitations(oPlatoon, M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMexes], true)
                    else
                        oPlatoon[reftMovementPath][1] = M27Logic.GetRandomPointInAreaThatCanPathTo(M27UnitInfo.refPathingTypeAmphibious, iPlateauGroup, GetPlatoonFrontPosition(oPlatoon), 25, 5)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have got the nearest mex with the lowest visitation count, movement path='..repru(oPlatoon[reftMovementPath][1] or {'nil'})) end
                end
            elseif sPlatoonName == 'M27PlateauMAA' then
                local tOwnedMexes = {}
                local iOwnedMexes = 0

                if M27Utilities.IsTableEmpty(M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMexes]) == false then
                    for iMex, tMexPosition in M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMexes] do
                        --Treat everything as unclaimed except mexes we or ally have b uilt on, that way can just refer to this
                        if M27Conditions.IsMexUnclaimed(aiBrain, tMexPosition, true, false, true) == false then
                            iOwnedMexes = iOwnedMexes + 1
                            tOwnedMexes[iOwnedMexes] = tMexPosition
                        end
                    end
                end
                if iOwnedMexes > 0 then
                    oPlatoon[reftMovementPath][1] = GetNearestLocationWithFewestVisitations(oPlatoon, tOwnedMexes, true)
                else
                    oPlatoon[reftMovementPath][1] = M27Logic.GetRandomPointInAreaThatCanPathTo(M27UnitInfo.refPathingTypeAmphibious, iPlateauGroup, GetPlatoonFrontPosition(oPlatoon), 25, 5)
                end
            elseif sPlatoonName == 'M27PlateauScout' then
                if M27Utilities.IsTableEmpty(M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMexes]) == false then
                    oPlatoon[reftMovementPath][1] = GetNearestLocationWithFewestVisitations(oPlatoon, M27MapInfo.tAllPlateausWithMexes[iPlateauGroup][M27MapInfo.subrefPlateauMexes], true)
                else
                    oPlatoon[reftMovementPath][1] = M27Logic.GetRandomPointInAreaThatCanPathTo(M27UnitInfo.refPathingTypeAmphibious, iPlateauGroup, GetPlatoonFrontPosition(oPlatoon), 25, 5)
                end
            else
                local bPathingWasWrong = M27MapInfo.RecheckPathingOfLocation(M27UnitInfo.refPathingTypeAmphibious, oPlatoon[refoFrontUnit], GetPlatoonFrontPosition(oPlatoon))
                if bPathingWasWrong == false then
                    M27Utilities.ErrorHandler('Unrecognised plateau platoon type; plan name='..oPlatoon:GetPlan()..'; will tell it to go to a random point nearby, and will check pathing. bPathingWasWrong='..tostring(bPathingWasWrong))
                end
                oPlatoon[reftMovementPath][1] = {GetPlatoonFrontPosition(oPlatoon)[1] + math.random(-20, 20), 0, GetPlatoonFrontPosition(oPlatoon)[3] + math.random(-20, 20)}
                oPlatoon[reftMovementPath][1][1] = GetSurfaceHeight(oPlatoon[reftMovementPath][1][1], oPlatoon[reftMovementPath][1][3])
                --M27Logic.GetRandomPointInAreaThatCanPathTo(M27UnitInfo.refPathingTypeAmphibious, iPlateauGroup, GetPlatoonFrontPosition(oPlatoon), 25, 5)
                if bPathingWasWrong then
                    oPlatoon[M27Transport.refiAssignedPlateau] = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, GetPlatoonFrontPosition(oPlatoon))
                end
            end
            --Backup for if couldnt find a valid position to path to:
            if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath]) or M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath][1]) then
                M27Utilities.ErrorHandler('Platoon has no movement path, will tell it go to a random point nearby')
                oPlatoon[reftMovementPath][1] = {GetPlatoonFrontPosition(oPlatoon)[1] + math.random(-5, 5), 0, GetPlatoonFrontPosition(oPlatoon)[3] + math.random(-5, 5)}
                oPlatoon[reftMovementPath][1][2] = GetSurfaceHeight(oPlatoon[reftMovementPath][1][1], oPlatoon[reftMovementPath][1][3])
            end

            MoveAlongPath(oPlatoon, oPlatoon[reftMovementPath], 1, bDontClearActions)
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetNewMovementPath(oPlatoon, bDontClearActions)
    --Sets the movement path variable for oPlatoon and then tells it to move along this
    --bDontClearActions: Set to true if want to add the movement actions to existing orders (e.g. if have issued secondary action such as overcharge)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNewMovementPath'
    M27Utilities.FunctionProfiler(sFunctionRef..': Total', M27Utilities.refProfilerStart)
    local aiBrain = oPlatoon:GetBrain()
    if not(aiBrain[M27Logic.refbAllEnemiesDead]) then
        oPlatoon[refiMultiPathReissueCount] = 0 --used to run backup pathing check
        oPlatoon[refiThreatWhenRetreatToRallyOrBase] = nil

        if oPlatoon[M27Transport.refiAssignedPlateau] and not(oPlatoon[M27Transport.refiAssignedPlateau] == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) then
            GetPlateauMovementPath(oPlatoon, bDontClearActions)
        else
            local sPlatoonName = oPlatoon:GetPlan()
            local bPlatoonNameDisplay = false
            if M27Config.M27ShowUnitNames == true then bPlatoonNameDisplay = true end
            M27Utilities.FunctionProfiler(sFunctionRef..': '..sPlatoonName, M27Utilities.refProfilerStart)
            --if sPlatoonName == 'M27LargeAttackForce' then bDebugMessages = true end

            --if sPlatoonName == 'M27IntelPathAI' then bDebugMessages = true end
            --if oPlatoon[refbACUInPlatoon] == true and GetGameTimeSeconds() >= 300 then bDebugMessages = true end
            --if EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId) then bDebugMessages = true end
            --if sPlatoonName == 'M27ScoutAssister' then bDebugMessages = true end
            --if sPlatoonName == 'M27MAAAssister' then bDebugMessages = true end
            --if sPlatoonName == 'M27EscortAI' then bDebugMessages = true end
            --if sPlatoonName == 'M27CombatPatrolAI' and oPlatoon[refiPlatoonCount] == 1 and GetGameTimeSeconds() >= 480 and aiBrain:GetArmyIndex() == 3 then bDebugMessages = true end
            --if sPlatoonName == 'M27IndirectDefender' then bDebugMessages = true end
            --if sPlatoonName == 'M27RetreatingShieldUnits' then bDebugMessages = true end
            --if sPlatoonName == 'M27MobileShield' then bDebugMessages = true end
            --if sPlatoonName == 'M27IndirectSpareAttacker' and oPlatoon[refiPlatoonCount] == 26 then bDebugMessages = true end
            --if sPlatoonName == 'M27MexLargerRaiderAI' and oPlatoon[refiPlatoonCount] == 5 and GetGameTimeSeconds() >= 465 then bDebugMessages = true end
            --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
            --if sPlatoonName == 'M27PlateauLandCombat' then bDebugMessages = true end
            --if sPlatoonName == 'M27DefenderAI' and oPlatoon[refiPlatoonCount] == 3 then bDebugMessages = true end

            local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
            --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Start of code') end
            local bDisbandAsNoUnits = false
            local bDontActuallyMove = false
            oPlatoon[refiCurrentPathTarget] = 1 --Redundancy, think put this elsewhere as well
            --If have ACU in the platoon then remove it unless its the ACU platoon
            if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..'-'..oPlatoon[refiPlatoonUniqueCount]..': A'..refActionNewMovementPath) end
            if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': Start of code, GettingNewMovementPath at game time '..GetGameTimeSeconds()) end
            local tCurPosition = GetPlatoonFrontPosition(oPlatoon)
            local bDontGetNewPath = false

            --Record whether we need to heal now, so can get a new movement path if we no longer need to heal later on
            oPlatoon[refbNeededToHealWhenGotMovementPath] = oPlatoon[refbNeedToHeal]

            --Update platoon action so it knows we have got a new movement path recently
            oPlatoon[refiCurrentAction] = refActionNewMovementPath

            if oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] == true or oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard] == true then
                if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonName..': About to refresh support platoon movement path') end
                RefreshSupportPlatoonMovementPath(oPlatoon)
            else
                local bHaveEmptyMovementPath = true
                if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath]) == false then
                    for iPath, tPath in oPlatoon[reftMovementPath] do
                        if M27Utilities.IsTableEmpty(tPath) == false then
                            bHaveEmptyMovementPath = false
                            break
                        end
                    end
                end
                if bHaveEmptyMovementPath == true then
                    if oPlatoon[reftMovementPath] == nil then oPlatoon[reftMovementPath] = {} end
                    if oPlatoon[reftMovementPath][1] == nil then oPlatoon[reftMovementPath][1] = {} end
                else
                    --Have we already got a movement path and no previous action (e.g. defender platoon created and assigned its movement path)
                    if M27Utilities.IsTableEmpty(oPlatoon[reftPrevAction]) == true then
                        --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Changing action to reissue movement path') end
                        bDontGetNewPath = true
                        oPlatoon[refiCurrentAction] = refActionReissueMovementPath
                        if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonName..oPlatoon[refiPlatoonCount]..': Have no prev action and ahve a valid movement path='..repru(oPlatoon[reftMovementPath])) end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': bDontGetNewPath='..tostring(bDontGetNewPath)) end

                if bDontGetNewPath == false then

                    --First check if we can path to the enemy, if not then udpate pathing for platoon
                    local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoFrontUnit])
                    --Note - need to use frontunit position just in case platoon front position is dif leading to inconsistency in logic
                    if not(M27MapInfo.GetSegmentGroupOfLocation(sPathing, oPlatoon[refoFrontUnit]:GetPosition()) == M27MapInfo.GetSegmentGroupOfLocation(sPathing, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) then
                        if bDebugMessages == true then LOG(sFunctionRef..': platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Front unit position='..repru(oPlatoon[refoFrontUnit]:GetPosition())..'; unit='..oPlatoon[refoFrontUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(oPlatoon[refoFrontUnit])..': Showing as a dif pathing group to base, so will do a CanPathTo to see if it really is different') end
                        --Cant path to base - double-check pathing if havent already
                        M27MapInfo.RecheckPathingOfLocation(sPathing, oPlatoon[refoFrontUnit], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], nil)
                    end


                    if sPlatoonName == 'M27LargeAttackForce' then
                        --Choose mex in enemy base as the end destination
                        oPlatoon[reftMovementPath] = M27Logic.GetMexRaidingPath(oPlatoon, 0, 15, 50, true)
                        --oPlatoon[refiLastPathTarget] = table.getn(oPlatoon[reftMovementPath])
                    elseif sPlatoonName == 'M27AttackNearestUnits' then
                        if M27Logic.GetNearestEnemyStartNumber(aiBrain) == nil then
                            LOG(sFunctionRef..':'..sPlatoonName..': EnemyStartNumber=nil, ERROR unless enemy dead')
                            if math.random(0,1) == 0 then
                                oPlatoon[reftMovementPath][1] = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                            else oPlatoon[reftMovementPath][1] = M27MapInfo.aiBrain[reftPrimaryEnemyBaseLocation]
                            end
                        else
                            local tTargetBase = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                            if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath][1]) == true or not(oPlatoon[reftMovementPath][1][1] == tTargetBase[1] and oPlatoon[reftMovementPath][1][3] == tTargetBase[3]) then
                                oPlatoon[reftMovementPath][1] = tTargetBase
                            else
                                --Already targeting nearest enemy - go back to nearest rally point instead if we arent close to the nearest enemy
                                if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tTargetBase) <= 20 then
                                    oPlatoon[reftMovementPath][1] = M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit])
                                else
                                    --Still retain target base
                                    oPlatoon[reftMovementPath][1] = tTargetBase
                                end
                            end
                        end
                        oPlatoon[refiCurrentPathTarget] = 1
                    elseif sPlatoonName == 'M27GroundExperimental' then
                        oPlatoon[reftMovementPath] = {}
                        --Do we have a chokepoint on our team? If so then defend the nearest one if the enemy has a certain level of mobile threat
                        local tChokepointToDefend
                        if (aiBrain[M27Overseer.refiTotalEnemyShortRangeThreat] >= 21000 or aiBrain[M27Overseer.refiTotalEnemyLongRangeThreat] >= 21000 or oPlatoon[refbHavePreviouslyRun]) and not(M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27MapInfo.tiPlannedChokepointsByDistFromStart])) then
                            local iNearestChokepointDist = 10000
                            local iCurDist
                            for iBrain, oBrain in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyActiveM27Brains] do
                                if oBrain[M27Overseer.refiDefaultStrategy] == M27Overseer.refStrategyTurtle then
                                    iCurDist = M27Utilities.GetDistanceBetweenPositions(oBrain[M27MapInfo.reftChokepointBuildLocation], GetPlatoonFrontPosition(oPlatoon))
                                    if bDebugMessages == true then LOG(sFunctionRef..': oBrain index '..oBrain:GetArmyIndex()..'; name='..oBrain.Nickname..'; Chokepoint='..repru(oBrain[M27MapInfo.reftChokepointBuildLocation] or {'nil'})..'; Dist to chokepoint='..iCurDist..'; iNearestChokepointDist='..iNearestChokepointDist) end
                                    if iCurDist < iNearestChokepointDist then
                                        tChokepointToDefend = {oBrain[M27MapInfo.reftChokepointBuildLocation][1], oBrain[M27MapInfo.reftChokepointBuildLocation][2], oBrain[M27MapInfo.reftChokepointBuildLocation][3]}
                                        iNearestChokepointDist = iCurDist
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a ground experimental, Is tChokepointToDefend empty='..tostring(M27Utilities.IsTableEmpty(tChokepointToDefend))) end
                        if not(tChokepointToDefend) and (aiBrain[M27Overseer.refiTotalEnemyShortRangeThreat] >= 21000 or aiBrain[M27Overseer.refiTotalEnemyLongRangeThreat] >= 21000) and aiBrain[M27Overseer.refiDefaultStrategy] == M27Overseer.refStrategyTurtle then
                            M27Utilities.ErrorHandler(sFunctionRef..': Couldnt locate a movement point for experimental when searching through all brains but our brain is turtling, so code for teamgames likely has error. WIll just go to our chokepoint')
                            oPlatoon[reftMovementPath][1] = {aiBrain[M27MapInfo.reftChokepointBuildLocation][1], aiBrain[M27MapInfo.reftChokepointBuildLocation][2], aiBrain[M27MapInfo.reftChokepointBuildLocation][3]}
                        end
                        if tChokepointToDefend then
                            --if M27Utilities.GetDistanceBetweenPositions(tChokepointToDefend, GetPlatoonFrontPosition(oPlatoon)) <= 20 then
                            --oPlatoon[reftMovementPath][1] = M27Logic.GetRandomPointInAreaThatCanPathTo(M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit]), M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit]), GetPlatoonFrontPosition(oPlatoon)), tChokepointToDefend, 30, 10, false)
                            --else
                            if M27Utilities.GetDistanceBetweenPositions(tChokepointToDefend, GetPlatoonFrontPosition(oPlatoon)) <= 20 then
                                oPlatoon[reftMovementPath][1] = M27Logic.GetRandomPointInAreaThatCanPathTo(M27UnitInfo.refPathingTypeLand, M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeLand, tChokepointToDefend), tChokepointToDefend, 30, 10)
                                if bDebugMessages == true then LOG(sFunctionRef..': Will get random point near chokepoint as we are already near it') end
                            else
                                oPlatoon[reftMovementPath][1] = tChokepointToDefend
                            end
                            --Are we already close to here? then pick a random position within 30

                            if bDebugMessages == true then LOG(sFunctionRef..': Will defend the chokepoint '..repru(tChokepointToDefend)) end
                            --end
                        else
                            --Do we lack air support and enemy has large air threat?  If so then stay back; also stay back if enemy has more experimentals than us
                            local bDefend = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if we want to stay on defence due to enemy air therat. Have air control='..tostring(aiBrain[M27AirOverseer.refbHaveAirControl])..'; Enemy air to ground threat='..aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat]..'; AirAAWanted='..aiBrain[M27AirOverseer.refiAirAAWanted]) end
                            if not(aiBrain[M27AirOverseer.refbHaveAirControl]) and aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat] >= 3000 and aiBrain[M27AirOverseer.refiAirAAWanted] >= 10 then
                                --We arent close to having air control, so only want to advance with experimental if we have lots of MAA to support it
                                bDefend = true
                                --cahnge back to false if we have lots of maa:

                                if oPlatoon[M27Overseer.refoUnitsMAAHelper] then
                                    --Want at least 1.5k threat in MAA assigned, and at least 75% of this nearby
                                    if bDebugMessages == true then LOG(sFunctionRef..': Assigned MAA units='..oPlatoon[M27Overseer.refoUnitsMAAHelper][refiCurrentUnits]..'; Mass value='..oPlatoon[M27Overseer.refoUnitsMAAHelper][refiPlatoonMassValue]) end
                                    local iMAAIncreaseFactor = M27Overseer.GetMAAFactoryAdjustForLargePlatoons(aiBrain)
                                    if aiBrain[M27Overseer.refiMAAShortfallLargePlatoons] == 0 then iMAAIncreaseFactor = 1 end
                                    if oPlatoon[M27Overseer.refoUnitsMAAHelper][refiCurrentUnits] > 0 and oPlatoon[M27Overseer.refoUnitsMAAHelper][refiPlatoonMassValue] >= M27Overseer.iMAAMinExperimentalLevelWithoutAir * iMAAIncreaseFactor then
                                        local tNearbyAssignedMAA = {}
                                        for iUnit, oUnit in oPlatoon[M27Overseer.refoUnitsMAAHelper][reftCurrentUnits] do
                                            if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= 100 then
                                                table.insert(tNearbyAssignedMAA, oUnit)
                                            end
                                        end
                                        if M27Utilities.IsTableEmpty(tNearbyAssignedMAA) == false then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Threat of nearby assigned MAA='..M27Logic.GetAirThreatLevel(aiBrain, tNearbyAssignedMAA, false, false, true, false, false)..'; iMAAIncreaseFactor='..iMAAIncreaseFactor..'; iMAAMinExperimentalLevelWithoutAir * 0.75 * iMAAIncreaseFactor='..M27Overseer.iMAAMinExperimentalLevelWithoutAir * 0.75 * iMAAIncreaseFactor) end
                                            if M27Logic.GetAirThreatLevel(aiBrain, tNearbyAssignedMAA, false, false, true, false, false) >=  M27Overseer.iMAAMinExperimentalLevelWithoutAir * 0.75 * iMAAIncreaseFactor then
                                                bDefend = false
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bDefend='..tostring(bDefend)..'; is MAA helper nil='..tostring(oPlatoon[M27Overseer.refoUnitsMAAHelper] == nil)) end

                            end
                            if not(bDefend) then
                                --Does the enemy have alot orme threat and we arent using a fatboy
                                if oPlatoon[refiPlatoonMaxRange] < 80 and M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyLandExperimentals]) == false then
                                    local iEnemyExperimentalThreat = M27Logic.GetCombatThreatRating(aiBrain, aiBrain[M27Overseer.reftEnemyLandExperimentals], false, nil, nil, nil, nil, nil, nil, false, false, false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyExperimentalThreat='..iEnemyExperimentalThreat..'; Will see if want to switch to defence mode') end
                                    if iEnemyExperimentalThreat > oPlatoon[refiPlatoonThreatValue] then
                                        local iNearbyAlliedExperimentalThreat = M27Logic.GetCombatThreatRating(aiBrain, aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandExperimental, GetPlatoonFrontPosition(oPlatoon), 200, 'Ally'), false, nil, nil, nil, nil, nil, nil, false, false, false)
                                        if iEnemyExperimentalThreat > iNearbyAlliedExperimentalThreat then
                                            bDefend = true
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': iNearbyAlliedExperimentalThreat='..iNearbyAlliedExperimentalThreat..'; bDefend='..tostring(bDefend)) end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': bDefend='..tostring(bDefend)) end
                            if bDefend then
                                --If enemy in emergency defence range then move to the enemy, otherwise go to nearest rally point

                                if aiBrain[M27Overseer.refiModDistFromStartNearestThreat] <= math.min(125, aiBrain[M27AirOverseer.refiBomberDefenceCriticalThreatDistance]) and M27Utilities.GetDistanceBetweenPositions(aiBrain[M27Overseer.reftLocationFromStartNearestThreat], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) <= math.max(150, aiBrain[M27AirOverseer.refiBomberDefenceCriticalThreatDistance]) and M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit]), GetPlatoonFrontPosition(oPlatoon)) == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit]), aiBrain[M27Overseer.reftLocationFromStartNearestThreat]) then
                                    oPlatoon[reftMovementPath] = {[1] = {aiBrain[M27Overseer.reftLocationFromStartNearestThreat][1], aiBrain[M27Overseer.reftLocationFromStartNearestThreat][2], aiBrain[M27Overseer.reftLocationFromStartNearestThreat][3]}}
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will move to nearest threat as it is near our base') end
                                else
                                    oPlatoon[reftMovementPath] = {[1] = M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon))}
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will move to nearest rally point, dist from our front position='..M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][1], GetPlatoonFrontPosition(oPlatoon))) end
                                end
                            else
                                if oPlatoon[refbHavePreviouslyRun] then --Patorl 2 mexes and rally point
                                    oPlatoon[reftMovementPath] = M27MapInfo.GetMexPatrolLocations(aiBrain, 2, true)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have previously run so will get mex patrol locations') end
                                else

                                    local tTargetBase = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                                    if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tTargetBase) >= 40 then
                                        oPlatoon[reftMovementPath][1] = tTargetBase
                                        if bDebugMessages == true then LOG(sFunctionRef..': Are more than 40 from target base so will go to target base') end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Are within 40 of the enemy target base; will target the last known enemy ACU position if there is one') end
                                        if M27UnitInfo.IsUnitValid(aiBrain[M27Overseer.refoACUKillTarget]) then
                                            oPlatoon[reftMovementPath][1] = aiBrain[M27Overseer.reftACUKillTarget]
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': No enemy ACUs, will still target current position if it has structures or we are more than 10 from it') end
                                            if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tTargetBase) <= 10 then
                                                --Are there structures around this point? If so then still target it
                                                if M27Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure, tTargetBase, 30, 'Enemy')) then
                                                    if bDebugMessages == true then LOG(sFunctionRef..': No structures around here, will look for the nearest highest tech structure we can path to') end

                                                    local tNearbyEnemyUnits
                                                    local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoFrontUnit])
                                                    local iPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))
                                                    local iNearestUnitDistance = 10000
                                                    local iCurUnitDistance
                                                    local oNearestUnit
                                                    for iTechLevel = 3, 1, -1 do
                                                        tNearbyEnemyUnits = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure * M27UnitInfo.ConvertTechLevelToCategory(iTechLevel), GetPlatoonFrontPosition(oPlatoon), 150, 'Enemy')
                                                        if M27Utilities.IsTableEmpty(tNearbyEnemyUnits) == false then
                                                            for iUnit, oUnit in tNearbyEnemyUnits do
                                                                if oUnit:GetFractionComplete() >= 0.9 and M27MapInfo.GetSegmentGroupOfLocation(sPathing, oUnit:GetPosition()) == iPathingGroup then
                                                                    iCurUnitDistance = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                                                    if iCurUnitDistance < iNearestUnitDistance and not(M27UnitInfo.IsUnitUnderwater(oUnit)) then
                                                                        oNearestUnit = oUnit
                                                                        iNearestUnitDistance = iCurUnitDistance
                                                                    end
                                                                end
                                                            end
                                                        end
                                                        if oNearestUnit then break end
                                                    end
                                                    if oNearestUnit then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Nearest structure to platoon (when looking for highest tech first)='..oNearestUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestUnit)) end
                                                        oPlatoon[reftMovementPath][1] = oNearestUnit:GetPosition()
                                                    else
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find any nearby structures so will target the nearest rally point we have') end
                                                        oPlatoon[reftMovementPath][1] = M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit])
                                                    end
                                                else
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Still have T2+ units around here so will return the enemy base') end
                                                    oPlatoon[reftMovementPath][1] = tTargetBase
                                                end
                                            else
                                                --Still retain target base
                                                oPlatoon[reftMovementPath][1] = tTargetBase
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        oPlatoon[refiCurrentPathTarget] = 1
                    elseif sPlatoonName == 'M27IndirectSpareAttacker' then
                        --Are we turtling? If so then go on defence
                        if aiBrain[M27Overseer.refiDefaultStrategy] == M27Overseer.refStrategyTurtle then
                            oPlatoon[reftMovementPath][1] = {aiBrain[M27MapInfo.reftChokepointBuildLocation][1], aiBrain[M27MapInfo.reftChokepointBuildLocation][2], aiBrain[M27MapInfo.reftChokepointBuildLocation][3]}
                        else
                            local tTargetBase = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                            oPlatoon[refiCurrentPathTarget] = 1
                            if oPlatoon[reftMovementPath] and oPlatoon[reftMovementPath][1] and oPlatoon[reftMovementPath][1][1] == tTargetBase[1] and oPlatoon[reftMovementPath][1][3] == tTargetBase[3] then
                                --Are already targetting enemy base - check if we're close to it
                                if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tTargetBase) <= 15 then
                                    --Close to enemy base so switch to attack nearest units
                                    oPlatoon[reftMovementPath][1] = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                                    if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..'-'..oPlatoon[refiPlatoonUniqueCount]..': A'..refActionUseAttackAI) end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Updating indirect spare attacker to use attacknearest AI as are near enemy base') end
                                    oPlatoon:SetAIPlan('M27AttackNearestUnits')
                                else
                                    --No need to change path as already targetting enemy base but not near it
                                end
                            else
                                --Not targetting enemy base, so target it
                                if bDebugMessages == true then LOG(sFunctionRef..': Targetting enemy base') end
                                oPlatoon[reftMovementPath][1] = tTargetBase
                            end
                        end
                        --oPlatoon[refiLastPathTarget] = 1

                    elseif sPlatoonName == M27Overseer.sIntelPlatoonRef then
                        --Overseer sets movement path for itnel platoons, so just set initial move position to current position if this is called
                        if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath][1]) == true then
                            oPlatoon[reftMovementPath][1] = tCurPosition
                        end
                    elseif sPlatoonName == 'M27CombatPatrolAI' then
                        --patrol near midpoint of map/mex near there - look for up to 2 mexes plus the rally point
                        oPlatoon[reftMovementPath] = M27MapInfo.GetMexPatrolLocations(aiBrain, 2, true)
                    elseif oPlatoon[refbACUInPlatoon] == true then
                        --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Have got new path, about to update platoon units') end
                        if sPlatoonName == M27Overseer.sDefenderPlatoonRef or sPlatoonName == 'M27IndirectDefender' then
                            --Want to disband ACU platoon/have it use the ACU main platoon
                            RemoveUnitsFromPlatoon(oPlatoon, { M27Utilities.GetACU(aiBrain)}, false)
                            local oPlatoonUnits = oPlatoon:GetPlatoonUnits()
                            if M27Utilities.IsTableEmpty(oPlatoonUnits) == true then
                                if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonName..': Disbanding platoon instead of new path as no units in it') end
                                bDisbandAsNoUnits = true
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': setting new movement path for M27ACUMain') end

                            oPlatoon[reftMovementPath] = {}
                            oPlatoon[reftMovementPath][1] = {}
                            oPlatoon[refiCurrentPathTarget] = 1

                            --Do we want to assist a hydro?
                            local bMoveToHydro = false
                            --Check if is a hydro near the ACU
                            if M27Conditions.ACUShouldAssistEarlyHydro(aiBrain) == true then
                                --Do we have power already? Check have >= 10 per tick (so 100)
                                if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] <= 10 then
                                    bMoveToHydro = true
                                end
                            end
                            --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Considered whether should assist hydro') end
                            if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..': bMoveToHydro='..tostring(bMoveToHydro)) end
                            if bMoveToHydro == true then
                                --Get nearest hydro location:
                                local tNearestHydro = {}
                                local iMinHydroDistance = 1000
                                local iCurHydroDistance
                                for iHydro, tHydroPos in M27MapInfo.HydroPoints do
                                    iCurHydroDistance = M27Utilities.GetDistanceBetweenPositions(tHydroPos, tCurPosition)
                                    if iCurHydroDistance < iMinHydroDistance then
                                        tNearestHydro = tHydroPos
                                        iMinHydroDistance = iCurHydroDistance
                                    end
                                end
                                --Are we already in range of the hydro?
                                local iBuildDistance = M27Utilities.GetACU(aiBrain):GetBlueprint().Economy.MaxBuildDistance
                                local iHydroSize = M27UnitInfo.GetBuildingSize('UAB1102')[1]
                                if iMinHydroDistance <= (iBuildDistance + iHydroSize*0.5) then
                                    --Give a dummy path so dont call this again immediately
                                    oPlatoon[reftMovementPath][1] = tCurPosition
                                    if M27Utilities.GetACU(aiBrain):IsUnitState('Building') == true or (M27Utilities.GetACU(aiBrain):IsUnitState('Repairing') and M27Utilities.GetACU(aiBrain):GetFocusUnit():GetFractionComplete() < 1) then
                                        --Do nothing
                                        bDontActuallyMove = true
                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU is already busy building or assisting so wont do anything') end
                                    else
                                        --Is the hydro being constructed? If so then assist it
                                        local tHydrosInArea = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryHydro, tNearestHydro,  iHydroSize, 'Ally')
                                        local oNearestHydro
                                        if M27Utilities.IsTableEmpty(tHydrosInArea) == false then
                                            oNearestHydro = tHydrosInArea[1]
                                            if oNearestHydro.GetFractionComplete and oNearestHydro:GetFractionComplete() < 1 then
                                                IssueGuard(oPlatoon[reftBuilders], oNearestHydro)
                                                oPlatoon[refiLastOrderType] = refiOrderIssueGuard
                                                oPlatoon[reftLastOrderPosition] = oNearestHydro:GetPosition()
                                            end
                                        end
                                        bDontActuallyMove = true
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..': want to move near hydro, about to call MoveNearConstruction') end
                                    --MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction)
                                    oPlatoon[reftMovementPath][1] = MoveNearConstruction(aiBrain, M27Utilities.GetACU(aiBrain), tNearestHydro, 'UAB1102', 0, true, false, false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..': Moving to hydro, reftMovementPath='..repru(oPlatoon[reftMovementPath])..'; platoon position='..repru(tCurPosition)) end
                                end
                            else
                                --Are we before the first ACU upgrade? then Choose priority expansion target
                                if M27Conditions.DoesACUHaveUpgrade(aiBrain, oPlatoon[reftBuilders][1]) == false then
                                    --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Considered whether ACU has gun yet') end
                                    if bDebugMessages == true then LOG(sFunctionRef..': ACU doesnt have gun yet, will get expansion movement path') end
                                    oPlatoon[reftMovementPath] = M27Logic.GetPriorityExpansionMovementPath(aiBrain, GetPathingUnit(oPlatoon))
                                    if oPlatoon[reftMovementPath] == nil then
                                        refiCurrentAction = refActionDisband
                                        if bDebugMessages == true then LOG(sFunctionRef..': Expansion movement path is nil so disbanding') end
                                    else
                                        --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Will be expanding with ACU') end
                                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..': Expanding, reftMovementPath='..repru(oPlatoon[reftMovementPath])..'; platoon position='..repru(tCurPosition)) end
                                    end
                                else
                                    local iEnemyGroundExperimentals = 0
                                    local bBigEnemyThreat = false
                                    --Are there any big threats? Then return to base unless we're cloaked, or are a fully upgraded sera com; retreat these anyway if there are 2+ enemy land or air experimentals
                                    --Note - alot of this logic has been moved earlier on, so this is more relevant for TMLs and for if we ahve a cloaked ACU (as cloaked ACU ignore the standard isbigthreat flag)
                                    if aiBrain[M27Overseer.refbAreBigThreats] then
                                        if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyLandExperimentals]) == false then
                                            for iExp, oExp in aiBrain[M27Overseer.reftEnemyLandExperimentals] do
                                                iEnemyGroundExperimentals = iEnemyGroundExperimentals + 1
                                            end
                                        end
                                    end

                                    if iEnemyGroundExperimentals >= 2 then bBigEnemyThreat = true --Even if have cloaked or maxed sera com want to run from 2+ land experis
                                    elseif not(M27Utilities.GetACU(aiBrain):HasEnhancement('CloakingGenerator')) and not(M27Utilities.GetACU(aiBrain):HasEnhancement('BlastAttack') and M27Utilities.GetACU(aiBrain):HasEnhancement('DamageStabilizationAdvanced')) then
                                        if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyNukeLaunchers]) == false then
                                            for iUnit, oUnit in aiBrain[M27Overseer.reftEnemyNukeLaunchers] do
                                                if M27UnitInfo.IsUnitValid(oUnit) then
                                                    bBigEnemyThreat = true
                                                    break
                                                end
                                            end
                                        end
                                        if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyLandExperimentals]) == false then
                                            for iUnit, oUnit in aiBrain[M27Overseer.reftEnemyLandExperimentals] do
                                                if M27UnitInfo.IsUnitValid(oUnit) then
                                                    bBigEnemyThreat = true
                                                    break
                                                end
                                            end
                                        end
                                        if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyTML]) == false then
                                            local iTMLCount = 0
                                            for iUnit, oUnit in aiBrain[M27Overseer.reftEnemyTML] do
                                                if M27UnitInfo.IsUnitValid(oUnit) and EntityCategoryContains(M27UnitInfo.refCategoryTML, oUnit.UnitId) then
                                                    iTMLCount = iTMLCount + 1
                                                end
                                            end
                                            if iTMLCount >= 4 then bBigEnemyThreat = true end
                                        end
                                    end
                                    if bBigEnemyThreat == false then
                                        --Check if lots of enemy air
                                        if (not(aiBrain[M27AirOverseer.refbHaveAirControl]) and aiBrain[M27AirOverseer.refiEnemyAirToGroundThreat] >= 1500) or aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] >= (aiBrain[M27AirOverseer.refiOurMassInAirAA] + 2500) or (aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] > 10000 and not(aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] < 15000 and aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] < aiBrain[M27AirOverseer.refiOurMassInAirAA] * 1.15)) then
                                            --If cloaked or fully upgraded sera com then reduce thresholds
                                            bBigEnemyThreat = true
                                            if M27Utilities.GetACU(aiBrain):HasEnhancement('CloakingGenerator') or M27Utilities.GetACU(aiBrain):HasEnhancement('DamageStabilizationAdvanced') then
                                                if not(aiBrain[M27AirOverseer.refiAirAANeeded] >= 5 and aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] >= aiBrain[M27AirOverseer.refiOurMassInAirAA] * 1.5 and aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] > 15000) then
                                                    bBigEnemyThreat = false
                                                end
                                            end
                                        end
                                    end
                                    if not(bBigEnemyThreat) then
                                        --Assume will be a big enemy threat if we have built 1 (or 2 with fully upgraded ACU) experimentals
                                        local iThreshold = 1
                                        if M27Utilities.GetACU(aiBrain):HasEnhancement('CloakingGenerator') or M27Utilities.GetACU(aiBrain):HasEnhancement('DamageStabilizationAdvanced') then iThreshold = 2 end
                                        if not(M27Conditions.LifetimeBuildCountLessThan(aiBrain, categories.EXPERIMENTAL, iThreshold)) then bBigEnemyThreat = true end
                                    end

                                    --If a big threat, return to first rally point
                                    local tTargetBaseAndOtherMovementPaths
                                    if bBigEnemyThreat == true then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy has  big threat so returning to nearest rally point or shield, subject to if they have a nuke') end
                                        local bGoToRally = true
                                        if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyNukeLaunchers]) == false then
                                            local tSMDNearOurBase = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategorySMD, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], 150, 'Ally')
                                            if bDebugMessages == true then LOG(sFunctionRef..': is table of SMD near our base empty='..tostring(M27Utilities.IsTableEmpty(tSMDNearOurBase))) end
                                            if M27Utilities.IsTableEmpty(tSMDNearOurBase) == false then
                                                local iCurDist
                                                local iClosestDist = 100000000
                                                local oClosestSMD
                                                for iSMD, oSMD in tSMDNearOurBase do
                                                    iCurDist = M27Utilities.GetDistanceBetweenPositions(oSMD:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                                    if oSMD:GetFractionComplete() < 1 then iCurDist = iCurDist + 2000
                                                    else
                                                        if oSMD.GetTacticalSiloAmmoCount == 0 then
                                                            if oSMD.GetWorkProgress then iCurDist = iCurDist + 1000 * (1 - oSMD:GetWorkProgress())
                                                            else iCurDist = iCurDist + 1000
                                                            end
                                                        end
                                                    end
                                                    if iCurDist < iClosestDist then
                                                        --Can we path here?
                                                        if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oSMD:GetPosition()) == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, GetPlatoonFrontPosition(oPlatoon)) then
                                                            iClosestDist = iCurDist
                                                            oClosestSMD = oSMD
                                                        end
                                                    end
                                                end
                                                if bDebugMessages == true then LOG(sFunctionRef..': Is oClosestSMD valid='..tostring(M27UnitInfo.IsUnitValid(oClosestSMD))) end
                                                if oClosestSMD then
                                                    bGoToRally = false
                                                    tTargetBaseAndOtherMovementPaths = {M27Logic.GetRandomPointInAreaThatCanPathTo(M27UnitInfo.refPathingTypeAmphibious, M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oClosestSMD:GetPosition()), oClosestSMD:GetPosition(), 50, 5)}
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Will go near the SMD, location='..repru(tTargetBaseAndOtherMovementPaths)) end
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': bGoToRally='..tostring(bGoToRally)) end
                                        if bGoToRally then
                                            tTargetBaseAndOtherMovementPaths = {[1]={aiBrain[M27MapInfo.reftRallyPoints][1][1], aiBrain[M27MapInfo.reftRallyPoints][1][2], aiBrain[M27MapInfo.reftRallyPoints][1][3]}}
                                            if bDebugMessages == true then LOG(sFunctionRef..': Set tTargetBaseAndOtherMovementPaths to '..repru(tTargetBaseAndOtherMovementPaths)) end
                                        end
                                        if M27Utilities.IsTableEmpty(tTargetBaseAndOtherMovementPaths) or M27Utilities.IsTableEmpty(tTargetBaseAndOtherMovementPaths[1]) then
                                            M27Utilities.ErrorHandler('Dont have a target movement location so will get ACU priority destination', true)
                                            LOG('For debug - tTargetBaseAndOtherMovementPaths='..repru((tTargetBaseAndOtherMovementPaths or '{nil}')))
                                            tTargetBaseAndOtherMovementPaths = {M27Logic.GetPriorityACUDestination(aiBrain, oPlatoon)}
                                        end
                                    else
                                        --Normal behaviour - Go to the enemy base/nearby enemy units or mexes
                                        tTargetBaseAndOtherMovementPaths = {M27Logic.GetPriorityACUDestination(aiBrain, oPlatoon)}
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will go to enemy base or priority destination = '..repru(tTargetBaseAndOtherMovementPaths)) end
                                        --[[
                                        if M27Logic.GetNearestEnemyStartNumber(aiBrain) == nil then
                                            LOG(sFunctionRef..': ERROR unless enemy dead as M27Logic.GetNearestEnemyStartNumber(aiBrain) is nil')
                                            tTargetBaseAndOtherMovementPaths = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                                        else
                                            tTargetBaseAndOtherMovementPaths = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                                        end --]]
                                    end
                                    if M27Utilities.IsTableEmpty(tTargetBaseAndOtherMovementPaths[1]) then
                                        M27Utilities.ErrorHandler('Dont have a movement path so will go to nearest rally point. Platoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount], true)
                                        tTargetBaseAndOtherMovementPaths = {M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon))}
                                    end


                                    --Are we already near the target position? If so then switch to go to enemy base, or home if close to enemy base
                                    if M27Utilities.GetDistanceBetweenPositions(tTargetBaseAndOtherMovementPaths[1], M27Utilities.GetACU(aiBrain):GetPosition()) <= 5 then
                                        if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)) <= 5 then
                                            --return to nearest rally point
                                            tTargetBaseAndOtherMovementPaths = {M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit])}
                                        else
                                            tTargetBaseAndOtherMovementPaths = {M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)}
                                        end

                                        if bDebugMessages == true then LOG(sFunctionRef..': Already near destination so will either go to enemy base or to nearest rally point; revised target='..repru(tTargetBaseAndOtherMovementPaths)) end
                                    end
                                    oPlatoon[reftMovementPath] = tTargetBaseAndOtherMovementPaths
                                end
                            end
                            if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath]) == true then M27Utilities.ErrorHandler('Platoon containing ACU has no movement path') end
                        end
                    elseif sPlatoonName == 'M27RetreatingShieldUnits' then
                        oPlatoon[reftMovementPath][1] = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                        oPlatoon[refiCurrentPathTarget] = 1
                        if bDebugMessages == true then LOG(sFunctionRef..': Have retreating shield units so setting movement path to player start') end
                    elseif sPlatoonName == 'M27SuicideSquad' then
                        oPlatoon[reftMovementPath][1] = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                        oPlatoon[refiCurrentPathTarget] = 1
                    elseif sPlatoonName == 'M27MexRaiderAI' or sPlatoonName == 'M27MexLargerRaiderAI' then
                        oPlatoon[reftMovementPath] = M27Logic.GetMexRaidingPath(oPlatoon, 50)
                        if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath]) then
                            bDisbandAsNoUnits = true
                            LOG('WARNING -  RaidingPath returned nil movement path so disbanding platoon')
                        end
                        --oPlatoon[refiLastPathTarget] = table.getn(oPlatoon[reftMovementPath])
                    elseif sPlatoonName == 'M27AmphibiousDefender' then
                        --target nearest enemy pathable naval threat
                        if aiBrain[M27Overseer.refbT2NavyNearOurBase] or aiBrain[M27Overseer.refiNearestT2PlusNavalThreat] <= 250 then
                            local tNearbyNavyOfInterest = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryCruiserCarrier, GetPlatoonFrontPosition(oPlatoon), 300, 'Enemy')
                            if M27Utilities.IsTableEmpty(tNearbyNavyOfInterest) then
                                tNearbyNavyOfInterest = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryNavalSurface, GetPlatoonFrontPosition(oPlatoon), 90, 'Enemy')
                                if M27Utilities.IsTableEmpty(tNearbyNavyOfInterest) then tNearbyNavyOfInterest = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryCruiserCarrier, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], 275, 'Enemy') end
                            end
                            if M27Utilities.IsTableEmpty(tNearbyNavyOfInterest) then bDisbandAsNoUnits = true
                            else
                                oPlatoon[reftMovementPath][1] = M27Utilities.GetNearestUnit(tNearbyNavyOfInterest, GetPlatoonFrontPosition(oPlatoon)):GetPosition() --want actual position so moves with the unit
                                oPlatoon[refiCurrentPathTarget] = 1
                            end
                        else
                            bDisbandAsNoUnits = true
                        end
                    elseif sPlatoonName == 'M27RAS' then
                        --Head to our base
                        local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit])
                        oPlatoon[reftMovementPath][1] = M27Logic.GetRandomPointInAreaThatCanPathTo(sPathing, M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon)), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], 35, 5)
                        oPlatoon[refiCurrentPathTarget] = 1
                        if bDebugMessages == true then LOG(sFunctionRef..': RAS platoon so will return to base') end
                    else
                        if bDisbandAsNoUnits == false and oPlatoon[refbACUInPlatoon] == false then
                            --local tPathablePriorityMexes = {}
                            local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit])
                            local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))
                            local tPriorityMex = M27MapInfo.GetRandomPathablePriorityMex(aiBrain, sPathing, iPathingGroupWanted)


                            --Backup in case we dont have any high priority mexes yet or none are pathable
                            if M27Utilities.IsTableEmpty(tPriorityMex) then
                                if GetGameTimeSeconds() >= 15 and not(aiBrain[M27Overseer.refbNoEnemies]) and aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand] then M27Utilities.ErrorHandler('Dont have any high priority mexes recorded, so platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..' cant get a target and will move towards enemy base instead') end
                                --Just move towards the enemy by 20

                                local tBackupLocation = M27Utilities.MoveInDirection(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)), 20 + oPlatoon[refiCurrentUnits], true)
                                local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit])
                                local iSegmentGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))
                                if not(iSegmentGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(sPathing, tBackupLocation)) then
                                    tBackupLocation = M27Logic.GetRandomPointInAreaThatCanPathTo(sPathing, iSegmentGroupWanted, tBackupLocation, 150, 0)
                                end

                                oPlatoon[reftMovementPath][1] = tBackupLocation

                            else
                                oPlatoon[reftMovementPath][1] = tPriorityMex
                                if bDebugMessages == true then LOG(sFunctionRef..': Will target priority mex at '..repru(tPriorityMex)) end

                                --oPlatoon[reftMovementPath] = M27MapInfo.GetMexPatrolLocations(aiBrain, 3, true)

                                --oPlatoon[reftMovementPath] = M27Logic.GetMexRaidingPath(oPlatoon, 50)
                                if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath]) then
                                    bDisbandAsNoUnits = true
                                    LOG('WARNING -  RaidingPath returned nil movement path so disbanding platoon')
                                end
                            end
                            --oPlatoon[refiLastPathTarget] = table.getn(oPlatoon[reftMovementPath])
                        end
                    end
                end
                if bDisbandAsNoUnits == true then
                    if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonName..oPlatoon[refiPlatoonCount]..': disbanding') end
                    if oPlatoon then oPlatoon[refiCurrentAction] = refActionDisband end --if oPlatoon and oPlatoon.PlatoonDisband then oPlatoon:PlatoonDisband() end
                else
                    --Large attack AI: get nearby raiders, attackers and defenders to merge (unless theyre closer to enemy base than ours)
                    if sPlatoonName == 'M27LargeAttackForce' then
                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': About to call platoon mergers; ReftMovementPath[1][1]='..oPlatoon[reftMovementPath][1][1]) end
                        MergeWithPlatoonsOnPath(oPlatoon, 'M27MexRaiderAI', true)
                        MergeWithPlatoonsOnPath(oPlatoon, M27Overseer.sDefenderPlatoonRef, true)
                        MergeWithPlatoonsOnPath(oPlatoon, sPlatoonName, true)
                        --Update move order with the merge location
                        if M27Utilities.IsTableEmpty(oPlatoon[reftMergeLocation]) == false then
                            table.insert(oPlatoon[reftMovementPath], 1, oPlatoon[reftMergeLocation])
                            oPlatoon:Stop()
                            oPlatoon:SetPlatoonFormationOverride('AttackFormation')
                        end
                        --oPlatoon[refiLastPathTarget] = table.getn(oPlatoon[reftMovementPath])

                    end
                    --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Getting near end of code now') end
                    if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..'-'..oPlatoon[refiPlatoonUniqueCount]..': A'..refActionNewMovementPath) end
                    if bDebugMessages == true then LOG(sFunctionRef..sPlatoonName..oPlatoon[refiPlatoonCount]..': bDontActuallyMove='..tostring(bDontActuallyMove)..'; considering whether to move along path') end
                    if bDontActuallyMove == false then
                        if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath]) == true then
                            LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': WARNING - about to issue a movealongpath order, but there is no movement path; will set movement destination to a random priority mex, or (if there is none) the enemy base')
                            oPlatoon[reftMovementPath] = {}
                            oPlatoon[reftMovementPath][1] = {}
                            oPlatoon[refiCurrentPathTarget] = 1
                            local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit])
                            local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))
                            oPlatoon[reftMovementPath][1] = M27MapInfo.GetRandomPathablePriorityMex(aiBrain, sPathing, iPathingGroupWanted)

                            if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath][1]) then
                                if M27Logic.GetNearestEnemyStartNumber(aiBrain) == nil then
                                    LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..':ERROR - enemy start number is nil if theyre not dead then something is wrong')
                                    oPlatoon[reftMovementPath][1] = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                                else
                                    oPlatoon[reftMovementPath][1] = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                                end
                            end
                        end


                        --move (or attack-move if specified for hte platoon)
                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': About to move along path, oPlatoon[reftMovementPath]='..repru(oPlatoon[reftMovementPath])..'; bDontClearActions='..tostring(bDontClearActions)) end
                        MoveAlongPath(oPlatoon, oPlatoon[reftMovementPath], 1, bDontClearActions)
                    end
                end
                --DoesACUHaveGun(aiBrain, bROFAndRange, oAltACU)
                if oPlatoon[refbACUInPlatoon] == true and M27Conditions.DoesACUHaveUpgrade(aiBrain, oPlatoon[reftBuilders][1]) == false then
                    --Update engineer tracker varaibles to factor in that ACU expected to build mexes
                    --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': About to call function to ACU action tracker') end
                    M27EngineerOverseer.UpdateActionsForACUMovementPath(oPlatoon[reftMovementPath], aiBrain, M27Utilities.GetACU(aiBrain), oPlatoon[refiCurrentPathTarget])
                    --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Finished calling function to ACU action tracker') end
                end
            end
            M27Utilities.FunctionProfiler(sFunctionRef..': '..sPlatoonName, M27Utilities.refProfilerEnd)
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef..': Total', M27Utilities.refProfilerEnd)
end

function ReissueMovementPath(oPlatoon, bDontClearActions, bCalledFromNewMovementPath)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReissueMovementPath'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    --Added bCalledFromNewMovementPath in case decide to use this functionality in the future - can cause an infinite loop so this would need to be set to true to avoid infinite loop.  However atm dont call this from the function so its not needed

    local bPlatoonNameDisplay = false
    if M27Config.M27ShowUnitNames == true then bPlatoonNameDisplay = true end
    local sPlatoonName = oPlatoon:GetPlan()

    --if sPlatoonName == 'M27IntelPathAI' then bDebugMessages = true end
    --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 1 then bDebugMessages = true end
    --if sPlatoonName == 'M27GroundExperimental' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
    --if sPlatoonName == 'M27LargeAttackForce' then bDebugMessages = true end
    --if sPlatoonName == 'M27ScoutAssister' then bDebugMessages = true end
    --if sPlatoonName == 'M27MAAAssister' then bDebugMessages = true end
    --if sPlatoonName == 'M27EscortAI' then bDebugMessages = true end
    --if sPlatoonName == 'M27IndirectSpareAttacker' and oPlatoon[refiPlatoonCount] == 26 then bDebugMessages = true end
    --if sPlatoonName == 'M27CombatPatrolAI' and oPlatoon[refiPlatoonCount] == 1 and GetGameTimeSeconds() >= 480 and oPlatoon:GetBrain():GetArmyIndex() == 3 then bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': bDontClearActions='..tostring((bDontClearActions or false))) end

    if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath]) == true then
        M27Utilities.ErrorHandler('Have been told to reissue movement path but tmovementpath is empty; will get new movement path instead. Platoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount])
        if not(bCalledFromNewMovementPath) then
            GetNewMovementPath(oPlatoon, bDontClearActions)
        end
    else
        if oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] == true or oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard] == true then
            if bDebugMessages == true then LOG(sFunctionRef..': about to refresh support movement path') end
            RefreshSupportPlatoonMovementPath(oPlatoon)
        else

            --Did we get our movement path when we needed to heal and no longer need to heal? If so then want a new movement path instead
            if oPlatoon[refbNeededToHealWhenGotMovementPath] and not(oPlatoon[refbNeedToHeal]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Needed to heal when last got movement path but we dont need to heal now') end
                if not(bCalledFromNewMovementPath) then GetNewMovementPath(oPlatoon, bDontClearActions) end
            else


                if oPlatoon[refiCurrentPathTarget] == nil then
                    LOG(sFunctionRef..': WARNING - have been told to reissue movement path but CurrentPathTarget is nil; will get first entry in movement path instead')
                    oPlatoon[refiCurrentPathTarget] = 1
                end
                if oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]] == nil then
                    LOG(sFunctionRef..': WARNING - have been told to reissue movement path, but movement path for iCurrentPathTarget'..oPlatoon[refiCurrentPathTarget]..' is nil, will get new movement path instead')
                    if not(bCalledFromNewMovementPath) then GetNewMovementPath(oPlatoon, bDontClearActions) end
                else
                    if bDebugMessages == true then
                        if sPlatoonName == nil then LOG(sFunctionRef..': Warning - sPlatoonName is nil') end
                        if oPlatoon[refiPlatoonCount] == nil then LOG(sFunctionRef..': Warning: PlatoonCount is nil') end
                    end

                    --General (all platoons) - are we closer to the current point on the path or the 2nd?
                    local bGetNewPathInstead = false
                    local iPossibleMovementPaths = table.getn(oPlatoon[reftMovementPath])
                    local tPlatoonCurPos = {}
                    local iDistToCurrent, iDistToNext, iDistBetween1and2
                    local iLoopCount = 0
                    local iMaxLoopCount = 100
                    if bDebugMessages == true then LOG(sFunctionRef..': About to check if we are closer to the next path than the current path target; iPossibleMovementPaths='..iPossibleMovementPaths..'; oPlatoon[refiCurrentPathTarget]='..oPlatoon[refiCurrentPathTarget]..'; Platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))) end
                    local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
                    if iPossibleMovementPaths <= oPlatoon[refiCurrentPathTarget] then
                        --Only 1 movement path point left - if are ACU then get a new movement path unless are in defender platoon or prev action was movement related, or are running
                        oPlatoon[refiMultiPathReissueCount] = 0
                        if oPlatoon[refbACUInPlatoon] == true and not(sPlatoonName==M27Overseer.sDefenderPlatoonRef) and not(oPlatoon[refbHavePreviouslyRun]) then
                            if bDebugMessages == true then
                                local iCount = oPlatoon[refiPlatoonCount]
                                if iCount == nil then iCount = 0 end
                                local iPrevAction = oPlatoon[reftPrevAction][1]
                                if iPrevAction == nil then iPrevAction = 0 end
                                LOG(sPlatoonName..iCount..':'..sFunctionRef..': ACU in platoon with only 1 movement path, so will get new movement path depending on if cur target is closer to our base ir not, prevAction='..iPrevAction)
                            end

                            tPlatoonCurPos = GetPlatoonFrontPosition(oPlatoon)
                            local iACUDistanceToStart = M27Utilities.GetDistanceBetweenPositions(tPlatoonCurPos, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                            local iTargetDistanceToStart = M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                            if iACUDistanceToStart > iTargetDistanceToStart then
                                bGetNewPathInstead = true
                            end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': Platoon name='..sPlatoonName..'; oPlatoon[refbHavePreviouslyRun]='..tostring((oPlatoon[refbHavePreviouslyRun] or false))..'; therefore wont get a new movement path despite being on the last point of the path')
                        end
                    else
                        --Have more than 1 movement path left, check we dont have any pathing issues if have a high value platoon
                        --i.e. one issue is that the first movement path can be cancelled by the game if it cant be pathed to, and we cause a perpetual loop by trying to remove back to it after it was cancelled
                        --Only want to do this check in limited circumstances though, and only for certain platoons; will ignore for first 3m as CanPathTo is less reliable the earlier that its used
                        if GetGameTimeSeconds() >= 180 and (oPlatoon[refiMultiPathReissueCount] or 0) > 5 and M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]) <= 20 and (oPlatoon[refiPlatoonMassValue] >= 700 or oPlatoon[refiCurrentUnits] >= 4) and not(oPlatoon[M27PlatoonTemplates.refbRequiresUnitToFollow] or oPlatoon[M27PlatoonTemplates.refbIgnoreStuckAction] or oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard]) then
                            --Are ok to run a pathing check
                            if bDebugMessages == true then LOG(sFunctionRef..': Running manual canpathto check') end
                            if M27MapInfo.RecheckPathingOfLocation(M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit]), oPlatoon[refoPathingUnit], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], nil) then
                                --Had a pathing change
                                if bDebugMessages == true then LOG(sFunctionRef..': Pathing error so will get a new movement path') end
                                bGetNewPathInstead = true
                            end
                            --Reset the pathing count to negative amount so less likely to call for a while
                            oPlatoon[refiMultiPathReissueCount] = -5
                        end
                        if not(bGetNewPathInstead) then
                            tPlatoonCurPos = GetPlatoonFrontPosition(oPlatoon)
                            if M27Utilities.GetDistanceBetweenPositions(tPlatoonCurPos, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]) <= 20 then
                                oPlatoon[refiMultiPathReissueCount] = (oPlatoon[refiMultiPathReissueCount] or 0) + 1
                            end
                            --If we check the next point in the movement path, is it closer than the current point?
                            while iPossibleMovementPaths > oPlatoon[refiCurrentPathTarget] do
                                iLoopCount = iLoopCount + 1
                                if iLoopCount > iMaxLoopCount then M27Utilities.ErrorHandler('Infinite loop') break end

                                iDistToCurrent = M27Utilities.GetDistanceBetweenPositions(tPlatoonCurPos, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                                iDistToNext = M27Utilities.GetDistanceBetweenPositions(tPlatoonCurPos, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget] + 1])
                                iDistBetween1and2 = M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget] + 1])
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..'iLoopCount='..iLoopCount..'; tPlatoonCurPos='..repru(tPlatoonCurPos)..'; CurMovePath='..repru(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]))
                                    LOG('Next movement path='..repru(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget] + 1]))
                                    LOG('iDistToCurrent='..iDistToCurrent..'; iDistToNext='..iDistToNext..'; iDistBetween1and2='..iDistBetween1and2)
                                end
                                if iDistToNext < iDistBetween1and2 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Next target is closer than current so skipping current') end
                                    oPlatoon[refiCurrentPathTarget] = oPlatoon[refiCurrentPathTarget] + 1
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Next target isnt closer than target so will stop looking') end
                                    break
                                end
                            end
                        end
                    end
                    if bGetNewPathInstead == true then
                        oPlatoon[refiMultiPathReissueCount] = 0
                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..':'..sFunctionRef..': Are getting new movement path instead') end
                        if not(bCalledFromNewMovementPath) then GetNewMovementPath(oPlatoon, bDontClearActions) end
                    else
                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionReissueMovementPath: About to update platoon name and movement path, current target='..oPlatoon[refiCurrentPathTarget]..'; position of this='..repru(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])..'PlatoonUnitCount='..table.getn(oPlatoon[reftCurrentUnits])..'; plaotonaction='..oPlatoon[refiCurrentAction]) end
                        if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..'-'..oPlatoon[refiPlatoonUniqueCount]..': A'..refActionReissueMovementPath) end
                        MoveAlongPath(oPlatoon, oPlatoon[reftMovementPath], oPlatoon[refiCurrentPathTarget], bDontClearActions)
                        if oPlatoon[refbACUInPlatoon] and not(M27Conditions.DoesACUHaveUpgrade(aiBrain, oPlatoon[reftBuilders][1])) and not(M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerActionsByEngineerRef][M27EngineerOverseer.GetEngineerUniqueCount(oPlatoon[reftBuilders][1])])) then
                            M27EngineerOverseer.UpdateActionsForACUMovementPath(oPlatoon[reftMovementPath], aiBrain, oPlatoon[reftBuilders][1], oPlatoon[refiCurrentPathTarget])
                        end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': End of code, Cur movement path number='..oPlatoon[refiCurrentPathTarget]..'; Movement path='..repru(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])) end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function HoldAndReenableFire(tUnitsToSynchronise, iMaxTimeToHold, iTimeToSpreadOver)
    --Hold fire to ensure are aligned
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HoldAndReenableFire'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local iHoldFireState = 1
    local iReturnFireState = 0

    local iLowestWeaponPercent = 1
    local iCurWeaponPercent
    local oCurWeapon
    local oCurBP

    for iUnit, oUnit in tUnitsToSynchronise do
        --oCurBP = oUnit:GetBlueprint()
        --[[
            if oUnit.GetWeapon then
            oCurWeapon = oUnit:GetWeapon(1)
            iCurWeaponPercent = oCurWeapon:GetFireClockPct()
            if iCurWeaponPercent < iLowestWeaponPercent then iCurWeaponPercent = iLowestWeaponPercent end
            if bDebugMessages == true then LOG(sFunctionRef..': iUnit='..iUnit..'; iCurWeaponPercent='..iCurWeaponPercent..'; can weapon fire='..tostring(oCurWeapon:CanFire())) end
        end --]]

        oUnit:SetFireState(iHoldFireState)
        if bDebugMessages == true then M27Utilities.DrawLocation(oUnit:GetPosition(), nil, 1, 50) end
    end
    --local iTimeToHold = iMaxTimeToHold * (1 - iLowestWeaponPercent)
    --if bDebugMessages == true then LOG(sFunctionRef..': iTimeToHold='..iTimeToHold..'; iMaxTimeToHold='..iMaxTimeToHold) end

    local iCurSecondsWaited = 0
    local iInterval = 1
    local bAllReadyToFire
    local iCount = 0
    while not(bAllReadyToFire) do
        iCount = iCount + 1 if iCount > 100 then M27Utilities.ErrorHandler('Infinite loop') break end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        WaitSeconds(iInterval)
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        iCurSecondsWaited = iCurSecondsWaited + iInterval
        --Check if all units can fire yet
        bAllReadyToFire = true
        for iUnit, oUnit in tUnitsToSynchronise do
            if not(oUnit.Dead) then
                oCurWeapon = oUnit:GetWeapon(1)
                if not(oCurWeapon:CanFire()) then bAllReadyToFire = false break end
            end
        end
        if iCurSecondsWaited + iInterval >= iMaxTimeToHold then
            if iCurSecondsWaited < iMaxTimeToHold then
                iInterval = iMaxTimeToHold - iCurSecondsWaited
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Ended up waiting the maximum time') end
                break
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurSecondsWaited='..iCurSecondsWaited..'; bAllReadyToFire='..tostring(bAllReadyToFire)) end
    end
    --WaitSeconds(iTimeToHold)
    if iTimeToSpreadOver == 0 then
        for iUnit, oUnit in tUnitsToSynchronise do
            if not(oUnit.Dead) then
                if bDebugMessages == true then M27Utilities.DrawLocation(oUnit:GetPosition(), nil, 2, 50) end
                oUnit:SetFireState(iReturnFireState)
            end
        end
    else
        --E.g. Aeon TMD - want to spread out
        local iUnitsToSynchronise = table.getn(tUnitsToSynchronise)
        local iDelayAfterFirstShot = 1.5 --e.g. for Aeon TMD
        if iTimeToSpreadOver <= 1.5 then iDelayAfterFirstShot = iTimeToSpreadOver / iUnitsToSynchronise end
        local iDelayBetweenUnit = 1
        if iUnitsToSynchronise > 2 then iDelayBetweenUnit = (iTimeToSpreadOver - iDelayAfterFirstShot) / (iUnitsToSynchronise - 2) end
        for iUnit, oUnit in tUnitsToSynchronise do
            if not(oUnit.Dead) then
                oUnit:SetFireState(iReturnFireState)
                if iUnit == 1 then
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                    WaitSeconds(iDelayAfterFirstShot)
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                else
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                    WaitSeconds(iDelayBetweenUnit)
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                end
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end


function SynchroniseUnitFiring(tUnitsToSynchronise, iTimeToSpreadOver)
    local sFunctionRef = 'SynchroniseUnitFiring'
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local oBP = tUnitsToSynchronise[1]:GetBlueprint()
    if oBP and oBP.Weapon and oBP.Weapon[1] and oBP.Weapon[1].RateOfFire > 0 then
        local iFiringCycle = 1 / oBP.Weapon[1].RateOfFire
        if bDebugMessages == true then LOG(sFunctionRef..': About to synchronise firing for '..table.getn(tUnitsToSynchronise)..' units, iFiringCycle='..iFiringCycle..'; iTimeToSpreadOver='..iTimeToSpreadOver) end
        ForkThread(HoldAndReenableFire, tUnitsToSynchronise, iFiringCycle, iTimeToSpreadOver)
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function IssueIndirectAttack(oPlatoon, bDontClearActions)
    --Targets structures first, if no structures then spread attack on units
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IssueIndirectAttack'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..':'..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Start of code: iIndirectUnites='..oPlatoon[refiIndirectUnits]) end
    if oPlatoon[refiIndirectUnits] > 0 then
        local sPlatoonName = oPlatoon:GetPlan()
        --if sPlatoonName == 'M27IndirectDefender' and oPlatoon[refiPlatoonCount] == 2 and oPlatoon:GetBrain():GetArmyIndex() == 5 then bDebugMessages = true end
        --if sPlatoonName == 'M27IndirectDefender' then bDebugMessages = true end
        local sPlatoonUniqueRef = sPlatoonName..oPlatoon[refiPlatoonCount]
        local sTargetedRef = sPlatoonUniqueRef..'Indirect'
        local iMinTargetsInRange
        local iMinTargetsAll
        local iCurUnitRange
        local bCurUnitInRange
        local oFirstUnitWithMinTargetsInRange
        local tCurPos
        local tUnitsInRange
        local iUnitsInRange

        local tPriorityEnemiesNearFiringRange
        local tStructuresCloseToMaxPlatoonRange
        local bSpreadAttack = false
        local bAreNearbyT2PlusPD = false


        if M27Utilities.IsTableEmpty(oPlatoon[reftIndirectUnits]) == true then
            M27Utilities.ErrorHandler('No indirect fire units in platoon despite iIndirectUnits = '..oPlatoon[refiIndirectUnits])
        else
            --local iPlatoonAttackRange = M27Logic.GetUnitMaxGroundRange(oPlatoon[reftIndirectUnits])
            local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
            local iPlatoonAttackRange = oPlatoon[refiPlatoonMaxRange]
            local iCurAttackRange
            local bResetTarget = false
            if oPlatoon[reftPrevAction] and not(oPlatoon[reftPrevAction][1] == oPlatoon[refiCurrentAction]) then bResetTarget = true end
            if bResetTarget then
                for iUnit, oUnit in oPlatoon[reftIndirectUnits] do
                    if M27UnitInfo.IsUnitValid(oUnit) then
                        --iCurAttackRange = M27UnitInfo.GetUnitIndirectRange(oUnit)
                        --if iCurAttackRange > iPlatoonAttackRange then iPlatoonAttackRange = iCurAttackRange end
                        --Reset last target if our previous action wasnt to attack
                        --if bResetTarget then oUnit[M27UnitInfo.refoLastTargetUnit] = nil end
                        oUnit[M27UnitInfo.refoLastTargetUnit] = nil
                    end
                end
            end

            local tShieldDisruptorUnits = EntityCategoryFilterDown(M27UnitInfo.refCategoryShieldDisruptor, GetPlatoonUnitsOrUnitCount(oPlatoon, reftIndirectUnits, false, true))
            local tNonShieldDisruptorUnits = EntityCategoryFilterDown(categories.ALLUNITS - M27UnitInfo.refCategoryShieldDisruptor, GetPlatoonUnitsOrUnitCount(oPlatoon, reftIndirectUnits, false, true))
            local iNonShieldDisruptorUnits = 0


            --Update range to the range of non-shield disruptor units if we have a mix and the front unit is a shield disruptor
            if M27Utilities.IsTableEmpty(tShieldDisruptorUnits) == false and M27Utilities.IsTableEmpty(tNonShieldDisruptorUnits) == false then
                if EntityCategoryContains(M27UnitInfo.refCategoryShieldDisruptor, oPlatoon[refoFrontUnit].UnitId) then
                    iPlatoonAttackRange = M27UnitInfo.GetUnitIndirectRange(tNonShieldDisruptorUnits[1])
                end
            elseif M27Utilities.IsTableEmpty(tNonShieldDisruptorUnits) == false then
                iNonShieldDisruptorUnits = oPlatoon[refiIndirectUnits] --have no shield disruptor units
            end

            --Shield disruptor specific logic
            if M27Utilities.IsTableEmpty(tShieldDisruptorUnits) == false then
                local oNearestShieldedEnemy
                local iNearestShieldedEnemy = 10000
                local iCurShield, iMaxShield, iCurDist

                function RecordIfClosestShieldedUnit(oUnit)
                    iCurShield, iMaxShield = M27UnitInfo.GetCurrentAndMaximumShield(oUnit)
                    if iCurShield > 0 or M27Logic.IsTargetUnderShield(aiBrain, oUnit, 0, false, false, false) then
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition())
                        if iCurDist < iNearestShieldedEnemy then
                            oNearestShieldedEnemy = oUnit
                        end
                    end
                end

                if oPlatoon[refiEnemiesInRange] > 0 then
                    for iUnit, oUnit in oPlatoon[reftEnemiesInRange] do
                        RecordIfClosestShieldedUnit(oUnit)
                    end
                end
                if oPlatoon[refiEnemyStructuresInRange] > 0 then
                    for iUnit, oUnit in oPlatoon[reftEnemyStructuresInRange] do
                        RecordIfClosestShieldedUnit(oUnit)
                    end
                end
                if iNearestShieldedEnemy <= oPlatoon[refiPlatoonMaxRange] + 10 then
                    --Attack the nearest unit
                    M27Utilities.IssueTrackedClearCommands(tShieldDisruptorUnits)
                    IssueAttack(tShieldDisruptorUnits, oNearestShieldedEnemy)
                else
                    --Not near enemy so just do an aggressive move order to our movement path destination
                    M27Utilities.IssueTrackedClearCommands(tShieldDisruptorUnits)
                    IssueAggressiveMove(tShieldDisruptorUnits, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                end
            end

            if iNonShieldDisruptorUnits > 0 then
                --Normal (nondisruptor) attack logic


                local iUnitRangeMod = 0 --Will treat any units within range+mod as being in range of the unit for choosing attack orders
                local iRevisedSearchRangeForBuildlings = oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures]
                local tPlatoonPosition = GetPlatoonFrontPosition(oPlatoon)
                if bDebugMessages == true then LOG(sFunctionRef..': oPlatoon[refiEnemyStructuresInRange]='..oPlatoon[refiEnemyStructuresInRange]..'; iNonShieldDisruptorUnits='..iNonShieldDisruptorUnits..'; iPlatoonAttackRange='..iPlatoonAttackRange) end
                local tNearbyEnemyT2PlusPD
                local bNearbyAeonTMD, bNearbyNonAeonTMD, tNearbyTMD
                local bNearbyShieldOrTMD = false
                local oNearestT2PlusPD
                if oPlatoon[refiEnemyStructuresInRange] > 0 then
                    --Check if there are nearby enemy PD, in which case want to only look for buildings within a smaller range
                    if bDebugMessages == true then LOG(sFunctionRef..': Have enemy structures in range, checking if any PD') end

                    tNearbyEnemyT2PlusPD = EntityCategoryFilterDown(categories.DIRECTFIRE * categories.TECH2 + categories.DIRECTFIRE * categories.TECH3, oPlatoon[reftEnemyStructuresInRange])
                    local iNearestT2PlusPD
                    bAreNearbyT2PlusPD = not(M27Utilities.IsTableEmpty(tNearbyEnemyT2PlusPD))
                    if bAreNearbyT2PlusPD == true then
                        --Get nearest enemy PD
                        oNearestT2PlusPD = M27Utilities.GetNearestUnit(tNearbyEnemyT2PlusPD, tPlatoonPosition, aiBrain, true)
                        iNearestT2PlusPD = M27Utilities.GetDistanceBetweenPositions(oNearestT2PlusPD:GetPosition(), tPlatoonPosition)
                        if iNearestT2PlusPD <= 70 then iRevisedSearchRangeForBuildlings = math.min(iNearestT2PlusPD + 5, iRevisedSearchRangeForBuildlings) end
                    end

                    if iRevisedSearchRangeForBuildlings < (iPlatoonAttackRange - 3) then iRevisedSearchRangeForBuildlings = iPlatoonAttackRange end
                    iRevisedSearchRangeForBuildlings = math.min(iRevisedSearchRangeForBuildlings, iPlatoonAttackRange + 10)
                    tStructuresCloseToMaxPlatoonRange = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure, tPlatoonPosition, iRevisedSearchRangeForBuildlings, 'Enemy')
                    if bDebugMessages == true then
                        if iNearestT2PlusPD == nil then iNearestT2PlusPD = 'nil' end
                        LOG(sFunctionRef..': iRevisedSearchRangeForBuildlings='..iRevisedSearchRangeForBuildlings..'; Platoon.refiSearchRangeForEnemyStructures='..oPlatoon[M27Overseer.refiSearchRangeForEnemyStructures]..'; iPlatoonAttackRange='..iPlatoonAttackRange..'; iNearestT2PlusPD='..iNearestT2PlusPD)
                    end
                    if M27Utilities.IsTableEmpty(tStructuresCloseToMaxPlatoonRange) == false then
                        if iNonShieldDisruptorUnits >= 4 then
                            bSpreadAttack = true
                            iUnitRangeMod = 4
                            if iNonShieldDisruptorUnits > 10 then iUnitRangeMod = 6 end
                        end

                        --Prioritise any shields and TMD
                        bNearbyAeonTMD = false
                        bNearbyNonAeonTMD = false
                        tPriorityEnemiesNearFiringRange = EntityCategoryFilterDown(categories.ANTIMISSILE + categories.SHIELD, tStructuresCloseToMaxPlatoonRange)
                        if M27Utilities.IsTableEmpty(tPriorityEnemiesNearFiringRange) == true then
                            --Target PD if no shields or TMD
                            tPriorityEnemiesNearFiringRange = EntityCategoryFilterDown(categories.DIRECTFIRE, tStructuresCloseToMaxPlatoonRange)
                            if M27Utilities.IsTableEmpty(tPriorityEnemiesNearFiringRange) == true then
                                --Target other structures
                                tPriorityEnemiesNearFiringRange = tStructuresCloseToMaxPlatoonRange
                            end
                        else
                            bNearbyShieldOrTMD = true
                            tNearbyTMD = EntityCategoryFilterDown(categories.AEON * M27UnitInfo.refCategoryTMD, tPriorityEnemiesNearFiringRange)
                            if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                                bNearbyAeonTMD = true
                            else
                                tNearbyTMD = EntityCategoryFilterDown(M27UnitInfo.refCategoryTMD, tPriorityEnemiesNearFiringRange)
                                if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                                    bNearbyNonAeonTMD = true
                                end
                            end
                        end
                    end
                end
                if M27Utilities.IsTableEmpty(tPriorityEnemiesNearFiringRange) == true then
                    tPriorityEnemiesNearFiringRange = aiBrain:GetUnitsAroundPoint(categories.LAND + M27UnitInfo.refCategoryStructure + categories.NAVAL, tPlatoonPosition, math.min(iRevisedSearchRangeForBuildlings, iPlatoonAttackRange), 'Enemy')
                    if M27Utilities.IsTableEmpty(tPriorityEnemiesNearFiringRange) == true then
                        tPriorityEnemiesNearFiringRange = oPlatoon[reftEnemiesInRange]
                        if M27Utilities.IsTableEmpty(oPlatoon[reftEnemiesInRange]) then tPriorityEnemiesNearFiringRange = oPlatoon[reftEnemyStructuresInRange] end
                    end
                    if iNonShieldDisruptorUnits > 1 then bSpreadAttack = true end --1 arti shell can kill 1 tank in some cases so want to spraed attack
                    if bDebugMessages == true then LOG(sFunctionRef..': Have no priority enemies so will include nearby mobile units when considering targets') end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Have priority enemies near firing range')
                end
                if M27Utilities.IsTableEmpty(tPriorityEnemiesNearFiringRange) == true then
                    M27Utilities.ErrorHandler('No units to target for indirect attack, will resume movement path instead')
                    ReissueMovementPath(oPlatoon, bDontClearActions)
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have some enemies that can attack, will go through each unit in platoon and allocate targets') end
                    --IssueAttack(oPlatoon[reftIndirectUnits], M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon)))



                    --Track no. of times a unit has been targetted - first reset variables
                    if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonUniqueRef..': No nearby structures so attacking nearest units') end
                    for iEnemyUnit, oEnemyUnit in tPriorityEnemiesNearFiringRange do
                        oEnemyUnit[sTargetedRef] = 0
                    end
                    --Cycle through each indirect fire unit, and then check for each enemy unit in its range
                    --Default target in case can't find one: the closest unit:
                    local oNearestEnemyUnit
                    local iNearestEnemyUnitDistance
                    local iCurDistanceToEnemy
                    local oNearestEnemyT2PlusPD, iNearestT2PlusPD
                    local bCurUnitSpreadAttack
                    local bQueueUpOtherAttacks

                    local bSynchroniseFiring = false
                    local iMMLs = 0
                    local tMMLNearFront = {}
                    local iMMLNearFront = 0
                    local tCurMMLPosition, oNearestTMD, tNearestTMD, iDistanceToNearestTMD
                    --Check if should consider using Synchronised firing
                    if bDebugMessages == true then LOG(sFunctionRef..': About to consider if should synchronise fire; iNonShieldDisruptorUnits='..iNonShieldDisruptorUnits) end
                    if iNonShieldDisruptorUnits >= 3 then
                        local tMMLs = EntityCategoryFilterDown(categories.SILO, tNonShieldDisruptorUnits)
                        if M27Utilities.IsTableEmpty(tMMLs) == false then iMMLs = table.getn(tMMLs) end
                        if bDebugMessages == true then LOG(sFunctionRef..': iMMLs='..iMMLs) end
                        if iMMLs >= 3 then
                            --More than 30s since we last Synchronised?
                            local iCurGameTime = GetGameTimeSeconds()
                            if bDebugMessages == true then
                                local iTimeOfLastRefresh = oPlatoon[refiTimeOfLastSyncronisation]
                                if iTimeOfLastRefresh == nil then iTimeOfLastRefresh = 'nil' end
                                LOG(sFunctionRef..': iTimeOfLastRefresh='..iTimeOfLastRefresh..'; iCurGameTime='..iCurGameTime..'; bNearbyAeonTMD='..tostring(bNearbyAeonTMD)..'; bNearbyNonAeonTMD='..tostring(bNearbyNonAeonTMD))
                            end
                            if oPlatoon[refiTimeOfLastSyncronisation] == nil or iCurGameTime - oPlatoon[refiTimeOfLastSyncronisation] > 9 then
                                --Only 9s, since hte way this works will be turning off once, and then turning on once; therefore even if this runs several times in the same cycle we should avoid units being permanently stuck waiting to attack
                                --Are there any nearby TMD?
                                if bNearbyAeonTMD == false and bNearbyNonAeonTMD == false then
                                    --Check in a larger search range
                                    local iTMDSearchRange = math.max(iPlatoonAttackRange, 70)
                                    tNearbyTMD = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryTMD, tPlatoonPosition, iTMDSearchRange, 'Enemy')
                                    if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                                        if M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.AEON, tNearbyTMD)) == false then
                                            bNearbyAeonTMD = true
                                        else
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef..': Size of table='..table.getn(tNearbyTMD))
                                                for iUnit, oUnit in tNearbyTMD do
                                                    LOG('TMD iUnit='..iUnit)
                                                end
                                            end
                                            bNearbyNonAeonTMD = true
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iNearbyTMD='..table.getn(tNearbyTMD)..'bNearbyAeonTMD='..tostring(bNearbyAeonTMD)..'; bNearbyNonAeonTMD='..tostring(bNearbyNonAeonTMD)) end
                                end
                                if bNearbyAeonTMD == true or bNearbyNonAeonTMD == true then
                                    --Get nearest TMD or PD or shield to front platoon unit; Do we have at least 3 MMLs within range of this?

                                    local oNearestPriorityUnit = M27Utilities.GetNearestUnit(tPriorityEnemiesNearFiringRange, GetPlatoonFrontPosition(oPlatoon), aiBrain, true)
                                    local tNearestUnit = oNearestPriorityUnit:GetPosition()
                                    local iNearestPriorityUnit = M27Utilities.GetDistanceBetweenPositions(tNearestUnit, GetPlatoonFrontPosition(oPlatoon))
                                    local oNearestUnit = oNearestPriorityUnit
                                    local tNearestT2PlusPD
                                    if M27Utilities.IsTableEmpty(tNearbyEnemyT2PlusPD) == false then
                                        oNearestEnemyT2PlusPD = M27Utilities.GetNearestUnit(tNearbyEnemyT2PlusPD, GetPlatoonFrontPosition(oPlatoon), aiBrain, nil)
                                        tNearestT2PlusPD = oNearestEnemyT2PlusPD:GetPosition()
                                        iNearestT2PlusPD = M27Utilities.GetDistanceBetweenPositions(tNearestT2PlusPD, GetPlatoonFrontPosition(oPlatoon))
                                        if iNearestPriorityUnit > iNearestT2PlusPD then
                                            oNearestUnit = oNearestT2PlusPD
                                            iNearestPriorityUnit = iNearestT2PlusPD
                                            tNearestUnit = tNearestT2PlusPD
                                        end
                                    end
                                    for iUnit, oUnit in tMMLs do
                                        if not(oUnit.Dead) and oUnit.GetPosition then
                                            tCurMMLPosition = oUnit:GetPosition()
                                            if M27Utilities.GetDistanceBetweenPositions(tCurMMLPosition, tNearestUnit) <= iPlatoonAttackRange then
                                                iMMLNearFront = iMMLNearFront + 1
                                                tMMLNearFront[iMMLNearFront] = oUnit
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': iMMLNearFront='..iMMLNearFront) end
                                    if iMMLNearFront >= 3 then
                                        if bDebugMessages == true then
                                            LOG('Size of tNearbyTMD='..table.getn(tNearbyTMD))
                                            for iUnit, oUnit in tNearbyTMD do
                                                LOG('iUnit='..iUnit)
                                            end
                                        end
                                        --Has the TMD moved since we last Synchronised?
                                        oNearestTMD = M27Utilities.GetNearestUnit(tNearbyTMD, tPlatoonPosition, aiBrain)
                                        if oNearestTMD then
                                            tNearestTMD = oNearestTMD:GetPosition()
                                            if bDebugMessages == true then
                                                local iDistanceToLastTMD = 0
                                                local iMMLFromLastSynchronisation = oPlatoon[refiMMLCountWhenLastSynchronised]
                                                if iMMLFromLastSynchronisation == nil then iMMLFromLastSynchronisation = 'nil' end
                                                if oPlatoon[reftNearestTMDWhenLastSynchronised] then iDistanceToLastTMD = M27Utilities.GetDistanceBetweenPositions(tNearestTMD, oPlatoon[reftNearestTMDWhenLastSynchronised]) end
                                                LOG(sFunctionRef..': iDistanceToLastTMD='..iDistanceToLastTMD..'; iMMLFromLastSynchronisation='..iMMLFromLastSynchronisation)
                                            end
                                            if oPlatoon[reftNearestTMDWhenLastSynchronised] == nil or M27Utilities.GetDistanceBetweenPositions(tNearestTMD, oPlatoon[reftNearestTMDWhenLastSynchronised]) >3 then
                                                bSynchroniseFiring = true
                                            else
                                                if oPlatoon[refiMMLCountWhenLastSynchronised] == nil or iMMLNearFront - oPlatoon[refiMMLCountWhenLastSynchronised] >= 2 then
                                                    bSynchroniseFiring = true
                                                end
                                            end
                                            if bSynchroniseFiring == true then
                                                oPlatoon[refiTimeOfLastSyncronisation] = iCurGameTime
                                                oPlatoon[reftNearestTMDWhenLastSynchronised] = tNearestTMD
                                                oPlatoon[refiMMLCountWhenLastSynchronised] = iMMLNearFront
                                                local iTimeToSpreadOver = 0
                                                if bNearbyAeonTMD == true then iTimeToSpreadOver = 3.1 end
                                                if bDebugMessages == true then LOG(sFunctionRef..': About to call function to synchronise unit firing') end
                                                SynchroniseUnitFiring(tMMLNearFront, iTimeToSpreadOver)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end


                    if M27Utilities.IsTableEmpty(tNonShieldDisruptorUnits) == false then
                        local bFirstTargetAttacked
                        for iUnit, oUnit in tNonShieldDisruptorUnits do
                            if not(oUnit.Dead) then
                                bFirstTargetAttacked = true
                                iMinTargetsAll = 100000
                                iMinTargetsInRange = 100000
                                iCurUnitRange = M27UnitInfo.GetUnitIndirectRange(oUnit) + iUnitRangeMod
                                tCurPos = oUnit:GetPosition()
                                iUnitsInRange = 0
                                tUnitsInRange = {}
                                iNearestEnemyUnitDistance = 10000
                                oNearestEnemyT2PlusPD = nil
                                iNearestT2PlusPD = 10000
                                bCurUnitSpreadAttack = bSpreadAttack
                                bQueueUpOtherAttacks = true
                                if bAreNearbyT2PlusPD then
                                    oNearestEnemyT2PlusPD = M27Utilities.GetNearestUnit(tNearbyEnemyT2PlusPD, tCurPos, aiBrain, nil)
                                    iNearestT2PlusPD = M27Utilities.GetDistanceBetweenPositions(oNearestEnemyT2PlusPD:GetPosition(), tCurPos)
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iUnit='..iUnit..': iNearestT2PlusPD='..iNearestT2PlusPD..': Will either pick the nearest T2 PD if <=56, or will cycle through priority targets') end
                                if iNearestT2PlusPD <= 56 then
                                    bCurUnitSpreadAttack = false
                                    bQueueUpOtherAttacks = false
                                    --Do we have TMD within our range? If so then attack them first
                                    if bNearbyShieldOrTMD == true then
                                        local tWithinRangeTMDAndShield = {}
                                        local iWithinRangeTMDAndShield = 0
                                        for iEnemy, oEnemy in tPriorityEnemiesNearFiringRange do
                                            if M27Utilities.GetDistanceBetweenPositions(tCurPos, oUnit:GetPosition()) <= iCurUnitRange then
                                                if bFirstTargetAttacked then
                                                    bFirstTargetAttacked = false
                                                    if not(bDontClearActions) and not(oUnit[M27UnitInfo.refoLastTargetUnit] == oEnemy) then M27Utilities.IssueTrackedClearCommands({oUnit}) end
                                                    oUnit[M27UnitInfo.refoLastTargetUnit] = oEnemy
                                                    oPlatoon[reftLastOrderPosition] = oEnemy:GetPosition()
                                                end
                                                IssueAttack({oUnit}, oEnemy)
                                            end
                                        end
                                        oPlatoon[refiLastOrderType] = refiOrderIssueAttack

                                    end
                                    oNearestEnemyUnit = oNearestEnemyT2PlusPD
                                else
                                    for iEnemyUnit, oEnemyUnit in tPriorityEnemiesNearFiringRange do
                                        if not(oEnemyUnit.Dead) then
                                            bCurUnitInRange = false
                                            iCurDistanceToEnemy = M27Utilities.GetDistanceBetweenPositions(tCurPos, oEnemyUnit:GetPosition())
                                            if iCurDistanceToEnemy <= iCurUnitRange then bCurUnitInRange = true end
                                            if iCurDistanceToEnemy <= iNearestEnemyUnitDistance then
                                                iNearestEnemyUnitDistance = iCurDistanceToEnemy
                                                oNearestEnemyUnit = oEnemyUnit
                                            end
                                            if bCurUnitInRange == true then
                                                table.insert(tUnitsInRange, 1,oEnemyUnit)
                                                iUnitsInRange = iUnitsInRange + 1
                                                if oEnemyUnit[sTargetedRef] == nil then oEnemyUnit[sTargetedRef] = 0 end
                                                if oEnemyUnit[sTargetedRef] < iMinTargetsInRange then
                                                    iMinTargetsInRange = oEnemyUnit[sTargetedRef]
                                                    oFirstUnitWithMinTargetsInRange = oEnemyUnit
                                                end
                                            end
                                        end
                                    end
                                end

                                if bCurUnitSpreadAttack == false then
                                    --Target nearest enemy (and queue up attacks on all other units)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Telling cur unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to attack the nearest enemy unit '..oNearestEnemyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestEnemyUnit)..'; bQueueUpOtherAttacks='..tostring(bQueueUpOtherAttacks)) end
                                    if bFirstTargetAttacked then
                                        bFirstTargetAttacked = false
                                        if not(bDontClearActions) and not(oUnit[M27UnitInfo.refoLastTargetUnit] == oNearestEnemyUnit) then M27Utilities.IssueTrackedClearCommands({oUnit}) end
                                        oUnit[M27UnitInfo.refoLastTargetUnit] = oNearestEnemyUnit
                                    end
                                    IssueAttack({oUnit}, oNearestEnemyUnit)
                                    oPlatoon[refiLastOrderType] = refiOrderIssueAttack
                                    oPlatoon[reftLastOrderPosition] = oNearestEnemyUnit:GetPosition()

                                    if oNearestEnemyUnit[sTargetedRef] == nil then oNearestEnemyUnit[sTargetedRef] = 0 end
                                    oNearestEnemyUnit[sTargetedRef] = oNearestEnemyUnit[sTargetedRef] + 1
                                    if bQueueUpOtherAttacks == true then
                                        --oPlatoon[refiLastOrderType] = refiOrderIssueAttack
                                        if iUnitsInRange > 0 then
                                            for iEnemyUnit, oEnemyUnit in tUnitsInRange do
                                                if not(oEnemyUnit == oNearestEnemyUnit) then IssueAttack({oUnit}, oEnemyUnit) end
                                            end
                                        else
                                            for iEnemyUnit, oEnemyUnit in tPriorityEnemiesNearFiringRange do
                                                if not(oEnemyUnit == oNearestEnemyUnit) then IssueAttack({oUnit}, oEnemyUnit) end
                                            end
                                        end
                                    end
                                else
                                    --Spread attack - target the unit in range with the least existing targets (or the nearest enemy unit if no units in range), and queue up attacks on all other priority units
                                    --If any units in range, then queue up attacks on all of them, starting with the one with min targets:
                                    if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonUniqueRef..': iUnit='..iUnit..'; iUnitsInRange='..iUnitsInRange..'; iMinTargetsInRange='..iMinTargetsInRange..'; bQueueUpOtherAttacks='..tostring(bQueueUpOtherAttacks)) end
                                    if bQueueUpOtherAttacks == true then
                                        oPlatoon[refiLastOrderType] = refiOrderIssueAttack
                                        if iUnitsInRange > 0 then
                                            if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonUniqueRef..': Telling unit to attack the least targetted enemy unit in range, iUnit='..iUnit..'; X position of target='..oFirstUnitWithMinTargetsInRange:GetPosition()[1]..'; oPlatoon[refiEnemiesInRange]='..oPlatoon[refiEnemiesInRange]..'; iIndirectUnits='..iNonShieldDisruptorUnits) end
                                            if bDebugMessages == true then LOG('oUnit ID='..oUnit.UnitId) end
                                            if bFirstTargetAttacked then
                                                bFirstTargetAttacked = false
                                                if not(bDontClearActions) and not(oUnit[M27UnitInfo.refoLastTargetUnit] == oFirstUnitWithMinTargetsInRange) then M27Utilities.IssueTrackedClearCommands({oUnit}) end
                                                oUnit[M27UnitInfo.refoLastTargetUnit] = oFirstUnitWithMinTargetsInRange
                                                oPlatoon[reftLastOrderPosition] = oFirstUnitWithMinTargetsInRange:GetPosition()
                                            end

                                            IssueAttack({oUnit}, oFirstUnitWithMinTargetsInRange)
                                            if oFirstUnitWithMinTargetsInRange[sTargetedRef] == nil then oFirstUnitWithMinTargetsInRange[sTargetedRef] = 0 end
                                            oFirstUnitWithMinTargetsInRange[sTargetedRef] = oFirstUnitWithMinTargetsInRange[sTargetedRef] + 1
                                            for iEnemyUnit, oEnemyUnit in tUnitsInRange do
                                                if not(oEnemyUnit == oFirstUnitWithMinTargetsInRange) then IssueAttack({oUnit}, oEnemyUnit) end
                                            end
                                        else
                                            --No units in range, so target the closest unit
                                            if oNearestEnemyUnit == nil then M27Utilities.ErrorHandler('Dont have any unit to target')
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Telling unit to attack the nearest enemy unit') end
                                                if bFirstTargetAttacked then
                                                    bFirstTargetAttacked = false
                                                    if not(bDontClearActions) and not(oUnit[M27UnitInfo.refoLastTargetUnit] == oNearestEnemyUnit) then M27Utilities.IssueTrackedClearCommands({oUnit}) end
                                                    oUnit[M27UnitInfo.refoLastTargetUnit] = oNearestEnemyUnit
                                                    oPlatoon[reftLastOrderPosition] = oNearestEnemyUnit:GetPosition()
                                                end

                                                IssueAttack({oUnit}, oNearestEnemyUnit)
                                                if oNearestEnemyUnit[sTargetedRef] == nil then oNearestEnemyUnit[sTargetedRef] = 0 end
                                                oNearestEnemyUnit[sTargetedRef] = oNearestEnemyUnit[sTargetedRef] + 1
                                            end

                                            for iEnemyUnit, oEnemyUnit in tPriorityEnemiesNearFiringRange do
                                                if not(oEnemyUnit == oNearestEnemyUnit) then IssueAttack({oUnit}, oEnemyUnit) end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - table of indirect units is empty') end
                    end
                end
            end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': No indirect fire units in platoon')
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function UpdateScoutPositions(oPlatoon)
    --Send scouts to the platoons current position (so should never be in front); sends up to 2 scouts to the middle (so for v.large platoons dont group them all in 1 place)
    local sFunctionRef = 'UpdateScoutPositions'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    if oPlatoon[refiScoutUnits] <= 2 then
        if oPlatoon[refiScoutUnits] > 0 and GetPlatoonUnitsOrUnitCount(oPlatoon, reftScoutUnits, true, true) >= 1 then
            if bDebugMessages == true then LOG('UpdateScoutPositions: Sending IssueMove command') end
            IssueMove(GetPlatoonUnitsOrUnitCount(oPlatoon, reftScoutUnits, false, true), GetPlatoonFrontPosition(oPlatoon))
            oPlatoon[refiLastOrderType] = refiOrderIssueMove
            oPlatoon[reftLastOrderPosition] = GetPlatoonFrontPosition(oPlatoon)
        end
    else
        if GetPlatoonUnitsOrUnitCount(oPlatoon, reftScoutUnits, true, true) > 0 then
            oPlatoon[refiLastOrderType] = refiOrderIssueMove
            oPlatoon[reftLastOrderPosition] = GetPlatoonFrontPosition(oPlatoon)
            for iUnit, oUnit in GetPlatoonUnitsOrUnitCount(oPlatoon, reftScoutUnits, false, true) do
                if iUnit >= 3 then break end
                if bDebugMessages == true then LOG('UpdateScoutPositions: Sending IssueMove command') end
                IssueMove({oUnit}, GetPlatoonFrontPosition(oPlatoon))
            end

        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetPositionAtOrNearTargetInPathingGroup(tStartPos, tTargetPos, iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
    --Intended as a rewriting of GetPositionNearTargetInSamePathingGroup due to some inconsistencies arising with the below, to make use of new logic that allows any angle; introduced from v15
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPositionAtOrNearTargetInPathingGroup'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if GetGameTimeSeconds() >= 780 and M27Utilities.GetDistanceBetweenPositions(tTargetPos, {108.48748779297, 12.083453178406, 367.40881347656}) <= 1 then bDebugMessages = true end
    --Get angle from target to start
    local iAngleFromTargetToStart = M27Utilities.GetAngleFromAToB(tTargetPos, tStartPos) + (iAngleAdjust or 0)
    --Get initial desired position
    local tPossibleTarget = M27Utilities.MoveInDirection(tTargetPos, iAngleFromTargetToStart, iDistanceFromTargetToStart)
    local sPathing = M27UnitInfo.GetUnitPathingType(oPathingUnit)
    local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(sPathing, tTargetPos)
    local iPathingGroupOfPossibleTarget = M27MapInfo.GetSegmentGroupOfLocation(sPathing, tPossibleTarget)
    local bCanPathToTarget = false

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code; oPathingUnit='..oPathingUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPathingUnit)..'; tTargetPos='..repru(tTargetPos)..'; iAngleAdjust ='..iAngleAdjust..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart..'; tStartPos='..repru(tStartPos)..'; iPathingGroupOfPossibleTarget='..iPathingGroupOfPossibleTarget..'; iPathingGroupWanted='..iPathingGroupWanted..'; Angle from start to target='..M27Utilities.GetAngleFromAToB(tStartPos, tTargetPos)..'; iAngleFromTargetToStart='..iAngleFromTargetToStart..'; Amphibious group of target position='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, tTargetPos)..'; Amphib group of our base='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, M27MapInfo.PlayerStartPoints[oPathingUnit:GetAIBrain().M27StartPositionNumber])..'; tPossibleTarget before adjust='..repru(tPossibleTarget)..'; Distance between possible target and tTargetPos='..M27Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)) end
    --Find a target we can path to
    if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
        bCanPathToTarget = true
    else
        --Dif pathing group, need to try alternatives; first try the target itself
        if not(bMoveCloserBeforeFurtherIfBlocked == false) then
            tPossibleTarget = {tTargetPos[1], tTargetPos[2], tTargetPos[3]}
            iPathingGroupOfPossibleTarget = M27MapInfo.GetSegmentGroupOfLocation(sPathing, tPossibleTarget)
            if bDebugMessages == true then LOG(sFunctionRef..': Pathing group if just try target position='..iPathingGroupOfPossibleTarget) end
            if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
                bCanPathToTarget = true
            end
        end

        if bCanPathToTarget == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Cant path to the initial expected point so will try nearby points') end
            local tDistanceFactors
            if bMoveCloserBeforeFurtherIfBlocked then
                tDistanceFactors = {0.5, 1.5, 3}
            else tDistanceFactors = {1.25, 3}
            end
            local tAngleVariations = {-45, 0, 45}
            --Make sure we have at least some distance we're moving away from
            if iDistanceFromTargetToStart == 0 then iDistanceFromTargetToStart = 1 end

            if math.abs(iDistanceFromTargetToStart) < 4 then
                local iFactorIncrease = 4 / iDistanceFromTargetToStart
                for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                    tDistanceFactors[iDistanceFactor] = tDistanceFactors[iDistanceFactor] * iFactorIncrease
                end
            end
            for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                for iAngleAlternative = 1, table.getn(tAngleVariations) do
                    tPossibleTarget = M27Utilities.MoveInDirection(tTargetPos, iAngleFromTargetToStart + tAngleVariations[iAngleAlternative], iDistanceFromTargetToStart * tDistanceFactors[iDistanceFactor])
                    if M27MapInfo.GetSegmentGroupOfLocation(sPathing, tPossibleTarget) == iPathingGroupWanted then
                        bCanPathToTarget = true
                        break
                    end
                end
                if bCanPathToTarget then break end
                if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFactor='..iDistanceFactor..'; tPossibleTarget based on the last of the angle variations='..repru(tPossibleTarget)..'; still cant path to the target so will keep looking') end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if can path to target, bCanPathToTarget='..tostring(bCanPathToTarget)..'; tPossibleTarget='..repru(tPossibleTarget)) end

    if bCanPathToTarget then
        --Consider if the target meets any other values specified (e.g. if must be certain distance away from current target or unit)
        if bCheckIfExistingTargetIsBetter == true or iMinDistanceFromExistingCommandTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Checking against existing target to see if thats better') end
            if oPathingUnit.GetNavigator then
                local oNavigator = oPathingUnit:GetNavigator()
                if oNavigator.GetCurrentTargetPos then
                    local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                    if M27Utilities.IsTableEmpty(tExistingTargetPos) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': tExistingTargetPos='..repru(tExistingTargetPos)..'; Distance to possible target='..M27Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget)..'; iMinDistanceFromExistingCommandTarget='..(iMinDistanceFromExistingCommandTarget or 'nil')..'; Pathing group of this='..M27MapInfo.GetSegmentGroupOfLocation(sPathing, tExistingTargetPos)..'; Pathing group wanted='..iPathingGroupWanted..'; sPathing='..sPathing..'; Distance of existing position toa ctual target='..M27Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)) end
                        if M27MapInfo.GetSegmentGroupOfLocation(sPathing, tExistingTargetPos) == iPathingGroupWanted then

                            --Do we have a minimum distance away from current target required?
                            if iMinDistanceFromExistingCommandTarget and M27Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget) < iMinDistanceFromExistingCommandTarget then
                                if bDebugMessages == true then LOG(sFunctionRef..': Distance between existing target position and possible target position is less than the min distance; tExistingTargetPos='..repru(tExistingTargetPos)..'; tPossibleTarget='..repru(tPossibleTarget)) end
                                tPossibleTarget = tExistingTargetPos
                            else
                                --Is the existing target position closer to the distance required than the new position, factoring in if we want a negative position or not?
                                local iDistanceFromQueuedMoveLocationToTarget = M27Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)
                                local iDistanceFromPossibleTargetToTarget = M27Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)
                                --Are these further away from the start position than the actual target?
                                if math.abs(iDistanceFromQueuedMoveLocationToTarget - iDistanceFromTargetToStart) < math.abs(iDistanceFromPossibleTargetToTarget - iDistanceFromTargetToStart) then
                                    --Have we said we want to move closer if the initial point is blocked?
                                    if not(bMoveCloserBeforeFurtherIfBlocked) or iDistanceFromQueuedMoveLocationToTarget <= iDistanceFromTargetToStart then
                                        --Factor in we might be infront of the target and actually want to be behind
                                        local iDistanceFromStartToTarget = M27Utilities.GetDistanceBetweenPositions(tStartPos, tTargetPos)
                                        local iDistanceFromQueuedToStart = M27Utilities.GetDistanceBetweenPositions(tStartPos, tExistingTargetPos)
                                        local iDistanceFromPossibleTargetToStart = M27Utilities.GetDistanceBetweenPositions(tStartPos, tPossibleTarget)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFromQueuedMoveLocationToTarget='..iDistanceFromQueuedMoveLocationToTarget..'; iDistanceFromPossibleTargetToTarget='..iDistanceFromPossibleTargetToTarget..'; iDistanceFromQueuedToStart='..iDistanceFromQueuedToStart..'; iDistanceFromStartToTarget='..iDistanceFromStartToTarget..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart) end
                                        if iDistanceFromQueuedToStart > 1 and ((iDistanceFromQueuedToStart < iDistanceFromStartToTarget and iDistanceFromTargetToStart > 0) or (iDistanceFromQueuedToStart > iDistanceFromStartToTarget and iDistanceFromTargetToStart < 0)) then

                                            --Adjust these based on if they're in the opposite direction - replaced with above distance checks to see if quicker
                                            --[[local iAngleDifference = math.abs(M27Utilities.GetAngleFromAToB(tTargetPos, tExistingTargetPos) - iAngleFromTargetToStart)
                                            if iAngleDifference <= 90 then iDistanceFromQueuedMoveLocationToTarget = -iDistanceFromQueuedMoveLocationToTarget end
                                            iAngleDifference = math.abs(M27Utilities.GetAngleFromAToB(tTargetPos, tPossibleTarget) - iAngleFromTargetToStart)
                                            if iAngleDifference <= 90 then iDistanceFromPossibleTargetToTarget = -iDistanceFromPossibleTargetToTarget end
                                            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFromQueuedMoveLocationToTarget='..iDistanceFromQueuedMoveLocationToTarget..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart..'; iDistanceFromPossibleTargetToTarget='..iDistanceFromPossibleTargetToTarget) end
                                            if math.abs(iDistanceFromQueuedMoveLocationToTarget - iDistanceFromTargetToStart) < math.abs(iDistanceFromPossibleTargetToTarget -iDistanceFromTargetToStart) then
                                            --]]
                                            if bDebugMessages == true then LOG(sFunctionRef..': Existing location is closer than the new possible location so go with this') end
                                            --Existing location is closer than the new location so go with this
                                            tPossibleTarget = tExistingTargetPos
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        --This could be due to a pathfinding error - is either location in same pathing group as our start position?
        local aiBrain = oPathingUnit:GetAIBrain()
        local iStartPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(sPathing, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
        if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find a target in same pathing group, will double check with canpathto; iStartPathingGroup='..iStartPathingGroup..'; Unit position pathing group='..M27MapInfo.GetSegmentGroupOfLocation(sPathing, oPathingUnit:GetPosition())..'; target pathing group='..iPathingGroupWanted) end
        if iStartPathingGroup == iPathingGroupWanted then
            --Unit is in a different pathing group; check if it can path to start - double-check its dif pathing group to be sure
            if not(iStartPathingGroup == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oPathingUnit:GetPosition())) then
                if M27MapInfo.RecheckPathingOfLocation(sPathing, oPathingUnit, tTargetPos, nil) then
                    --Pathing was wrong and should now be fixed
                    tPossibleTarget = {tTargetPos[1], tTargetPos[2], tTargetPos[3]}
                    bCanPathToTarget = true
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Pathing unit cant path to player start point so pathing is correct') end
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': iStartPathingGroup='..iStartPathingGroup..'; Segment group of pathing unit='..M27MapInfo.GetSegmentGroupOfLocation(sPathing, oPathingUnit:GetPosition())..'; Pathing group of destination='..M27MapInfo.GetSegmentGroupOfLocation(sPathing, tTargetPos)) end
                M27Utilities.ErrorHandler('Possible flaw in logic - likely because the original target to try and move to cant be pathed to.  Most likely scenario is when trying to retreat and picking a location x distance away that cant be pathed to', true)
            end
        else
            --Target is in a different pathing group to start; check if unit is in same group as start and (if so) if it can path to the target
            if iStartPathingGroup == M27MapInfo.GetSegmentGroupOfLocation(sPathing, oPathingUnit:GetPosition()) then
                --Double-check it really is a different pathing group to be sure before using canpathto
                --if not(iStartPathingGroup == M27MapInfo.GetSegmentGroupOfLocation(sPathing, tTargetPos)) then
                if M27MapInfo.RecheckPathingOfLocation(sPathing, oPathingUnit, tTargetPos, nil) then
                    --Error with map's predetermined pathing logic
                    tPossibleTarget = {tTargetPos[1], tTargetPos[2], tTargetPos[3]}
                    bCanPathToTarget = true
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Pathing unit cant path to target point so pathing is correct') end
                end
            end
        end
        if not(bCanPathToTarget) then
            if bDebugMessages == true then LOG(sFunctionRef..': Cant path to the target so will return nil') end
            --dont have a valid pathing target so return nil
            tPossibleTarget = nil
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code; tPossibleTarget='..repru(tPossibleTarget or {'nil'})) end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return tPossibleTarget
end


function GetPositionNearTargetInSamePathingGroup(tStartPos, tTargetPos, iDistanceFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions, bCheckAgainstExistingCommandTarget, iMinDistanceFromCurrentBuilderMoveTarget)
    --DEPRECATED, use GetPositionAtOrNearTargetInPathingGroup instead


    --Returns the position to move to in order to be iDistanceFromTarget away from tTargetPos
    --Returns nil if empty table
    --Returns pathing unit's current move location if it also fits the criteria
    --iAngleBase: 0 = straight line; 90 and 270: right angle to the direction; 180 - opposite direction (not yet supported other angles)
    --oPathingUnit - Unit to use for seeing if can path to the desired location
    --iNearbyMethodIfBlocked: default and 1: Move closer to target until are in same pathing group, checking side options as we go;
            --2: Move further away from target until are in same pathing group
            --3: Alternate between closer and further away from target until are in same pathing group
        --bTrySidePositions: Alternates left and right if base line can't find a position, based on the outer distance (so effectively plotting a circle around the target)
    --bCheckAgainstExistingCommandTarget: If true, then will check oPathingUnit's current target location, and if that appears a better fit than what this method results in
        --iMinDistanceFromCurrentBuilderMoveTarget - if bCheckAgainstExistingCommandTarget is true, then this will also check if the potential move target is >1 from the current target (and ignore if its not)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPositionNearTargetInSamePathingGroup'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    M27Utilities.ErrorHandler('Deprecated function as of v15')
    if bCheckAgainstExistingCommandTarget == nil then bCheckAgainstExistingCommandTarget = true end
    if iMinDistanceFromCurrentBuilderMoveTarget == nil then iMinDistanceFromCurrentBuilderMoveTarget = 0 end
    if bDebugMessages == true then LOG(sFunctionRef..': Start; oPathingUnit blueprint='..oPathingUnit.UnitId..'; iDistanceFromTarget='..iDistanceFromTarget) end
    local rPlayableArea = M27MapInfo.rMapPlayableArea
    local iMaxX = rPlayableArea[3] - rPlayableArea[1]
    local iMaxZ = rPlayableArea[4] - rPlayableArea[2]

    local iAdjDistance = 0
    local iLoopCount = 0
    local iIncrement = 0.5

    local iMaxLoopCount = math.max(math.abs(iDistanceFromTarget) / iIncrement + 1, 4)
    local bHaveValidTarget = false
    local tPossibleTarget = {}
    local iAngleToTarget = 0
    local iMaxAdjCycleCount = 2
    if iNearbyMethodIfBlocked == 3 then iMaxAdjCycleCount = 3 end
    local iMaxAngleCycleCount = 1
    if bTrySidePositions == true then iMaxAngleCycleCount = 3 end
    local iAdjSignage
    local tBasePossibleTarget = {}
    if bDebugMessages == true then LOG(sFunctionRef..': bHaveValidTarget='..tostring(bHaveValidTarget)..'; iDistanceFromTarget='..iDistanceFromTarget..'; iMaxLoopCount='..iMaxLoopCount..'; iLoopCount='..iLoopCount) end
    while bHaveValidTarget == false do
        iLoopCount = iLoopCount + 1
        if iLoopCount > iMaxLoopCount then
            if bDebugMessages == true then LOG(sFunctionRef..': Have exhausted all options on the way to the target location, so will give up moving within range of the target') end
            break
        end

        if bDebugMessages == true then LOG(sFunctionRef..': iLoopCount='..iLoopCount..'; iMaxAdjCycleCount='..iMaxAdjCycleCount..'; iAdjDistance='..iAdjDistance..'; iDistanceFromTarget='..iDistanceFromTarget..' tBasePossibleTarget='..repru(tBasePossibleTarget)) end

        for iAdjCycleCount = 1, iMaxAdjCycleCount do
            if iAdjCycleCount == iMaxAdjCycleCount then iAdjDistance = iAdjDistance + 1 end  --e.g. if passed distance of 0, then want to increase the distance by 1 after the first attempt or else will be checking the same location each time
            if iAdjCycleCount < 3 then iAdjSignage = 1 else iAdjSignage = -1 end
            iAngleToTarget = iAngleBase

            tBasePossibleTarget = M27Utilities.MoveTowardsTarget(tTargetPos, tStartPos, (iDistanceFromTarget + iAdjDistance) * iAdjSignage, iAngleToTarget)
            if bDebugMessages == true then LOG(sFunctionRef..': Will move from the target towards the start by '..(iDistanceFromTarget + iAdjDistance) * iAdjSignage..' distance, as iDistanceFromTarget='..iDistanceFromTarget..'; iAdjDistance='..iAdjDistance..'; iAdjSignage='..iAdjSignage..'; iAngleToTarget='..iAngleToTarget..'; tBasePossibleTarget='..repru(tBasePossibleTarget)) end
            for iAngleCycleCount = 1, iMaxAngleCycleCount do

                if iAngleCycleCount == 1 then
                    tPossibleTarget = tBasePossibleTarget
                    if bDebugMessages == true then LOG(sFunctionRef..': tPossibleTarget is set to equal tBasePossibleTarget') end
                else
                    if iAngleCycleCount == 2 then
                        iAngleToTarget = 90
                        iAdjDistance = iAdjDistance + 1
                    elseif iAngleCycleCount == 3 then iAngleToTarget = 270
                    end
                    iAngleToTarget = iAngleToTarget + iAngleBase
                    if iAngleToTarget < 0 then iAngleToTarget = iAngleToTarget + 360
                    elseif iAngleToTarget > 360 then iAngleToTarget = iAngleToTarget - 360 end

                --MoveTowardsTarget(tStartPos, tTargetPos, iDistanceToTravel, iAngle)
                    --tPossibleTarget = M27Utilities.MoveTowardsTarget(tTargetPos, tStartPos, (iDistanceFromTarget + iAdjDistance) * iAdjSignage, iAngleToTarget)
                    tPossibleTarget = M27Utilities.MoveInDirection(tTargetPos, iAngleToTarget, iDistanceFromTarget + iAdjDistance)
                    if bDebugMessages == true then LOG(sFunctionRef..': tPossibleTarget is based on iAngleToTarget of '..iAngleToTarget..'; and tPossibleTarget is '..repru(tPossibleTarget)..'; iDistanceFromTarget + iAdjDistance='..iDistanceFromTarget + iAdjDistance) end
                end

                if bDebugMessages == true then
                    LOG(sFunctionRef..': tPossibleTarget='..repru(tPossibleTarget)..'; checking if its valid; oPathingUnit blueprint='..oPathingUnit.UnitId..'; Adjusted distance='..(iDistanceFromTarget + iAdjDistance) * iAdjSignage..'; iAngleCycleCount='..iAngleCycleCount..'; iAdjCycleCount='..iAdjCycleCount..'; iLoopCount='..iLoopCount..'; iAngleToTarget='..iAngleToTarget)
                    M27Utilities.DrawLocation(tPossibleTarget, nil, 4, 10)
                end
                --Are we in map bounds?
                tPossibleTarget[1] = math.max(rPlayableArea[1] + 1, math.min(tPossibleTarget[1], (iMaxX-1)))
                tPossibleTarget[3] = math.max(rPlayableArea[2] + 1, math.min(tPossibleTarget[3], (iMaxZ-1)))

                        --Are we in the same segment group?

                if M27MapInfo.InSameSegmentGroup(oPathingUnit, tPossibleTarget) == true then
                    --are in same pathing grouping
                    if bDebugMessages == true then LOG(sFunctionRef..': tPossibleTarget is valid, ='..repru(tPossibleTarget)..'; checking if its valid; oPathingUnit blueprint='..oPathingUnit.UnitId) end
                    if bDebugMessages == true then LOG(sFunctionRef..': have valid location='..repru(tPossibleTarget)) end
                    bHaveValidTarget = true
                    break
                    --note - not bothering with check re if target built on as engi seems to cope ok id building covering its move location
                else
                    if bDebugMessages == true then
                        local iTargetSegmentX, iTargetSegmentZ = M27MapInfo.GetPathingSegmentFromPosition(tPossibleTarget)
                        local iUnitSegmentGroup = M27MapInfo.GetUnitSegmentGroup(oPathingUnit)
                        if iUnitSegmentGroup == nil then iUnitSegmentGroup = 'nil' end
                        local iSegmentGroupOfTarget = M27MapInfo.GetSegmentGroupOfTarget(M27UnitInfo.GetUnitPathingType(oPathingUnit), iTargetSegmentX, iTargetSegmentZ)
                        if iSegmentGroupOfTarget == nil then iSegmentGroupOfTarget = 'nil' end
                        LOG(sFunctionRef..': Not in same segment group; oPathingUnitSegmentGroup='..iUnitSegmentGroup..'; SegmentGroupOfTarget='..iSegmentGroupOfTarget)
                    end
                end
            end
            if bHaveValidTarget == true then break end
        end
    end
    --Check if already have a move location that will take us here
    if bHaveValidTarget == true then
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if already have a move location that will take us to the target') end
        tPossibleTarget[2] = GetTerrainHeight(tPossibleTarget[1], tPossibleTarget[3])
        if bCheckAgainstExistingCommandTarget == true then
            if bDebugMessages == true then LOG(sFunctionRef..': Checking against existing target to see if thats better') end
            if oPathingUnit.GetNavigator then
                local oNavigator = oPathingUnit:GetNavigator()
                if oNavigator.GetCurrentTargetPos then
                    local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                    if M27Utilities.IsTableEmpty(tExistingTargetPos) == false then
                        if M27MapInfo.InSameSegmentGroup(oPathingUnit, tExistingTargetPos) == true then
                            local iDistanceBetweenQueuedAndPossibleTarget = M27Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget)
                            if bDebugMessages == true then LOG(sFunctionRef..': iDistanceBetweenQueuedAndPossibleTarget='..iDistanceBetweenQueuedAndPossibleTarget) end
                            if iDistanceBetweenQueuedAndPossibleTarget > iMinDistanceFromCurrentBuilderMoveTarget then
                                local tPatherPos = oPathingUnit:GetPosition()
                                local iDistanceFromQueuedMoveLocationToTarget = M27Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)
                                local iDistanceFromPossibleTargetToTarget = M27Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)
                                local iDistanceFromPatherToPossibleTarget = M27Utilities.GetDistanceBetweenPositions(tPossibleTarget, tPatherPos)
                                local iDistanceFromPatherToQueuedLocation = M27Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPatherPos)

                                --first check - are they both within the desired range?
                                local bPossibleTargetIsGood, bQueuedTargetIsGood
                                if iDistanceFromQueuedMoveLocationToTarget == iDistanceFromTarget then bQueuedTargetIsGood = true
                                elseif iDistanceFromQueuedMoveLocationToTarget < iDistanceFromTarget then
                                    if iNearbyMethodIfBlocked == 2 then --Want to be >=
                                        bQueuedTargetIsGood = false
                                    else bQueuedTargetIsGood = true
                                    end
                                else --must be > distance
                                    if iNearbyMethodIfBlocked == 1 then --Want to be <=
                                        bQueuedTargetIsGood = false else bQueuedTargetIsGood = true
                                    end
                                end

                                if iDistanceFromPossibleTargetToTarget == iDistanceFromTarget then bPossibleTargetIsGood = true
                                elseif iDistanceFromPossibleTargetToTarget < iDistanceFromTarget then
                                    if iNearbyMethodIfBlocked == 2 then --Want to be >=
                                        bPossibleTargetIsGood = false
                                    else bPossibleTargetIsGood = true
                                    end
                                else --must be > distance
                                    if iNearbyMethodIfBlocked == 1 then --Want to be <=
                                        bPossibleTargetIsGood = false else bPossibleTargetIsGood = true
                                    end
                                end
                                local bBothGoodOrBad = false
                                if bPossibleTargetIsGood == true and bQueuedTargetIsGood == true then bBothGoodOrBad = true
                                elseif bPossibleTargetIsGood == false and bQueuedTargetIsGood == false then bBothGoodOrBad = true end



                                if bBothGoodOrBad == false then
                                    --One is better than the other so pick it
                                    if bDebugMessages == true then LOG(sFunctionRef..': One of locations is better than the other at meeting initial requirements so will pick it; bQueuedTargetIsGood='..tostring(bQueuedTargetIsGood)) end
                                    if bQueuedTargetIsGood == true then tPossibleTarget = tExistingTargetPos end
                                else
                                    --both are good or bad re meeting the requirements; pick the one that's closest to the target
                                    if bDebugMessages == true then LOG(sFunctionRef..': Both locations are equally good/bad; if theyre both within the target distance will return closet to builder/pather; if theyre both outside the target will pick the one closest to target') end
                                    if iDistanceFromPossibleTargetToTarget <= iDistanceFromTarget and iDistanceFromQueuedMoveLocationToTarget <= iDistanceFromTarget and iDistanceFromPatherToQueuedLocation <= iDistanceFromPatherToPossibleTarget then tPossibleTarget = tExistingTargetPos
                                    elseif iDistanceFromPossibleTargetToTarget > iDistanceFromTarget and iDistanceFromQueuedMoveLocationToTarget > iDistanceFromTarget and iDistanceFromQueuedMoveLocationToTarget <= iDistanceFromPossibleTargetToTarget then tPossibleTarget = tExistingTargetPos
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    else tPossibleTarget = nil end
    if bDebugMessages == true then
        if M27Utilities.IsTableEmpty(tPossibleTarget) == true then LOG(sFunctionRef..': End of code, tPossibleTarget is empty')
        else LOG(sFunctionRef..': End of code, tPossibleTarget='..repru(tPossibleTarget)) end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return tPossibleTarget
end
--PUT IN TO HELP SEARCHING - USE GetPositionAtOrNearTargetInPathingGroup instead
function MoveTowardsSameGroupTarget(tStartPos, tTargetPos, iDistanceFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions, bCheckAgainstExistingCommandTarget, iMinDistanceFromCurrentBuilderMoveTarget)
    M27Utilities.ErrorHandler('Obsolete code')
    --GetPositionNearTargetInSamePathingGroup(tStartPos, tTargetPos, iDistanceFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions, bCheckAgainstExistingCommandTarget, iMinDistanceFromCurrentBuilderMoveTarget)
end

function MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction, bReturnMoveLocationifGivenOne)
    --gives oBuilder a move command to get them within range of building on tLocation, factoring in the size of buildingType
    --sBlueprintID - if nil, then will treat the action as having a size of 0
    --iBuildDistanceMod - increase or decrease if want to move closer/further away than build distance would send you; e.g. if want to get 3 within the build distance, set this to -3
    --bReturnMovePathInstead - if true return move destination instead of moving there; returns oBuilder's current position if it doesnt need to move
    --bUpdatePlatoonMovePath - default false; if true then if oBuilder has a platoon, updates that platoon's movement path
    --bReturnNilIfAlreadyMovingNearConstruction - will return nil if bReturnMovePathInstead is set to true and unit is already moving towards target, otherwise will return current move target if its close enough, or the builder position if already in position
    --bReturnMoveLocationifGivenOne - defaults to false, if true then will return the location of the move target if gave one (or nil if didnt refresh/update)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveNearConstruction'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if EntityCategoryContains(M27UnitInfo.refCategoryNavalFactory, sBlueprintID) then bDebugMessages = true end
    --if oBuilder == M27Utilities.GetACU(aiBrain) then bDebugMessages = true end
    if bDebugMessages == true then
        local sBuilderName = oBuilder.UnitId
        sBuilderName = sBuilderName..M27UnitInfo.GetUnitLifetimeCount(oBuilder)
        LOG(sFunctionRef..': Start; oBuilderId and unique count='..sBuilderName..'; target location='..repru(tLocation)..'; Builder location='..repru(oBuilder:GetPosition())..'; dist between them='..M27Utilities.GetDistanceBetweenPositions(oBuilder:GetPosition(), tLocation)..'; Amphib pathing group of builder='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oBuilder:GetPosition())..'; Pathing group of target location='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, tLocation))
        M27Utilities.DrawLocation(tLocation)
    end
    if iBuildDistanceMod == nil then iBuildDistanceMod = 0 end
    if bReturnMovePathInstead == nil then bReturnMovePathInstead = false end
    if bUpdatePlatoonMovePath == nil then bUpdatePlatoonMovePath = false end
    if bReturnNilIfAlreadyMovingNearConstruction == nil then bReturnNilIfAlreadyMovingNearConstruction = true end
    local bReturnMoveTarget = false
    local tBuilderLocation = oBuilder:GetPosition()
    local iBuildDistance = 0
    local oBuilderBP = oBuilder:GetBlueprint()
    if oBuilderBP.Economy and oBuilderBP.Economy.MaxBuildDistance then iBuildDistance = oBuilderBP.Economy.MaxBuildDistance end
    iBuildDistance = iBuildDistance + iBuildDistanceMod
    --if iBuildDistance <= 0 then iBuildDistance = 1 end
    local iBuildingSize
    if sBlueprintID == nil then
        iBuildingSize = 0
    else
        iBuildingSize = M27UnitInfo.GetBuildingSize(sBlueprintID)[1]
    end
    local fSizeMod = 0.5
    local iDistanceWantedFromTarget = iBuildingSize * fSizeMod + iBuildDistance + math.min(oBuilderBP.SizeX, oBuilderBP.SizeZ) * 0.5 - 0.01
    local tPossibleTarget
    local bIgnoreMove = false
    local bUseLocationInsteadOfMoveNearby = false
    local iPossibleDistanceFromTarget

    --Determine target:
    local iCurrentDistanceFromTarget = M27Utilities.GetDistanceBetweenPositions(tBuilderLocation, tLocation)
    if bDebugMessages == true and oBuilder then LOG(sFunctionRef..': oBuilder='..oBuilder.UnitId..M27UnitInfo.GetUnitLifetimeCount(oBuilder)..'; Distance between builder location and target location='..iCurrentDistanceFromTarget..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget..'; Angle from builder to target='..M27Utilities.GetAngleFromAToB(tBuilderLocation, tLocation)..'; Expected position to move to if reduce the build range slightly='..repru(M27Utilities.MoveInDirection(tBuilderLocation, M27Utilities.GetAngleFromAToB(tBuilderLocation, tLocation), iCurrentDistanceFromTarget - (iDistanceWantedFromTarget - 0.25), true))..'; If instead move from target towards start by the distance wanted from target, then angleTargetToStart='..M27Utilities.GetAngleFromAToB(tLocation, tBuilderLocation)..'; Location='..repru(M27Utilities.MoveInDirection(tLocation, M27Utilities.GetAngleFromAToB(tLocation, tBuilderLocation), iDistanceWantedFromTarget - 0.25, true))) end
    if iCurrentDistanceFromTarget > iDistanceWantedFromTarget then
        --Add slight buffer so move into place:
        if bDebugMessages == true then LOG(sFunctionRef..': About to get move position near the target '..repru(tLocation)..'; iCurrentDistanceFromTarget='..iCurrentDistanceFromTarget..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget..'; will decrease distance wanted very slightly; tBuilderLocation='..repru(tBuilderLocation)) end
        iDistanceWantedFromTarget = iDistanceWantedFromTarget - 0.25 --NOTE: If changing this, then also consider if the below adjustment for naval factories with cliffs needs changing

        --GetPositionNearTargetInSamePathingGroup(tStartPos, tTargetPos, iDistanceWantedFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions)
        local iMinDistanceFromCurrentBuilderMoveTarget = 2 --dont want to change movement path from the one generated if it's not that different

        --tPossibleTarget = GetPositionNearTargetInSamePathingGroup(tBuilderLocation, tLocation, iDistanceWantedFromTarget, 0, oBuilder, 1, true, true, iMinDistanceFromCurrentBuilderMoveTarget)
        tPossibleTarget = GetPositionAtOrNearTargetInPathingGroup(tBuilderLocation, tLocation, iDistanceWantedFromTarget, 0, oBuilder, true, true, iMinDistanceFromCurrentBuilderMoveTarget)

        --Adjust further for naval factory to facilitate greater cliff-building
        if tPossibleTarget and EntityCategoryContains(M27UnitInfo.refCategoryNavalFactory, sBlueprintID) then
            --If we move from Possible target towards our currnet position do we come across a cliff very soon?

            local bHaveCliff = false

            local iAngleFromMoveTarget = M27Utilities.GetAngleFromAToB(tPossibleTarget, tBuilderLocation)

            local iMaxCliffSearchRange = 15 + math.floor(iBuildDistance)
            local sPathing = M27UnitInfo.GetUnitPathingType(oBuilder)
            local iEngiPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(sPathing, tBuilderLocation)
            function IsCliffBlockingTarget(tTarget)
                local iDistToMoveTarget = M27Utilities.GetDistanceBetweenPositions(tBuilderLocation, tTarget)
                local tCliffPositionCheck
                if iDistToMoveTarget > 1 then
                    for iDistAdjust = 1, math.min(iMaxCliffSearchRange, math.floor(iDistToMoveTarget)) do
                        tCliffPositionCheck = M27Utilities.MoveInDirection(tPossibleTarget, iAngleFromMoveTarget, iDistAdjust, true, false)
                        if not(M27MapInfo.GetSegmentGroupOfLocation(sPathing, tCliffPositionCheck) == iEngiPathingGroup) then
                            return true
                        end
                    end
                end
                return false
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Building naval factory, IsCliffBlockingTarget(tPossibleTarget='..tostring(IsCliffBlockingTarget(tPossibleTarget))..'; tPossibleTarget='..repru(tPossibleTarget)..'; tLocation (of where we want to build)='..repru(tLocation)) end
            if IsCliffBlockingTarget(tPossibleTarget) then
                --Can we get any closer to our build distance if we broaden the angle range?  Also increase the distance slightly
                iDistanceWantedFromTarget = iDistanceWantedFromTarget + 0.1
                local iAngleToEngi = M27Utilities.GetAngleFromAToB(tLocation, tBuilderLocation)
                local tReplacementTarget
                local tPathingPosition
                if bDebugMessages == true then LOG(sFunctionRef..': About to try different positions from tLocation '..repru(tLocation)..' to tBuilderLocation '..repru(tBuilderLocation)..'; Angle to here='..iAngleToEngi..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
                for iAngleAdjust = 0, 40, 8 do
                    for iAngleFactor = -1, 1, 2 do
                                                    --MoveInDirection(tStart, iAngle, iDistance, bKeepInMapBounds, bTravelUnderwater)
                        tPathingPosition = M27Utilities.MoveInDirection(tLocation, iAngleToEngi + iAngleAdjust * iAngleFactor, iDistanceWantedFromTarget, true, false)
                        if bDebugMessages == true then

                            local iColour = 3
                            if M27MapInfo.GetSegmentGroupOfLocation(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then iColour = 7 end
                            LOG(sFunctionRef..': Considering tPathingPosition='..repru(tPathingPosition)..'; iAngleAdjust='..iAngleAdjust * iAngleFactor..'; Pathing group='..M27MapInfo.GetSegmentGroupOfLocation(sPathing, tPathingPosition)..'; Engi pathing group='..iEngiPathingGroup..'; Is cliff blocking target='..tostring(IsCliffBlockingTarget(tPathingPosition))..'; will draw match in white, nonmatch in black. iColour='..iColour..'; Dist from original move target planned='..M27Utilities.GetDistanceBetweenPositions(tPathingPosition, tPossibleTarget))
                            M27Utilities.DrawLocation(tPathingPosition, false, iColour, 200)
                        end
                        if M27MapInfo.GetSegmentGroupOfLocation(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then
                            tReplacementTarget = tPathingPosition
                        end

                        if iAngleAdjust == 0 or tReplacementTarget then break end
                    end
                    if tReplacementTarget then break end
                end
                if tReplacementTarget then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a replacement position to use') end
                    tPossibleTarget = {tReplacementTarget[1], tReplacementTarget[2], tReplacementTarget[3]}

                end
            end
        end


        if tPossibleTarget == nil then
            if bDebugMessages == true then LOG(sFunctionRef..': Cant get a nearby location for target; will return tLocation if can path to it') end
            bUseLocationInsteadOfMoveNearby = true
        else
            iPossibleDistanceFromTarget = M27Utilities.GetDistanceBetweenPositions(tLocation, tPossibleTarget)
            if iPossibleDistanceFromTarget - iDistanceWantedFromTarget > 0.01 then --Can sometimes get tiny rounding differences
                if bDebugMessages == true then LOG(sFunctionRef..': Possible target location is outside the build range, so want to just return the target position instead, iPossibleDistanceFromTarget='..iPossibleDistanceFromTarget..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
                bUseLocationInsteadOfMoveNearby = true
            end
        end
        if bUseLocationInsteadOfMoveNearby == true then
            --Couldn't find anywhere; can we path to the target?
            bIgnoreMove = true
            if M27MapInfo.InSameSegmentGroup(oBuilder, tLocation, false) == true then
                if bDebugMessages == true then LOG(sFunctionRef..': Can path to tLocation so returning that') end
                if tPossibleTarget == tLocation then M27Utilities.ErrorHandler('GetPositionAtOrNearTargetInPathingGroup should already consider if target location is valid and use that instead of pathing units current position, so investigate how this has triggered (this was added as quick fix backup for v6 hotfix, but hope was with other changes this wouldnt be needed/trigger') end
                tPossibleTarget = tLocation
            else
                --Could be our logic for pathing is faulty - use canpathto instead
                if M27MapInfo.RecheckPathingOfLocation(M27UnitInfo.GetUnitPathingType(oBuilder), oBuilder, tLocation, nil) then
                    --Faulty pathfinding logic
                    tPossibleTarget = tLocation
                else
                    --Correct that we cant path to the location
                    M27Utilities.ErrorHandler('MoveNearConstructions target location cant be pathed to and cant find pathable positions near it, will return nil, may cause future error depending on what has called this')
                end
            end
        end

        --Is this target different to current move target?
        if tPossibleTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': tPossibleTarget='..repru(tPossibleTarget)) end
            local oNavigator = oBuilder:GetNavigator()
            if oNavigator.GetCurrentTargetPos then
                local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                if M27Utilities.IsTableEmpty(tExistingTargetPos) == false then
                    if M27Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget) < iMinDistanceFromCurrentBuilderMoveTarget then
                        if bDebugMessages == true then LOG(sFunctionRef..': Existing move location '..repru(tExistingTargetPos)..' is close enough to possible target '..repru(tPossibleTarget)..' so will go with that, or return nil if have specified to') end
                        if bReturnNilIfAlreadyMovingNearConstruction == true then tPossibleTarget = nil
                        else tPossibleTarget = tExistingTargetPos end
                        bIgnoreMove = true
                    end
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Are already close enough to target position, so will return builder location or nil depending on function arguments') end
        --Are already in position
        if bReturnNilIfAlreadyMovingNearConstruction == true then tPossibleTarget = nil
        else tPossibleTarget = tBuilderLocation end
        bIgnoreMove = true
    end

    --Move to target:
    if bReturnMovePathInstead == false then
        --Check if unit's current move location is within 1 of this already (note the getpositionneartarget function will have more advanced logic for considering if no need to change current target
        if bIgnoreMove == false then
            --[[if oBuilder.GetNavigator then
                local oNavigator = oBuilder:GetNavigator()
                if oNavigator.GetCurrentTargetPos then
                    local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                    if M27Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget) < 1 then
                        bIgnoreMove = true
                    end
                end
            end]]--
            if bIgnoreMove == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Issuing move command to tPossibleTarget='..repru(tPossibleTarget)) end
                if not(oBuilder[M27UnitInfo.refbSpecialMicroActive]) then
                    IssueMove({oBuilder}, tPossibleTarget)
                    if oBuilder.PlatoonHandle then
                        oBuilder.PlatoonHandle[refiLastOrderType] = refiOrderIssueMove
                        oBuilder.PlatoonHandle[reftLastOrderPosition] = tPossibleTarget
                    end

                    bReturnMoveTarget = bReturnMoveLocationifGivenOne
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Not issuing move command as tPossibleTarget is close to existing target') end
            end
        end
    end
    --Update platoon movement path:
    if bIgnoreMove == false then
        if bUpdatePlatoonMovePath == true and oBuilder.PlatoonHandle then
            if oBuilder.PlatoonHandle[reftMovementPath] == nil then oBuilder.PlatoonHandle[reftMovementPath] = {} end
            if oBuilder.PlatoonHandle[refiCurrentPathTarget] == nil then oBuilder.PlatoonHandle[refiCurrentPathTarget] = 1 end
            if oBuilder.PlatoonHandle[reftMovementPath][oBuilder.PlatoonHandle[refiCurrentPathTarget]] == nil then oBuilder.PlatoonHandle[reftMovementPath][oBuilder.PlatoonHandle[refiCurrentPathTarget]] = {} end
            oBuilder.PlatoonHandle[reftMovementPath][oBuilder.PlatoonHandle[refiCurrentPathTarget]] = tPossibleTarget
        end
    end
    --Return position if have asked for one:
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    if bReturnMovePathInstead == true or bReturnMoveTarget then
        if bDebugMessages == true then
            if tPossibleTarget == nil then LOG(sFunctionRef..': End of function, returning nil')
            else LOG(sFunctionRef..': End of function, returning '..repru(tPossibleTarget)) end
        end
        return tPossibleTarget
    end
end

function RefreshSupportPlatoonMovementPath(oPlatoon)
    --Updates movement path for oPlatoon
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshSupportPlatoonMovementPath'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if oPlatoon:GetPlan() == 'M27MAAAssister' then bDebugMessages = true end
    local sPlatoonName = oPlatoon:GetPlan()

    local sPlatoonRef = sPlatoonName..oPlatoon[refiPlatoonCount]
    --if sPlatoonName == 'M27ScoutAssister' and oPlatoon[refiPlatoonCount] == 2 then bDebugMessages = true end
    --if sPlatoonName == 'M27MAAAssister' and GetGameTimeSeconds() >= 937 and oPlatoon:GetBrain():GetArmyIndex() == 4 and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
    --if sPlatoonName == 'M27EscortAI' and oPlatoon[refiPlatoonCount] == 1 and GetGameTimeSeconds() >= 780  then bDebugMessages = true end
    --if sPlatoonName == 'M27MobileShield' then bDebugMessages = true end
    --if sPlatoonName == 'M27MobileStealth' then bDebugMessages = true end
    --if oPlatoon:GetPlan() == 'M27AttackNearestUnits' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end

    --If no unit assigned default to first intel path midpoint
    local bHaveUnitToFollow = false
    if oPlatoon then
        local iCurrentUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftCurrentUnits, true, true)
        local tCurrentUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftCurrentUnits, false, true)
        local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())

        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonRef..': Start of code') end
        if oPlatoon[reftMovementPath] == nil then oPlatoon[reftMovementPath] = {} end
        if oPlatoon[M27PlatoonTemplates.refbRequiresSingleLocationToGuard] == true then
            --Are we the MAA platoon that is meant to patrol the last rally point? If so then first update its movement path if its not the latest rally point
            if oPlatoon == aiBrain[M27PlatoonFormer.refoMAARallyPatrolPlatoon] then
                local tRallyPointWanted = M27MapInfo.GetNearestRallyPoint(aiBrain, M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain), oPlatoon[refoFrontUnit])
                oPlatoon[reftLocationToGuard] = {tRallyPointWanted[1], tRallyPointWanted[2], tRallyPointWanted[3]}
                if bDebugMessages == true then LOG(sFunctionRef..': Have just assigned location to guard as the rally point wanted='..repru(tRallyPointWanted)..'; all rally points='..repru(aiBrain[M27MapInfo.reftRallyPoints])) end
            end
            oPlatoon[reftMovementPath][1] = oPlatoon[reftLocationToGuard]
            if iCurrentUnits > 0 and M27Utilities.IsTableEmpty(oPlatoon[reftLocationToGuard]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                PlatoonMove(oPlatoon, oPlatoon[reftMovementPath][1])
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Will tell platoon '..sPlatoonName..oPlatoon[refiPlatoonCount]..' to disband as have no units in it or no location to guard') end
                oPlatoon[refiCurrentAction] = refActionDisband
                if M27Utilities.IsTableEmpty(oPlatoon[reftLocationToGuard]) then
                    M27Utilities.ErrorHandler('Platoon plan '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..' was flagged as guarding a location but had no location to guard set so will disband')
                end
            end
        else
            local bNoLongerHaveTargetToFollow = not(DoesPlatoonStillHaveSupportTarget(oPlatoon))
            --local bNoLongerHaveTargetToFollow = false
            local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
            if bNoLongerHaveTargetToFollow == true then
                --Make sure variables are cleared:
                oPlatoon[refoSupportHelperUnitTarget] = nil
                oPlatoon[refoSupportHelperPlatoonTarget] = nil
                oPlatoon[refoPlatoonOrUnitToEscort] = nil
                local tTempMovePosition = {}
                local tCurPosition = GetPlatoonFrontPosition(oPlatoon)
                if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonRef..': Just cleared platoon/unit/support to escort; No scout helper target, will look for intel path instead') end
                if aiBrain[M27Overseer.refbIntelPathsGenerated] == false then --Shouldnt happen but code just in case
                    --Set to current position for now
                    tTempMovePosition = tCurPosition
                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonRef..': No intel path generated, setting to platoon position instead') end
                else
                    tTempMovePosition = aiBrain[M27Overseer.reftIntelLinePositions][1][1]
                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonRef..': No scout helper target, setting to intel path instead') end
                end
                oPlatoon[reftMovementPath][1] = tTempMovePosition
                if M27Utilities.GetDistanceBetweenPositions(tCurPosition, tTempMovePosition) <= 20 then
                    oPlatoon[refiCurrentAction] = refActionDisband
                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonRef..': Have fallen back to intel path, now want to disband') end
                else
                    oPlatoon[refiCurrentPathTarget] = 1
                    if iCurrentUnits > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                        M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                        PlatoonMove(oPlatoon, tTempMovePosition)
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Sending platoon to the temporary move position='..repru(tTempMovePosition)) end
                end
            else
                -- GetPositionToFollowTargets(tUnitsToFollow, oFollowingUnit, iFollowDistance)
                if bDebugMessages == true then LOG(sFunctionRef..': Either helperunit or helperplatoon isnt nil') end
                local tTargetUnitPosition
                local tUnitsToFollow = {}
                local bHavePlatoonTarget = false
                if oPlatoon[refoSupportHelperPlatoonTarget] or oPlatoon[refoPlatoonOrUnitToEscort] then
                    if oPlatoon[refoSupportHelperPlatoonTarget].GetPlatoonUnits or oPlatoon[refoPlatoonOrUnitToEscort].GetPlatoonUnits or oPlatoon[refoPlatoonOrUnitToEscort].GetUnitId then
                        bHavePlatoonTarget = true
                    end
                end
                if bHavePlatoonTarget then
                    --Get the unit(s) we want to follow
                    if oPlatoon[refoSupportHelperPlatoonTarget] then
                        if bDebugMessages == true then LOG(sFunctionRef..': refoSupportHelperPlatoonTarget='..oPlatoon[refoSupportHelperPlatoonTarget]:GetPlan()..oPlatoon[refoSupportHelperPlatoonTarget][refiPlatoonCount]) end
                        if oPlatoon[refoSupportHelperPlatoonTarget][refoFrontUnit] and not(oPlatoon[refoSupportHelperPlatoonTarget][refoFrontUnit].Dead) then tUnitsToFollow = {oPlatoon[refoSupportHelperPlatoonTarget][refoFrontUnit]}
                        else tUnitsToFollow = oPlatoon[refoSupportHelperPlatoonTarget]:GetPlatoonUnits()
                        end
                        tTargetUnitPosition = GetPlatoonFrontPosition(oPlatoon[refoSupportHelperPlatoonTarget])
                    else
                        if oPlatoon[refoPlatoonOrUnitToEscort][refbShouldHaveEscort] == true or oPlatoon[refoPlatoonOrUnitToEscort][M27PlatoonTemplates.refbWantsShieldEscort] == true then
                            tTargetUnitPosition = GetPlatoonFrontPosition(oPlatoon[refoPlatoonOrUnitToEscort])
                            if bDebugMessages == true then
                                if oPlatoon[refoPlatoonOrUnitToEscort].GetPlan then
                                    LOG(sFunctionRef..': refoPlatoonOrUnitToEscort='..oPlatoon[refoPlatoonOrUnitToEscort]:GetPlan()..oPlatoon[refoPlatoonOrUnitToEscort][refiPlatoonCount])
                                else
                                    LOG(sFunctionRef..': Escorting platoon with UnitID='..oPlatoon[refoPlatoonOrUnitToEscort].UnitId)
                                end
                            end
                            if oPlatoon[refoPlatoonOrUnitToEscort][refoFrontUnit] and not(oPlatoon[refoPlatoonOrUnitToEscort][refoFrontUnit].Dead) then
                                tUnitsToFollow = {oPlatoon[refoPlatoonOrUnitToEscort][refoFrontUnit]}
                            else
                                if oPlatoon[refoPlatoonOrUnitToEscort].GetPlatoonUnits then
                                    tUnitsToFollow = oPlatoon[refoPlatoonOrUnitToEscort]:GetPlatoonUnits()
                                end
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Platoon to escort/shield no longer wants an escort or a shield') end
                        end
                    end
                else
                    tUnitsToFollow = {oPlatoon[refoSupportHelperUnitTarget]}
                    tTargetUnitPosition = tUnitsToFollow[1]:GetPosition()
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a platoon target so will get the position of the unit to follow instead = '..repru(tTargetUnitPosition)) end
                end
                if M27Utilities.IsTableEmpty(tTargetUnitPosition) == true then
                    LOG('WARNING - potential error - have no tTargetUnitPosition for the escort/support unit')
                end

                --Check at least 1 of target is alive
                local iFollowingUnitCount = 0
                local oUnitToFollow
                if M27Utilities.IsTableEmpty(tUnitsToFollow) == false then
                    for iUnit, oUnit in tUnitsToFollow do
                        if not(oUnit.Dead) then
                            iFollowingUnitCount = iFollowingUnitCount + 1
                            oUnitToFollow = oUnit
                        end
                    end
                end
                if iFollowingUnitCount == 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonRef..': No units to follow so returning to nearest rally point') end
                    oPlatoon[refiCurrentAction] = refActionGoToNearestRallyPoint
                    oPlatoon[refoSupportHelperPlatoonTarget] = nil
                    oPlatoon[refoPlatoonOrUnitToEscort] = nil
                    oPlatoon[refoSupportHelperUnitTarget] = nil
                    ReturnToBaseOrRally(oPlatoon, M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit]), nil, false, false)
                else
                    if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonRef..': Have '..iFollowingUnitCount..' units that are following') end
                    local oUnitPather = oPlatoon[reftCurrentUnits][1]
                    if oUnitPather == nil or oUnitPather.Dead then
                        if oPlatoon[refiCurrentUnits] > 1 then
                            for _, oPlatoonUnit in oPlatoon[reftCurrentUnits] do
                               if not(oPlatoonUnit.Dead) then oUnitPather = oPlatoonUnit end
                            end
                        else
                            --Platoon is dead so disband
                            if bDebugMessages == true then LOG(sFunctionRef..': Platoon is dead so disband') end
                            oPlatoon[refiCurrentAction] = refActionDisband
                        end
                    end
                    if oUnitPather == nil then
                        if bDebugMessages == true then LOG(sFunctionRef..': Unit pather is nil so disbanding') end
                        oPlatoon[refiCurrentAction] = refActionDisband
                    else
                        --Update distance to follow if are meant to be leading the unit that are escorting, based on our platoon size and target platoon size

                        if oPlatoon[M27PlatoonTemplates.refiAirAttackRange] and aiBrain[M27AirOverseer.refbMercySightedRecently] and (oPlatoon[refoPlatoonOrUnitToEscort][refbACUInPlatoon] or (oPlatoon[refoSupportHelperUnitTarget] and EntityCategoryContains(categories.COMMAND, oPlatoon[refoSupportHelperUnitTarget])) or oPlatoon[refoSupportHelperPlatoonTarget][refbACUInPlatoon]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': AA platoon and mercy detected so wnat to lead the units we are covering if its an ACU platoon') end
                            oPlatoon[refiSupportHelperFollowDistance] = -5
                        else
                            --ACU MAA escort - adjust follow range if ACU vulnerable to air snipe
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking follow distance. oPlatoon[M27PlatoonTemplates.refiAirAttackRange]='..(oPlatoon[M27PlatoonTemplates.refiAirAttackRange] or 'nil')..'; aiBrain[M27Overseer.refbACUVulnerableToAirSnipe]='..tostring(aiBrain[M27Overseer.refbACUVulnerableToAirSnipe])..'; Is ACU in platoon to escort='..tostring(oPlatoon[refoPlatoonOrUnitToEscort][refbACUInPlatoon])..'; Unit ID (if unit)='..(oPlatoon[refoPlatoonOrUnitToEscort].UnitId or 'nil')) end


                            if oPlatoon[M27PlatoonTemplates.refiAirAttackRange] > 0 and aiBrain[M27Overseer.refbACUVulnerableToAirSnipe] and oPlatoon[refoSupportHelperUnitTarget] and EntityCategoryContains(categories.COMMAND, oPlatoon[refoSupportHelperUnitTarget].UnitId) then
                                local oACUPlatoon = oPlatoon[refoSupportHelperUnitTarget].PlatoonHandle
                                --Decide on follow distance based on enemies in range
                                local iIntelCoverage = M27Logic.GetIntelCoverageOfPosition(aiBrain, GetPlatoonFrontPosition(oACUPlatoon), nil, false)
                                if bDebugMessages == true then LOG(sFunctionRef..' Time='..GetGameTimeSeconds()..'; About to decide if MAA platoon should adjust its follow distance. iIntelCoverage='..iIntelCoverage..'; Enemies in range for MAA platoon='..oPlatoon[refiEnemiesInRange]..'; ENemies in range for ACU='..oACUPlatoon[refiEnemiesInRange]..'; Time of last death to surface unit='..(oPlatoon[refiTimeOfLastDeathToSurfaceUnit] or 0)) end
                                if iIntelCoverage > 33 and (oPlatoon[refiEnemiesInRange] == 0 or oACUPlatoon[refiEnemiesInRange] == 0) and GetGameTimeSeconds() - (oPlatoon[refiTimeOfLastDeathToSurfaceUnit] or 0) >= 60 then
                                    oPlatoon[refiSupportHelperFollowDistance] = -20
                                    if bDebugMessages == true then LOG(sFunctionRef..': MAA platoon helping ACU, with no nearby enemies, so will stay infront of ACU') end
                                else
                                    --How close is the nearest enemy
                                    local oClosestEnemy = M27Utilities.GetNearestUnit(oACUPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oACUPlatoon))
                                    if iIntelCoverage > 26.1 and GetGameTimeSeconds() - (oPlatoon[refiTimeOfLastDeathToSurfaceUnit] or 0) >= 45 and (not(oClosestEnemy) or M27Utilities.GetDistanceBetweenPositions(oClosestEnemy:GetPosition(), GetPlatoonFrontPosition(oACUPlatoon)) >= 60)  then
                                        oPlatoon[refiSupportHelperFollowDistance] = -8
                                    else
                                        oPlatoon[refiSupportHelperFollowDistance] = math.min(10, 5 + oPlatoon[refiCurrentUnits])
                                    end
                                end
                            else
                                --oPlatoon[refiSupportHelperFollowDistance]
                                --Do we want to go infront of the target rather than behind?
                                if oPlatoon[refiSupportHelperFollowDistance] < 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Follow distance is negative, will double-check based on platoon size the distance we want') end
                                    local iFollowDistance = math.min(20, 10 + oPlatoon[refiCurrentUnits])
                                    --Escort platoons - be closer to target if its small
                                    if oPlatoon[refoPlatoonOrUnitToEscort] and oPlatoon[refoPlatoonOrUnitToEscort][refiCurrentUnits] <= 3 then
                                        iFollowDistance = math.max(10, iFollowDistance - 5)
                                    end
                                    if oPlatoon[refoPlatoonOrUnitToEscort] and (oPlatoon[refoPlatoonOrUnitToEscort][refbACUInPlatoon] or (oPlatoon[refoPlatoonOrUnitToEscort].UnitId and EntityCategoryContains(categories.COMMAND, oPlatoon[refoPlatoonOrUnitToEscort].UnitId))) and M27Utilities.GetACU(aiBrain):GetHealth() >= 6000 then
                                        oPlatoon[refiSupportHelperFollowDistance] = iFollowDistance
                                    else
                                        oPlatoon[refiSupportHelperFollowDistance] = -iFollowDistance
                                    end
                                elseif oPlatoon[refiSupportHelperFollowDistance] == nil then --NOTE: Platoon initial setup should have determined this, below is backup
                                    oPlatoon[refiSupportHelperFollowDistance] = 5
                                    if EntityCategoryContains(categories.HOVER, oPlatoon[refoFrontUnit].UnitId) then oPlatoon[refiSupportHelperFollowDistance] = 0.5 end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Follower distance not set so will set now') end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonRef..': iFollowDistance='..oPlatoon[refiSupportHelperFollowDistance]) end

                        local refiFollowedUnitIsDeadOrNilCycleCount = 'M27FollowedUnitDeadOrNilCycleCount'
                        if oPlatoon[refiFollowedUnitIsDeadOrNilCycleCount] == nil then oPlatoon[refiFollowedUnitIsDeadOrNilCycleCount] = 0 end
                        if not(oUnitToFollow) or oUnitToFollow.Dead then
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have valid unit to follow, will look for alternative units to follow') end
                            oPlatoon[refiFollowedUnitIsDeadOrNilCycleCount] = oPlatoon[refiFollowedUnitIsDeadOrNilCycleCount] + 1
                            if oPlatoon[refiFollowedUnitIsDeadOrNilCycleCount] > 1 then
                                if oPlatoon[refiFollowedUnitIsDeadOrNilCycleCount] == 2 then
                                    --Try to find a different unit to follow
                                    for iUnit, oUnit in tUnitsToFollow do
                                        if not(oUnit.Dead) then
                                            oUnitToFollow = oUnit
                                            bHaveUnitToFollow = true
                                            break end
                                    end
                                end
                                if bHavePlatoonTarget == false then
                                    if oPlatoon[refiFollowedUnitIsDeadOrNilCycleCount] > 2 then
                                        if bDebugMessages == true then LOG('First unit of platoon to follow has been dead or nil 3+ cycles in a row; will set platoon '..sPlatoonRef..' to move to itself') end
                                        if oPlatoon.GetPosition then oPlatoon[reftMovementPath][1] = GetPlatoonFrontPosition(oPlatoon) end
                                        if oPlatoon[refiFollowedUnitIsDeadOrNilCycleCount] > 6 then
                                            M27Utilities.ErrorHandler('First unit of platoon to follow has been dead or nil 7+ cycles in a row; will disband platoon')
                                            oPlatoon[refiCurrentAction] = refActionDisband
                                        end
                                    end
                                end
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Have valid unit that are following, ='..oUnitToFollow.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToFollow)..'; position='..repru(oUnitToFollow:GetPosition())..'; our platoon position='..repru(GetPlatoonFrontPosition(oPlatoon))) end
                            bHaveUnitToFollow = true

                        end
                        if bHaveUnitToFollow then
                            local oOurPlatoonUnitReference = oPlatoon[refoFrontUnit]
                            if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) then
                                if oOurPlatoonUnitReference == nil then oOurPlatoonUnitReference = oPlatoon[reftCurrentUnits][1] end
                                --oPlatoon[reftMovementPath][1] = M27Logic.GetPositionToFollowTargets(tUnitsToFollow, oOurPlatoonUnitReference, oPlatoon[refiSupportHelperFollowDistance])
                                --GetPositionNearTargetInSamePathingGroup(tStartPos, tTargetPos, iDistanceFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions, bCheckAgainstExistingCommandTarget, iMinDistanceFromCurrentBuilderMoveTarget)
                                if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': About to get position near target in same pathing group; tTargetUnitPosition='..repru(tTargetUnitPosition)..'; distance we want to be towards enemy base from the target='..-oPlatoon[refiSupportHelperFollowDistance]) end
                                --local tNewTargetDestination = GetPositionNearTargetInSamePathingGroup(M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain), tTargetUnitPosition, -oPlatoon[refiSupportHelperFollowDistance], 0, oOurPlatoonUnitReference, 1, true, true, 3)
                                local tNewTargetDestination = GetPositionAtOrNearTargetInPathingGroup(M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain), tTargetUnitPosition, -oPlatoon[refiSupportHelperFollowDistance], 0, oOurPlatoonUnitReference, true, true, 3)
                                if M27Utilities.IsTableEmpty(tNewTargetDestination) == false then
                                    --If new path isnt far enough from our target position then see if get better result if use enemy base
                                    local iDistFromTarget = M27Utilities.GetDistanceBetweenPositions(tTargetUnitPosition, tNewTargetDestination)
                                    local iAbsDif = math.abs(iDistFromTarget - math.abs(oPlatoon[refiSupportHelperFollowDistance]))
                                    if bDebugMessages == true then LOG(sFunctionRef..': iDistFromTarget of new destination='..iDistFromTarget..'; iAbsDif='..iAbsDif) end
                                    if iAbsDif >= 4 then
                                        local tAltDestination = GetPositionAtOrNearTargetInPathingGroup(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], tTargetUnitPosition, oPlatoon[refiSupportHelperFollowDistance], 0, oOurPlatoonUnitReference, true, true, 3)
                                        if M27Utilities.IsTableEmpty(tAltDestination) == false then
                                            local iAltDistFromTarget = M27Utilities.GetDistanceBetweenPositions(tTargetUnitPosition, tAltDestination)
                                            local iAltAbsDif = math.abs(iAltDistFromTarget - math.abs(oPlatoon[refiSupportHelperFollowDistance]))
                                            if bDebugMessages == true then LOG(sFunctionRef..': tAltDestination='..repru(tAltDestination)..'; iAltDistFromTarget='..iAltDistFromTarget..'; iAltAbsDif='..iAltAbsDif) end
                                            if iAltAbsDif + 1 < iAbsDif then
                                                tNewTargetDestination = tAltDestination
                                                if bDebugMessages == true then LOG(sFunctionRef..': Closer to the distance we want if we move towards our base so will try here instead') end
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then
                                    if M27Utilities.IsTableEmpty(tNewTargetDestination) == false then M27Utilities.DrawLocation(tNewTargetDestination, nil, 2, 10) end --red
                                    M27Utilities.DrawLocation(tTargetUnitPosition, nil, 5, 10) --Light blue
                                    LOG(sFunctionRef..': tNewTargetDestination='..repru(tNewTargetDestination or {'nil'})..'; tTargetUnitPosition='..repru(tTargetUnitPosition)..'; Dist between them='..M27Utilities.GetDistanceBetweenPositions(tNewTargetDestination, tTargetUnitPosition))
                                end
                                if M27Utilities.IsTableEmpty(tNewTargetDestination) == true then
                                    if bDebugMessages == true then LOG(sFunctionRef..': tNewTargetDestination is empty, will just use the platoons current movement path instead') end
                                    if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath][1]) == true then
                                        --Couldnt get a new path (e.g. target is in a different pathing group) and we dont have an existing path; return to base for now
                                        oPlatoon[reftMovementPath][1] = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                                    end
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': tNewTargetDestination='..repru(tNewTargetDestination)..'; will set the movement path equal to this') end
                                    oPlatoon[reftMovementPath][1] = tNewTargetDestination
                                end
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': '..sPlatoonRef..': Targetting location of helper; NewMovementPath='..repru(oPlatoon[reftMovementPath][1])..'; tTargetUnitPosition='..repru(tTargetUnitPosition)..'; oPlatoon[refiSupportHelperFollowDistance]='..oPlatoon[refiSupportHelperFollowDistance])
                                end
                                if iCurrentUnits > 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Issuing move command to '..repru(oPlatoon[reftMovementPath][1])) end
                                    M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                                    PlatoonMove(oPlatoon, oPlatoon[reftMovementPath][1])
                                end
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Failed to find a unit to follow') end
                        end
                    end
                end
            end
        end
        oPlatoon[refiCurrentPathTarget] = 1
    else
        if bDebugMessages == true then LOG(sFunctionRef..': dont have a platoon assigned to scout helper') end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function MoveNearHydroAndAssistEngiBuilder(oPlatoon, oHydroBuilder, tHydroPosition)
    --called by AssistHydro platoon.lua AI - intended for platoon that can build/assist
    --oHydroBuilder is the unit constructing a hydro at tHydroPosition that want to assist
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveNearHydroAndAssistEngiBuilder'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local tPlatoonPosition = GetPlatoonFrontPosition(oPlatoon)
    local aiBrain = (oPlatoon[refoBrain] or oPlatoon:GetBrain())
    local iCurHydroDistance = M27Utilities.GetDistanceBetweenPositions(tHydroPosition, tPlatoonPosition)
    local tBuilders = EntityCategoryFilterDown(categories.CONSTRUCTION + categories.REPAIR, oPlatoon:GetPlatoonUnits())
    if M27Utilities.IsTableEmpty(tBuilders) == false then
        local oBuilder = tBuilders[1]
        if iCurHydroDistance > (oBuilder:GetBlueprint().Economy.MaxBuildDistance + M27UnitInfo.GetBuildingSize('UAB1102')[1]*0.5) then
            --Send move command towards the hydro
            if bDebugMessages == true then LOG(sFunctionRef..': About to call MoveNearConstruction') end
            --MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction)
            MoveNearConstruction(aiBrain, oBuilder, tHydroPosition, 'UAB1102', 0, false, true, false, false)
        else
            if oPlatoon[reftMovementPath] == nil then oPlatoon[reftMovementPath] = {} end
            if oPlatoon[reftMovementPath][1] == nil then oPlatoon[reftMovementPath][1] = {} end
            oPlatoon[reftMovementPath][1] = tPlatoonPosition
            oPlatoon[refiCurrentPathTarget] = 1
        end


        if bDebugMessages == true then LOG(sFunctionRef..': Attempting to issue guard command') end
        if oHydroBuilder == nil or oHydroBuilder.Dead or oHydroBuilder:BeenDestroyed() then LOG(sFunctionRef..': ERROR - There is no valid target; wont issue guard command')
        else
            IssueGuard({ oBuilder}, oHydroBuilder)
            oPlatoon[refiLastOrderType] = refiOrderIssueGuard
            oPlatoon[reftLastOrderPosition] = oHydroBuilder:GetPosition()
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ReplaceMovementPathWithNewTarget(oPlatoon, tNewTarget)
    --Replace current movement path target with this
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReplaceMovementPathWithNewTarget'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]] = tNewTarget
    local iLoopCountCheck = 0
    while table.getn(oPlatoon[reftMovementPath]) > oPlatoon[refiCurrentPathTarget] do
        iLoopCountCheck = iLoopCountCheck + 1
        if iLoopCountCheck > 20 then M27Utilities.ErrorHandler('Infinite loop') break end
        table.remove(oPlatoon[reftMovementPath], oPlatoon[refiCurrentPathTarget] + 1)
    end
    if bDebugMessages == true then LOG(oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Replacing remaining movement path with tNewTarget='..repru(tNewTarget)) end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ShouldACUMoveAndConsiderClearingEngis(aiBrain, oACU, sEngineerActionRef, tExistingBuildLocation)
    --Check if want to help an existing engi instead. tExistingBuildLocation should be any existing location we have determined subject to override by this function
    --Returns two variables; the first is true/false whether we want to move near target, the second is the location to move to (if we want to move towards target)
    --Assumes have already checked for part-complete buildings to assist
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ShouldACUMoveAndConsiderClearingEngis'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)


    local bMoveNearTargetInstead = false
    if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][sEngineerActionRef]) == false then
        local oPrimaryEngineer
        local tEngiTarget
        for iRef, tSubtable in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][sEngineerActionRef] do
            if M27UnitInfo.IsUnitValid(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]) then
                oPrimaryEngineer = tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef] --so always have one engi
                if tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refbPrimaryBuilder] then
                    tEngiTarget = tSubtable[M27EngineerOverseer.refEngineerAssignmentActualLocation]
                    oPrimaryEngineer = tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]
                    break
                end
            end
        end
        if oPrimaryEngineer then
            if not(tEngiTarget) then tEngiTarget = oPrimaryEngineer else tEngiTarget = oPrimaryEngineer[M27EngineerOverseer.reftEngineerCurrentTarget] end
            local iEngiDistToTarget = M27Utilities.GetDistanceBetweenPositions(tEngiTarget, oPrimaryEngineer:GetPosition()) - oPrimaryEngineer:GetBlueprint().Economy.MaxBuildDistance
            local iACUDistToTarget = M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oPrimaryEngineer:GetPosition()) - oACU:GetBlueprint().Economy.MaxBuildDistance
            if iACUDistToTarget <= iEngiDistToTarget then
                --Clear existing engis
                local tEngineersToReassign = {}
                for iRef, tSubtable in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][sEngineerActionRef] do
                    if M27UnitInfo.IsUnitValid(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]) then
                        M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef], true)
                        table.insert(tEngineersToReassign, tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef])
                    end
                    M27Utilities.IssueTrackedClearCommands(tEngineersToReassign)
                    ForkThread(M27EngineerOverseer.DelayedEngiReassignment, aiBrain, false, tEngineersToReassign)
                    if bDebugMessages == true then LOG(sFunctionRef..': Have cleared all existing assigned engineers as our ACU is closer') end
                end
            else
                bMoveNearTargetInstead = true
                tExistingBuildLocation = {tEngiTarget[1], tEngiTarget[2], tEngiTarget[3]}
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return bMoveNearTargetInstead, tExistingBuildLocation
end

function ProcessPlatoonAction(oPlatoon)
    --Assumes DeterminePlatoonAction has been called
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ProcessPlatoonAction'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    if oPlatoon and oPlatoon.GetBrain then
        local aiBrain = (oPlatoon[refoBrain] or oPlatoon[refoBrain])
        if aiBrain and aiBrain.PlatoonExists and aiBrain:PlatoonExists(oPlatoon) then

            local sPlatoonName = oPlatoon:GetPlan()
            --if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) and EntityCategoryContains(M27UnitInfo.refCategoryIndirectT2Plus - categories.EXPERIMENTAL - M27UnitInfo.refCategorySniperBot, oPlatoon[refoFrontUnit].UnitId) and GetGameTimeSeconds() >= 1380 and oPlatoon[refiEnemyStructuresInRange] > 0 and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryPD * categories.TECH3, oPlatoon[reftEnemyStructuresInRange])) == false then bDebugMessages = true end
            --if oPlatoon[refbACUInPlatoon] == true and oPlatoon[refoFrontUnit] and EntityCategoryContains(categories.COMMAND, oPlatoon[refoFrontUnit]) and oPlatoon[refoFrontUnit]:HasEnhancement('CloakingGenerator') and oPlatoon[refiEnemiesInRange] > 0 then bDebugMessages = true end
            --if sPlatoonName == 'M27DefenderAI' and oPlatoon[refiPlatoonCount] == 3 then bDebugMessages = true end
            --if oPlatoon[refiCurrentAction] == refActionUseAttackAI then bDebugMessages = true end
            --if GetGameTimeSeconds() >= 600 and aiBrain:GetArmyIndex() == 2 then bDebugMessages = true end
            --if sPlatoonName == 'M27RAS' and oPlatoon[refiPlatoonCount] == 8 and GetGameTimeSeconds() >= 2400 then bDebugMessages = true end
            --if sPlatoonName == 'M27Skirmisher' and M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) and GetGameTimeSeconds() >= 300 and EntityCategoryContains(M27UnitInfo.refCategorySniperBot, oPlatoon[refoFrontUnit].UnitId) and oPlatoon[refiPlatoonCount] == 9 then bDebugMessages = true M27Config.M27ShowUnitNames = true M27Config.M27ShowEnemyUnitNames = true end
            --if sPlatoonName == 'M27AmphibiousDefender' then bDebugMessages = true end
            --if sPlatoonName == 'M27EscortAI' and oPlatoon[refiPlatoonCount] == 1 and GetGameTimeSeconds() >= 780  then bDebugMessages = true end
            --if EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId) then bDebugMessages = true end
            --if sPlatoonName == 'M27AttackNearestUnits' and oPlatoon[refiPlatoonCount] == 86 then bDebugMessages = true end
            --if sPlatoonName == 'M27MexRaiderAI' and oPlatoon[refiPlatoonCount] == 2 and GetGameTimeSeconds() >= 270 then bDebugMessages = true end
            --if sPlatoonName == 'M27ScoutAssister' and oPlatoon[refiPlatoonCount] == 2 then bDebugMessages = true end
            --if sPlatoonName == 'M27MAAAssister' and GetGameTimeSeconds() >= 937 and aiBrain:GetArmyIndex() == 4 and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
            --if sPlatoonName == M27Overseer.sIntelPlatoonRef then bDebugMessages = true end
            --if sPlatoonName == 'M27LargeAttackForce' then bDebugMessages = true end
            --if sPlatoonName == 'M27IntelPathAI' then bDebugMessages = true end
            --if sPlatoonName == 'M27IndirectDefender' then bDebugMessages = true end
            --if sPlatoonName == 'M27CombatPatrolAI' and oPlatoon[refiPlatoonCount] == 1 and GetGameTimeSeconds() >= 480 and aiBrain:GetArmyIndex() == 3 then bDebugMessages = true end
            --if sPlatoonName == 'M27EscortAI' then bDebugMessages = true end
            --if sPlatoonName == 'M27MexLargerRaiderAI' and oPlatoon[refiPlatoonCount] == 2 and aiBrain:GetArmyIndex() == 2 and GetGameTimeSeconds() >= 420 then bDebugMessages = true end
            --if sPlatoonName == 'M27RetreatingShieldUnits' then bDebugMessages = true end
            --if sPlatoonName == 'M27MobileShield' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
            --if sPlatoonName == 'M27MobileStealth' then bDebugMessages = true end
            --if sPlatoonName == 'M27IndirectSpareAttacker' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
            --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
            --if sPlatoonName == 'M27PlateauLandCombat' then bDebugMessages = true end

            if bDebugMessages == true then
                if oPlatoon[refiCurrentAction] == nil then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': refiCurrentAction is nil')
                else LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..sFunctionRef..': refiCurrentAction = '..oPlatoon[refiCurrentAction]) end
            end

            --First add in extra action (if have one) - currently extra action is just overcharge

            local bDontClearActions = false
            local bCancelOvercharge = false
            local bGiveMoveTargetFirst = false
            if bDebugMessages == true then
                local sCurFormation = oPlatoon.PlatoonData.UseFormation
                if sCurFormation == nil then sCurFormation = 'None' end
                LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': formation = '..sCurFormation..'; oPlatoon[refiExtraAction]='..(oPlatoon[refiExtraAction] or 'nil'))
            end
            if not(oPlatoon[refiExtraAction]==nil) then
                local oOverchargingUnit = oPlatoon[reftBuilders][1]
                if bDebugMessages == true then LOG(sFunctionRef..': Have extra action to process') end
                if oPlatoon[refiExtraAction] == refExtraActionOvercharge then
                    if bDebugMessages == true then LOG(sFunctionRef..': Extra action is overcharge - checking have a target') end
                    if oPlatoon[refExtraActionTargetUnit] and not(oPlatoon[refExtraActionTargetUnit].Dead) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have valid target, issuing overcharge') end
                        if M27Utilities.IsTableEmpty(oPlatoon[reftBuilders]) == true then
                            LOG(sFunctionRef..': ERROR - tried calling overcharge action but dont have a unit to issue it to')
                        else
                            local oUnitToIssueOverchargeTo = oOverchargingUnit
                            if oUnitToIssueOverchargeTo and not(oUnitToIssueOverchargeTo.Dead) and not(oUnitToIssueOverchargeTo[M27UnitInfo.refbSpecialMicroActive]) then
                                --Do we need to move closer to get in range of overcharge (e.g. are targetting T2 PD)?
                                local tOCTargetPos = oPlatoon[refExtraActionTargetUnit]:GetPosition()
                                local tOverchargingUnitPos = oOverchargingUnit:GetPosition()
                                local iOverchargingUnitRange = M27UnitInfo.GetUnitMaxGroundRange(oOverchargingUnit) --M27Logic.GetACUMaxDFRange(oOverchargingUnit)
                                local iDistanceBetweenUnits = M27Utilities.GetDistanceBetweenPositions(tOCTargetPos, tOverchargingUnitPos)
                                local tMoveTarget = {}
                                local tPossibleTarget = {}
                                if iDistanceBetweenUnits > iOverchargingUnitRange then
                                    --Move towards the target
                                    local iLoopCount = 0
                                    local iMaxLoop = 100
                                    bGiveMoveTargetFirst = true
                                    --GetPositionNearTargetInSamePathingGroup(tStartPos, tTargetPos, iDistanceWantedFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions)
                                    --tMoveTarget = GetPositionNearTargetInSamePathingGroup(tOverchargingUnitPos, tOCTargetPos, iDistanceBetweenUnits - iOverchargingUnitRange, 0, oOverchargingUnit, 1, true)
                                    tMoveTarget = GetPositionAtOrNearTargetInPathingGroup(tOverchargingUnitPos, tOCTargetPos, iDistanceBetweenUnits - iOverchargingUnitRange, 0, oOverchargingUnit, true, true, 1)
                                    if tMoveTarget == nil then
                                        bCancelOvercharge = true
                                    end
                                end
                                if bCancelOvercharge == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                                    M27Utilities.IssueTrackedClearCommands({oUnitToIssueOverchargeTo})
                                    if bGiveMoveTargetFirst == true then IssueMove({ oOverchargingUnit }, tMoveTarget) end
                                    IssueOverCharge({oOverchargingUnit}, oPlatoon[refExtraActionTargetUnit])
                                    oPlatoon[refiLastOrderType] = refiOrderOvercharge
                                    oPlatoon[reftLastOrderPosition] = oPlatoon[refExtraActionTargetUnit]:GetPosition()
                                    oOverchargingUnit[M27UnitInfo.refbOverchargeOrderGiven] = true
                                    --Give up on issuing overcharge after 4s
                                    M27Utilities.DelayChangeVariable(oOverchargingUnit, M27UnitInfo.refbOverchargeOrderGiven, false, 4, nil, nil)
                                    bDontClearActions = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have just issued overcharge action with gametime='..GetGameTimeSeconds()..' at a unit that is '..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[refExtraActionTargetUnit]:GetPosition())..' away; if current action is nil then will reissue prev action. oPlatoon[refiCurrentAction]='..(oPlatoon[refiCurrentAction] or 'nil')..'; Is the prev action table empty='..tostring(M27Utilities.IsTableEmpty(oPlatoon[reftPrevAction]))) end
                                    --Reissue prev action if current action is nil so we dont stand around for a while
                                    if oPlatoon[refiCurrentAction] == nil then
                                        if M27Utilities.IsTableEmpty(oPlatoon[reftPrevAction]) == false then
                                            for iPrevAction = 1, 10 do
                                                if bDebugMessages == true then LOG(sFunctionRef..': Considering the '..iPrevAction..' previous action; Prev action ref ='..(oPlatoon[reftPrevAction][iPrevAction] or 'nil')) end
                                                if oPlatoon[reftPrevAction][iPrevAction] then
                                                    oPlatoon[refiCurrentAction] = oPlatoon[reftPrevAction][iPrevAction]
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Updated current action to '..oPlatoon[refiCurrentAction]) end
                                                end
                                            end
                                        end
                                        if oPlatoon[refiCurrentAction] == refActionAttackSpecificUnit and not(M27UnitInfo.IsUnitValid(refoTemporaryAttackTarget)) then
                                            M27Utilities.ErrorHandler(sFunctionRef..': No action for the platoon so using prev action but it was to attack a unit that is no logner valid, so will issue new movement path')
                                            oPlatoon[refiCurrentAction] = refActionNewMovementPath
                                        end
                                    end
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Cancelling overcharge')
                                end
                            else
                                LOG(sFunctionRef..': Warning - unit to issue overcharge to isnt valid or is dead')
                            end
                        end
                    else
                        LOG(sFunctionRef..': ERROR - tried calling overcharge action without a target')
                    end
                end
            end

            if oPlatoon[refiCurrentAction] == nil then
                --dont change what are currently doing
                if bDebugMessages == true then LOG(sFunctionRef..': Action is nil so wont change what are currently doing') end
            else
                --local aiBrain = oPlatoon:GetBrain()
                local bPlatoonNameDisplay = false
                if bDebugMessages == true then
                    if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) then LOG(sFunctionRef..': State of platoon front unit='..M27Logic.GetUnitState(oPlatoon[refoFrontUnit])..'; Special Micro='..tostring(M27Utilities.GetACU(aiBrain).M27UnitInfo.refbSpecialMicroActive or false)..'; ACU movementpath='..repru((oPlatoon[reftMovementPath] or {'nil'}))..'; Previously run='..tostring(oPlatoon[refbHavePreviouslyRun])) end
                    if oPlatoon[refbACUInPlatoon] and M27Utilities.GetACU(aiBrain).GetNavigator and M27Utilities.GetACU(aiBrain):GetNavigator().GetCurrentTargetPos then
                        LOG('ACU CurrentTargetPos='..repru(M27Utilities.GetACU(aiBrain):GetNavigator():GetCurrentTargetPos()))
                        LOG('Platoon last attack location='..repru((oPlatoon[reftLastAttackLocation] or {'nil'}))..'; ACU last attack location='..repru((M27Utilities.GetACU(aiBrain)[reftLastAttackLocation] or {'nil'}))..'; oPlatoon[refbAttackMovedToLastAttackLocation]='..tostring(oPlatoon[refbAttackMovedToLastAttackLocation] or false))
                        if M27Utilities.IsTableEmpty(oPlatoon[reftLastAttackLocation]) == false then M27Utilities.DrawLocation(oPlatoon[reftLastAttackLocation], nil, 7, 10) end
                        --M27Utilities.DrawLocation(M27Utilities.GetACU(aiBrain):GetNavigator():GetCurrentTargetPos(), nil, 7, 10)
                    end
                end
                if M27Config.M27ShowUnitNames == true then bPlatoonNameDisplay = true end
                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': ProcessPlatoonAction: refiCurrentAction='..oPlatoon[refiCurrentAction]..'; bDontClearActions='..tostring(bDontClearActions)) end
                if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..'-'..oPlatoon[refiPlatoonUniqueCount]..': A'..oPlatoon[refiCurrentAction]) end

                if not(oPlatoon[refiCurrentAction] == refActionMoveToTemporaryLocation) then oPlatoon[reftTemporaryMoveTarget] = {} end --Resets variable since are about to get new command

                local tCurrentUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftCurrentUnits, false, true)
                local iCurrentUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftCurrentUnits, true, true)


                if oPlatoon[refiCurrentAction] == refActionAttack then
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': A'..refActionAttack) end

                    --Clearing actions - do manually for each scenario to improve DPS by minimising clearing
                    --[[if bDontClearActions == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Clearing commands for all units in platoon') end
                        if iCurrentUnits > 0 then M27Utilities.IssueTrackedClearCommands(tCurrentUnits) end
                    end--]]
                    --attack-move to nearest enemy; LargeAttackAI - prioritise structure over nearest enemy if <=5 enemy units
                    local oUnitToAttackInstead
                    local tUnitsToAttackAfterFirst = {} --e.g. used for experimentals so can queue up multiple attack orders to avoid it switching to default logic

                    oPlatoon[refbHavePreviouslyRun] = false --If we want to attack then no longer treat platoon as running away
                    if oPlatoon[refiEnemiesInRange] == 0 and oPlatoon[refiEnemyStructuresInRange] == 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont have enemy units or structures in range so will issueclearcommands and reissue movement path') end
                        if bDontClearActions == false and iCurrentUnits > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                        end
                        ReissueMovementPath(oPlatoon)
                    else
                        local bMoveNotAttack = not(oPlatoon[M27PlatoonTemplates.refbAttackMove])
                        --Override if are moving not attacking
                        if bMoveNotAttack and M27PlatoonTemplates.PlatoonTemplate[sPlatoonName][M27PlatoonTemplates.refbAttackMove] then oPlatoon[M27PlatoonTemplates.refbAttackMove] = true bMoveNotAttack = true end
                        local tDFTargetPosition = {}

                        local bAlreadyDeterminedTargetEnemy = false
                        local bChangedActions = false
                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionAttack: About to process action') end
                        --Get DF Unit target:
                        if sPlatoonName == 'M27LargeAttackForce' then
                            --If only a small number of enemies then target the nearest DF structure or the slowest enemy unit
                            if oPlatoon[refiEnemiesInRange] < math.min(8, oPlatoon[refiDFUnits] * 0.5) then
                                local oTargetEnemy
                                if oPlatoon[refiEnemyStructuresInRange] > 0 then
                                    --Are there any nearby PD? If so are we in range of them
                                    local tNearbyPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD, oPlatoon[reftEnemyStructuresInRange])
                                    if M27Utilities.IsTableEmpty(tNearbyPD) == false then
                                        local iEnemyPDRange = M27Logic.GetUnitMaxGroundRange(tNearbyPD)
                                        local oNearestPD = M27Utilities.GetNearestUnit(tNearbyPD, GetPlatoonFrontPosition(oPlatoon))
                                        if M27Utilities.GetDistanceBetweenPositions(oNearestPD:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) < (iEnemyPDRange + 4) then
                                            --have a PD thats in range or almost in range of us, so should attack it
                                            oTargetEnemy = oNearestPD
                                            --tDFTargetPosition = oNearestPD:GetPosition()
                                            bAlreadyDeterminedTargetEnemy = true
                                        end
                                    end
                                    if bAlreadyDeterminedTargetEnemy == false then
                                        --No nearby PD so just go for nearest structure
                                        oTargetEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon))
                                        --tDFTargetPosition = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon)):GetPosition()
                                        bAlreadyDeterminedTargetEnemy = true
                                    end
                                end
                                if bAlreadyDeterminedTargetEnemy == false then
                                    --No structures; see if are any slower enemies and if so then target them
                                    local tSlowerEnemies = M27Logic.GetUnitSpeedData(oPlatoon[reftEnemiesInRange], aiBrain, true, 4, M27Logic.GetUnitMinSpeed(oPlatoon[reftCurrentUnits], aiBrain, false))
                                    if not(tSlowerEnemies==nil) then
                                        if table.getn(tSlowerEnemies) > 0 then
                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': ProcessPlatoonAction: table.getn(tSlowerEnemies)='..table.getn(tSlowerEnemies)) end
                                            oTargetEnemy = M27Utilities.GetNearestUnit(tSlowerEnemies, GetPlatoonFrontPosition(oPlatoon))
                                            --tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = M27Utilities.GetNearestUnit(tSlowerEnemies, GetPlatoonFrontPosition(oPlatoon)):GetPositionXYZ()
                                            bAlreadyDeterminedTargetEnemy = true
                                        end
                                    end
                                end
                                if oTargetEnemy then
                                    local iDistAwayFromTarget = 3
                                    if EntityCategoryContains(categories.VOLATILE, oTargetEnemy.UnitId) then iDistAwayFromTarget = 7 end --energy storage has an aoe of 5, dont want to just set equal to this since then we wouldnt attack things like a paragon
                                    --If shot is blocked and are already within this distance (or close to it) then reduce the distance from target

                                    if oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] then
                                        local iCurDistToTarget = M27Utilities.GetDistanceBetweenPositions(oPlatoon[refoFrontUnit]:GetPosition(), oTargetEnemy:GetPosition())
                                        if iCurDistToTarget <= iDistAwayFromTarget + 1 then iDistAwayFromTarget = math.max(1, iCurDistToTarget - 2) end
                                    end
                                    tDFTargetPosition = M27Utilities.MoveInDirection(oTargetEnemy:GetPosition(), M27Utilities.GetAngleFromAToB(oTargetEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon)), iDistAwayFromTarget, true)
                                end
                            end
                        elseif sPlatoonName == 'M27GroundExperimental' then
                            --if bDontClearActions == false and iCurrentUnits > 0 then M27Utilities.IssueTrackedClearCommands(tCurrentUnits) end
                            --Dont want to apply normal logic, instead keep things simple for now - attack-move or move to the target
                            local bHaveFatboy = false
                            if EntityCategoryContains(M27UnitInfo.refCategoryFatboy, oPlatoon[refoFrontUnit].UnitId) then bHaveFatboy = true end
                            bAlreadyDeterminedTargetEnemy = true
                            bChangedActions = true

                            --Is the enemy ACU near us, on ground, and we have DF units in the platoon (so not a fatboy)? If so then target it
                            tDFTargetPosition = { }
                            local tNearbyEnemiesOfInterest

                            if oPlatoon[refiPlatoonMaxRange] >= 60 and not(M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit])) and not(oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked]) then oPlatoon[M27PlatoonTemplates.refbAttackMove] = true
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Either our range is <60 or we are underwater so wont attackmove') end
                                oPlatoon[M27PlatoonTemplates.refbAttackMove] = false
                            end


                            if bHaveFatboy and oPlatoon[refiEnemyStructuresInRange] > 0 then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have fatboy platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..' with '..oPlatoon[refiEnemyStructuresInRange]..' enemy structures in range, will check if any of them are shields or t2 arti near us') end
                                local tNearbyShields = EntityCategoryFilterDown(M27UnitInfo.refCategoryFixedShield, oPlatoon[reftEnemyStructuresInRange])
                                local oClosestShield
                                local iClosestShield = 10000
                                local iCurDistance
                                if M27Utilities.IsTableEmpty(tNearbyShields) == false then
                                    for iShield, oShield in tNearbyShields do
                                        iCurDistance = M27Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                        if iCurDistance < iClosestShield then
                                            oClosestShield = oShield
                                            iClosestShield = iCurDistance
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iClosestShield='..iClosestShield..'; platoon range='..oPlatoon[refiPlatoonMaxRange]) end
                                if iClosestShield <= oPlatoon[refiPlatoonMaxRange] then
                                    oUnitToAttackInstead = oClosestShield
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will attack closest shield '..oClosestShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestShield)) end
                                elseif iClosestShield <= 125 then --Will be in range of enemy shield soon
                                    oUnitToAttackInstead = oClosestShield
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will be in range of shield soon so will attack it, shield='..oClosestShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestShield)) end
                                else --Wont be in range of a shield soon
                                    local tNearbyT2Arti = EntityCategoryFilterDown(M27UnitInfo.refCategoryFixedT2Arti, oPlatoon[reftEnemyStructuresInRange])
                                    local oClosestT2Arti
                                    local iClosestT2Arti = 10000
                                    if M27Utilities.IsTableEmpty(tNearbyT2Arti) == false then
                                        for iArti, oArti in tNearbyT2Arti do
                                            iCurDistance = M27Utilities.GetDistanceBetweenPositions(oArti:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                            if iCurDistance < iClosestT2Arti then
                                                oClosestT2Arti = oArti
                                                iClosestT2Arti = iCurDistance
                                            end
                                        end
                                        if iClosestT2Arti <= 135 then
                                            oUnitToAttackInstead = oClosestT2Arti
                                        end

                                        if bDebugMessages == true then LOG(sFunctionRef..': iClosestT2Arti='..iClosestT2Arti) end

                                    end

                                    if not(M27MapInfo.IsUnderwater(GetPlatoonFrontPosition(oPlatoon), false)) then
                                        if iClosestT2Arti <= 135 and iClosestT2Arti >= (oPlatoon[refiPlatoonMaxRange] - 5) then
                                            oPlatoon[M27PlatoonTemplates.refbAttackMove] = true
                                        else
                                            oPlatoon[M27PlatoonTemplates.refbAttackMove] = false
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Platoon should attackmove='..tostring(oPlatoon[M27PlatoonTemplates.refbAttackMove])) end


                                    --If no shield or t2 arti, the normal logic for pd should work for us so dont need anything special
                                end
                            else
                                --Not a fatboy so consider enemy ACU


                                --Dont move to enemy com if have fatboy (as it might die)
                                tNearbyEnemiesOfInterest = aiBrain:GetUnitsAroundPoint(categories.COMMAND, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refiPlatoonMaxRange] + 20, 'Enemy')
                                if bDebugMessages == true then LOG(sFunctionRef..': Dealing with an experimental platoon, will see if its near enemy ACU by looking for enemies based on oPlatoon[refiPlatoonMaxRange]='..oPlatoon[refiPlatoonMaxRange]..'; oPlatoon[refiIndirectUnits]='..oPlatoon[refiIndirectUnits]..'; oPlatoon[refiDFUnits]='..oPlatoon[refiDFUnits]..'; is table of nearby enemy ACUs empty='..tostring(M27Utilities.IsTableEmpty(tNearbyEnemiesOfInterest))) end

                                if M27Utilities.IsTableEmpty(tNearbyEnemiesOfInterest) == false then
                                    oUnitToAttackInstead = M27Utilities.GetNearestUnit(tNearbyEnemiesOfInterest, GetPlatoonFrontPosition(oPlatoon), aiBrain, nil, nil)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have nearby ACU, will attack it unless its far enough away that we should keep moving twoards it; distance='..M27Utilities.GetDistanceBetweenPositions(oUnitToAttackInstead:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) > (oPlatoon[refiPlatoonMaxRange] - 10)) end
                                    if M27Utilities.GetDistanceBetweenPositions(oUnitToAttackInstead:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) > (oPlatoon[refiPlatoonMaxRange] - 10) or M27Logic.IsShotBlocked(oPlatoon[refoFrontUnit], oUnitToAttackInstead) then
                                        tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = oUnitToAttackInstead:GetPositionXYZ()
                                        if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked or we are far away. oUnitToAttackInstead='..oUnitToAttackInstead.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAttackInstead)..'; Distance to unit='..M27Utilities.GetDistanceBetweenPositions(oUnitToAttackInstead:GetPosition(), GetPlatoonFrontPosition(oPlatoon))..'; platoon max range='..oPlatoon[refiPlatoonMaxRange]..'; Is shot blocked='..tostring(M27Logic.IsShotBlocked(oPlatoon[refoFrontUnit], oUnitToAttackInstead))) end
                                        oUnitToAttackInstead = nil
                                    end
                                    oPlatoon[M27PlatoonTemplates.refbAttackMove] = false
                                end
                            end

                            if M27Utilities.IsTableEmpty(tDFTargetPosition) and not(oUnitToAttackInstead) then

                                --ENemy PD and shield in range? Target it (fatboy has already considered shields above)
                                local oNearestUnitOfInterest
                                if bDebugMessages == true then LOG(sFunctionRef..': Will now consider if enemy shield and PD in range unless are a fatboy. oPlatoon[refiEnemyStructuresInRange]='..oPlatoon[refiEnemyStructuresInRange]) end
                                if oPlatoon[refiEnemyStructuresInRange] > 0 and not(bHaveFatboy) then
                                    --First get unshielded PD that can hit us and which we can hit
                                    local tPotentialPDInRange = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD, oPlatoon[reftEnemyStructuresInRange])
                                    local tPDInRange = {}
                                    local tUnshieldedPDInRange = {}
                                    if M27Utilities.IsTableEmpty(tPotentialPDInRange) == false then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Have PD in nearby structures, will check if any are unshielded and in range of us and we in range of them') end
                                        local iCurDistToPlatoon
                                        for iPD, oPD in tPotentialPDInRange do
                                            iCurDistToPlatoon = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPD:GetPosition())
                                            if bDebugMessages == true then LOG(sFunctionRef..': oPD='..oPD.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPD)..'; iCurDistToPlatoon='..iCurDistToPlatoon..'; oPlatoon[refiPlatoonMaxRange]='..oPlatoon[refiPlatoonMaxRange]..'; PD range='..M27UnitInfo.GetUnitMaxGroundRange(oPD)) end
                                            if iCurDistToPlatoon <= oPlatoon[refiPlatoonMaxRange] and iCurDistToPlatoon <= M27UnitInfo.GetUnitMaxGroundRange(oPD) then
                                                table.insert(tPDInRange, oPD)
                                                if bDebugMessages == true then LOG(sFunctionRef..': Adding to tPDInRange table. Is under shield='..tostring(M27Logic.IsTargetUnderShield(aiBrain, oPD, 0, false, true, true, false))) end
                                                if not(M27Logic.IsTargetUnderShield(aiBrain, oPD, 0, false, true, true, false)) then
                                                    table.insert(tUnshieldedPDInRange, oPD)
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Adding to table of unshielded PD in range') end
                                                end
                                            end
                                        end
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering nearby PD. is table of unshielded PD in range empty='..tostring(M27Utilities.IsTableEmpty(tUnshieldedPDInRange))) end

                                    if M27Utilities.IsTableEmpty(tUnshieldedPDInRange) == false then
                                        oUnitToAttackInstead = M27Utilities.GetNearestUnit(tUnshieldedPDInRange, GetPlatoonFrontPosition(oPlatoon))
                                        for iUnit, oUnit in tUnshieldedPDInRange do
                                            if not(oUnitToAttackInstead == oUnit) then
                                                table.insert(tUnitsToAttackAfterFirst, oUnit)
                                            end
                                        end
                                    end


                                    tNearbyEnemiesOfInterest = EntityCategoryFilterDown(M27UnitInfo.refCategoryFixedShield, oPlatoon[reftEnemyStructuresInRange])
                                    if not(oUnitToAttackInstead) and not(M27Utilities.IsTableEmpty(tNearbyEnemiesOfInterest)) then
                                        oNearestUnitOfInterest = M27Utilities.GetNearestUnit(tNearbyEnemiesOfInterest, GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                        if M27Utilities.GetDistanceBetweenPositions(oNearestUnitOfInterest:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= oPlatoon[refiPlatoonMaxRange] + 10 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will attack oNearestUnitOfInterest='..oNearestUnitOfInterest.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestUnitOfInterest)..'; Distance to us='..M27Utilities.GetDistanceBetweenPositions(oNearestUnitOfInterest:GetPosition(), GetPlatoonFrontPosition(oPlatoon))..'; Platoon max range='..oPlatoon[refiPlatoonMaxRange]) end
                                            if M27Utilities.GetDistanceBetweenPositions(oNearestUnitOfInterest:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= oPlatoon[refiPlatoonMaxRange] then
                                                oUnitToAttackInstead = oNearestUnitOfInterest
                                            else
                                                tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = oNearestUnitOfInterest:GetPositionXYZ()
                                                if bDebugMessages == true then LOG(sFunctionRef..': Out of range so will move to the unit instead') end
                                            end
                                        end
                                        oNearestUnitOfInterest = nil --If shield not near our range then dont want to actively seek it out; hence Dont want to think we have a target for later on
                                    end

                                    --If shielded PD but we arent targeting a shield then target the PD

                                    if M27Utilities.IsTableEmpty(tDFTargetPosition) and not(oUnitToAttackInstead) and not(oNearestUnitOfInterest) then
                                        if M27Utilities.IsTableEmpty(tPDInRange) == false then
                                            oUnitToAttackInstead = M27Utilities.GetNearestUnit(tPDInRange, GetPlatoonFrontPosition(oPlatoon))
                                            for iUnit, oUnit in tPDInRange do
                                                if not(oUnitToAttackInstead == oUnit) then
                                                    table.insert(tUnitsToAttackAfterFirst, oUnit)
                                                end
                                            end
                                        end
                                    end
                                end
                                if M27Utilities.IsTableEmpty(tDFTargetPosition) and not(oUnitToAttackInstead) and not(oNearestUnitOfInterest) then
                                    --Is there nearby enemy land experimental? If so then target position that would bring us in range of this unless we're a fatboy in which case run
                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking for nearby land experimental. oPlatoon[refiPlatoonMaxRange]='..oPlatoon[refiPlatoonMaxRange]..'; oPlatoon[refiEnemiesInRange]='..oPlatoon[refiEnemiesInRange]) end

                                    --Note - will have already checekd for enemy experimental and run away for fatboy as part of the logic for determining nearby enemy
                                    if oPlatoon[refiEnemiesInRange] > 0 then
                                        tNearbyEnemiesOfInterest = EntityCategoryFilterDown(M27UnitInfo.refCategoryLandExperimental, oPlatoon[reftEnemiesInRange])
                                        if M27Utilities.IsTableEmpty(tNearbyEnemiesOfInterest) == false then
                                            oNearestUnitOfInterest = M27Utilities.GetNearestUnit(tNearbyEnemiesOfInterest, GetPlatoonFrontPosition(oPlatoon), aiBrain, nil, nil)
                                        end
                                    end
                                    if M27Utilities.IsTableEmpty(tDFTargetPosition) and not (oUnitToAttackInstead) and not (oNearestUnitOfInterest) then
                                        --Is there nearby enemy PD? Then want to get in range of this
                                        if oPlatoon[refiEnemyStructuresInRange] > 0 then
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Checking for nearby PD')
                                            end
                                            tNearbyEnemiesOfInterest = EntityCategoryFilterDown(M27UnitInfo.refCategoryT2PlusPD + M27UnitInfo.refCategoryFixedT2Arti, oPlatoon[reftEnemyStructuresInRange])
                                            if M27Utilities.IsTableEmpty(tNearbyEnemiesOfInterest) == false then
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef .. ': Have nearby PD')
                                                end
                                                oNearestUnitOfInterest = M27Utilities.GetNearestUnit(tNearbyEnemiesOfInterest, GetPlatoonFrontPosition(oPlatoon), aiBrain, nil, nil)
                                            end
                                        end
                                    end

                                    if M27Utilities.IsTableEmpty(tDFTargetPosition) and not (oUnitToAttackInstead) and not (oNearestUnitOfInterest) then
                                        --Nearby T3 land (or T2+ surface navy if we have the range)?
                                        if oPlatoon[refiEnemiesInRange] > 0 then
                                            local iCategoriesOfInterest = M27UnitInfo.refCategoryMobileLand * categories.TECH3 * categories.DIRECTFIRE + M27UnitInfo.refCategoryMobileLand * categories.TECH3 * categories.INDIRECTFIRE + categories.SUBCOMMANDER
                                            if oPlatoon[refiPlatoonMaxRange] >= 60 then iCategoriesOfInterest = iCategoriesOfInterest + M27UnitInfo.refCategoryNavalSurface - categories.TECH1 end
                                            tNearbyEnemiesOfInterest = EntityCategoryFilterDown(iCategoriesOfInterest, oPlatoon[reftEnemiesInRange])
                                            if M27Utilities.IsTableEmpty(tNearbyEnemiesOfInterest) == false then
                                                if bDebugMessages == true then
                                                    LOG(sFunctionRef .. ': Have nearby T3 mobile land')
                                                end
                                                oNearestUnitOfInterest = M27Utilities.GetNearestUnit(tNearbyEnemiesOfInterest, GetPlatoonFrontPosition(oPlatoon), aiBrain, nil, nil)
                                            elseif bDebugMessages == true then
                                                LOG(sFunctionRef..': No nearby T3 mobile land, will list out each unit in range')
                                                if oPlatoon[refiEnemiesInRange] > 0 then
                                                    for iUnit, oUnit in oPlatoon[reftEnemiesInRange] do
                                                        LOG(sFunctionRef..': EnemiesInRange: iUnit='..iUnit..'; oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit))
                                                    end
                                                end
                                            end
                                        end

                                        if M27Utilities.IsTableEmpty(tDFTargetPosition) and not (oUnitToAttackInstead) and not (oNearestUnitOfInterest) then
                                            if oPlatoon[refiEnemyStructuresInRange] > 0 then
                                                tNearbyEnemiesOfInterest = EntityCategoryFilterDown(M27UnitInfo.refCategoryStructure - categories.TECH1, oPlatoon[reftEnemyStructuresInRange])
                                                if not (M27Utilities.IsTableEmpty(tNearbyEnemiesOfInterest)) then
                                                    oNearestUnitOfInterest = M27Utilities.GetNearestUnit(tNearbyEnemiesOfInterest, GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                                    local iDistOutOfOurRange = 10
                                                    if EntityCategoryContains(categories.TECH3, oNearestUnitOfInterest.UnitId) then
                                                        iDistOutOfOurRange = 20
                                                    end
                                                    if M27Utilities.GetDistanceBetweenPositions(oNearestUnitOfInterest:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) > oPlatoon[refiPlatoonMaxRange] + iDistOutOfOurRange then
                                                        --Too far away so dont ahve as a target
                                                        oNearestUnitOfInterest = nil
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    if M27Utilities.IsTableEmpty(tDFTargetPosition) and not (oUnitToAttackInstead) and oNearestUnitOfInterest then
                                        --Target the unit of interest, using an attack order if it is well within our range
                                        if M27Utilities.GetDistanceBetweenPositions(oNearestUnitOfInterest:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= math.max(oPlatoon[refiPlatoonMaxRange] * 0.6, oPlatoon[refiPlatoonMaxRange] - 12) then
                                            oUnitToAttackInstead = oNearestUnitOfInterest
                                            if bDebugMessages == true then LOG(sFunctionRef..': Are close enough to the unit of interest so will attack it. Unit='..oNearestUnitOfInterest.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestUnitOfInterest)) end
                                        else
                                            tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = oNearestUnitOfInterest:GetPositionXYZ()
                                            if bDebugMessages == true then LOG(sFunctionRef..': Setting tDFTargetPosition to be the nearest unit of interest='..oNearestUnitOfInterest.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestUnitOfInterest)) end
                                        end

                                    end
                                end
                            end




                            --Check we can path to the target?
                            local bCanReachTarget = false
                            local iOurPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, GetPlatoonFrontPosition(oPlatoon))
                            if oUnitToAttackInstead then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have unit to attack, will check we can path to it. oUnitToAttackInstead='..oUnitToAttackInstead.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAttackInstead)..'; is our front unit underwater='..tostring(M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit]))) end
                                if M27UnitInfo.IsUnitUnderwater(oPlatoon[refoFrontUnit]) then
                                    --Want to attack a unit but we are underwater; is the target on land and we can path there?
                                    if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnitToAttackInstead:GetPosition()) == iOurPathingGroup then
                                        bCanReachTarget = true
                                        tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = oUnitToAttackInstead:GetPositionXYZ()
                                        oUnitToAttackInstead = nil
                                        if bDebugMessages == true then LOG(sFunctionRef..': Can reach target so will go to its position') end
                                    else
                                        bCanReachTarget = false --Redundancy
                                        if bDebugMessages == true then LOG(sFunctionRef..': Underwater so cant reach target') end
                                    end
                                else
                                    --We arent underwater; is the target unit in range?
                                    if bDebugMessages == true then LOG(sFunctionRef..': We arent underwtaer, will see if we are in range of the target. Distance to them='..M27Utilities.GetDistanceBetweenPositions(oUnitToAttackInstead:GetPosition(), GetPlatoonFrontPosition(oPlatoon))..'; Platoon range='..oPlatoon[refiPlatoonMaxRange]..'; Is target unit underwater='..tostring(M27UnitInfo.IsUnitUnderwater(oUnitToAttackInstead))) end
                                    if M27Utilities.GetDistanceBetweenPositions(oUnitToAttackInstead:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) <= oPlatoon[refiPlatoonMaxRange] and not(M27UnitInfo.IsUnitUnderwater(oUnitToAttackInstead)) then
                                        --Target is in range, is our shot blocked?

                                        if M27Logic.IsShotBlocked(oPlatoon[refoFrontUnit], oUnitToAttackInstead) then
                                            --Shot is blocked, can we path there?
                                            if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnitToAttackInstead:GetPosition()) == iOurPathingGroup then
                                                bCanReachTarget = true
                                                tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = oUnitToAttackInstead:GetPositionXYZ()
                                                oUnitToAttackInstead = nil
                                            else
                                                bCanReachTarget = false --redundancy
                                            end
                                        else
                                            --Shot not blocked, target on land, we are on land, and it is in range
                                            bCanReachTarget = true
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Target is in range, is our shot blocked='..tostring(M27Logic.IsShotBlocked(oPlatoon[refoFrontUnit], oUnitToAttackInstead))..'; bCanReachTarget='..tostring(bCanReachTarget)) end
                                    else
                                        --Target is out of range, can we path to it?
                                        if bDebugMessages == true then LOG(sFunctionRef..': Target is out of range, our segment group='..iOurPathingGroup..'; Unit segment group='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnitToAttackInstead:GetPosition())..'; Enemy unit='..oUnitToAttackInstead.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAttackInstead)) end
                                        if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnitToAttackInstead:GetPosition()) == iOurPathingGroup then
                                            bCanReachTarget = true
                                        else
                                            bCanReachTarget = false --redundancy
                                        end
                                    end
                                end
                            elseif M27Utilities.IsTableEmpty(tDFTargetPosition) == false then
                                --Are trying to move to a destination - can we path there?
                                if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, tDFTargetPosition) == iOurPathingGroup then
                                    bCanReachTarget = true
                                else bCanReachTarget = false --redundancy
                                end
                            else
                                --Have no target
                                bCanReachTarget = false --redundancy
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering if we can reach the desired target. bCanReachTarget='..tostring(bCanReachTarget)) end

                            if not(bCanReachTarget) then
                                --Just go for the enemy base if we aren't already there
                                if HasPlatoonReachedDestination(oPlatoon) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have reached destination so will get a new movement path') end
                                    GetNewMovementPath(oPlatoon)
                                    tDFTargetPosition = oPlatoon[reftMovementPath][1]
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': No priority locations to go to so will just target movement path. Full movement path='..repru(oPlatoon[reftMovementPath])..'; Dist to enemy base='..M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain))) end
                                    --If the movement path will take us more than 30 away from base vs current position then get new movement path
                                    local iDistToEnemy = M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain))
                                    if oPlatoon[refiPlatoonMassValue] >= 200 and oPlatoon[refiDFUnits] > 0 and iDistToEnemy - 30 > M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon),  M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Reissuing our movement path would take us far from enemy base and we are wanting to attack, so switch to attack') end
                                        GetNewMovementPath(oPlatoon)
                                        tDFTargetPosition = oPlatoon[reftMovementPath][1]
                                    else
                                        tDFTargetPosition = oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]
                                    end
                                end
                            end
                            --Get position near the target in the same group
                            --GetPositionAtOrNearTargetInPathingGroup(tStartPos, tTargetPos, iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
                            if M27Utilities.IsTableEmpty(tDFTargetPosition) and not(oUnitToAttackInstead) then
                                M27Utilities.ErrorHandler('Couldnt find target for experimental that is valid, will revert to enemy base', true)
                                tDFTargetPosition = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                            elseif not(oUnitToAttackInstead) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a DF position, will move near the target') end
                                tDFTargetPosition = GetPositionAtOrNearTargetInPathingGroup(GetPlatoonFrontPosition(oPlatoon), tDFTargetPosition, 2, 0, oPlatoon[refoPathingUnit], true, true, 2)
                            end

                            --Get platoon front unit target - if platoon front and rear units both have this as the target then dont clear commands
                            if bDontClearActions == false and iCurrentUnits > 0 then
                                local bFrontAndRearHaveSameTarget = false
                                if oUnitToAttackInstead then
                                    if oPlatoon[refoTemporaryAttackTarget] == oUnitToAttackInstead then
                                        bFrontAndRearHaveSameTarget = true
                                    end
                                else
                                    if oPlatoon[reftPrevAction] and oPlatoon[reftPrevAction][1] == oPlatoon[refiCurrentAction] then
                                        for iUnit, oUnit in {oPlatoon[refoFrontUnit], oPlatoon[refoRearUnit]} do
                                            --Cant use navigator as doesnt work well with attack move
                                            if M27Utilities.IsTableEmpty(oUnit[reftLastAttackLocation]) == false and math.abs(oUnit[reftLastAttackLocation][1] - tDFTargetPosition[1]) <= 3 and math.abs(oUnit[reftLastAttackLocation][3] - tDFTargetPosition[3]) <= 3 and oPlatoon[refbAttackMovedToLastAttackLocation] == oPlatoon[M27PlatoonTemplates.refbAttackMove] then
                                                bFrontAndRearHaveSameTarget = true
                                            end
                                            if iCurrentUnits == 1 or bFrontAndRearHaveSameTarget == false then break end
                                        end
                                    end
                                end
                                if not(bFrontAndRearHaveSameTarget) and iCurrentUnits > 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Front and rear have different targets so clearing 2') end
                                    M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                                    oPlatoon[reftLastAttackLocation] = {tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3]}
                                    oPlatoon[refbAttackMovedToLastAttackLocation] = oPlatoon[M27PlatoonTemplates.refbAttackMove]
                                    oPlatoon[refoFrontUnit][reftLastAttackLocation] = tDFTargetPosition
                                    oPlatoon[refoRearUnit][reftLastAttackLocation] = tDFTargetPosition
                                end
                            end
                            --Is shot blocked? then still treat us as attacking the unit, but move towards it
                            if bDebugMessages == true then LOG(sFunctionRef..': Was our last shot blocked='..tostring(oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] or false)) end

                            if oUnitToAttackInstead and oPlatoon[refoFrontUnit] and oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] and oUnitToAttackInstead == oPlatoon[refoTemporaryAttackTarget] then
                                tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = oUnitToAttackInstead:GetPositionXYZ()
                                oPlatoon[refoTemporaryAttackTarget] = oUnitToAttackInstead
                                if not(M27UnitInfo.IsUnitValid(oUnitToAttackInstead)) then M27Utilities.ErrorHandler('Invalid oUnitToAttackInstead unit') end
                                oUnitToAttackInstead = nil
                            end
                            if oUnitToAttackInstead then
                                if bDebugMessages == true then LOG(sFunctionRef..': Issuing a manual attack order at unit '..oUnitToAttackInstead.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAttackInstead)..'; Unit last order type='..(oPlatoon[refiLastOrderType] or 'nil')) end
                                if not(oPlatoon[refiLastOrderType] == refiOrderIssueAttack) or not(oPlatoon[refoTemporaryAttackTarget] == oUnitToAttackInstead) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Platoon had a different order before or different target so will clear commands') end
                                    M27Utilities.IssueTrackedClearCommands(oPlatoon[reftCurrentUnits])
                                end
                                IssueAttack(oPlatoon[reftCurrentUnits], oUnitToAttackInstead)
                                oPlatoon[refoTemporaryAttackTarget] = oUnitToAttackInstead
                                if not(M27UnitInfo.IsUnitValid(oUnitToAttackInstead)) then M27Utilities.ErrorHandler('Invalid oUnitToAttackInstead2 unit') end
                                oPlatoon[refiLastOrderType] = refiOrderIssueAttack
                                oPlatoon[reftLastOrderPosition] = oUnitToAttackInstead:GetPosition()
                                if M27Utilities.IsTableEmpty(tUnitsToAttackAfterFirst) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Queuing up attack orders on the other units') end
                                    for iUnit, oUnit in tUnitsToAttackAfterFirst do
                                        IssueAttack(oPlatoon[reftCurrentUnits], oUnit)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Queued up attack roder on unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                    end
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Sending standard move/attackmove command. refbAttackMove]'..tostring(oPlatoon[M27PlatoonTemplates.refbAttackMove])..'; tDFTargetPosition='..repru(tDFTargetPosition)) end

                                PlatoonMove(oPlatoon, tDFTargetPosition)
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking default attack action for DF units if have DF untis in platoon; iDFUnits='..oPlatoon[refiDFUnits]) end
                            if oPlatoon[refiDFUnits] > 0 then
                                if oPlatoon[M27PlatoonTemplates.refbAlwaysAttack] == true then
                                    --Has platoon attack nearby structures and (if there are none) nearby land units forever; if no known units then will attack enemy base and then go back to our base and repeat
                                    if oPlatoon[refiEnemyStructuresInRange] > 0 then
                                        tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon)):GetPositionXYZ()
                                        bAlreadyDeterminedTargetEnemy = true
                                    elseif oPlatoon[refiEnemiesInRange] == 0 then --Redundancy - no structures or enemies in range
                                        bChangedActions = true
                                        if bDontClearActions == false and iCurrentUnits > 0 then
                                            if bDebugMessages == true then LOG(sFunctionRef..': No mobile units or structures in range, will clear commands') end
                                            M27Utilities.IssueTrackedClearCommands(tCurrentUnits) end
                                        ReturnToBaseOrRally(oPlatoon, M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit]))
                                    end
                                end
                                if bAlreadyDeterminedTargetEnemy == false then
                                    if oPlatoon[refiEnemiesInRange] > 0 then
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionAttack: Enemies in range, will attack nearest enemy unit') end
                                        local oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon))
                                        tDFTargetPosition = {} --redundancy
                                        if EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oNearestEnemy.UnitId) then
                                            --Are we almost within the engineer's build range? if so then want to move away a bit
                                            local iEnemyReclaimRange = oNearestEnemy:GetBlueprint().Economy.MaxBuildDistance
                                            if oPlatoon[refiPlatoonMaxRange] > iEnemyReclaimRange then
                                                local iDistToEnemy = M27Utilities.GetDistanceBetweenPositions(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                                --Are we in range of the enemy engineer but it isnt our weapon's target?
                                                local oWeapon = oPlatoon[refoFrontUnit]:GetWeapon(1)
                                                if iDistToEnemy < oPlatoon[refiPlatoonMaxRange] and oPlatoon[refoFrontUnit]:GetWeaponCount() == 1 and oWeapon:WeaponHasTarget() and not(EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oWeapon:GetCurrentTarget().UnitId)) then
                                                    --Arent targeting the engineer
                                                    oUnitToAttackInstead = oNearestEnemy
                                                    tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = oNearestEnemy:GetPositionXYZ()
                                                elseif iDistToEnemy < math.min(oPlatoon[refiPlatoonMaxRange], iEnemyReclaimRange + 3) then
                                                    --About to be reclaimed so move back a bit
                                                    tDFTargetPosition = M27Utilities.MoveInDirection(oNearestEnemy:GetPosition(), M27Utilities.GetAngleFromAToB(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon)), math.min(oPlatoon[refiPlatoonMaxRange], iEnemyReclaimRange + 3), true)
                                                end

                                            end



                                        end
                                        if M27Utilities.IsTableEmpty(tDFTargetPosition) and not(oUnitToAttackInstead) then
                                            tDFTargetPosition = M27Utilities.MoveInDirection(oNearestEnemy:GetPosition(), M27Utilities.GetAngleFromAToB(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon)), math.min(oPlatoon[refiPlatoonMaxRange], 3), true)
                                        end

                                    elseif oPlatoon[refiEnemyStructuresInRange] > 0 then
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionAttack: No enemies in range but have structures in range') end
                                        tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3] = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon)):GetPositionXYZ()
                                        bMoveNotAttack = false
                                    else
                                        LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': WARNING - have been assigned action to attack for DF units, but no nearby units recorded.  Will tell DF units to go to current movement path target')
                                        if M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]) == true then
                                            GetNewMovementPath(oPlatoon, bDontClearActions)
                                            bChangedActions = true
                                        else
                                            tDFTargetPosition = oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]
                                        end
                                    end
                                end
                            end
                        end
                        --Attack-move to target enemy for direct fire units if spread out, otherwise move; for indirect fire units instead do special attack targetting structures if there are any, or spread attack if there arent
                        if bChangedActions == false then
                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionAttack: About to issue attack orders') end
                            --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': A'..refActionAttack) end
                            --if bDontClearActions == false and iCurrentUnits > 0 then M27Utilities.IssueTrackedClearCommands(tCurrentUnits) end
                            if oPlatoon[refiDFUnits] > 0 and GetPlatoonUnitsOrUnitCount(oPlatoon, reftDFUnits, true, true) > 0 then
                                --Do we have enemy mobile units? If so consider moving towards them:
                                if oPlatoon[refiEnemiesInRange] > 0 then
                                    --if enemy T1 arti or T2 MML detected then move instead of attack-move even if spread out:
                                    --v64 - decided to remove this aspect given we have shot dodging now
                                    --[[if oPlatoon[refiVisibleEnemyIndirect] > 0 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Visible enemy dinriect so will move not attackmove') end
                                        bMoveNotAttack = true
                                    else--]]
                                    --ACU in platoon? Then attack move
                                    if oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] then bMoveNotAttack = true
                                    elseif oPlatoon[refbACUInPlatoon] == true then
                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU in platoon so will attack move') end
                                        bMoveNotAttack = false
                                    else
                                        if not(oPlatoon[M27PlatoonTemplates.refbAttackMove]) and GetPlatoonPositionDeviation(oPlatoon) <= 10 then
                                            --Platoon isn't spread out, so ok to move unless we normally want to attackmove with this platoon
                                            bMoveNotAttack = true
                                        end
                                    end
                                    --end
                                end
                                if M27Utilities.IsTableEmpty(tDFTargetPosition) == true and not(oUnitToAttackInstead) then tDFTargetPosition = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain) end

                                --Is the target under shield? If so then change the target to the shield itself unless we are an ACU and doing so brings us in range of T1 PD
                                local oNearestEnemyShield = M27Logic.GetNearestActiveFixedEnemyShield(aiBrain, tDFTargetPosition)
                                if oNearestEnemyShield then
                                    --There is an enemy shield covering the target location, so move to within this shield's shield radius instead
                                    --GetPositionAtOrNearTargetInPathingGroup(tStartPos, tTargetPos, iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
                                    --if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oNearestEnemyShield:GetPosition()) <= oNearestEnemyShield:GetBlueprint().Defense.Shield.ShieldSize - 3 then

                                    tDFTargetPosition = GetPositionAtOrNearTargetInPathingGroup(GetPlatoonFrontPosition(oPlatoon), oNearestEnemyShield:GetPosition(), oNearestEnemyShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5 - 3, 0, oPlatoon[refoFrontUnit], true, true, 2)
                                    oUnitToAttackInstead = nil
                                    bMoveNotAttack = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have a nearby enemy shield at position '..repru(oNearestEnemyShield:GetPosition())..'; will adjust target location to be near this, tDFTargetPosition='..repru(tDFTargetPosition)) end
                                    if oPlatoon[refbACUInPlatoon] and not(M27Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryPD, tDFTargetPosition, 27, 'Enemy'))) then
                                        bMoveNotAttack = false
                                    elseif oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] then
                                        bMoveNotAttack = false
                                    end
                                end

                                oPlatoon[reftTemporaryMoveTarget] = tDFTargetPosition
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting temporary move target to tDFTargetPosition='..repru(oPlatoon[reftTemporaryMoveTarget])) end


                                if bMoveNotAttack and M27Conditions.HaveNearbyMobileShield(oPlatoon) and not(oNearestEnemyShield) then bMoveNotAttack = false end

                                --Dont attackmove if we cant hit the target
                                if not(bMoveNotAttack) and oPlatoon[refoFrontUnit] and oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] then bMoveNotAttack = true end

                                --Get platoon front unit target - if platoon front and rear units both have this as the target then dont clear commands
                                if bDontClearActions == false and iCurrentUnits > 0 then
                                    local bFrontAndRearHaveSameTarget = false
                                    if not(oUnitToAttackInstead) and oPlatoon[reftPrevAction] and oPlatoon[reftPrevAction][1] == oPlatoon[refiCurrentAction] then
                                        for iUnit, oUnit in {oPlatoon[refoFrontUnit], oPlatoon[refoRearUnit]} do
                                            --Cant use navigator as doesnt work well with attack move
                                            if M27Utilities.IsTableEmpty(oUnit[reftLastAttackLocation]) == false and math.abs(oUnit[reftLastAttackLocation][1] - tDFTargetPosition[1]) <= 3 and math.abs(oUnit[reftLastAttackLocation][3] - tDFTargetPosition[3]) <= 3 and oPlatoon[refbAttackMovedToLastAttackLocation] == oPlatoon[M27PlatoonTemplates.refbAttackMove] then
                                                bFrontAndRearHaveSameTarget = true
                                            end
                                            if iCurrentUnits == 1 or bFrontAndRearHaveSameTarget == false then break end
                                        end
                                    end
                                    if not(bFrontAndRearHaveSameTarget) and iCurrentUnits > 0 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Front and rear have different targets so clearing 2') end
                                        M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                                        oPlatoon[reftLastAttackLocation] = {tDFTargetPosition[1], tDFTargetPosition[2], tDFTargetPosition[3]}
                                        oPlatoon[refbAttackMovedToLastAttackLocation] = oPlatoon[M27PlatoonTemplates.refbAttackMove]
                                        oPlatoon[refoFrontUnit][reftLastAttackLocation] = tDFTargetPosition
                                        oPlatoon[refoRearUnit][reftLastAttackLocation] = tDFTargetPosition
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': tDFTargetPosition='..repru(tDFTargetPosition)..'; bMoveNotAttack='..tostring(bMoveNotAttack)) end
                                if M27UnitInfo.IsUnitValid(oUnitToAttackInstead) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Issuing a manual attack order at unit '..oUnitToAttackInstead.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAttackInstead)) end

                                    IssueAttack(oPlatoon[reftCurrentUnits], oUnitToAttackInstead)
                                    oPlatoon[refoTemporaryAttackTarget] = oUnitToAttackInstead

                                    oPlatoon[refiLastOrderType] = refiOrderIssueAttack
                                    oPlatoon[reftLastOrderPosition] = oUnitToAttackInstead:GetPosition()
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are attacking a specific unit='..oUnitToAttackInstead.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToAttackInstead)) end
                                else
                                    if not(bMoveNotAttack) then
                                        IssueAggressiveMove(GetPlatoonUnitsOrUnitCount(oPlatoon, reftDFUnits, false, true), tDFTargetPosition)
                                        oPlatoon[refiLastOrderType] = refiOrderIssueAggressiveMove
                                    else
                                        IssueMove(GetPlatoonUnitsOrUnitCount(oPlatoon, reftDFUnits, false, true), tDFTargetPosition)
                                        oPlatoon[refiLastOrderType] = refiOrderIssueMove
                                    end
                                    oPlatoon[reftLastOrderPosition] = tDFTargetPosition
                                end
                            end
                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionAttack: About to issue attack orders for indirect units') end
                            IssueIndirectAttack(oPlatoon, bDontClearActions) --if are any indirect fire units this will tell them to target structures, or (if none) spread attack enemy unitsi n range
                            UpdateScoutPositions(oPlatoon)
                        end
                    end

                elseif oPlatoon[refiCurrentAction] == refActionRun or oPlatoon[refiCurrentAction] == refActionTemporaryRetreat or oPlatoon[refiCurrentAction] == refActionKitingRetreat then
                    --Specific to indirect platoons - exclude T3 mobile artillery since they can take a while to redeploy so may be better just carrying on firing
                    --if oPlatoon[refbACUInPlatoon] and oPlatoon[refiCurrentAction] == refActionTemporaryRetreat then bDebugMessages = true end
                    if bDebugMessages == true then
                        if oPlatoon[refiCurrentAction] == refActionTemporaryRetreat or oPlatoon[refiCurrentAction] == refActionKitingRetreat then LOG('Temporary retreat action processing start')
                        else LOG('ActionRun processing start') end
                    end

                    --Seraphim Sniperbot platoons - adjust weapon range based on how close nearest enemy is, as they get reduced speed from the long range sniperrifle
                    if EntityCategoryContains(M27UnitInfo.refCategorySniperBot * categories.SERAPHIM, oPlatoon[refoFrontUnit]) then
                        local bWantSpeed = false
                        if oPlatoon[refiEnemiesInRange] > 0 then
                            local oNearestUnit = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain)
                            if M27UnitInfo.IsUnitValid(oNearestUnit) then
                                if M27Utilities.GetDistanceBetweenPositions(oNearestUnit:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) < 65 then
                                    bWantSpeed = true
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Seraphim sniperbot specific - do we want speed='..tostring(bWantSpeed)..'; Is our front unit sniper rifle enabled='..tostring(oPlatoon[refoFrontUnit][M27UnitInfo.refbSniperRifleEnabled])) end
                        if bWantSpeed and oPlatoon[refoFrontUnit][M27UnitInfo.refbSniperRifleEnabled] then
                            for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to toggle sniper status for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M27UnitInfo.refbSniperRifleEnabled]='..tostring(oUnit[M27UnitInfo.refbSniperRifleEnabled])) end
                                if oUnit[M27UnitInfo.refbSniperRifleEnabled] then
                                    M27UnitInfo.DisableLongRangeSniper(oUnit)
                                    oPlatoon[refbPlatoonUnitDetailsChangedRecently] = true
                                end
                            end
                        elseif not(bWantSpeed) and not(oPlatoon[refoFrontUnit][M27UnitInfo.refbSniperRifleEnabled]) then
                            for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                                if EntityCategoryContains(M27UnitInfo.refCategorySniperBot * categories.SERAPHIM, oUnit.UnitId) and not(oUnit[M27UnitInfo.refbSniperRifleEnabled]) then
                                    M27UnitInfo.EnableLongRangeSniper(oUnit)
                                    oPlatoon[refbPlatoonUnitDetailsChangedRecently] = true
                                end
                            end
                        end
                    end

                    oPlatoon[M27PlatoonTemplates.refbAttackMove] = false
                    --v58: Will address by only giving them the temporary retreat if enemy more than 20 within range, so have removed code leading to them attack-moving
                    --[[local tNewCurrentUnits = {}  --Will replace the norla units to apply the retreat/run action with this if we only have indirect fire units and some of these are T3 mobile arty
                    if oPlatoon[refiIndirectUnits] > 0 and oPlatoon[refiDFUnits] == 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have indirect units in platoon, will check if we have any T3 mobile arti') end

                        local iNewCurrentUnits = 0
                        for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                            if M27UnitInfo.IsUnitValid(oUnit) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' is a T3 mobile arty') end
                                if not(EntityCategoryContains(M27UnitInfo.refCategoryT3MobileArtillery, oUnit.UnitId)) then
                                    iNewCurrentUnits = iNewCurrentUnits + 1
                                    tNewCurrentUnits[iNewCurrentUnits] = oUnit
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit isnt t3 mobile arty so will include actions for it, and set it to not attackmove') end
                                    oPlatoon[M27PlatoonTemplates.refbAttackMove] = false
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit is t3 mobile arty so wont do a retreat aciton for it')
                                end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit isnt valid')
                            end
                        end
                        tCurrentUnits = tNewCurrentUnits
                    end--]]
                    if M27Utilities.IsTableEmpty(tCurrentUnits) == false then
                        local bAlreadyGivenMoveOrderThisCycle = false
                        --Do we have a chokepoint with an ACU near it and we are a combat platoon? If so then dont retreat
                        local bGoToChokepoint = false
                        if oPlatoon[refiPlatoonMassValue] >= 2000 and (oPlatoon[refiDFUnits] > 0 or oPlatoon:GetPlan() == 'M27GroundExperimental') and not(oPlatoon[refbACUInPlatoon]) and aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle and M27Utilities.GetDistanceBetweenPositions(M27Utilities.GetACU(aiBrain):GetPosition(), aiBrain[M27MapInfo.reftChokepointBuildLocation]) <= 50 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Are a combat platoon so will go to the chokepoint as ACU is near it') end
                            bGoToChokepoint = true
                        end

                        local bTemporaryRetreat = false
                        if oPlatoon[refiCurrentAction] == refActionTemporaryRetreat or oPlatoon[refiCurrentAction] == refActionKitingRetreat then bTemporaryRetreat = true end
                        --[[if bPlatoonNameDisplay == true then
                            if bTemporaryRetreat == true then --UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': A'..refActionTemporaryRetreat)
                            else
                                --UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': '..refActionRun)
                                oPlatoon[refbHavePreviouslyRun] = true
                            end
                        end--]]
                        if not(oPlatoon[refiCurrentAction] == refActionKitingRetreat) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Platoon is retreating but not kiting retreat so is running from something') end
                            oPlatoon[refbHavePreviouslyRun] = true
                        end
                        if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..'-'..oPlatoon[refiPlatoonUniqueCount]..': A'..oPlatoon[refiCurrentAction]) end

                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Start of refActionRun and refActionTemporaryRetreat; bTemporaryRetreat='..tostring(bTemporaryRetreat)..'; Platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))..'; platoon movement path='..repru(oPlatoon[reftMovementPath])) end

                        --Check if current target is away from nearest enemy and also the enemy start location:
                        local bTargetAwayFromNearestEnemy = false
                        local tCurPlatoonPos = GetPlatoonFrontPosition(oPlatoon)
                        local bUseTempPath = false
                        --What is the platoons current move location?
                        local oUnit = oPlatoon[refoFrontUnit]
                        local tPlatoonCurMoveLocation
                        if M27UnitInfo.IsUnitValid(oUnit) then
                            if oUnit.GetNavigator then
                                local oNavigator = oUnit:GetNavigator()
                                if oNavigator.GetCurrentTargetPos then
                                    tPlatoonCurMoveLocation = oNavigator:GetCurrentTargetPos()
                                    if bDebugMessages == true then LOG(sFunctionRef..': tPlatoonCurMoveLocation='..repru(tPlatoonCurMoveLocation)) end
                                end
                            end
                        end
                        if M27Utilities.IsTableEmpty(tPlatoonCurMoveLocation) then tPlatoonCurMoveLocation = GetPlatoonFrontPosition(oPlatoon) end
                        --if tPlatoonCurMoveLocation == nil then tPlatoonCurMoveLocation = oPlatoon[reftTemporaryMoveTarget] end --redundancy now
                        --Distance to run back by: If follower platoon (such as intel platoon) with temporary retreat or actionrun then will be refreshing every 2s (6s if hover in platoon)
                        local iDistanceToRunBackBy = 60
                        local iMinDistanceToRunBack = 50
                        if oPlatoon[refiCurrentAction] == refActionTemporaryRetreat then
                            iDistanceToRunBackBy = 25
                            iMinDistanceToRunBack = 20
                            if sPlatoonName == 'M27GroundExperimental' then iDistanceToRunBackBy = 30 end
                        elseif oPlatoon[refiCurrentAction] == refActionKitingRetreat then
                            iDistanceToRunBackBy = 13
                            iMinDistanceToRunBack = 10
                            if sPlatoonName == 'M27GroundExperimental' then iDistanceToRunBackBy = 16 end
                        end

                        local iOurMinSpeed = M27Logic.GetUnitMinSpeed(oPlatoon[reftCurrentUnits], aiBrain, false)
                        if iOurMinSpeed > 3.5 then
                            --Dealing with a fast unit such as a land scout
                            if oPlatoon[refbHoverInPlatoon] then iDistanceToRunBackBy = math.max(iDistanceToRunBackBy, 30)
                            else iDistanceToRunBackBy = math.min(25, iDistanceToRunBackBy)
                            end
                        end

                        if M27Utilities.IsTableEmpty(oPlatoon[reftTemporaryMoveTarget]) == false and M27Utilities.IsTableEmpty(tPlatoonCurMoveLocation) == false and oPlatoon[reftTemporaryMoveTarget][1] == tPlatoonCurMoveLocation[1] and oPlatoon[reftTemporaryMoveTarget][3] == tPlatoonCurMoveLocation[3] then
                            bUseTempPath = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Have a temporary move target set which is equal to platoon front unit current target location') end
                        else
                            bUseTempPath = false
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have a temporary move target set which is equal to platoon front unit current target location') end
                        end

                        --if M27Utilities.IsTableEmpty(tPlatoonCurMoveLocation) == true then
                        --    tPlatoonCurMoveLocation = oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]
                        --[[else
                            bUseTempPath = true
                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Temporary move target being used which shouldnt be nil, repr='..repru(oPlatoon[reftTemporaryMoveTarget])) end
                        end--]]
                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Point 1: platoon movement path='..repru(oPlatoon[reftMovementPath])) end

                        if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] == 0 and not(oPlatoon[refiCurrentAction] == refActionKitingRetreat) then
                            --Head towards rally as we either have low health or just got hit by an unseen unit so dont know that our current move target is safe, unless we are at max health
                            if bDebugMessages == true then LOG(sFunctionRef..': Either low health or taken unseen damage, so about to call returntobase. iDistanceToRunBackBy='..iDistanceToRunBackBy..'; bTemporaryRetreat='..tostring(bTemporaryRetreat)) end

                            ReturnToBaseOrRally(oPlatoon, M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit]), iDistanceToRunBackBy, bDontClearActions, bTemporaryRetreat)
                            bTargetAwayFromNearestEnemy = true
                            bAlreadyGivenMoveOrderThisCycle = true

                        else
                            --Can detect enemy units, so will see if current move target will take us far enough away from them
                            if bGoToChokepoint then
                                if M27Utilities.GetDistanceBetweenPositions(aiBrain[M27MapInfo.reftChokepointBuildLocation], tPlatoonCurMoveLocation) <= 30 then
                                    bTargetAwayFromNearestEnemy = true
                                else
                                    bTargetAwayFromNearestEnemy = false
                                end
                            else

                                --IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPos, tCurDestination, iEnemySearchRadius, bAlsoRunFromEnemyStartLocation)
                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': RunAway action - are nearby enemies so checking if moving away from them and enemy base``') end
                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': oPlatoon[refiEnemySearchRadius]='..(oPlatoon[refiEnemySearchRadius] or 'nil')..'; oPlatoon[refiCurrentPathTarget]='..(oPlatoon[refiCurrentPathTarget] or 'nil')..'; Search range for enemy structures='..(aiBrain[M27Overseer.refiSearchRangeForEnemyStructures] or 'nil')..'; iMinDistanceToRunBack='..(iMinDistanceToRunBack or 'nil')) end
                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': tCurPlatoonPos='..repru(tCurPlatoonPos)) end
                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': tPlatoonCurMoveLocation='..repru(tPlatoonCurMoveLocation)) end
                                local tPositionTowardsCurMoveLocation = M27Utilities.MoveInDirection(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), tPlatoonCurMoveLocation), iDistanceToRunBackBy, true)
                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]='..repru(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])..'; tPositionTowardsCurMoveLocation='..repru(tPositionTowardsCurMoveLocation)) end
                                --IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPos,          tCurDestination,                iEnemySearchRadius,                                                                                 bAlsoRunFromEnemyStartLocation, iMinDistanceOverride, tOptionalNearbyEnemies)
                                if (oPlatoon[refiEnemiesInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tPositionTowardsCurMoveLocation, math.max(oPlatoon[refiEnemySearchRadius], aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), true, nil, oPlatoon[reftEnemiesInRange]) == true) and (oPlatoon[refiEnemyStructuresInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tPositionTowardsCurMoveLocation, math.max(oPlatoon[refiEnemySearchRadius], aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), true, nil, oPlatoon[reftEnemyStructuresInRange]) == true) and M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], tCurPlatoonPos) >= iMinDistanceToRunBack and (oPlatoon[refiEnemiesInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tPlatoonCurMoveLocation, math.max(oPlatoon[refiEnemySearchRadius], aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), true, nil, oPlatoon[reftEnemiesInRange]) == true) and (oPlatoon[refiEnemyStructuresInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tPlatoonCurMoveLocation, math.max(oPlatoon[refiEnemySearchRadius], aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), true, nil, oPlatoon[reftEnemyStructuresInRange]) == true) then bTargetAwayFromNearestEnemy = true end
                                if bDebugMessages == true then
                                    LOG('bTargetAwayFromNearestEnemy='..tostring(bTargetAwayFromNearestEnemy)..'; oPlatoon[refiCurrentPathTarget]='..oPlatoon[refiCurrentPathTarget]..'; oPlatoon[refiEnemySearchRadius]='..oPlatoon[refiEnemySearchRadius]..'; Will draw cur platoon position in blue, and move target in gold')
                                    M27Utilities.DrawLocation(tCurPlatoonPos, nil, 1, 50)
                                    M27Utilities.DrawLocation(tPlatoonCurMoveLocation, nil, 4, 50)
                                end
                            end
                        end
                        if bDebugMessages == true then
                            LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Point 2: platoon movement path='..repru(oPlatoon[reftMovementPath]))
                            LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Action is to run; bTargetAwayFromNearestEnemy and enemy start='..tostring(bTargetAwayFromNearestEnemy))
                        end
                        if bTargetAwayFromNearestEnemy == false then
                            --Will need to change direction, so clear current commands
                            if bDontClearActions == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                                M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                            end

                            --Not moving further away with the current movement path target, try the previous movement path
                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': 1s loop: Running away - Try moving to first mex location or start; iCurrentPathTarget='..oPlatoon[refiCurrentPathTarget]) end
                            local tTempMoveTarget = {}
                            --Would moving to the previous movement path mean we move away from the enemy?

                            if bGoToChokepoint then
                                tTempMoveTarget = {aiBrain[M27MapInfo.reftChokepointBuildLocation][1], aiBrain[M27MapInfo.reftChokepointBuildLocation][2], aiBrain[M27MapInfo.reftChokepointBuildLocation][3]}
                                bTargetAwayFromNearestEnemy = true
                                if bTemporaryRetreat == true then
                                    bUseTempPath = true
                                    oPlatoon[reftTemporaryMoveTarget] = tTempMoveTarget
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Setting temporary move target '..repru(tTempMoveTarget)..' to earlier movement path') end
                                else
                                    --Replace current movement path target with this
                                    ReplaceMovementPathWithNewTarget(oPlatoon, tTempMoveTarget)
                                end
                            else
                                if oPlatoon[refiCurrentPathTarget] > 1 then
                                    tTempMoveTarget[1] = oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget] - 1][1]
                                    tTempMoveTarget[2] = oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget] - 1][2]
                                    tTempMoveTarget[3] = oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget] - 1][3]

                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Trying previous movement target='..repru(tTempMoveTarget)..'; will see if it is away from nearby enemies.  Will draw in Cyan')
                                        M27Utilities.DrawLocation(tTempMoveTarget, false, 6)
                                    end
                                    --IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPos,          tCurDestination,                iEnemySearchRadius,                                                                                 bAlsoRunFromEnemyStartLocation, iMinDistanceOverride, tOptionalNearbyEnemies)
                                    if (oPlatoon[refiEnemiesInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tTempMoveTarget, math.max(oPlatoon[refiEnemySearchRadius], aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), false, nil, oPlatoon[reftEnemiesInRange]) == true) and (oPlatoon[refiEnemyStructuresInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tTempMoveTarget, math.max(oPlatoon[refiEnemySearchRadius], aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), false, nil, oPlatoon[reftEnemyStructuresInRange]) == true) and M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget] - 1], tCurPlatoonPos) >= iMinDistanceToRunBack then
                                        bTargetAwayFromNearestEnemy = true
                                        oPlatoon[refiCurrentPathTarget] = oPlatoon[refiCurrentPathTarget] - 1
                                        if bTemporaryRetreat == true then
                                            bUseTempPath = true
                                            oPlatoon[reftTemporaryMoveTarget] = tTempMoveTarget
                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Setting temp move target '..repru(tTempMoveTarget)..' to earlier movement path') end
                                        else
                                            --Replace current movement path target with this
                                            ReplaceMovementPathWithNewTarget(oPlatoon, tTempMoveTarget)
                                        end
                                    elseif bDebugMessages == true then LOG(sFunctionRef..': Previous movement target isnt away from nearby enemies')
                                    end
                                end
                            end

                            if bTargetAwayFromNearestEnemy == false then
                                --Try going towards base
                                tTempMoveTarget = M27Utilities.MoveTowardsTarget(tCurPlatoonPos, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], iDistanceToRunBackBy, 0)
                                local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit])
                                local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))

                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Will try going towards base instead. tTempMoveTarget='..repru(tTempMoveTarget)..' if we can path to it.  Will draw location moving towards base in black')
                                    M27Utilities.DrawLocation(tTempMoveTarget, false, 3)
                                end

                                if iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(sPathing, tTempMoveTarget) and (oPlatoon[refiEnemiesInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tTempMoveTarget, math.max(oPlatoon[refiEnemySearchRadius],aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), false, nil, oPlatoon[reftEnemiesInRange]) == true) and (oPlatoon[refiEnemyStructuresInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tTempMoveTarget, math.max(oPlatoon[refiEnemySearchRadius],aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), false, nil, oPlatoon[reftEnemyStructuresInRange]) == true) then
                                    bTargetAwayFromNearestEnemy = true
                                    if bTemporaryRetreat == true then
                                        bUseTempPath = true
                                        oPlatoon[reftTemporaryMoveTarget] = tTempMoveTarget
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Setting temp move target '..repru(tTempMoveTarget)..' to towards base and away from nearest enemy') end
                                    else
                                        --Replace current movement path target with this
                                        ReplaceMovementPathWithNewTarget(oPlatoon, tTempMoveTarget)
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Replacing remaining movement path with the retreat location') end
                                    end
                                else
                                    --Just run in opposite direction to nearest enemy
                                    local oNearestEnemy
                                    if oPlatoon[refiEnemiesInRange] > 0 then oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], tCurPlatoonPos)
                                    else oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], tCurPlatoonPos) end

                                    tTempMoveTarget = M27Utilities.MoveTowardsTarget(tCurPlatoonPos, oNearestEnemy:GetPosition(), iDistanceToRunBackBy, 180)
                                    --IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPos, tCurDestination, iEnemySearchRadius, bAlsoRunFromEnemyStartLocation)
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': RunAway action - Seeing if moving in opposite direction will move us away') end
                                    if (oPlatoon[refiEnemiesInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tTempMoveTarget, math.max(oPlatoon[refiEnemySearchRadius],aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), false, nil, oPlatoon[reftEnemiesInRange]) == true) and (oPlatoon[refiEnemyStructuresInRange] == 0 or IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, tTempMoveTarget, math.max(oPlatoon[refiEnemySearchRadius],aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), false, nil, oPlatoon[reftEnemyStructuresInRange]) == true) then
                                        bTargetAwayFromNearestEnemy = true
                                        if bTemporaryRetreat == true then
                                            bUseTempPath = true
                                            oPlatoon[reftTemporaryMoveTarget] = tTempMoveTarget
                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Setting temp move target '..repru(tTempMoveTarget)..' to move away from nearest enemy') end
                                        else
                                            --Replace current movement path target with this
                                            ReplaceMovementPathWithNewTarget(oPlatoon, tTempMoveTarget)
                                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Replacing remaining movement path with the retreat location') end
                                        end
                                    else
                                        --Although going to base may not be running from nearest enemy, other alternatives arent suitable either; if nearest rally point is further from enemy than our current position then move there, otherwise move to base
                                        tTempMoveTarget = M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit])
                                        local oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon), aiBrain)
                                        if bDebugMessages == true then
                                            LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Considering going to nearest rally point, location='..repru(tTempMoveTarget)..'; will draw in white')
                                            M27Utilities.DrawLocation(tTempMoveTarget, false, 7)
                                        end

                                        if M27UnitInfo.IsUnitValid(oNearestEnemy) and M27Utilities.GetDistanceBetweenPositions(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) + math.min(30, oPlatoon[refiPlatoonMaxRange]) < M27Utilities.GetDistanceBetweenPositions(tTempMoveTarget,oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Nearest rally point is far enough away so will go here') end
                                        else
                                            tTempMoveTarget = {M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][2], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3]}
                                            if bDebugMessages == true then
                                                LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Returning to base as moving away from nearest enemy doesnt move us away from other enemies; location that tried to move awawy to='..repru(tTempMoveTarget)..'; will draw in light blue')
                                                M27Utilities.DrawLocation(tTempMoveTarget, false, 5)
                                            end
                                        end

                                        if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..'-'..oPlatoon[refiPlatoonUniqueCount]..': A'..refActionReturnToBase) end
                                        local iReturnToBaseDistance --nil unless special case
                                        if oPlatoon[M27PlatoonTemplates.refbRunFromAllEnemies] == true then iReturnToBaseDistance = iDistanceToRunBackBy end
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Point 2B: platoon movement path='..repru(oPlatoon[reftMovementPath])) end
                                        ReturnToBaseOrRally(oPlatoon, tTempMoveTarget, iDistanceToRunBackBy, bDontClearActions, bTemporaryRetreat)
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Point 2c: platoon movement path='..repru(oPlatoon[reftMovementPath])) end
                                    end
                                end
                            end
                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Point 3: platoon movement path='..repru(oPlatoon[reftMovementPath])..'; bTargetAwayFromNearestEnemy='..tostring(bTargetAwayFromNearestEnemy)) end
                            if bTargetAwayFromNearestEnemy == true then
                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': bTargetAwayFromNearestEnemy is true; bUseTempPath='..tostring(bUseTempPath)) end
                                --(v60 commented out the below as we already ahve a clear commands above that should always trigger if have reached this point and hte below commented section wouldve triggered, i.e. were double-clearing)
                                --[[if bDontClearActions == false and iCurrentUnits > 0 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                                    M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                                end--]]
                                oPlatoon:SetPlatoonFormationOverride('GrowthFormation')
                                if not(bUseTempPath == true) then
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': RunAway action - Are already moving away from nearest enemy based on the current movement path; oPlatoon[refiCurrentPathTarget]='..oPlatoon[refiCurrentPathTarget]) end
                                    if iCurrentUnits > 0 then
                                        PlatoonMove(oPlatoon, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                                        if bDebugMessages == true then LOG(sFunctionRef..': Sent order to move to current movement path which is '..repru(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])) end
                                    end
                                    --oPlatoon:MoveToLocation(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], false)
                                    if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': RunToPrev') end
                                else
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': RunAway action - moving to temporary move target') end
                                    if iCurrentUnits > 0 then
                                        PlatoonMove(oPlatoon, oPlatoon[reftTemporaryMoveTarget])
                                        if bDebugMessages == true then LOG(sFunctionRef..': Sent order to move to temporary move target '..repru(oPlatoon[reftTemporaryMoveTarget])) end
                                    end
                                    --oPlatoon:MoveToLocation(oPlatoon[reftTemporaryMoveTarget], false)
                                    if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': RunToTemp') end
                                end
                                --oPlatoon[refiLastPathTarget] = oPlatoon[refiCurrentPathTarget]
                                --WaitSeconds(2)
                            end
                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Point 4: platoon movement path='..repru(oPlatoon[reftMovementPath])) end
                        else
                            --Already moving from enemy, so no need to change things unless we were given an attack order
                            if not(bAlreadyGivenMoveOrderThisCycle) and iCurrentUnits > 0 and M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) then
                                if not(oPlatoon[refoFrontUnit]:IsUnitState('Moving')) or (not(oPlatoon[refiLastOrderType] == refiOrderIssueMove) and not(oPlatoon[refiLastOrderType] == refiOrderIssueFormMove)) then
                                    if bDontClearActions == false then
                                        if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Platoon should be moving away from enemy based on movement path but its unit state isnt moving so will refresh. Clearing commands; Gametime='..GetGameTimeSeconds()..'; tPlatoonCurMoveLocation='..repru(tPlatoonCurMoveLocation)) end
                                        M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                                    end
                                    --If position is close to the cur move location the nrevise to be the movement path
                                    if M27Utilities.GetDistanceBetweenPositions(tPlatoonCurMoveLocation, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]) >= 5 and M27Utilities.GetDistanceBetweenPositions(tPlatoonCurMoveLocation, GetPlatoonFrontPosition(oPlatoon)) <= 5 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Current move location is more than 5 from movement path and less tahn 5 from current position, so need to change so we will move to movement path='..repru(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])) end
                                        tPlatoonCurMoveLocation = {oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][1], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][2], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][3]}
                                    end
                                    PlatoonMove(oPlatoon, tPlatoonCurMoveLocation)
                                end
                            end

                            --[[
                            --Already moving away from enemy, so no need to change things, unless we're moving to a temporary movement path
                            local bReissuePath = false
                            if oPlatoon[reftPrevAction][1] == refActionMoveDFToNearestEnemy or oPlatoon[reftPrevAction][1] == refActionMoveToTemporaryLocation then
                                bReissuePath = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Prev action was to move somewhere else so will reissue movement path') end
                            else
                                --Check if cur destination is away from enemy if ACU in platoon
                                if oPlatoon[refbACUInPlatoon] == true then
                                    if IsDestinationAwayFromNearbyEnemies(aiBrain, tCurPlatoonPos, M27Utilities.GetACU(aiBrain):GetNavigator():GetCurrentTargetPos(), math.max(oPlatoon[refiEnemySearchRadius], aiBrain[M27Overseer.refiSearchRangeForEnemyStructures]), true) == false then bReissuePath = true end
                                end
                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': 1s loop: Already running away from enemy, no need to change things unless we arent following our movement path. Prev action='..oPlatoon[reftPrevAction][1]..'; bReissuePath='..tostring(bReissuePath)) end
                            end
                            if bReissuePath == true then ReissueMovementPath(oPlatoon, false) end --]]
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - platoon current units are empty') end
                    end
                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': End of refActionRun; platoon movement path='..repru(oPlatoon[reftMovementPath])) end
                elseif oPlatoon[refiCurrentAction] == refActionGoToNearestRallyPoint or oPlatoon[refiCurrentAction] == refActionGoToRallyPointNearAir then
                    if bDontClearActions == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                        M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                    end
                    oPlatoon[M27PlatoonTemplates.refbAttackMove] = false --Dont e.g. want fatboy to attack-move back to rally point
                    oPlatoon[reftMovementPath] = {}
                    if oPlatoon[refiCurrentAction] == refActionGoToNearestRallyPoint then
                        oPlatoon[reftMovementPath][1] = M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit])
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just set platoon movement path to the nearest rally point which is '..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[reftMovementPath][1])..' away from the platoon') end
                    else

                        --Want rally point near air rally point, assuming air rally point is closer to our base than the nearest rally point
                        local tAirRallyPoint = M27AirOverseer.GetAirRallyPoint(aiBrain)
                        if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) < M27Utilities.GetDistanceBetweenPositions(tAirRallyPoint, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) then
                            oPlatoon[reftMovementPath][1] = M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit])
                        else
                            oPlatoon[reftMovementPath][1] = M27Logic.GetNearestRallyPoint(aiBrain, tAirRallyPoint, oPlatoon[refoFrontUnit])
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Going to nearest rally point near air rally point. Movement path now='..repru(oPlatoon[reftMovementPath][1])..'; air rally point='..repru(tAirRallyPoint)..'; Cur position='..repru(GetPlatoonFrontPosition(oPlatoon))..'; Dist to air rally point='..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), tAirRallyPoint)..'; Dist to movement destination='..M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][1], GetPlatoonFrontPosition(oPlatoon))..'; Distance from platoon to base='..M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) end
                    end
                    oPlatoon[refiCurrentPathTarget] = 1
                    PlatoonMove(oPlatoon, oPlatoon[reftMovementPath][1])
                    oPlatoon[refiThreatWhenRetreatToRallyOrBase] = math.max(M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits]), (oPlatoon[refiThreatWhenRetreatToRallyOrBase] or 0))
                    if bDebugMessages == true then LOG(sFunctionRef..': Have updated '..sPlatoonName..oPlatoon[refiPlatoonCount]..' movement path to the nearest rally point='..repru(oPlatoon[reftMovementPath][1])..'; platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))..'; platoon threat at this point='..oPlatoon[refiThreatWhenRetreatToRallyOrBase]) end
                elseif oPlatoon[refiCurrentAction] == refActionReissueMovementPath then
                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': About to call reissuemovementpath; bDontClearActions='..tostring(bDontClearActions)) end
                    ReissueMovementPath(oPlatoon, bDontClearActions)

                    --IssueMove(oPlatoon[reftCurrentUnits], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                elseif oPlatoon[refiCurrentAction] == refActionContinueMovementPath  then
                    --Did we get our movement path when we needed to heal and no longer need to heal? If so then want a new movement path instead
                    if oPlatoon[refbNeededToHealWhenGotMovementPath] and not(oPlatoon[refbNeedToHeal]) then
                        if bDebugMessages == true then LOG(sFunctionRef..': ContinueMovementPath: Needed to heal when last got movement path but we dont need to heal now') end
                        GetNewMovementPath(oPlatoon, bDontClearActions)
                    else
                        --if if bDontClearActions == false then M27Utilities.IssueTrackedClearCommands(oPlatoon[reftCurrentUnits]) end --already clear using MoveAlongPath
                        --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionContinueMovementPath') end
                        oPlatoon:SetPlatoonFormationOverride('AttackFormation')
                        --Update movement path if have already gone past it and are closer to the next part of the path:
                        if table.getn(oPlatoon[reftMovementPath]) > oPlatoon[refiCurrentPathTarget] then
                            local tPlatoonCurPos = GetPlatoonFrontPosition(oPlatoon)
                            if tPlatoonCurPos == nil then
                                M27Utilities.ErrorHandler(sPlatoonName..oPlatoon[refiPlatoonCount]..': Processing current action ContinueMovementPath - platoon has nil position so disbanding instead')
                                oPlatoon[refiCurrentAction] = refActionDisband
                                --if oPlatoon and aiBrain:PlatoonExists(oPlatoon) then oPlatoon:PlatoonDisband() end
                            else
                                if M27Utilities.GetDistanceBetweenPositions(tPlatoonCurPos, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget] + 1]) < M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]+1]) then
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Are moving current path target up 1 as a recloser to next destination than current; refiCurrentPathTarget='..oPlatoon[refiCurrentPathTarget]..'; table.getn(oPlatoon[reftMovementPath])='..table.getn(oPlatoon[reftMovementPath])) end
                                    oPlatoon[refiCurrentPathTarget] = oPlatoon[refiCurrentPathTarget] + 1
                                else
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Are not moving current path target up 1. Distance between platoon and current target='..M27Utilities.GetDistanceBetweenPositions(tPlatoonCurPos, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget] + 1])..'; distance between current and next move targets='..M27Utilities.GetDistanceBetweenPositions(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]+1])..'; refiCurrentPathTarget='..oPlatoon[refiCurrentPathTarget]..'; table.getn(oPlatoon[reftMovementPath])='..table.getn(oPlatoon[reftMovementPath])) end
                                end
                            end
                        end

                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': About to issue MoveAlongPath order, oPlatoon[refiCurrentPathTarget]='..oPlatoon[refiCurrentPathTarget]) end
                        MoveAlongPath(oPlatoon, oPlatoon[reftMovementPath], oPlatoon[refiCurrentPathTarget], bDontClearActions)
                    end
                elseif oPlatoon[refiCurrentAction] == refActionNewMovementPath  then
                    --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Pre getting new movement path') end
                    GetNewMovementPath(oPlatoon, bDontClearActions)
                    --if bDebugMessages == true then M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..': Post getting new movement path') end
                    if oPlatoon[refiCurrentAction] == refActionReissueMovementPath then ReissueMovementPath(oPlatoon, bDontClearActions) end

                elseif oPlatoon[refiCurrentAction] == refActionUseAttackAI  then
                    if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..' Army Index='..aiBrain:GetArmyIndex()..': will switch to using attackAI. Gametime='..GetGameTimeSeconds()) end
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionuseAttackAI') end
                    oPlatoon:SetAIPlan('M27AttackNearestUnits')
                elseif oPlatoon[refiCurrentAction] == refActionDisband then
                    --Refresh the unit list
                    local tPlatoonUnits = oPlatoon:GetPlatoonUnits()
                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Platoon disbanding') end
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionDisband') end
                    if oPlatoon then
                        --Clear skirmisher intel request tracker
                        if oPlatoon[M27PlatoonTemplates.refbSkirmisherRetreatLogic] then aiBrain[reftSkirmisherPlatoonWantingIntel][sPlatoonName..oPlatoon[refiPlatoonCount]] = nil end

                        --Refresh all plateau trackers
                        if oPlatoon[M27Transport.refiAssignedPlateau] then
                            ForkThread(M27MapInfo.RefreshPlateauPlatoons, aiBrain, oPlatoon[M27Transport.refiAssignedPlateau])
                        end

                        oPlatoon[refbPlatoonLogicActive] = false
                        if aiBrain:PlatoonExists(oPlatoon) and M27Utilities.IsTableEmpty(tPlatoonUnits) == false then
                            if oPlatoon[refbACUInPlatoon] == false then


                                --local iRallyPointIntelLine = aiBrain[M27Overseer.refiCurIntelLineTarget]
                                local tRallyPoint = M27Logic.GetNearestRallyPoint(aiBrain, (GetPlatoonFrontPosition(oPlatoon) or M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]), oPlatoon[refoFrontUnit])
                                --[[if iRallyPointIntelLine then
                                    iRallyPointIntelLine = iRallyPointIntelLine - 2
                                    if iRallyPointIntelLine < 0 then iRallyPointIntelLine = 1 end
                                    tRallyPoint = aiBrain[M27Overseer.reftIntelLinePositions][iRallyPointIntelLine][1]
                                end
                                if iRallyPointIntelLine == nil or M27Utilities.IsTableEmpty(tRallyPoint) == true then
                                    tRallyPoint = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                                end--]]
                                if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Still have units, so sending them to rallypoint='..repru(tRallyPoint)) end
                                M27Utilities.IssueTrackedClearCommands(tPlatoonUnits)
                                IssueMove(tPlatoonUnits, tRallyPoint)
                                --Allocate units after a 1 tick delay to prevent infinite loop
                                M27PlatoonFormer.AllocateNewUnitsToPlatoonNotFromFactory(tPlatoonUnits, 1)
                            end
                        end
                        --Was there a helper assigned to this platoon? If so clear its target and tell it to return to the nearest rally point
                        local refHelper = M27Overseer.refoScoutHelper
                        local oHelperPlatoon
                        for iHelperType = 1, 2 do
                            if iHelperType == 2 then
                                refHelper = M27Overseer.refoUnitsMAAHelper
                            end
                            oHelperPlatoon = oPlatoon[refHelper]
                            if oHelperPlatoon then
                                oHelperPlatoon[refoSupportHelperPlatoonTarget] = nil
                                oHelperPlatoon[refbOverseerAction] = true
                                oHelperPlatoon[refiOverseerAction] = refActionGoToNearestRallyPoint
                            end
                        end
                        --Are we escorting a platoon? If so then clear that platoon's tracker
                        if oPlatoon[refoPlatoonOrUnitToEscort] and oPlatoon[refoPlatoonOrUnitToEscort][refoEscortingPlatoon] == oPlatoon then oPlatoon[refoPlatoonOrUnitToEscort][refoEscortingPlatoon] = nil end
                        --Are we being escorted by a platoon? If so then disband that platoon
                        if oPlatoon[refoEscortingPlatoon] and oPlatoon[refoEscortingPlatoon][refoPlatoonOrUnitToEscort] == oPlatoon then
                            if bDebugMessages == true then LOG(sFunctionRef..': We are being escorted by a platoon so will disband that platoon') end
                            oPlatoon[refoEscortingPlatoon][refoPlatoonOrUnitToEscort] = nil
                            oPlatoon[refoEscortingPlatoon][refiCurrentAction] = refActionDisband
                        end
                        --Are we being tracked as needing an escort?
                        if oPlatoon[refiNeedingEscortUniqueCount] and aiBrain[reftPlatoonsOrUnitsNeedingEscorts][oPlatoon[refiNeedingEscortUniqueCount]] then
                            table.remove(aiBrain[reftPlatoonsOrUnitsNeedingEscorts], oPlatoon[refiNeedingEscortUniqueCount])
                        end
                        --Are we a mobile shield platoon? If so then assign the shield to a retreating platoon
                        if sPlatoonName == 'M27MobileShield' then
                            local tRemainingUnits = oPlatoon:GetPlatoonUnits()
                            --Strange bug where just doing istableempty wasnt sufficient and could lead to constant spamming of error that object was destroyed; therefore will both check platoon exists and every unit wiithin it is valid
                            if M27Utilities.IsTableEmpty(tRemainingUnits) == false and aiBrain:PlatoonExists(oPlatoon) then
                                local tUnitsToRetreat = {}
                                for iRetreatingUnit, oRetreatingUnit in tRemainingUnits do
                                    if M27UnitInfo.IsUnitValid(oRetreatingUnit) then table.insert(tUnitsToRetreat, oRetreatingUnit) end
                                end
                                if M27Utilities.IsTableEmpty(tUnitsToRetreat) == false then
                                    local oShieldPlatoon = M27PlatoonFormer.CreatePlatoon(aiBrain, 'M27RetreatingShieldUnits', tUnitsToRetreat)
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will now wait 1 tick and then disband platoon with ref='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]) end
                        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                        WaitTicks(1)
                        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

                        if oPlatoon and aiBrain:PlatoonExists(oPlatoon) then
                            local tRemainingUnits = oPlatoon:GetPlatoonUnits()
                            aiBrain:DisbandPlatoon(oPlatoon)
                            if M27Utilities.IsTableEmpty(tRemainingUnits) == false then
                                if not(tRemainingUnits[1].PlatoonHandle) or tRemainingUnits[1].PlatoonHandle == oPlatoon then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will send aggressive move order to remaining units in the platoon. Size of table='..table.getsize(tRemainingUnits)) end
                                    IssueAggressiveMove(tRemainingUnits, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                    if M27Config.M27ShowUnitNames == true then UpdateUnitNames(tRemainingUnits, "DisbandedReturnToBase", true) end
                                    for iUnit, oUnit in tRemainingUnits do
                                        oUnit[M27PlatoonFormer.refbWaitingForAssignment] = false
                                    end
                                    M27PlatoonFormer.AllocateNewUnitToPlatoonBase(tRemainingUnits, true)
                                end
                            end
                        end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionMoveDFToNearestEnemy  then
                    --Update the name just for direct fire units hence commented out below
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionMoveDFToNearestEnemy') end
                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': About to process move DF to nearest enemy') end
                    if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] > 0 then
                        if oPlatoon[refiDFUnits] > 0 and GetPlatoonUnitsOrUnitCount(oPlatoon, reftDFUnits, true, true) > 0 then
                            if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': We have DF units in our platoon') end
                            local oTargetEnemy
                            if oPlatoon[refiEnemiesInRange] == 0 then oTargetEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemyStructuresInRange], GetPlatoonFrontPosition(oPlatoon))
                            elseif oPlatoon[refiEnemyStructuresInRange] == 0 then oTargetEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon))
                            else
                                oTargetEnemy = M27Utilities.GetNearestUnit(M27Utilities.CombineTables(oPlatoon[reftEnemiesInRange], oPlatoon[reftEnemyStructuresInRange]), GetPlatoonFrontPosition(oPlatoon))
                            end
                            if oTargetEnemy then
                                if bDebugMessages == true then
                                    LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Have a target to move to. bDontClearActions='..tostring(bDontClearActions)..'; will draw target in blue')
                                    M27Utilities.DrawLocation(oTargetEnemy:GetPosition(), nil, 1)
                                end
                                if bDontClearActions == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                                    M27Utilities.IssueTrackedClearCommands(GetPlatoonUnitsOrUnitCount(oPlatoon, reftDFUnits, false, true))
                                end
                                local iDistAwayFromTarget = 3
                                if EntityCategoryContains(categories.VOLATILE, oTargetEnemy.UnitId) then iDistAwayFromTarget = 7 end --energy storage has an aoe of 5, dont want to just set equal to this since then we wouldnt attack things like a paragon
                                --If shot is blocked and are already within this distance (or close to it) then reduce the distance from target

                                if oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] then
                                    local iCurDistToTarget = M27Utilities.GetDistanceBetweenPositions(oPlatoon[refoFrontUnit]:GetPosition(), oTargetEnemy:GetPosition())
                                    if iCurDistToTarget <= iDistAwayFromTarget + 1 then iDistAwayFromTarget = math.max(1, iCurDistToTarget - 2) end
                                end


                                oPlatoon[reftTemporaryMoveTarget] = M27Utilities.MoveInDirection(oTargetEnemy:GetPosition(), M27Utilities.GetAngleFromAToB(oTargetEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon)), iDistAwayFromTarget, true)
                                --oPlatoon[reftTemporaryMoveTarget][1], oPlatoon[reftTemporaryMoveTarget][2], oPlatoon[reftTemporaryMoveTarget][3] = oTargetEnemy:GetPositionXYZ()

                                --Record location and switch to continuing with movement path if we have tried going here too many times and cant path
                                if ReconsiderTarget(oPlatoon, oPlatoon[reftTemporaryMoveTarget]) then
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Have tried moving to '..repru(oPlatoon[reftTemporaryMoveTarget])..' too many times so will ignore action; will draw platoon and temp target in red with line; platoon position='..repru(GetPlatoonFrontPosition(oPlatoon)))
                                        M27Utilities.DrawLocations({GetPlatoonFrontPosition(oPlatoon), oPlatoon[reftTemporaryMoveTarget]}, nil, 2, 200)
                                    end
                                    --Will no longer check unit is idle, since it could lead to e.g. ACU firing at a unit (not idle) but not having any move orders, and if shot was blocked it'd be a problem
                                    --if M27Logic.IsUnitIdle(oPlatoon[refoFrontUnit], false, false, false) then
                                    --Front unit idle so reissue movement path
                                    ReissueMovementPath(oPlatoon, bDontClearActions)
                                    --end
                                else
                                    if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Sending Issue Move to DF units.  Is front unit shot blocked='..tostring(oPlatoon[refoFrontUnit][M27UnitInfo.refbLastShotBlocked] or false)) end


                                    IssueMove(GetPlatoonUnitsOrUnitCount(oPlatoon, reftDFUnits, false, true), oPlatoon[reftTemporaryMoveTarget])
                                    oPlatoon[refiLastOrderType] = refiOrderIssueMove
                                    oPlatoon[reftLastOrderPosition] = {oPlatoon[reftTemporaryMoveTarget][1], oPlatoon[reftTemporaryMoveTarget][2], oPlatoon[reftTemporaryMoveTarget][3]}
                                    if oPlatoon[refiScoutUnits] > 0 and GetPlatoonUnitsOrUnitCount(oPlatoon, reftScoutUnits, true, true) > 0 then
                                        if bDontClearActions == false then
                                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                                            M27Utilities.IssueTrackedClearCommands(GetPlatoonUnitsOrUnitCount(oPlatoon, reftScoutUnits, false, true))
                                        end
                                        UpdateScoutPositions(oPlatoon) --Moves scouts to platoon average position
                                    end
                                    if bPlatoonNameDisplay == true then --Only update name of DF units (so cant use normal function):
                                        for iUnit, oUnit in oPlatoon[reftDFUnits] do
                                            if not oUnit.Dead then
                                                oUnit:SetCustomName(sPlatoonName..oPlatoon[refiPlatoonCount]..': DFUnitsMoveToEnemy')
                                            end
                                        end
                                    end
                                end
                            else
                                M27Utilities.ErrorHandler(sPlatoonName..oPlatoon[refiPlatoonCount]..': Warning - Told to move DF units to nearby enemy but no nearby enemy')
                            end
                            --WaitSeconds(1)
                        else
                            --Might have all units on micro (e.g. if platoon is ACU)
                            if oPlatoon[refiDFUnits] == 0 then M27Utilities.ErrorHandler(sPlatoonName..oPlatoon[refiPlatoonCount]..': Told to move DF units to nearby enemy but we have no DF units in our platoon') end
                        end
                    end

                elseif oPlatoon[refiCurrentAction] == refActionReturnToBase   then
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': refActionReturnToBase') end
                    --ReturnToBaseOrRally(oPlatoon, tLocationToReturnTo, iOnlyGoThisFarTowardsBase, bDontClearActions, bUseTemporaryMoveLocation)
                    local tBasePositionToUse
                    if bDebugMessages == true then LOG(sFunctionRef..': Will determine if are a plateau platoon or not. oPlatoon[M27Transport.refiAssignedPlateau]='..(oPlatoon[M27Transport.refiAssignedPlateau] or 'nil')..'; aiBrain[M27MapInfo.refiOurBasePlateauGroup]='..aiBrain[M27MapInfo.refiOurBasePlateauGroup]..'; Segment group of current position of front unit='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, GetPlatoonFrontPosition(oPlatoon))) end



                    if oPlatoon[M27Transport.refiAssignedPlateau] == aiBrain[M27MapInfo.refiOurBasePlateauGroup] or not(oPlatoon[M27Transport.refiAssignedPlateau]) or M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, GetPlatoonFrontPosition(oPlatoon)) == aiBrain[M27MapInfo.refiOurBasePlateauGroup] then

                        if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFirebaseUnitsByFirebaseRef]) == false then
                            --Check if are near range of experimental so want to prioritise getting a shield if have chokepoint
                            if oPlatoon[refbACUInPlatoon] and M27Conditions.ACUShouldRunFromBigThreat(aiBrain) then
                                tBasePositionToUse = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                            else
                                local tNearestFirebase = M27Logic.GetNearestFirebase(aiBrain, GetPlatoonFrontPosition(oPlatoon), true)
                                if M27Utilities.GetDistanceBetweenPositions(tNearestFirebase, GetPlatoonFrontPosition(oPlatoon)) <= math.max(50, M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) then
                                    tBasePositionToUse = {tNearestFirebase[1], tNearestFirebase[2], tNearestFirebase[3]}
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will use nearest firebase') end
                                    if M27Conditions.ACUShouldRunFromBigThreat(aiBrain) then
                                        tBasePositionToUse = M27Utilities.MoveInDirection(tBasePositionToUse, M27Utilities.GetAngleFromAToB(tBasePositionToUse, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]), 25, true)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Big threat so will move slightly from firebase towards own base') end
                                    end
                                else
                                    tBasePositionToUse = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a firebase so will use start position') end
                                end
                            end
                        else
                            tBasePositionToUse = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont have any firebase so will use start position') end
                        end

                    else
                        --Dealing with a plateau platoon
                        tBasePositionToUse = M27Logic.GetNearestRallyPoint(aiBrain, GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoFrontUnit])
                        if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a plateau platoon so will get nearest rally point. oPlatoon[M27Transport.refiAssignedPlateau]='..oPlatoon[M27Transport.refiAssignedPlateau]..'; aiBrain[M27MapInfo.refiOurBasePlateauGroup]='..aiBrain[M27MapInfo.refiOurBasePlateauGroup]..'; M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, GetPlatoonFrontPosition(oPlatoon))='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, GetPlatoonFrontPosition(oPlatoon))) end
                    end



                    --Do we have a shield near here?
                    local tShieldsNearTarget = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryFixedShield, tBasePositionToUse, 40, 'Ally')
                    if bDebugMessages == true then LOG(sFunctionRef..': tBasePositionToUse='..repru(tBasePositionToUse)..'; distance between here and our start='..M27Utilities.GetDistanceBetweenPositions(tBasePositionToUse, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])..'; is table of nearby shields empty='..tostring(M27Utilities.IsTableEmpty(tShieldsNearTarget))) end
                    if M27Utilities.IsTableEmpty(tShieldsNearTarget) == false then
                        local iCurShield, iMaxShield
                        local bWantShieldFurthestFromEnemyStart = false
                        if oPlatoon[refbACUInPlatoon] and M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyLandExperimentals]) == false then
                            local iCurDist
                            local iClosestExperimental = 100000
                            for iUnit, oUnit in aiBrain[M27Overseer.reftEnemyLandExperimentals] do
                                if M27UnitInfo.IsUnitValid(oUnit) then
                                    iCurDist = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oUnit:GetPosition())
                                    if iCurDist < iClosestExperimental then iClosestExperimental = iCurDist end
                                end
                            end
                            if iClosestExperimental >= 50 then bWantShieldFurthestFromEnemyStart = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': If experimental far away will prioritise shields furthest from enemy base.  iClosestExperimental='..iClosestExperimental..'; bWantShieldFurthestFromEnemyStart='..tostring(bWantShieldFurthestFromEnemyStart)) end
                        end

                        local iBestShieldDistance = 10000
                        if bWantShieldFurthestFromEnemyStart then iBestShieldDistance = 0 end

                        for iShield, oShield in tShieldsNearTarget do
                            iCurShield, iMaxShield = M27UnitInfo.GetCurrentAndMaximumShield(oShield)
                            local oNearestShield
                            local iCurDist
                            if iCurShield >= 1000 then
                                if bWantShieldFurthestFromEnemyStart then
                                    iCurDist = M27Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain))
                                else
                                    iCurDist = M27Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': oShield='..oShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurDist='..iCurDist..'; iBestShieldDistance='..iBestShieldDistance..'; bWantShieldFurthestFromEnemyStart='..tostring(bWantShieldFurthestFromEnemyStart)) end
                                if (not(bWantShieldFurthestFromEnemyStart) and iCurDist < iBestShieldDistance) or (bWantShieldFurthestFromEnemyStart and iCurDist > iBestShieldDistance) then
                                    iBestShieldDistance = iCurDist
                                    oNearestShield = oShield
                                    if bDebugMessages == true then LOG(sFunctionRef..': This shield is now the best shield') end
                                end
                            end
                            if oNearestShield then
                                tBasePositionToUse = oNearestShield:GetPosition()
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a shield near the base position so will go there instead. oNearestShield='..oNearestShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestShield)..'; iBestShieldDistance='..iBestShieldDistance) end
                            end
                        end
                    end

                    oPlatoon[refiThreatWhenRetreatToRallyOrBase] = math.max(M27Logic.GetCombatThreatRating(aiBrain, oPlatoon[reftCurrentUnits]), (oPlatoon[refiThreatWhenRetreatToRallyOrBase] or 0))

                    if bDebugMessages == true then LOG(sFunctionRef..': About to give order to return to base or ally. tBasePositionToUse='..repru(tBasePositionToUse)..'; Actual base start position='..repru(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])..'; Platoon cur pos='..repru(GetPlatoonFrontPosition(oPlatoon))) end

                    ReturnToBaseOrRally(oPlatoon, tBasePositionToUse, nil, bDontClearActions)
                elseif oPlatoon[refiCurrentAction] == refActionReclaimTarget then
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': ActionReclaim') end
                    if bDebugMessages == true then
                        local iReclaim = oPlatoon[refoNearbyReclaimTarget].MaxMassReclaim
                        if iReclaim == nil then iReclaim = 0 end
                        LOG(sFunctionRef..': Have a reclaim target, mass on reclaim='..iReclaim)
                    end
                    --Will have already determined reclaim target as part of the check whether to reclaim (for efficiency)
                    if oPlatoon[reftReclaimers] and (M27UnitInfo.IsUnitValid(oPlatoon[refoNearbyReclaimTarget]) or oPlatoon[refoNearbyReclaimTarget] and oPlatoon[refoNearbyReclaimTarget].IsWreckage) and M27Utilities.IsTableEmpty(GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true)) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..' about to issue reclaim target') end
                        if bDontClearActions == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true))
                        end

                        --Change the target to reclaim if we think we are having issues reclaiming it
                        if oPlatoon[refbNotStartedReclaimingYet] then
                            local iBuildRange = GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true)[1]:GetBlueprint().Economy.MaxBuildDistance
                            if iBuildRange > 1  then
                                local oEngineer = GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true)[1]
                                local tEnemiesToReclaim = oEngineer:GetAIBrain():GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure + M27UnitInfo.refCategoryMobileLand + M27UnitInfo.refCategoryAllNavy - categories.COMMAND - categories.SUBCOMMANDER, oEngineer:GetPosition(), iBuildRange, 'Enemy')
                                if M27Utilities.IsTableEmpty(tEnemiesToReclaim) == false then
                                    local oPreferredReclaimTarget
                                    local oBackupReclaimTarget
                                    local iClosestDist = 10000
                                    local iCurDist
                                    for iUnit, oUnit in tEnemiesToReclaim do
                                        if not(oUnit == oPlatoon[refoNearbyReclaimTarget]) then
                                            iCurDist =  M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                            if iCurDist >= 2 then
                                                iClosestDist = iCurDist
                                                oPreferredReclaimTarget = oUnit
                                            else
                                                oBackupReclaimTarget = oUnit
                                            end
                                        end
                                    end
                                    if not(oPreferredReclaimTarget) then oPreferredReclaimTarget = oBackupReclaimTarget end
                                    if oPreferredReclaimTarget then
                                        oPlatoon[refoNearbyReclaimTarget] = oPreferredReclaimTarget
                                    else
                                        --No other suitable reclaim targets so move a bit then try reclaiming
                                        if M27UnitInfo.IsUnitValid(oPlatoon[refoNearbyReclaimTarget]) then
                                            iCurDist = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoNearbyReclaimTarget]:GetPosition())
                                            if iCurDist <= 2 then
                                                --Move away from the unit
                                                IssueMove(GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true), M27Utilities.MoveInDirection(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetAngleFromAToB(oPlatoon[refoNearbyReclaimTarget]:GetPosition(), GetPlatoonFrontPosition(oPlatoon)), iCurDist + 1, true))
                                            else
                                                --Move towards the unit
                                                if bDebugMessages == true then LOG(sFunctionRef..': Mre than 2 away from the reclaim target. iCurDist='..(iCurDist or 'nil')..'; will move towards it') end
                                                IssueMove(GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true), M27Utilities.MoveInDirection(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoNearbyReclaimTarget]:GetPosition()), iCurDist - 1, true))
                                            end
                                        end
                                    end
                                end
                            end
                        end

                        IssueReclaim(GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true), oPlatoon[refoNearbyReclaimTarget])
                        if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[refoNearbyReclaimTarget]:GetPosition()) <= GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true)[1]:GetBlueprint().Economy.MaxBuildDistance then
                            --Are within range to start reclaiming immediately so set the flag that we should reclaim (to help coutner issue where sometimes we dont due to glitch if are too close)
                            oPlatoon[refbNotStartedReclaimingYet] = true
                        end
                        oPlatoon[refiLastOrderType] = refiOrderIssueReclaim
                        oPlatoon[reftLastOrderPosition] = oPlatoon[refoNearbyReclaimTarget]:GetPosition()

                    else
                        if M27Utilities.IsTableEmpty(GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true)) == true then
                            --Aborted due to units being busy on micro
                        else
                            M27Utilities.ErrorHandler(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': the object to be reclaim doesnt exist or we dont have reclaimers in the platoon')
                            if oPlatoon[reftReclaimers] then LOG('tReclaimers is valid') end
                            if oPlatoon[refoNearbyReclaimTarget] then LOG('Reclaim target is valid') end
                            LOG('Size of tReclaimers='..GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, true, true))
                        end
                    end
                    --Add move command so unit wont stay idle (but dont record this as the last order type)
                    IssueMove(GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true), oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                    --oPlatoon[refiLastOrderType] = refiOrderIssueMove --(want to have reclaim as the last order type as the move order is just backup logic)
                elseif oPlatoon[refiCurrentAction] == refActionReclaimAllNearby then
                    --Have reclaim potentially near us - action will be cleared as part of engineer logic
                    local tAvailableReclaimers = GetPlatoonUnitsOrUnitCount(oPlatoon, reftReclaimers, false, true)
                    if M27Utilities.IsTableEmpty(tAvailableReclaimers) == false then
                        for iEngineer, oEngineer in tAvailableReclaimers do
                            oEngineer[M27EngineerOverseer.reftEngineerCurrentTarget] = oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]
                            if bDebugMessages == true then LOG(sFunctionRef..': Have set engineer '..oEngineer.UnitId..' with LC='..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' to have a current target of '..repru(oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]] or {'nil'})..'; oEngineer[M27EngineerOverseer.reftEngineerCurrentTarget]='..repru(oEngineer[M27EngineerOverseer.reftEngineerCurrentTarget] or {'nil'})) end
                            local iMinIndividualReclaim = 5
                            if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= 46 then
                                local bWantEnergy, bWantMass = M27Conditions.WantEnergyOrMassReclaim(aiBrain)
                                --Dont want ACU to be trying to get individual trees if already ahve high energy income as better uses for its time
                                if bWantEnergy then iMinIndividualReclaim = 50 end
                            end
                            --UpdateActionForNearbyReclaim(oEngineer, iMinReclaimIndividualValue, bDontIssueMoveAfter)
                            M27EngineerOverseer.UpdateActionForNearbyReclaim(oEngineer, iMinIndividualReclaim, true)
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': About to reissue movement path after updating action for nearby reclaim, unless we are near destination in which case will get new movement path') end
                        if M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]]) <= 3 then
                            GetNewMovementPath(oPlatoon, true)
                        else
                            ReissueMovementPath(oPlatoon, true)
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': tReclaimers is nil; oPlatoon[refiReclaimers]='..oPlatoon[refiReclaimers]..'; Is micro active on first unit on platoon='..tostring(oPlatoon[refoFrontUnit].M27UnitInfo.refbSpecialMicroActive or false)) end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionBuildMex then
                    --Will have already determined the location to build the mex on (and checked its available to build oin) as part of the check of whether to have this as an action
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': ActionBuildMex') end
                    if GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, true, true) > 0 then
                        local tBuilders = GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..' about to issue command to build mex at location '..repru(oPlatoon[reftNearbyMexToBuildOn])..'; bDontClearActions='..tostring(bDontClearActions)) end
                        if bDontClearActions == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(tBuilders)
                        end
                        if bDebugMessages == true then M27Utilities.DrawLocation(oPlatoon[reftNearbyMexToBuildOn], nil, nil, 20) end --blue circle
                        --First move near construction if it's different to current move target
                        local tMoveNearMex
                        local tBuilderCurPos
                        local bDontMoveBefore = false
                        for _, oBuilder in tBuilders do
                            if not(oBuilder.Dead) then
                                --Not sure how well this will work with platoons containing multiple builders - if gives issues then switch to using assist for the remaining units
                                --M27BuildStructureAtLocation(oBuilder, sBuildingType, tBuildLocation, bMoveNearFirst)
                                if bDebugMessages == true then LOG(sFunctionRef..': First builder position='..repru(oBuilder:GetPosition())..'; will move near mex') end
                                --MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction)
                                tMoveNearMex = MoveNearConstruction(aiBrain, oBuilder, oPlatoon[reftNearbyMexToBuildOn], 'UAB1103', -0.1, true, false, true)
                                if tMoveNearMex then
                                    --Check if this is different to current position by enough (as movenearconstruction returns current position if dont need to change things)
                                    tBuilderCurPos = oBuilder:GetPosition()
                                    if bDebugMessages == true then LOG(sFunctionRef..': tMoveNearMex='..repru(tMoveNearMex)..'; tBuilderCurPos='..repru(tBuilderCurPos)..'; distance between builder position and move near mex position='..M27Utilities.GetDistanceBetweenPositions(tMoveNearMex, tBuilderCurPos)) end
                                    if M27Utilities.GetDistanceBetweenPositions(tMoveNearMex, tBuilderCurPos) < 1 then bDontMoveBefore = true tMoveNearMex = nil end
                                else bDontMoveBefore = true
                                end

                                break
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': BuildingMex process action; bDontMoveBefore='..tostring(bDontMoveBefore)) end
                        if bDontMoveBefore == false then
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': tMoveNearMex='..repru(tMoveNearMex))
                                M27Utilities.DrawLocation(tMoveNearMex, nil, 3, 20) --orange circle
                            end
                            IssueMove(tBuilders, tMoveNearMex)
                            oPlatoon[refiLastOrderType] = refiOrderIssueMove
                            oPlatoon[reftLastOrderPosition] = tMoveNearMex
                        end
                        for _, oBuilder in tBuilders do
                            if not(oBuilder.Dead) then
                                --AIBuildStructures.M27BuildStructureAtLocation(oBuilder, 'T1Resource', oPlatoon[reftNearbyMexToBuildOn])
                                if bDebugMessages == true then LOG(sFunctionRef..': Issuing build command to '..oBuilder.UnitId..M27UnitInfo.GetUnitLifetimeCount(oBuilder)..'; to build mex at '..repru(oPlatoon[reftNearbyMexToBuildOn])) end
                                --BuildStructureAtLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForPartCompleteBuildings, bLookForQueuedBuildings)
                                oPlatoon[reftLastBuildLocation] = M27EngineerOverseer.BuildStructureAtLocation(aiBrain, oBuilder, M27UnitInfo.refCategoryT1Mex, nil, nil, oPlatoon[reftNearbyMexToBuildOn], false, false)
                                oPlatoon[refiLastOrderType] = refiOrderIssueBuild
                                oPlatoon[reftLastOrderPosition] = {oPlatoon[reftNearbyMexToBuildOn][1], oPlatoon[reftNearbyMexToBuildOn][2], oPlatoon[reftNearbyMexToBuildOn][3]}
                                --AIBuildStructures.M27BuildStructureDirectAtLocation(oBuilder, 'T1Resource', oPlatoon[reftNearbyMexToBuildOn])
                            end
                        end
                        --Move as soon as are done:
                        IssueMove(tBuilders, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                        oPlatoon[refiLastOrderType] = refiOrderIssueMove
                        oPlatoon[reftLastOrderPosition] = {oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][1], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][2], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][3]}
                    end
                elseif oPlatoon[refiCurrentAction] == refActionBuildFactory then
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': BuildLandFac') end
                    if GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, true, true) > 0 then
                        local tBuilders = GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..' about to issue command to build factory; bDontClearActions='..tostring(bDontClearActions)) end
                        if bDontClearActions == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(tBuilders)
                        end
                        local oACU = M27Utilities.GetACU(aiBrain)
                        local iCategoryToBuild = M27UnitInfo.refCategoryLandFactory --Default
                        local iCategoryToBuildBy = M27UnitInfo.refCategoryT1Mex
                        --Do we want to build an air factory instead?  Consider building air if we're relatively close to our base, we have a base level of energy taht could support it, and we have the minimum number of land factories wanted

                        --Air fac requires 80 energy per second just to build with an ACU
                        local tNearbyAirFactories = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryAirFactory, GetPlatoonFrontPosition(oPlatoon), 35, 'Ally')
                        local bHavePartCompleteAirFactory = false
                        local bMoveNearTargetInstead = false --Used if another engi has queued up to build an air factory so we can move to be able to help build it if the other engi is closer
                        local tExistingBuildLocation

                        local iMaxAreaToSearch = 35
                        if aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryAllFactories) >= 2 and iCategoryToBuild == M27UnitInfo.refCategoryLandFactory and (aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyLandRush or (aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] <= 400 and aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand])) then
                            iMaxAreaToSearch = 20
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': refiMinLandFactoryBeforeOtherTypes='..aiBrain[M27Overseer.refiMinLandFactoryBeforeOtherTypes]) end


                        if M27Utilities.IsTableEmpty(tNearbyAirFactories) == false then --THIS SECTION MAY BE REDUNDANT as later on we tell ACU to guard a factory that is part-built (but within 30 rather than 35)
                            for iUnit, oUnit in tNearbyAirFactories do
                                if oUnit:GetFractionComplete() < 1 then
                                    iCategoryToBuild = M27UnitInfo.refCategoryAirFactory
                                    iCategoryToBuildBy = M27UnitInfo.refCategoryPower + M27UnitInfo.refCategoryHydro
                                    bHavePartCompleteAirFactory = true
                                    tExistingBuildLocation = oUnit:GetPosition()
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have nearby part complete air factory so will build air factory') end
                                    break
                                end
                            end
                        end
                        if not(bHavePartCompleteAirFactory) then
                            local iExistingAirFactories = aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryAirFactory)
                            local iEnergyIncomeNeeded = math.max((2400 - aiBrain:GetEconomyStored('ENERGY')), 1) / 300 + iExistingAirFactories * 12
                            local iMinGrossIncomeWanted = 18
                            if aiBrain[M27Overseer.refiMinLandFactoryBeforeOtherTypes] == 1 then iMinGrossIncomeWanted = 16 end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have energy to support an air factory. aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome]='..aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome]..'; Stored energy='..aiBrain:GetEconomyStored('ENERGY')..'; iEnergyIncomeNeeded='..iEnergyIncomeNeeded..'; aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome]='..aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome]..'; iExistingAirFactories='..iExistingAirFactories) end
                            if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= 16 and (aiBrain:GetEconomyStored('ENERGY') >= 2500 or aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome] >= iEnergyIncomeNeeded) then
                                --We have enough energy to support an air factory, check if we're relatively close to our base
                                if bDebugMessages == true then LOG(sFunctionRef..': Have enough energy, checking if we are close to base; Distance between ACU and base='..M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) end
                                if M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) <= 90 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Are close enough to base, checking if we have more land factories than we want and not enough air factories. Current land factories='..aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryLandFactory)..'; Current air factories='..aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryAirFactory)..'; Min land fac wanted='..aiBrain[M27Overseer.refiMinLandFactoryBeforeOtherTypes]..'; Max air fac wanted='..aiBrain[M27Overseer.reftiMaxFactoryByType][M27Overseer.refFactoryTypeAir]) end
                                    if aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryLandFactory) >= aiBrain[M27Overseer.refiMinLandFactoryBeforeOtherTypes] and aiBrain:GetCurrentUnits(M27UnitInfo.refCategoryAirFactory) < aiBrain[M27Overseer.reftiMaxFactoryByType][M27Overseer.refFactoryTypeAir] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try to build air factory instead') end
                                        iCategoryToBuild = M27UnitInfo.refCategoryAirFactory
                                        --Is hydro nearby? If so then only try to build by hydro
                                        if M27Conditions.HydroNearACUAndBase(aiBrain, false) then
                                            iCategoryToBuildBy = M27UnitInfo.refCategoryT2Power + M27UnitInfo.refCategoryT3Power + M27UnitInfo.refCategoryHydro
                                        else
                                            iCategoryToBuildBy = M27UnitInfo.refCategoryPower + M27UnitInfo.refCategoryHydro
                                        end
                                    end
                                end
                            end
                        end



                        local oNearbyUnderConstruction = M27EngineerOverseer.GetPartCompleteBuilding(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, 30)
                        if oNearbyUnderConstruction == nil then
                            local sEngineerActionRef
                            if M27Utilities.DoesCategoryContainCategory(M27UnitInfo.refCategoryAirFactory, iCategoryToBuild, false) then
                                sEngineerActionRef = M27EngineerOverseer.refActionBuildAirFactory
                            else
                                sEngineerActionRef = M27EngineerOverseer.refActionBuildLandFactory
                            end
                            bMoveNearTargetInstead, tExistingBuildLocation = ShouldACUMoveAndConsiderClearingEngis(aiBrain, oACU, sEngineerActionRef, tExistingBuildLocation)
                        end
                        if oNearbyUnderConstruction == nil and not(bMoveNearTargetInstead) then
                            --BuildStructureAtLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, tAlternativePositionToLookFrom)
                            local bLookForNearbyBuildings = false
                            if M27Utilities.DoesCategoryContainCategory(iCategoryToBuild, M27UnitInfo.refCategoryAirFactory) then
                                bLookForNearbyBuildings = true
                            end
                            if bDebugMessages == true then
                                LOG(sFunctionRef..': About to tell ACU to build land or air factory. iMaxAreaToSearch='..iMaxAreaToSearch..'; Is table of engineers assigned to build air factory empty='..tostring(M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionBuildAirFactory]))..'; will list out units that fall into iCategoryToBuildBy')
                                if M27Utilities.IsTableEmpty(EntityCategoryGetUnitList(iCategoryToBuildBy)) == false then
                                    for iBlueprint, sBlueprint in EntityCategoryGetUnitList(iCategoryToBuildBy) do
                                        LOG(sBlueprint)
                                    end
                                end
                            end
                            --BuildStructureAtLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForPartCompleteBuildings, bLookForQueuedBuildings, oUnitToBuildBy, bNeverBuildRandom, iOptionalCategoryForStructureToBuild)
                            iMaxAreaToSearch = math.max(math.min(10, iMaxAreaToSearch), iMaxAreaToSearch - 5)
                            oPlatoon[reftLastBuildLocation] = M27EngineerOverseer.BuildStructureAtLocation(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, nil, bLookForNearbyBuildings, bLookForNearbyBuildings, nil, nil, M27UnitInfo.refCategoryEngineer)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just told ACU to try and build factory with iMaxAreaToSearch='..iMaxAreaToSearch..'; oPlatoon[reftLastBuildLocation]='..repru(oPlatoon[reftLastBuildLocation])) end
                            if not(M27Utilities.IsTableEmpty(oPlatoon[reftLastBuildLocation])) then
                                oPlatoon[refiLastOrderType] = refiOrderIssueBuild
                                oPlatoon[reftLastOrderPosition] = {oPlatoon[reftLastBuildLocation][1], oPlatoon[reftLastBuildLocation][2], oPlatoon[reftLastBuildLocation][3]}
                                --Update engineer trackers so they can assist us, and clear existing trackers so we dont ahve engineers assisting us when theyre not meant to
                                M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, tBuilders[1], true)

                                --UpdateEngineerActionTrackers(aiBrain, oEngineer, iActionToAssign, tTargetLocation, bAreAssisting, iConditionNumber, oUnitToAssist, bDontClearExistingTrackers, oUnitToBeDestroyed)
                                if iCategoryToBuild == M27UnitInfo.refCategoryAirFactory then
                                    M27EngineerOverseer.UpdateEngineerActionTrackers(aiBrain, tBuilders[1], M27EngineerOverseer.refActionBuildAirFactory, oPlatoon[reftLastBuildLocation], false, nil, nil, false, nil, iCategoryToBuild)
                                else
                                    M27EngineerOverseer.UpdateEngineerActionTrackers(aiBrain, tBuilders[1], M27EngineerOverseer.refActionBuildLandFactory, oPlatoon[reftLastBuildLocation], false, nil, nil, false, nil, iCategoryToBuild)
                                end
                            else
                                M27Utilities.ErrorHandler('Coudlnt find a location to build a factory at', true)
                            end


                            --Move as soon as are done:
                            IssueMove(tBuilders, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                            oPlatoon[refiLastOrderType] = refiOrderIssueMove
                            oPlatoon[reftLastOrderPosition] = {oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][1], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][2], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][3]}
                        elseif bMoveNearTargetInstead then
                            IssueMove(tBuilders, M27Utilities.MoveInDirection(tExistingBuildLocation, M27Utilities.GetAngleFromAToB(tExistingBuildLocation, oACU:GetPosition()), 6, true, false))
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to move near the location that another engineer has queued up. tExistingBuildLocation='..repru(tExistingBuildLocation)) end
                        else
                            IssueGuard(tBuilders, oNearbyUnderConstruction)
                            oPlatoon[refiLastOrderType] = refiOrderIssueGuard
                            oPlatoon[reftLastOrderPosition] = oNearbyUnderConstruction:GetPosition()
                            if bDebugMessages == true then LOG(sFunctionRef..': Already under construction nearby so want to assist') end
                        end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionBuildInitialPower then
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..': BuildPower') end
                    if GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, true, true) > 0 then
                        local tBuilders = GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..' about to issue command to build power; bDontClearActions='..tostring(bDontClearActions)) end
                        if bDontClearActions == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(tBuilders)
                        end
                        local oACU = M27Utilities.GetACU(aiBrain)
                        local iCategoryToBuild = M27UnitInfo.refCategoryPower
                        --local iMaxAreaToSearch = 14
                        local iMaxAreaToSearch = 19 --ACU sizeX and Z is 1.2; T1 power is 0.6; ACU build range is 10, factory is 4.2; meanwhile T2 power skirt size is 2, and factory is 8; during testing, a factory could be 14.3 away from the ACU and can still built it without moving
                        --therefore if search range of 19, should bea ble to pick up any factories that we might be adjacent to
                        local iCategoryToBuildBy = M27UnitInfo.refCategoryLandFactory

                        --BuildStructureAtLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, tAlternativePositionToLookFrom)
                        --M27EngineerOverseer.BuildStructureAtLocation(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, nil)

                        local oNearbyUnderConstruction = M27EngineerOverseer.GetPartCompleteBuilding(aiBrain, oACU, iCategoryToBuild + M27UnitInfo.refCategoryHydro, iMaxAreaToSearch, 30)
                        if oNearbyUnderConstruction == nil then
                            --BuildStructureAtLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, tAlternativePositionToLookFrom)
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build power') end
                            oPlatoon[reftLastBuildLocation] = M27EngineerOverseer.BuildStructureAtLocation(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, nil)
                            if M27Utilities.IsTableEmpty(oPlatoon[reftLastBuildLocation]) then M27Utilities.ErrorHandler('Couldnt find location to build power at', true)
                            else
                                oPlatoon[refiLastOrderType] = refiOrderIssueBuild
                                oPlatoon[reftLastOrderPosition] = {oPlatoon[reftLastBuildLocation][1], oPlatoon[reftLastBuildLocation][2], oPlatoon[reftLastBuildLocation][3]}
                            end
                            --Update engineer trackers so they can assist us
                            --UpdateEngineerActionTrackers(aiBrain, oEngineer, iActionToAssign, tTargetLocation, bAreAssisting, iConditionNumber, oUnitToAssist, bDontClearExistingTrackers, oUnitToBeDestroyed, iPrimaryEngineerCategoryBuilt)
                            M27EngineerOverseer.UpdateEngineerActionTrackers(aiBrain, oACU, M27EngineerOverseer.refActionBuildPower, oPlatoon[reftLastBuildLocation], false, nil, nil, false, nil, iCategoryToBuild)
                            --Move as soon as are done:
                            IssueMove(tBuilders, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                            oPlatoon[refiLastOrderType] = refiOrderIssueMove
                            oPlatoon[reftLastOrderPosition] = {oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][1], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][2], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][3]}
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to assist part-complete power') end
                            IssueGuard(tBuilders, oNearbyUnderConstruction)
                            oPlatoon[refiLastOrderType] = refiOrderIssueGuard
                            oPlatoon[reftLastOrderPosition] = oNearbyUnderConstruction:GetPosition()
                            --UpdateEngineerActionTrackers(aiBrain, oEngineer, iActionToAssign, tTargetLocation, bAreAssisting, iConditionNumber, oUnitToAssist, bDontClearExistingTrackers)
                            M27EngineerOverseer.UpdateEngineerActionTrackers(aiBrain, oACU, M27EngineerOverseer.refActionBuildPower, oPlatoon[reftLastBuildLocation], false, nil, nil, false)
                        end

                        --Move as soon as are done:
                        IssueMove(tBuilders, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                        oPlatoon[refiLastOrderType] = refiOrderIssueMove
                        oPlatoon[reftLastOrderPosition] = {oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][1], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][2], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][3]}
                    end
                elseif oPlatoon[refiCurrentAction] == refActionBuildStructure then
                    if bDebugMessages == true then LOG(sFunctionRef..': Action is to build structure, builders in platoon='..GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, true, true)) end
                    if GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, true, true) > 0 then
                        local tBuilders = GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, false, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..' about to issue command to build power; bDontClearActions='..tostring(bDontClearActions)) end
                        if bDontClearActions == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(tBuilders)
                        end
                        local oACU = M27Utilities.GetACU(aiBrain)
                        local iCategoryToBuild = oPlatoon[refiStructureCategoryToBuild]
                        --local iMaxAreaToSearch = 14
                        local iMaxAreaToSearch = 10 --ACU sizeX and Z is 1.2; T1 power is 0.6; ACU build range is 10, factory is 4.2; meanwhile T2 power skirt size is 2, and factory is 8; during testing, a factory could be 14.3 away from the ACU and can still built it without moving
                        --therefore if search range of 19, should bea ble to pick up any factories that we might be adjacent to
                        local iCategoryToBuildBy = nil

                        --BuildStructureAtLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, tAlternativePositionToLookFrom)
                        --M27EngineerOverseer.BuildStructureAtLocation(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, nil)

                        local oNearbyUnderConstruction = M27EngineerOverseer.GetPartCompleteBuilding(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, 30)
                        if oNearbyUnderConstruction == nil then
                            --BuildStructureAtLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, tAlternativePositionToLookFrom)
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build structure; will list out every valid blueprint of the category to build')
                                for iBlueprint, sBlueprint in EntityCategoryGetUnitList(iCategoryToBuild) do
                                    LOG(sBlueprint)
                                end
                            end
                            oPlatoon[reftLastBuildLocation] = M27EngineerOverseer.BuildStructureAtLocation(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iCategoryToBuildBy, oPlatoon[reftStructureLocationToBuild])
                            if M27Utilities.IsTableEmpty(oPlatoon[reftLastBuildLocation]) then
                                M27Utilities.ErrorHandler('Couldnt find location to build power at', true)
                            else
                                oPlatoon[refiLastOrderType] = refiOrderIssueBuild
                                oPlatoon[reftLastOrderPosition] = {oPlatoon[reftLastBuildLocation][1], oPlatoon[reftLastBuildLocation][2], oPlatoon[reftLastBuildLocation][3]}
                            end
                            --Update engineer trackers so they can assist us
                            --UpdateEngineerActionTrackers(aiBrain, oEngineer, iActionToAssign, tTargetLocation, bAreAssisting, iConditionNumber, oUnitToAssist, bDontClearExistingTrackers, oUnitToBeDestroyed, iPrimaryEngineerCategoryBuilt)
                            M27EngineerOverseer.UpdateEngineerActionTrackers(aiBrain, oACU, M27EngineerOverseer.refActionBuildPower, oPlatoon[reftLastBuildLocation], false, nil, nil, false, nil, iCategoryToBuild)
                            --Move as soon as are done:
                            IssueMove(tBuilders, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                            oPlatoon[refiLastOrderType] = refiOrderIssueMove
                            oPlatoon[reftLastOrderPosition] = {oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][1], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][2], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][3]}
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to assist part-complete structure') end
                            IssueGuard(tBuilders, oNearbyUnderConstruction)
                            oPlatoon[refiLastOrderType] = refiOrderIssueGuard
                            oPlatoon[reftLastOrderPosition] = oNearbyUnderConstruction:GetPosition()
                            --UpdateEngineerActionTrackers(aiBrain, oEngineer, iActionToAssign, tTargetLocation, bAreAssisting, iConditionNumber, oUnitToAssist, bDontClearExistingTrackers)
                            M27EngineerOverseer.UpdateEngineerActionTrackers(aiBrain, oACU, M27EngineerOverseer.refActionBuildPower, oPlatoon[reftLastBuildLocation], false, nil, nil, false)
                        end

                        --Move as soon as are done:
                        IssueMove(tBuilders, oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]])
                        oPlatoon[refiLastOrderType] = refiOrderIssueMove
                        oPlatoon[reftLastOrderPosition] = {oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][1], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][2], oPlatoon[reftMovementPath][oPlatoon[refiCurrentPathTarget]][3]}
                    end

                elseif oPlatoon[refiCurrentAction] == refActionAssistConstruction then
                    --shoudl have already determined the unit/building to assist previously
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..':ActionAssistConstruction') end
                    if GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, true, true) > 0 then
                        local tBuilders = GetPlatoonUnitsOrUnitCount(oPlatoon, reftBuilders, false, true)
                        if bDontClearActions == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(tBuilders)
                        end
                        --Is it in our build range?
                        local iBuildDistance = 5
                        local tBuildingPosition = oPlatoon[refoConstructionToAssist]:GetPosition()
                        if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonName..': about to assign construction target to assist') end
                        for _, oBuilder in tBuilders do
                            if not(oBuilder.Dead) then
                                iBuildDistance = oBuilder:GetBlueprint().Economy.MaxBuildDistance
                                if M27Utilities.GetDistanceBetweenPositions(tBuildingPosition, oBuilder:GetPosition()) > iBuildDistance then
                                    --Move to location
                                    if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonName..': Are too far away, will move closer before assisting') end
                                    if oPlatoon[refiOverrideDistanceToReachDestination] == nil and oPlatoon[refoFrontUnit].GetBlueprint and EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oPlatoon[refoFrontUnit].UnitId) then
                                        oPlatoon[refiOverrideDistanceToReachDestination] = math.max((oPlatoon[refoFrontUnit]:GetBlueprint().SizeX or 0), (oPlatoon[refoFrontUnit]:GetBlueprint().SizeZ or 0)) + 3 --(redundancy as set when platoon first created if there are builders in it)
                                    end
                                    MoveNearConstruction(aiBrain, oBuilder, tBuildingPosition, oPlatoon[refoConstructionToAssist].UnitId, -(oPlatoon[refiOverrideDistanceToReachDestination] or 3) - 1, false)
                                end
                                if EntityCategoryContains(M27UnitInfo.refCategoryStructure + categories.EXPERIMENTAL, oPlatoon[refoConstructionToAssist].UnitId) and oPlatoon[refoConstructionToAssist]:GetFractionComplete() < 1 then
                                    IssueRepair({oBuilder}, oPlatoon[refoConstructionToAssist])
                                    oPlatoon[refiLastOrderType] = refiOrderIssueRepair
                                    oPlatoon[reftLastOrderPosition] = oPlatoon[refoConstructionToAssist]:GetPosition()
                                else
                                    IssueGuard({oBuilder}, oPlatoon[refoConstructionToAssist])
                                    oPlatoon[refiLastOrderType] = refiOrderIssueGuard
                                    oPlatoon[reftLastOrderPosition] = oPlatoon[refoConstructionToAssist]:GetPosition()
                                end
                                --IssueGuard({oBuilder}, oPlatoon[refoConstructionToAssist])
                                if bDebugMessages == true then LOG(sFunctionRef..':'..sPlatoonName..': Issued guard order to assist') end
                            end
                        end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionMoveJustWithinRangeOfNearestPD then
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..':ActionMoveNearPD') end
                    if iCurrentUnits > 0 then
                        if bDontClearActions == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                        end
                        --Locate nearest PD:
                        if oPlatoon[refiEnemyStructuresInRange] > 0 then
                            local tNearbyPD = EntityCategoryFilterDown(categories.DIRECTFIRE, oPlatoon[reftEnemyStructuresInRange])
                            if M27Utilities.IsTableEmpty(tNearbyPD) == false then
                                local oNearestPD = M27Utilities.GetNearestUnit(tNearbyPD, GetPlatoonFrontPosition(oPlatoon), aiBrain, true)
                                if oPlatoon[refiPlatoonMaxRange] > 0 then
                                    --GetPositionNearTargetInSamePathingGroup(tStartPos, tTargetPos, iDistanceWantedFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions)
                                    local iDistanceFromPDWanted = oPlatoon[refiPlatoonMaxRange] - math.ceil(oPlatoon[refiCurrentUnits] / 4) - 1
                                    if iDistanceFromPDWanted < 0 then iDistanceFromPDWanted = 0 end
                                    --local tMoveTarget = GetPositionNearTargetInSamePathingGroup(GetPlatoonFrontPosition(oPlatoon), oNearestPD:GetPosition(), iDistanceFromPDWanted, 0, GetPathingUnit(oPlatoon), 1, true)
                                    local tMoveTarget = GetPositionAtOrNearTargetInPathingGroup(GetPlatoonFrontPosition(oPlatoon), oNearestPD:GetPosition(), iDistanceFromPDWanted, 0, GetPathingUnit(oPlatoon), true, true, 1)
                                    if tMoveTarget then
                                        --Is this target the same as our current positoin and we aren't in range of the PD?
                                        if bDebugMessages == true then LOG(sFunctionRef..': Our position='..repru(GetPlatoonFrontPosition(oPlatoon))..'; Nearest PD='..repru(oNearestPD:GetPosition())..'; iDistanceFromPDWanted='..iDistanceFromPDWanted..'; Platoon range='..oPlatoon[refiPlatoonMaxRange]..'; Dist from cur move target to PD='..M27Utilities.GetDistanceBetweenPositions(tMoveTarget, oNearestPD:GetPosition())) end
                                        if M27Utilities.GetDistanceBetweenPositions(tMoveTarget, oNearestPD:GetPosition()) > oPlatoon[refiPlatoonMaxRange] then
                                            tMoveTarget = oNearestPD:GetPosition()
                                            if bDebugMessages == true then LOG(sFunctionRef..': Replacing target with the PD as the target wouldnt have got us in range of the PD') end
                                        end
                                        if bDebugMessages == true then LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': Move target for enemy PD='..repru(tMoveTarget)) end
                                        PlatoonMove(oPlatoon, tMoveTarget)
                                    else
                                        --Have a nearby enemy PD but can't move within range of it - resume normal move path (but dont clear actions)
                                        ReissueMovementPath(oPlatoon, true)
                                    end
                                else
                                    LOG(sFunctionRef..':'..sPlatoonName..oPlatoon[refiPlatoonCount]..': Likely error - sent action to move within range of nearest PD, but platoon has no max range')
                                end
                            else
                                LOG(sFunctionRef..':'..sPlatoonName..oPlatoon[refiPlatoonCount]..': Likely error - sent action to move within range of nearest PD, and no nearby structures found')
                            end
                        else
                            LOG(sFunctionRef..':'..sPlatoonName..oPlatoon[refiPlatoonCount]..': Likely error - sent action to move within range of nearest PD, and no nearby structures found')
                        end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionMoveToTemporaryLocation then
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..':ActionTempMove') end
                    if iCurrentUnits > 0 then
                        if bDontClearActions == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                        end
                        if M27Utilities.IsTableEmpty(oPlatoon[reftTemporaryMoveTarget]) == true then
                            M27Utilities.ErrorHandler('Temporary move target is blank, will send log with platoon details if theyre not blank')
                            if oPlatoon.GetPlan and oPlatoon:GetPlan() and oPlatoon[refiPlatoonCount] and oPlatoon[refiCurrentUnits] then LOG('Platoon plan, count and current units='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'; units='..oPlatoon[refiCurrentUnits])
                            else LOG('Platoon core values contained a nil value') end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': Temporary move target='..repru(oPlatoon[reftTemporaryMoveTarget])) end
                            PlatoonMove(oPlatoon, oPlatoon[reftTemporaryMoveTarget])
                            MoveAlongPath(oPlatoon, oPlatoon[reftMovementPath], oPlatoon[refiCurrentPathTarget], true)
                        end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionAttackSpecificUnit then
                    --if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..':ActionSpecificUnitAttack') end
                    if oPlatoon[refoTemporaryAttackTarget] == nil then M27Utilities.ErrorHandler('Temporary attack target is nil')
                    else
                        if iCurrentUnits > 0 then
                            if bDontClearActions == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                                M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                            end
                            if not(M27UnitInfo.IsUnitValid(oPlatoon[refoTemporaryAttackTarget])) then
                                M27Utilities.ErrorHandler('Dont have a valid temporary attack target. reprs will go in log if first time')
                                if not(oPlatoon['M27TempTargetError']) then oPlatoon['M27TempTargetError'] = true LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': reprs='..reprs(oPlatoon[refoTemporaryAttackTarget])) end
                            else
                                IssueAttack(tCurrentUnits, oPlatoon[refoTemporaryAttackTarget])
                                oPlatoon[refiLastOrderType] = refiOrderIssueAttack
                                oPlatoon[reftLastOrderPosition] = oPlatoon[refoTemporaryAttackTarget]:GetPosition()
                            end
                        end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionCoordinatedAttack then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to process coordinated attack at time '..GetGameTimeSeconds()..' for platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..' with current units='..oPlatoon[refiCurrentUnits]) end


                    --Will treat all current units as DF units for the unlikely scenario where this gets used for indirect fire units; sniperbots are both indirect and direct fire so cant just give orders to indirectfire units
                    local tDFUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftCurrentUnits, false, true)
                    local tbAreUnitsUnassigned = {}
                    for iUnit, oUnit in tDFUnits do
                        tbAreUnitsUnassigned[iUnit] = true
                    end

                    if M27Utilities.IsTableEmpty(tDFUnits) == false then
                        oPlatoon[refiLastOrderType] = refiOrderIssueAttack --Some will be aggressive move instead of attack
                        if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] == 0 then
                            M27Utilities.ErrorHandler('No enemies within range so will just do an attack-move to our movement path')
                        else
                            --Get potential units to target
                            local tTargetData = {}
                            local subrefCoordinationUnit = 'PlatUtilCoordinationUnit'
                            local subrefCoordinationDamageWanted = 'PlatUtilCoordinationDamageWanted'
                            local iUnitsWithoutEnoughDamageCount = 0


                            local tFrontPosition = GetPlatoonFrontPosition(oPlatoon)

                            function ConsiderUnitsAsTarget(tUnits)
                                local iCurShield, iMaxShield, iCurHealth, iMaxHealth, iDamageWanted
                                for iUnit, oUnit in tUnits do
                                    if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tFrontPosition) <= oPlatoon[refiPlatoonMaxRange] then
                                        iCurShield, iMaxShield = M27UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                                        iCurHealth = oUnit:GetHealth()
                                        iMaxHealth = oUnit:GetMaxHealth()
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..': strike damage assigned pre refresh='..(oUnit[M27UnitInfo.refiDFStrikeDamageAssigned] or 'nil')) end
                                        if oUnit[M27UnitInfo.refiDFStrikeDamageAssigned] > 0 then
                                            M27UnitInfo.RefreshUnitDFStrikeDamage(oUnit)
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..': strike damage assigned post refresh='..(oUnit[M27UnitInfo.refiDFStrikeDamageAssigned] or 'nil')) end
                                        iDamageWanted = math.min((iCurHealth + iCurShield) * 1.1, (iMaxShield + iMaxHealth))
                                        if (oUnit[M27UnitInfo.refiDFStrikeDamageAssigned] or 0) < iDamageWanted then
                                            iUnitsWithoutEnoughDamageCount = iUnitsWithoutEnoughDamageCount + 1
                                            tTargetData[iUnitsWithoutEnoughDamageCount] = {}
                                            tTargetData[iUnitsWithoutEnoughDamageCount][subrefCoordinationUnit] = oUnit
                                            tTargetData[iUnitsWithoutEnoughDamageCount][subrefCoordinationDamageWanted] = iDamageWanted - (oUnit[M27UnitInfo.refiDFStrikeDamageAssigned] or 0)
                                        end
                                    end
                                end
                            end






                            if oPlatoon[refiEnemiesInRange] > 0 then
                                ConsiderUnitsAsTarget(oPlatoon[reftEnemiesInRange])
                            elseif oPlatoon[refiEnemyStructuresInRange] > 0 then --Dont want to target structures unless no mobile enemies, since structures cant follow us
                                ConsiderUnitsAsTarget(oPlatoon[reftEnemyStructuresInRange])
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Finished considering units to add to the target data. Is table of target data empty='..tostring(M27Utilities.IsTableEmpty(tTargetData))..'; iUnitsWithoutEnoughDamageCount='..iUnitsWithoutEnoughDamageCount) end

                            if M27Utilities.IsTableEmpty(tTargetData) == false and iUnitsWithoutEnoughDamageCount > 0 then
                                --Assign to each of our units - cycle through each of our units, get a table of units that we can hit, and pick the best one
                                local oBestTarget
                                local iShotValue
                                local iCurStrikeDamage
                                local iBestValueFound
                                local iBestTargetRef
                                for iUnit, oUnit in tDFUnits do
                                    oBestTarget = nil
                                    iBestValueFound = 0
                                    if bDebugMessages == true then LOG(sFunctionRef..' Considering best target for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; is unit valid='..tostring(M27UnitInfo.IsUnitValid(oUnit))) end
                                    iCurStrikeDamage = M27UnitInfo.GetUnitStrikeDamage(oUnit)

                                    --Get the best target for this unit - only consider units within its range

                                    for iTable, tTable in tTargetData do
                                        if bDebugMessages == true then LOG(sFunctionRef..': tTableUnit='..tTable[subrefCoordinationUnit].UnitId..M27UnitInfo.GetUnitLifetimeCount(tTable[subrefCoordinationUnit])..'; Distance between it and us='..M27Utilities.GetDistanceBetweenPositions(tTable[subrefCoordinationUnit]:GetPosition(), oUnit:GetPosition())..'; oPlatoon[refiPlatoonMaxRange]='..oPlatoon[refiPlatoonMaxRange]..'; tTable[subrefCoordinationDamageWanted]='..tTable[subrefCoordinationDamageWanted]..'; iCurStrikeDamage='..iCurStrikeDamage) end
                                        if M27Utilities.GetDistanceBetweenPositions(tTable[subrefCoordinationUnit]:GetPosition(), oUnit:GetPosition()) <= oPlatoon[refiPlatoonMaxRange] then
                                            --Can consider the target
                                            if tTable[subrefCoordinationDamageWanted] <= iCurStrikeDamage then
                                                iShotValue = tTable[subrefCoordinationUnit]:GetBlueprint().Economy.BuildCostMass
                                            else
                                                iShotValue = iCurStrikeDamage / tTable[subrefCoordinationDamageWanted] * 0.5 * tTable[subrefCoordinationUnit]:GetBlueprint().Economy.BuildCostMass
                                            end
                                            if iShotValue > iBestValueFound then
                                                oBestTarget = tTable[subrefCoordinationUnit]
                                                iBestTargetRef = iTable
                                            end
                                        end
                                    end



                                    if oBestTarget then
                                        if bDontClearActions == false then
                                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                                            M27Utilities.IssueTrackedClearCommands({ oUnit })
                                        end

                                        IssueAttack({oUnit}, oBestTarget)
                                        M27UnitInfo.AssignUnitDFStrikeDamage(oUnit, oBestTarget, iCurStrikeDamage)
                                        tTargetData[iBestTargetRef][subrefCoordinationDamageWanted] = tTargetData[iBestTargetRef][subrefCoordinationDamageWanted] - iCurStrikeDamage
                                        if tTargetData[iBestTargetRef][subrefCoordinationDamageWanted] <= 0 then
                                            tTargetData[iBestTargetRef] = nil
                                        end

                                        tbAreUnitsUnassigned[iUnit] = false
                                        if bDebugMessages == true then LOG(sFunctionRef..': oBestTarget for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' is '..oBestTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oBestTarget)..'; strike damage assigned to oBestTarget now='..oBestTarget[M27UnitInfo.refiDFStrikeDamageAssigned]) end
                                        oPlatoon[reftLastOrderPosition] = oBestTarget:GetPosition()
                                    end
                                end

                            end


                            --For any units with no targets, do attack-move
                            local tUnassignedUnits = {}
                            for iUnit, oUnit in tDFUnits do
                                if tbAreUnitsUnassigned[iUnit] then
                                    table.insert(tUnassignedUnits, oUnit)
                                end
                            end
                            IssueAggressiveMove(tUnassignedUnits, GetPlatoonFrontPosition(oPlatoon))
                        end
                    else
                        M27Utilities.ErrorHandler('Were expecting to have DF units, platoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount])
                    end
                    --Issue attack-move to any remaining units
                    if M27Utilities.IsTableEmpty(tDFUnits) then
                        if bDontClearActions == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                            M27Utilities.IssueTrackedClearCommands(tDFUnits)
                        end
                        IssueAggressiveMove(tDFUnits, GetPlatoonFrontPosition(oPlatoon))
                    end



                elseif oPlatoon[refiCurrentAction] == refActionUpgrade then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to try and process action to upgrade') end
                    if not(oPlatoon[refbACUInPlatoon]) then M27Utilities.ErrorHandler('Dont have code to handle non-ACU upgrades yet')
                    else
                        local oACU = M27Utilities.GetACU(aiBrain)
                        if not(oACU:IsUnitState('Upgrading')) and not(oACU[M27UnitInfo.refbSpecialMicroActive]) then
                            --Get a new upgrade
                            local sUpgrade = GetACUUpgradeWanted(aiBrain, oACU)
                            if sUpgrade then
                                if bDontClearActions == false then
                                    if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                                    M27Utilities.IssueTrackedClearCommands(oPlatoon[reftCurrentUnits])
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to upgrade using sUpgrade='..sUpgrade) end

                                --Check for conflicting upgrades - for now just done manually
                                if sUpgrade == 'BlastAttack' and oACU:HasEnhancement('AdvancedEngineering') then
                                    IssueScript({oACU}, {TaskName = 'EnhanceTask', Enhancement = 'AdvancedEngineeringRemove'})
                                    oACU[M27UnitInfo.refbRecentlyRemovedHealthUpgrade] = true
                                    M27Utilities.DelayChangeVariable(oACU, M27UnitInfo.refbRecentlyRemovedHealthUpgrade, false, 11)
                                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                                    WaitTicks(1)
                                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                                end
                                IssueScript({oACU}, {TaskName = 'EnhanceTask', Enhancement = sUpgrade})
                                oACU[M27UnitInfo.refsUpgradeRef] = sUpgrade
                                --IssueUpgrade({oACU}, sUpgrade)
                                if bDebugMessages == true then LOG(sFunctionRef..'ACU state after sending issueupgrade='..M27Logic.GetUnitState(oACU)) end

                                --Add the ACU's current position as its destination, so once it finishes the upgrade it iwll get a new one; also clear the flag for if its previously run as a redundancy for if it doesnt trigger reaching its destination after finishing its upgrade
                                oPlatoon[reftMovementPath] = {}
                                oPlatoon[reftMovementPath][1] = oACU:GetPosition()
                                oPlatoon[refiCurrentPathTarget] = 1
                                oPlatoon[refbHavePreviouslyRun] = false
                            elseif bDebugMessages == true then LOG(sFunctionRef..': sUpgrade is nil')
                            end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': Unit state is upgrading or special micro is active')
                        end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionKillACU then

                    if bDebugMessages == true then LOG(sFunctionRef..': About to send orders to attack enemy ACU') end
                    if bDontClearActions == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                        M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                    end
                    local tDFUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftDFUnits, false, true)
                    local iDistanceWithinAttackRange = 11
                    local iDistanceBehindACUWanted = 2
                    local iOffsetToNotBlockACUDistance = 5
                    local iDistanceFromACUForUnitMicro = 40 --If platoon front unit is this close to ACU then will do micro on a unit by unit basis
                    local bPerUnitMicro = false
                    local bEnemyACUUnderwater = M27UnitInfo.IsUnitUnderwater(aiBrain[M27Overseer.refoACUKillTarget])
                    if bEnemyACUUnderwater then iDistanceBehindACUWanted = aiBrain[M27Overseer.refoACUKillTarget]:GetBlueprint().Economy.MaxBuildDistance or 10 end

                    --Pick a location that means we're less likely to block the ACU if its in the attack
                    --ACU direction from our base
                    if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftACUKillTarget]) then
                        M27Utilities.ErrorHandler('Dont have ACU kill target set, will try setting to enemy ACU position')
                        if M27UnitInfo.IsUnitValid( aiBrain[M27Overseer.refoACUKillTarget]) then
                            aiBrain[M27Overseer.reftACUKillTarget] = aiBrain[M27Overseer.refoACUKillTarget]:GetPosition()
                        elseif M27UnitInfo.IsUnitValid(aiBrain[M27Overseer.refoLastNearestACU]) then
                            aiBrain[M27Overseer.reftACUKillTarget] = aiBrain[M27Overseer.refoLastNearestACU]:GetPosition()
                        else
                            LOG('Dont have ACU kill target or valid lastnearestACU, will get a lua error')
                        end
                    end
                    local iACULikelyFleeAngle = M27Utilities.GetAngleFromAToB((aiBrain[M27Overseer.reftACUKillTarget] or aiBrain[M27Overseer.refoACUKillTarget]:GetPosition()), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                    local tPositionBehindEnemyACU = M27Utilities.MoveInDirection(aiBrain[M27Overseer.reftACUKillTarget], iACULikelyFleeAngle, iDistanceBehindACUWanted)
                    local tTargetMoveLocation
                    local iOurACUAngleToTarget
                    local tACUPos = M27Utilities.GetACU(aiBrain):GetPosition()
                    local iACUDistanceToTarget = M27Utilities.GetDistanceBetweenPositions(tACUPos, aiBrain[M27Overseer.reftACUKillTarget])
                    if aiBrain[M27Overseer.refbIncludeACUInAllOutAttack] and not(oPlatoon[refbACUInPlatoon]) then
                        if M27Utilities.IsTableEmpty(tDFUnits) == false and M27Utilities.GetDistanceBetweenPositions(tACUPos, GetPlatoonFrontPosition(oPlatoon)) <= iDistanceFromACUForUnitMicro then
                            bPerUnitMicro = true
                        end
                    else
                        bPerUnitMicro = true
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': bPerUnitMicro='..tostring(bPerUnitMicro)..'; M27Utilities.IsTableEmpty(tDFUnits)='..tostring(M27Utilities.IsTableEmpty(tDFUnits))..'; aiBrain[M27Overseer.refbIncludeACUInAllOutAttack]='..tostring(aiBrain[M27Overseer.refbIncludeACUInAllOutAttack])..'; M27Utilities.GetDistanceBetweenPositions(tACUPos, GetPlatoonFrontPosition(oPlatoon))='..M27Utilities.GetDistanceBetweenPositions(tACUPos, GetPlatoonFrontPosition(oPlatoon))) end

                    local tIndirectUnits = GetPlatoonUnitsOrUnitCount(oPlatoon, reftIndirectUnits, false, true)
                    if bDebugMessages == true then LOG(sFunctionRef..'; Ignoring micro, iCurrentUnits='..oPlatoon[refiCurrentUnits]..'; DF units='..oPlatoon[refiDFUnits]..'; Indirect units='..oPlatoon[refiIndirectUnits]) end

                    if tDFUnits and table.getn(tDFUnits) > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have DF units in platoon, action will depend on where they are.  Will set their targeting category to prioritise the enemy ACU') end
                        oPlatoon[reftPlatoonDFTargettingCategories] = M27UnitInfo.refWeaponPriorityACU

                        if not(oPlatoon[refbACUInPlatoon]) then iOurACUAngleToTarget = M27Utilities.GetAngleFromAToB(tACUPos, tPositionBehindEnemyACU) end
                        if bPerUnitMicro == true then
                            if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Have per unit micro present, tDFUnits='..table.getn(tDFUnits)..'; oPlatoon[refbACUInPlatoon]='..tostring(oPlatoon[refbACUInPlatoon])..'; aiBrain[M27Overseer.refbIncludeACUInAllOutAttack]='..tostring(aiBrain[M27Overseer.refbIncludeACUInAllOutAttack])) end
                            for iDFUnit, oDFUnit in tDFUnits do
                                if M27UnitInfo.IsUnitValid(oDFUnit) then
                                    --Dont wait for the normal logic on weapon targeting to trigger
                                    if EntityCategoryContains(M27UnitInfo.refCategoryShieldDisruptor, oDFUnit.UnitId) then
                                        M27UnitInfo.SetUnitTargetPriorities(oDFUnit, M27UnitInfo.refWeaponPriorityShieldDisruptor)
                                    elseif EntityCategoryContains(M27UnitInfo.refCategorySniperBot, oDFUnit.UnitId) then
                                        M27UnitInfo.SetUnitTargetPriorities(oDFUnit, M27UnitInfo.refWeaponPrioritySniperBot)
                                    else
                                        M27UnitInfo.SetUnitTargetPriorities(oDFUnit, oPlatoon[reftPlatoonDFTargettingCategories])
                                    end
                                    --Are we further from target than our ACU and our ACU is in the attack?
                                    if bDebugMessages == true then LOG(sFunctionRef..': oDFUnit='..oDFUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oDFUnit)..'; Position to enemy ACU='..M27Utilities.GetDistanceBetweenPositions(oDFUnit:GetPosition(), aiBrain[M27Overseer.reftACUKillTarget])..'; iACUDistanceToTarget='..iACUDistanceToTarget..'; iOffsetToNotBlockACUDistance='..iOffsetToNotBlockACUDistance) end
                                    --Check if we're further away from target than ACU (ignore if within a bit of ACU distance to avoid us dobuling back)
                                    if aiBrain[M27Overseer.refbIncludeACUInAllOutAttack] and not(oPlatoon[refbACUInPlatoon]) then
                                        local iDFDistToTarget = M27Utilities.GetDistanceBetweenPositions(oDFUnit:GetPosition(), aiBrain[M27Overseer.reftACUKillTarget])
                                        if (iDFDistToTarget - iOffsetToNotBlockACUDistance * 0.6 + 1) >=  iACUDistanceToTarget or (iDFDistToTarget > iACUDistanceToTarget and M27Utilities.GetDistanceBetweenPositions(tACUPos, oDFUnit:GetPosition()) <= 2) then
                                            --We're further away than ACU so take detour
                                            if bDebugMessages == true then LOG(sFunctionRef..': tACUPos before getting position to side of target='..repru(tACUPos)) end
                                            local tPositionToSide = M27Logic.GetPositionToSideOfTarget(oDFUnit, tACUPos, iOurACUAngleToTarget, iOffsetToNotBlockACUDistance)
                                            IssueMove({oDFUnit}, tPositionToSide)
                                            oPlatoon[refiLastOrderType] = refiOrderIssueMove
                                            oPlatoon[reftLastOrderPosition] = tPositionToSide
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to detour by ACU; Details after getting position to side of targeet: Our position='..repru(oDFUnit:GetPosition())..'; ACU pos='..repru(tACUPos)..'; Detour='..repru(M27Logic.GetPositionToSideOfTarget(oDFUnit, tACUPos, iOurACUAngleToTarget, iOffsetToNotBlockACUDistance))..'; Angle from us to ACU='..M27Utilities.GetAngleFromAToB(oDFUnit:GetPosition(), tACUPos)..'; iOurACUAngleToTarget='..iOurACUAngleToTarget) end
                                        end

                                    end
                                    --Check how close we are to the target (are doing per unit micro so consider each unit range individually)
                                    local iPlatoonRange = M27Logic.GetUnitMaxGroundRange({ oDFUnit})
                                    local iDistToTarget = M27Utilities.GetDistanceBetweenPositions(oDFUnit:GetPosition(), aiBrain[M27Overseer.reftACUKillTarget])
                                    if iDistToTarget < iPlatoonRange - iDistanceWithinAttackRange then
                                        if M27UnitInfo.IsUnitValid(aiBrain[M27Overseer.refoACUKillTarget]) and M27Utilities.CanSeeUnit(aiBrain, aiBrain[M27Overseer.refoACUKillTarget], true) then
                                            if bEnemyACUUnderwater and not(EntityCategoryContains(categories.ANTINAVY + categories.OVERLAYANTINAVY, oDFUnit.UnitId)) then
                                                oPlatoon[refiLastOrderType] = refiOrderIssueAggressiveMove
                                                oPlatoon[reftLastOrderPosition] = tPositionBehindEnemyACU
                                                IssueAggressiveMove({oDFUnit}, tPositionBehindEnemyACU)

                                                if bDebugMessages == true then LOG(sFunctionRef..': ACU underwater so sending attack move order to unit '..oDFUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oDFUnit)..' to go to '..repru(tPositionBehindEnemyACU)..'; Dist from unit cur position='..M27Utilities.GetDistanceBetweenPositions(tPositionBehindEnemyACU, oDFUnit:GetPosition())) end
                                            else
                                                if bDebugMessages == true then LOG(sFunctionRef..': Sending order to attack the ACU to unit '..oDFUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oDFUnit)) end
                                                IssueAttack({oDFUnit}, aiBrain[M27Overseer.refoACUKillTarget])
                                                oPlatoon[refiLastOrderType] = refiOrderIssueAttack
                                                oPlatoon[reftLastOrderPosition] = aiBrain[M27Overseer.refoACUKillTarget]:GetPosition()
                                            end
                                        else
                                            if bDebugMessages == true then LOG(sFunctionRef..': Cant see enemy ACU so will move to its last known position instead. bEnemyACUUnderwater='..tostring(bEnemyACUUnderwater)) end
                                            if bEnemyACUUnderwater then
                                                IssueMove({oDFUnit}, tPositionBehindEnemyACU)
                                                oPlatoon[reftLastOrderPosition] = tPositionBehindEnemyACU
                                            else
                                                IssueMove({oDFUnit}, aiBrain[M27Overseer.reftACUKillTarget])
                                                oPlatoon[reftLastOrderPosition] = aiBrain[M27Overseer.reftACUKillTarget]
                                            end
                                            oPlatoon[refiLastOrderType] = refiOrderIssueMove
                                        end
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': iDistToTarget='..iDistToTarget..'; iPlatoonRange='..iPlatoonRange..'; iDistanceWithinAttackRange='..iDistanceWithinAttackRange..'; will try to move to side of target unless we are the ACU in which case will try and move behind the ACU') end
                                        --Revise move position to be away from target unless we are the ACU
                                        if oPlatoon[refbACUInPlatoon] == false then
                                            tTargetMoveLocation = M27Logic.GetPositionToSideOfTarget(oDFUnit, tPositionBehindEnemyACU, iOurACUAngleToTarget, iOffsetToNotBlockACUDistance)
                                        else
                                            --ACU move location
                                            tTargetMoveLocation = tPositionBehindEnemyACU
                                        end
                                        IssueMove({oDFUnit}, tTargetMoveLocation)
                                        oPlatoon[refiLastOrderType] = refiOrderIssueMove
                                        oPlatoon[reftLastOrderPosition] = tTargetMoveLocation
                                    end
                                end
                            end
                        else
                            if oPlatoon[refbACUInPlatoon] then M27UnitInfo.SetUnitTargetPriorities(M27Utilities.GetACU(aiBrain), oPlatoon[reftPlatoonDFTargettingCategories]) end
                            if bDebugMessages == true then LOG(sFunctionRef..': No per unit micro for DF units so can apply logic to all DF units') end
                            --Apply logic based on entire platoon
                            local iPlatoonRange = M27Logic.GetUnitMaxGroundRange(tDFUnits)
                            local iDistToTarget = M27Utilities.GetDistanceBetweenPositions(GetPlatoonFrontPosition(oPlatoon), aiBrain[M27Overseer.reftACUKillTarget])
                            if iDistToTarget < iPlatoonRange - iDistanceWithinAttackRange then
                                if M27UnitInfo.IsUnitValid(aiBrain[M27Overseer.refoACUKillTarget]) then
                                    if bEnemyACUUnderwater and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.ANTINAVY + categories.OVERLAYANTINAVY, tDFUnits)) then
                                        oPlatoon[refiLastOrderType] = refiOrderIssueAggressiveMove
                                        oPlatoon[reftLastOrderPosition] = tPositionBehindEnemyACU
                                        IssueAggressiveMove(tDFUnits, tPositionBehindEnemyACU)
                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU underwater so sending attack move order to all DF units to go to '..repru(tPositionBehindEnemyACU)..'; Dist from unit cur position='..M27Utilities.GetDistanceBetweenPositions(tPositionBehindEnemyACU, GetPlatoonFrontPosition(oPlatoon))) end
                                    else
                                        IssueAttack(tDFUnits, aiBrain[M27Overseer.refoACUKillTarget])
                                        oPlatoon[refiLastOrderType] = refiOrderIssueAttack
                                        oPlatoon[reftLastOrderPosition] = aiBrain[M27Overseer.refoACUKillTarget]:GetPosition()
                                        if bDebugMessages == true then LOG(sFunctionRef..': ACU underwater so sending attack  order to all DF units to attack ACU') end
                                    end
                                else
                                    IssueMove(tDFUnits, aiBrain[M27Overseer.reftACUKillTarget])
                                    oPlatoon[refiLastOrderType] = refiOrderIssueMove
                                    oPlatoon[reftLastOrderPosition] = {aiBrain[M27Overseer.reftACUKillTarget][1], aiBrain[M27Overseer.reftACUKillTarget][2], aiBrain[M27Overseer.reftACUKillTarget][3]}
                                    if bDebugMessages == true then LOG(sFunctionRef..': No valid ACU to target') end
                                end
                            else
                                if M27UnitInfo.IsUnitValid(oPlatoon[refoFrontUnit]) then
                                    tTargetMoveLocation = M27Logic.GetPositionToSideOfTarget(oPlatoon[refoFrontUnit], tPositionBehindEnemyACU, iOurACUAngleToTarget, iOffsetToNotBlockACUDistance)
                                    IssueMove(tDFUnits, tTargetMoveLocation)
                                    oPlatoon[refiLastOrderType] = refiOrderIssueMove
                                    oPlatoon[reftLastOrderPosition] = tTargetMoveLocation
                                end
                            end
                        end

                        --Set weapon priorities
                        for iUnit, oUnit in tDFUnits do
                            if EntityCategoryContains(M27UnitInfo.refCategoryShieldDisruptor, oUnit.UnitId) then
                                M27UnitInfo.SetUnitTargetPriorities(oUnit, M27UnitInfo.refWeaponPriorityShieldDisruptor)
                            elseif EntityCategoryContains(M27UnitInfo.refCategorySniperBot, oUnit.UnitId) then
                                M27UnitInfo.SetUnitTargetPriorities(oUnit, M27UnitInfo.refWeaponPrioritySniperBot)
                            else
                                M27UnitInfo.SetUnitTargetPriorities(oUnit, oPlatoon[reftPlatoonDFTargettingCategories])
                            end
                        end
                    end

                    if M27Utilities.IsTableEmpty(tIndirectUnits) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have indirect fire units in platoon') end
                        local tNearbyStructures = GetPlatoonUnitsOrUnitCount(oPlatoon, reftEnemyStructuresInRange, false, true)
                        local tNearbyPD
                        if tNearbyStructures then tNearbyPD = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD, tNearbyStructures) end

                        if M27Utilities.IsTableEmpty(tNearbyPD) == true then
                            if bDebugMessages == true then LOG(sFunctionRef..': No nearby PD, if have sight of ACU will issueattack on it') end
                            if M27UnitInfo.IsUnitValid(aiBrain[M27Overseer.refoACUKillTarget]) and M27Utilities.CanSeeUnit(aiBrain, aiBrain[M27Overseer.refoACUKillTarget], true) then
                                if bEnemyACUUnderwater and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.ANTINAVY + categories.OVERLAYANTINAVY, tIndirectUnits)) then
                                    oPlatoon[refiLastOrderType] = refiOrderIssueAggressiveMove
                                    IssueAggressiveMove(tIndirectUnits, tPositionBehindEnemyACU)
                                    oPlatoon[reftLastOrderPosition] = tPositionBehindEnemyACU
                                else
                                    if bDebugMessages == true then LOG(sFunctionRef..': Can see enemy ACU so will attack it directly') end
                                    IssueAttack(tIndirectUnits, aiBrain[M27Overseer.refoACUKillTarget])
                                    oPlatoon[refiLastOrderType] = refiOrderIssueAttack
                                    oPlatoon[reftLastOrderPosition] = aiBrain[M27Overseer.refoACUKillTarget]:GetPosition()
                                end
                            else
                                if bDebugMessages == true then LOG(sFunctionRef..': Cant see enemy ACU so will attack-move to its last known position='..repru(aiBrain[M27Overseer.reftACUKillTarget])) end
                                IssueAggressiveMove(tIndirectUnits, aiBrain[M27Overseer.reftACUKillTarget])
                                oPlatoon[refiLastOrderType] = refiOrderIssueAggressiveMove
                                oPlatoon[reftLastOrderPosition] = {aiBrain[M27Overseer.reftACUKillTarget][1], aiBrain[M27Overseer.reftACUKillTarget][2], aiBrain[M27Overseer.reftACUKillTarget][3]}
                            end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Nearby PD so will use normal indirect unit attack logic') end
                            IssueIndirectAttack(oPlatoon, false)
                        end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionMoveInCircle then
                    --Will clear the action as part of the micro
                    if M27Utilities.IsTableEmpty(oPlatoon[reftCurrentUnits]) == false then
                        for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                            --MoveInCircleTemporarily(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
                            M27UnitMicro.MoveInCircleTemporarily(oUnit, 5, true, false, 8, 1)
                        end

                    end
                    --MoveInCircleTemporarily(oUnit, iTimeToRun, bTreatAsMicroAction, bDontClearCommandsFirst)
                elseif oPlatoon[refiCurrentAction] == refActionTurnAwayFromEnemy then
                    if bDontClearActions == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; Gametime='..GetGameTimeSeconds()) end
                        M27Utilities.IssueTrackedClearCommands(tCurrentUnits)
                    end
                    --Get the nearest enemy
                    local oNearestEnemy
                    if oPlatoon[refiEnemiesInRange] > 0 then
                        oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon))
                    elseif oPlatoon[refiEnemyStructuresInRange] > 0 then
                        oNearestEnemy = M27Utilities.GetNearestUnit(oPlatoon[reftEnemiesInRange], GetPlatoonFrontPosition(oPlatoon))
                    end
                    local iFacingAngleWanted
                    if oNearestEnemy then
                        iFacingAngleWanted = M27Utilities.GetAngleFromAToB(oNearestEnemy:GetPosition(), GetPlatoonFrontPosition(oPlatoon))
                    else
                        iFacingAngleWanted = M27Utilities.GetAngleFromAToB(M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain), GetPlatoonFrontPosition(oPlatoon))
                    end
                    local iCurDifToFacingAngle = M27Utilities.GetAngleDifference(iFacingAngleWanted, M27UnitInfo.GetUnitFacingAngle(oPlatoon[refoFrontUnit]))
                    if bDebugMessages == true then LOG(sFunctionRef..': iFacingAngleWanted='..iFacingAngleWanted..'; Cur facing angle='..M27UnitInfo.GetUnitFacingAngle(oPlatoon[refoFrontUnit])..'; iCurDifToFacingAngle='..iCurDifToFacingAngle) end
                    if iCurDifToFacingAngle >= 22.5 then
                        PlatoonMove(oPlatoon, M27Utilities.MoveInDirection(GetPlatoonFrontPosition(oPlatoon), iFacingAngleWanted, 2, true))
                    end

                elseif oPlatoon[refiCurrentAction] == refActionSuicide then

                    if bDebugMessages == true then LOG(sFunctionRef..': About to ctrl-K every unit in platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]) end
                    for iUnit, oUnit in oPlatoon[reftCurrentUnits] do
                        if M27UnitInfo.IsUnitValid(oUnit) then oUnit:Kill() end
                    end
                elseif oPlatoon[refiCurrentAction] == refActionGoToRandomLocationForAWhile then
                    M27Utilities.IssueTrackedClearCommands(oPlatoon[reftCurrentUnits])
                    local tPlatoonAveragePosition = oPlatoon:GetPlatoonPosition()
                    local iAngleToMovementPath = M27Utilities.GetAngleFromAToB(tPlatoonAveragePosition, oPlatoon[reftMovementPath][1])
                    local iStartAngleAdjust = math.random(-80, 80)
                    local iStartDistance = math.random(30, 80)
                    local iAngleChange = 15
                    local sPathing = M27UnitInfo.GetUnitPathingType(oPlatoon[refoPathingUnit])
                    local iPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(sPathing, GetPlatoonFrontPosition(oPlatoon))
                    oPlatoon[reftMovementPath] = {}
                    local iMaxLoop = 20
                    local iCurLoop = 0
                    local tPossibleLocation
                    while M27Utilities.IsTableEmpty(oPlatoon[reftMovementPath]) do
                        iCurLoop = iCurLoop + 1
                        if iCurLoop == 10 then --Check pathing as could be an error
                            M27MapInfo.RecheckPathingOfLocation(sPathing, oPlatoon[refoPathingUnit], tPossibleLocation)
                        end
                        if iCurLoop > iMaxLoop then
                            M27Utilities.ErrorHandler('Platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..' couldnt find random place to move to that we can path to even after rechecking pathing, will head towards our base instead')
                            oPlatoon[reftMovementPath][1] = M27Utilities.MoveInDirection(GetPlatoonFrontPosition(oPlatoon), M27Utilities.GetAngleFromAToB(GetPlatoonFrontPosition(oPlatoon), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]), 60)
                            break
                        end

                        for iAngleFactor = -1, 1, 2 do
                            tPossibleLocation = M27Utilities.MoveInDirection(tPlatoonAveragePosition, iAngleToMovementPath + iStartAngleAdjust + iAngleFactor * iAngleChange * (iCurLoop - 1), iStartDistance)
                            if M27MapInfo.GetSegmentGroupOfLocation(sPathing, tPossibleLocation) == iPathingGroup then
                                oPlatoon[reftMovementPath][1] = tPossibleLocation
                                break
                            end
                        end
                    end
                    oPlatoon[refiCurrentPathTarget] = 1
                    if bDebugMessages == true then LOG(sFunctionRef..': oPlatoon='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'; platoon position='..repru(tPlatoonAveragePosition)..'; moving to random point='..repru(oPlatoon[reftMovementPath][1])) end
                    PlatoonMove(oPlatoon, oPlatoon[reftMovementPath][1])
                else
                    --Unrecognised platoon action
                    if oPlatoon[refiCurrentAction]  then M27Utilities.ErrorHandler('Dont recognise the current platoon action='..oPlatoon[refiCurrentAction])
                    else M27Utilities.ErrorHandler('Platoon action is nil')
                    end
                end

                if bDebugMessages == true then
                    local sPlatoonAction = oPlatoon[refiCurrentAction]
                    if sPlatoonAction == nil then sPlatoonAction = 'nil' end
                    LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': end of function - platoon curaction='..sPlatoonAction)
                    if oPlatoon[refbACUInPlatoon] then
                        LOG(sPlatoonName..oPlatoon[refiPlatoonCount]..': '..'ACU state='..M27Logic.GetUnitState(M27Utilities.GetACU(aiBrain))..'; Special Micro='..tostring(M27Utilities.GetACU(aiBrain).M27UnitInfo.refbSpecialMicroActive or false)..'; ACU movementpath='..repru((oPlatoon[reftMovementPath] or {'nil'}))..'; Previously run='..tostring(oPlatoon[refbHavePreviouslyRun]))
                        if M27Utilities.GetACU(aiBrain).GetNavigator and M27Utilities.GetACU(aiBrain):GetNavigator().GetCurrentTargetPos then LOG('ACU CurrentTargetPos='..repru(M27Utilities.GetACU(aiBrain):GetNavigator():GetCurrentTargetPos())) end
                    end

                end

            end
        else
            LOG(sFunctionRef..': PlatoonExists is no longer valid')
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end



function PlatoonInitialSetup(oPlatoon)
    --Updates platoon name and number of times its been called, then ensures segment pathing and mexes within the pathing group exist
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PlatoonInitialSetup'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    oPlatoon[refiCurrentAction] = nil --Needed as backup as we set this to disband later if something goes wrong in the setup

    --PROFILER NOTE - is included lower down due to waitticks
    local aiBrain = oPlatoon:GetBrain()
    local sPlatoonName = oPlatoon:GetPlan()
    --if sPlatoonName == 'M27GroundExperimental' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end
    --if sPlatoonName == 'M27ACUMain' then bDebugMessages = true end
    --if sPlatoonName == 'M27IndirectDefender' then bDebugMessages = true end
    --if sPlatoonName == 'M27EscortAI' then bDebugMessages = true end
    --if sPlatoonName == 'M27CombatPatrolAI' then bDebugMessages = true end
    --if sPlatoonName == 'M27RetreatingShieldUnits' then bDebugMessages = true end
    --if sPlatoonName == 'M27MobileShield' then bDebugMessages = true end
    --if sPlatoonName == 'M27MAAAssister' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauScout' then bDebugMessages = true end
    --if sPlatoonName == 'M27PlateauLandCombat' then bDebugMessages = true end


    --oPlatoon[refbPlatoonLogicActive] = true --Removed from here, as the platoon cycler always runs this, but this function is also claled by idle platoons who dont run the cycler
    aiBrain[refiPlatoonUniqueCount] = (aiBrain[refiPlatoonUniqueCount] or 0) + 1
    oPlatoon[refiPlatoonUniqueCount] = aiBrain[refiPlatoonUniqueCount]

    oPlatoon[refiLocationVisitationCount] = {}

    local tCurrentUnits = oPlatoon:GetPlatoonUnits()
    local bIdlePlatoon = M27PlatoonTemplates.PlatoonTemplate[sPlatoonName][M27PlatoonTemplates.refbIdlePlatoon]
    local bAbort = false
    if bDebugMessages == true then LOG(sFunctionRef..': sPlatoonName='..sPlatoonName..': Start of code') end
    if M27Utilities.IsTableEmpty(tCurrentUnits) == true and bIdlePlatoon == false then
        oPlatoon[refiCurrentAction] = refActionDisband
        if sPlatoonName == nil then sPlatoonName = 'NilName' end
        if bDebugMessages == true then LOG('WARNING - Platoon setup but no units in platoon so will disband in 1s if still the case. Platoon name='..sPlatoonName..(oPlatoon[refiPlatoonCount] or 'nil')) end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        WaitTicks(10)
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if bDebugMessages == true then LOG('Finished waiting 10 ticks for '..sPlatoonName..(oPlatoon[refiPlatoonCount] or 'nil')) end
        tCurrentUnits = oPlatoon:GetPlatoonUnits()
        if M27Utilities.IsTableEmpty(tCurrentUnits) == true then
            if bDebugMessages == true then LOG('Platoon still has no units so will disband. Platoon name='..sPlatoonName..(oPlatoon[refiPlatoonCount] or 'nil')) end
            bAbort = true
            oPlatoon[refbPlatoonLogicActive] = false
            if aiBrain:PlatoonExists(oPlatoon) then oPlatoon:PlatoonDisband() end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..(oPlatoon[refiPlatoonCount] or 'nil')..': Now have units after waiting 1s, so will proceed') end
        end
    end

    if not(bAbort) then
        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..': Platoon has units so proceeding with intialisation; platoon front position='..repru(GetPlatoonFrontPosition(oPlatoon))) end
        --General data for idle and non-idle platoons alike:

        --Record the platoon plan's default template values:
        if M27PlatoonTemplates.PlatoonTemplate then
            for sReference, val in M27PlatoonTemplates.PlatoonTemplate[sPlatoonName] do
                oPlatoon[sReference] = val
            end
        else M27Utilities.ErrorHandler('Dont have a platoon template for platoon with name='..sPlatoonName)
        end
        local sFormationOverride = oPlatoon[M27PlatoonTemplates.refsDefaultFormation]
        if sFormationOverride == nil then sFormationOverride = 'GrowthFormation' end --default
        oPlatoon:SetPlatoonFormationOverride(sFormationOverride)

        --Backup - not sure if it even works:
        if oPlatoon.PlatoonData.UseFormation == nil then oPlatoon.PlatoonData.UseFormation = oPlatoon[sFormationOverride] end
        --if oPlatoon[refbACUInPlatoon] == true and oPlatoon:GetBrain():GetArmyIndex() == 1 then bDebugMessages = true end

        if aiBrain[refiLifetimePlatoonCount] == nil then aiBrain[refiLifetimePlatoonCount] = {} end
        if aiBrain[refiLifetimePlatoonCount][sPlatoonName] == nil then aiBrain[refiLifetimePlatoonCount][sPlatoonName] = 0 end
        aiBrain[refiLifetimePlatoonCount][sPlatoonName] = aiBrain[refiLifetimePlatoonCount][sPlatoonName] + 1
        oPlatoon[refiPlatoonCount] = aiBrain[refiLifetimePlatoonCount][sPlatoonName]

        --if oPlatoon:GetPlan() == 'M27PlateauIndirect' and oPlatoon[refiPlatoonCount] == 1 then bDebugMessages = true end

        --Skirmisher - combine if have too many
        if oPlatoon[refiPlatoonCount] >= 20 and sPlatoonName == 'M27Skirmisher' then
            ForkThread(CombineNearbyPlatoonsOfType, aiBrain, sPlatoonName)
        elseif oPlatoon[refiPlatoonCount] >= 5 and sPlatoonName == 'M27RAS' then
            ForkThread(CombineNearbyPlatoonsOfType, aiBrain, sPlatoonName)
        end

        local bPlatoonNameDisplay = false
        if M27Config.M27ShowUnitNames == true then bPlatoonNameDisplay = true end
        if bPlatoonNameDisplay == true then UpdatePlatoonName(oPlatoon, sPlatoonName..oPlatoon[refiPlatoonCount]..'-'..oPlatoon[refiPlatoonUniqueCount]..': A'..refActionReturnToBase) end
        if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': Have a platoon with units, proceeding with rest of initialisation') end

        oPlatoon[reftDestinationCount] = {}



        --Non-idle logic:
        if not(bIdlePlatoon) then
            oPlatoon[refoBrain] = aiBrain
            oPlatoon[refbMovingToBuild] = false
            oPlatoon[refiLastTimeWantedEscort] = 0
            local oPathingUnit = GetPathingUnit(oPlatoon)
            local tPlatoonUnits = oPlatoon:GetPlatoonUnits()

            --Make sure action that give in this platoon repalces any existing action the platoon has:
            local sPathing
            if not(M27UnitInfo.IsUnitValid(oPathingUnit)) then
                M27Utilities.ErrorHandler('Possible error - no pathing unit in platoon; sPlatoonName='..sPlatoonName..oPlatoon[refiPlatoonCount]..'; will disband platoon')
                if M27Utilities.IsTableEmpty(tPlatoonUnits) == false then LOG('PlatoonInitialSetup: tPlatoonUnits is not empty') end
                if oPlatoon then oPlatoon[refiCurrentAction] = refActionDisband end --and aiBrain:PlatoonExists(oPlatoon) then oPlatoon:PlatoonDisband() end
            else
                --Is this a plateau platoon?
                if not(oPathingUnit[M27Transport.refiAssignedPlateau]) then oPathingUnit[M27Transport.refiAssignedPlateau] = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oPathingUnit:GetPosition()) end
                if bDebugMessages == true then LOG(sFunctionRef..': Is this a plateau platoon? oPathingUnit[M27Transport.refiAssignedPlateau]='..(oPathingUnit[M27Transport.refiAssignedPlateau] or 'nil')..'; aiBrain[M27MapInfo.refiOurBasePlateauGroup]='..aiBrain[M27MapInfo.refiOurBasePlateauGroup]) end

                if oPathingUnit[M27Transport.refiAssignedPlateau] and not(oPathingUnit[M27Transport.refiAssignedPlateau] == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) and M27Utilities.IsTableEmpty(aiBrain[M27MapInfo.reftOurPlateauInformation][oPathingUnit[M27Transport.refiAssignedPlateau]]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Think we have a plateau platoon. sPlatoonName='..sPlatoonName..'; Will set assigned platoon plateau group to '..oPathingUnit[M27Transport.refiAssignedPlateau]) end
                    oPlatoon[M27Transport.refiAssignedPlateau] = oPathingUnit[M27Transport.refiAssignedPlateau]
                    local sPlatoonSubref
                    if sPlatoonName == 'M27PlateauLandCombat' then
                        sPlatoonSubref = M27MapInfo.subrefPlateauLandCombatPlatoons
                    elseif sPlatoonName == 'M27PlateauIndirect' then
                        sPlatoonSubref = M27MapInfo.subrefPlateauIndirectPlatoons
                    elseif sPlatoonName == 'M27PlateauMAA' then
                        sPlatoonSubref = M27MapInfo.subrefPlateauMAAPlatoons
                    elseif sPlatoonName == 'M27PlateauScout' then
                        sPlatoonSubref = M27MapInfo.subrefPlateauScoutPlatoons
                    end
                    if sPlatoonSubref then
                        if not(aiBrain[M27MapInfo.reftOurPlateauInformation][oPlatoon[M27Transport.refiAssignedPlateau]][sPlatoonSubref]) then aiBrain[M27MapInfo.reftOurPlateauInformation][oPlatoon[M27Transport.refiAssignedPlateau]][sPlatoonSubref] = {} end
                        aiBrain[M27MapInfo.reftOurPlateauInformation][oPlatoon[M27Transport.refiAssignedPlateau]][sPlatoonSubref][oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]] = oPlatoon
                        if bDebugMessages == true then LOG(sFunctionRef..': Have recorded platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..' in the aiBrain tracker. sPlatoonSubref='..sPlatoonSubref..'; oPlatoon[M27Transport.refiAssignedPlateau]='..(oPlatoon[M27Transport.refiAssignedPlateau] or 'nil')) end
                    else M27Utilities.ErrorHandler('Unrecognised plateau platoon plan '..sPlatoonName..oPlatoon[refiPlatoonCount])
                    end
                else
                    if bDebugMessages == true then
                        if oPathingUnit[M27Transport.refiAssignedPlateau] then
                            LOG(sFunctionRef..': Dont think we have a valid plateau')
                        else
                            LOG(sFunctionRef..': oPathingUnit doesnt have an assigned plateau')
                        end
                    end
                end

                if bDebugMessages == true then LOG(sFunctionRef..': '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': Clearing commands; oPathingUnit='..oPathingUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPathingUnit)..'; pathing unit position='..repru(oPathingUnit:GetPosition())) end
                M27Utilities.IssueTrackedClearCommands(tPlatoonUnits)
                if bDebugMessages == true then LOG(sFunctionRef..': About to get segment group of unit '..oPathingUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPathingUnit)..' with platooon ='..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'; Platoon front unit position='..repru(oPathingUnit:GetPosition() or {'nil'})..' for platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]) end
                local bAbortSetup = false
                if M27Utilities.IsTableEmpty(oPathingUnit:GetPosition()) then
                    bAbortSetup = true
                    M27Utilities.ErrorHandler(sPlatoonName..oPlatoon[refiPlatoonCount]..': Somehow have a valid pathing unit '..oPathingUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPathingUnit)..' that has no position')

                end
                if not(bAbortSetup) then
                    local iSegmentGroup = M27MapInfo.GetUnitSegmentGroup(oPathingUnit)
                    if iSegmentGroup == nil then
                        bAbortSetup = true
                        M27Utilities.ErrorHandler(sPlatoonName..oPlatoon[refiPlatoonCount]..': No segments that the platoon can path to')
                    end

                    if not(bAbortSetup) then

                        --M27MapInfo.RecordMexForPathingGroup(oPathingUnit)

                        --Kiting logic (and ACU overcharge):
                        SetIfPlatoonCanKite(oPlatoon)
                        --Do we have an ACU in the platoon? If so set auto-overcharge to be on
                        local oACU = M27Utilities.GetACU(aiBrain)
                        local tACUs = EntityCategoryFilterDown(categories.COMMAND, tPlatoonUnits)
                        if not(tACUs == nil) then --for some reason using the above would return non-nil value even when ACU not in platoon, so below is to make sure that there is an ACU in platoon
                            for iUnit, oUnit in tACUs do
                                if oUnit == oACU then
                                    oPlatoon[refbACUInPlatoon] = true
                                    oPlatoon[refbKiteEnemies] = true --redundancy
                                    M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, M27Utilities.GetACU(aiBrain), true)
                                    break
                                end
                            end
                        end
                        if not(oPlatoon[refbACUInPlatoon]) then
                            oPlatoon[refbACUInPlatoon] = false
                            --GetDFAndT1ArtiUnitMinOrMaxRange(tUnits, iReturnRangeType)
                            --    --Works if either sent a table of units or a single unit
                            --    --iReturnRangeType: nil or 0: Return min+Max; 1: Return min only; 2: Return max only
                            if bDebugMessages == true then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..'; iMaxRange='..(oPlatoon[refiPlatoonMaxRange] or 'nil')..'; Is table of platoon units filtered to fatboys empty='..tostring(M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryFatboy, tPlatoonUnits)))..'; oPlatoon[refbKiteEnemies]='..tostring(oPlatoon[refbKiteEnemies])) end
                        end


                        --Does the platoon contain builders or reclaimers? If so then flag to consider nearby mexes and reclaim respectively
                        --(although below also updates the tables of these, these will be refreshed every platoon cycle anyway)
                        local tBuilders = EntityCategoryFilterDown(categories.CONSTRUCTION, tPlatoonUnits)
                        local bCanBuildMex = false
                        if bDebugMessages == true then
                            if tBuilders == nil then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': tBuilder size=nil')
                            else LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': tBuilder size='..table.getn(tBuilders))
                            end
                        end
                        if M27Utilities.IsTableEmpty(tBuilders) == false then
                            local iBuilderFaction
                            local sFactionMexBPID
                            for iBuilder, oBuilder in tBuilders do
                                iBuilderFaction = M27UnitInfo.GetFactionFromBP(oBuilder:GetBlueprint())
                                sFactionMexBPID = M27UnitInfo.GetBlueprintIDFromBuildingTypeAndFaction('T1Resource', iBuilderFaction)
                                if oBuilder:CanBuild(sFactionMexBPID) then
                                    bCanBuildMex = true
                                    break
                                end
                            end
                        end
                        --Pathing range override for ACU and builders
                        if oPlatoon[refbACUInPlatoon] == true then
                            if oPlatoon[refoFrontUnit].GetBlueprint then
                                oPlatoon[refiOverrideDistanceToReachDestination] = math.max((oPlatoon[refoFrontUnit]:GetBlueprint().SizeX or 0), (oPlatoon[refoFrontUnit]:GetBlueprint().SizeZ or 0)) + 2 --ACU treated as reaching destination when it gets this close to it
                            else --(redundancy)
                                oPlatoon[refiOverrideDistanceToReachDestination] = 3
                            end
                        elseif M27Utilities.IsTableEmpty(tBuilders) == false then
                            --Might trigger as builder if are SACU or fatboy, so only update this if are engineer
                            if EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oPlatoon[refoFrontUnit].UnitId) then
                                oPlatoon[refiOverrideDistanceToReachDestination] = math.max((oPlatoon[refoFrontUnit]:GetBlueprint().SizeX or 0), (oPlatoon[refoFrontUnit]:GetBlueprint().SizeZ or 0)) + 3
                            end
                        end
                        oPlatoon[refbConsiderMexes] = bCanBuildMex
                        if bCanBuildMex == true then
                            oPlatoon[reftBuilders] = tBuilders
                        end

                        local tReclaimers = EntityCategoryFilterDown(categories.RECLAIM, tPlatoonUnits)
                        local bHaveReclaimers = false
                        bHaveReclaimers = M27Utilities.IsTableEmpty(tReclaimers)
                        if bDebugMessages == true then LOG(sFunctionRef..': bHaveReclaimers='..tostring(bHaveReclaimers)) end
                        oPlatoon[refbConsiderReclaim] = not(bHaveReclaimers)
                        if bHaveReclaimers == true then
                            oPlatoon[reftReclaimers] = tReclaimers
                        end
                        if bDebugMessages == true then
                            LOG('oPlatoon[refbConsiderReclaim]='..tostring(oPlatoon[refbConsiderReclaim])..' oPlatoon[refbConsiderMexes]='..tostring(oPlatoon[refbConsiderMexes]))
                            if tBuilders == nil then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': tBuilder size=nil')
                            else LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': tBuilder size='..table.getn(tBuilders))
                            end
                            if tReclaimers == nil then LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': tReclaimers size=nil')
                            else LOG(sFunctionRef..': '..sPlatoonName..oPlatoon[refiPlatoonCount]..': tReclaimers size='..table.getn(tReclaimers))
                            end
                        end

                        --Does the platoon contain underwater land units?
                        oPlatoon[refbPlatoonHasUnderwaterLand] = false
                        oPlatoon[refbPlatoonHasOverwaterLand] = false
                        if sPathing == M27UnitInfo.refPathingTypeAmphibious then
                            for iUnit, oUnit in tPlatoonUnits do
                                if M27UnitInfo.IsUnitUnderwaterAmphibious(oUnit) == true then
                                    oPlatoon[refbPlatoonHasUnderwaterLand] = true
                                    break
                                else
                                    oPlatoon[refbPlatoonHasOverwaterLand] = true
                                    break
                                end
                            end
                        end

                        if oPlatoon and oPlatoon.SetPlatoonFormationOverride and aiBrain:PlatoonExists(oPlatoon) then oPlatoon:SetPlatoonFormationOverride('AttackFormation') end--default is to stick together

                        --Follower support platoon logic:
                        if sPlatoonName == 'M27EscortAI' then
                            oPlatoon[refiSupportHelperFollowDistance] = -15
                        elseif sPlatoonName == 'M27MobileShield' then
                            if oPathingUnit and EntityCategoryContains(categories.HOVER, oPathingUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting platoon follow distance to 0.5 as has hover in it') end
                                oPlatoon[refiSupportHelperFollowDistance] = 0.5
                            else
                                oPlatoon[refiSupportHelperFollowDistance] = 1.5
                                if bDebugMessages == true then
                                    if M27UnitInfo.IsUnitValid(oPathingUnit) then
                                        LOG(sFunctionRef..': Front unit='..oPathingUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPathingUnit)..'; setting to normal shield distance')
                                    else
                                        LOG(sFunctionRef..': oPathingUnit isnt valid')
                                end
                                end
                            end
                        elseif sPlatoonName == 'M27MobileStealth' then oPlatoon[refiSupportHelperFollowDistance] = 7
                        else
                            local iOurMinSpeed = M27Logic.GetUnitMinSpeed(oPlatoon:GetPlatoonUnits(), aiBrain, false)
                            if iOurMinSpeed <= 3.5 then oPlatoon[refiSupportHelperFollowDistance] = 18 --i.e. MAA
                            else --i.e. land scout
                                oPlatoon[refiSupportHelperFollowDistance] = 4
                                if oPlatoon[refoSupportHelperPlatoonTarget] and oPlatoon[refoSupportHelperPlatoonTarget][refoFrontUnit] and oPlatoon[refoSupportHelperPlatoonTarget][refoFrontUnit]:GetBlueprint().Physics.MaxSpeed >= 3 then oPlatoon[refiSupportHelperFollowDistance] = 3 end
                                --Seraphim scouts have poor intel range so need to be closer:
                                if M27UnitInfo.IsUnitValid(oPathingUnit) and EntityCategoryContains(categories.SERAPHIM * categories.SCOUT, oPathingUnit.UnitId) then oPlatoon[refiSupportHelperFollowDistance] = 2 end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished setting follower distance to '..(oPlatoon[refiSupportHelperFollowDistance] or 'nil')) end
                    end
                end
                if bAbortSetup then
                    oPlatoon[refiCurrentAction] = refActionDisband
                end
            end
        end
    end
    oPlatoon[refiLastPrevActionOverride] = 0
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function RunPlatoonSingleCycle(oPlatoon)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RunPlatoonSingleCycle'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    M27Utilities.FunctionProfiler(sFunctionRef..oPlatoon:GetPlan(), M27Utilities.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start for platoon with UC='..oPlatoon[refiPlatoonUniqueCount]..'; About to run a platoon cycle unless all brains defeated') end
    if M27Logic.iTimeOfLastBrainAllDefeated < 10 then
        oPlatoon[refiTimeOfLastRefresh] = GetGameTimeSeconds()
        DeterminePlatoonAction(oPlatoon)
        ProcessPlatoonAction(oPlatoon)
    end
    M27Utilities.FunctionProfiler(sFunctionRef..oPlatoon:GetPlan(), M27Utilities.refProfilerEnd)
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)

end

function PlatoonCycler(oPlatoon)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PlatoonCycler'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local aiBrain = oPlatoon:GetBrain()
    local sOrigPlatoonName = oPlatoon:GetPlan()


    if aiBrain:PlatoonExists(oPlatoon) then
        --Check we're not duplicating a backup loop
        if not(oPlatoon[refbPlatoonLogicActive]) and not(oPlatoon[M27PlatoonTemplates.refbIdlePlatoon]) then
            --NOTE: Idle platoons only run initialsetup, they dont call the platooncycler
            PlatoonInitialSetup(oPlatoon)
            if not(oPlatoon[refiCurrentAction] == refActionDisband) then
                oPlatoon[refbPlatoonLogicActive] = true
                if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for platoon with orig name '..sOrigPlatoonName..(oPlatoon[refiPlatoonCount] or 'nil')..'; curplan='..oPlatoon:GetPlan()..'; oPlatoon[refiPlatoonUniqueCount]='..oPlatoon[refiPlatoonUniqueCount]) end
                local iOrigPlatoonCount = oPlatoon[refiPlatoonCount]

                --These values get overridden, have set for if we want to disable the logic by just commenting out iTicksToWait
                local iTicksToWait = 10
                local iMaxTicksToWait = 10
                local iPlatoonCost = 0.5

                oPlatoon[refiEnemiesInRange] = 0
                oPlatoon[refiEnemyStructuresInRange] = 0
                oPlatoon[refiSecondsSinceLastCycle] = 1

                while aiBrain:PlatoonExists(oPlatoon) and not(aiBrain.M27IsDefeated) and not(aiBrain[M27Logic.refbAllEnemiesDead]) do
                    if bDebugMessages == true then LOG(sFunctionRef..': About to run a platoon cycle for platoon '..oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..'-'..oPlatoon[refiPlatoonUniqueCount]..'; GameTime='..GetGameTimeSeconds()) end
                    ForkThread(RunPlatoonSingleCycle, oPlatoon)
                    if oPlatoon[refiEnemiesInRange] + oPlatoon[refiEnemyStructuresInRange] > 0 then
                        iMaxTicksToWait = (oPlatoon[M27PlatoonTemplates.refiMaxTicksBetweenCycleEnemies] or 2)
                        iPlatoonCost = 0.7
                    else
                        iMaxTicksToWait = (oPlatoon[M27PlatoonTemplates.refiMaxTicksBetweenCycleNoEnemies] or 2)
                        iPlatoonCost = 0.4
                    end
                    if oPlatoon[refbACUInPlatoon] then iPlatoonCost = iPlatoonCost + 0.6 end
                    if iMaxTicksToWait < 10 then M27Utilities.ErrorHandler(oPlatoon:GetPlan()..oPlatoon[refiPlatoonCount]..': iMaxTicksToWait='..(iMaxTicksToWait or 0)) end

                    --[refiMaxTicksBetweenCycleEnemies]
                    local iMinTicksToWait = 10
                    if oPlatoon[refbFasterRefreshNextCycle] then
                        iMinTicksToWait = 6
                        iMaxTicksToWait = iMaxTicksToWait - 3
                    end
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                    --WaitTicks(10)
                    iTicksToWait = _G.MyM27Scheduler:WaitTicks(10, iMaxTicksToWait, iPlatoonCost)
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                    oPlatoon[refiSecondsSinceLastCycle] = iTicksToWait * 0.1
                    --WaitTicks(iTicksToWait)

                    if bDebugMessages == true then LOG(sFunctionRef..': Waited 1s after running cycle, checking if platoon still valid; GameTime='..GetGameTimeSeconds()) end
                    if oPlatoon and oPlatoon.GetPlan and aiBrain then
                        if bDebugMessages == true then LOG(sFunctionRef..': Platoon still appears to be valid') end
                        --Removed below as now have refbPlatoonLogicActive to check this
                        --[[if not(oPlatoon:GetPlan() == sOrigPlatoonName) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Platoon plan has changed, orig name='..sOrigPlatoonName..iOrigPlatoonCount..'; new name='..oPlatoon:GetPlan()..(oPlatoon[refiPlatoonCount] or 'nil')..'; will abort') end
                            break
                        end--]]
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Platoon no longer exists, orig name='..sOrigPlatoonName..iOrigPlatoonCount..'; will abort') end
                        if oPlatoon then oPlatoon[refbPlatoonLogicActive] = false end
                        break
                    end
                    if M27Logic.iTimeOfLastBrainAllDefeated > 10 then
                        if bDebugMessages == true then LOG(sFunctionRef..': All brains defeated so aborting platoon logic') end
                        if oPlatoon then oPlatoon[refbPlatoonLogicActive] = false end
                        break
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': End of loop for platoon with UC='..oPlatoon[refiPlatoonUniqueCount]) end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Platoon no longer exists or we are defeated') end
            if oPlatoon then oPlatoon[refbPlatoonLogicActive] = false end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': '..sOrigPlatoonName..(oPlatoon[refiPlatoonCount] or 'nil')..': Platoon is either an idle platoon or already has an active cycler so wont duplicate') end
        end
    else
        oPlatoon[refbPlatoonLogicActive] = false
        if bDebugMessages == true then LOG(sFunctionRef..': '..sOrigPlatoonName..(oPlatoon[refiPlatoonCount] or 'nil')..' has ceased to exist so stopping platoon loop') end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ACUInitialBuildOrder(self)
    --Do nothing - main logic is handled in M27Overseer ACUInitialisation, this is just to make sure we dont get platoon logic interfering
end
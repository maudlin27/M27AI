---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 17/08/2022 19:03
---
local M27MapInfo = import('/mods/M27AI/lua/AI/M27MapInfo.lua')
local M27UnitInfo = import('/mods/M27AI/lua/AI/M27UnitInfo.lua')
local M27Utilities = import('/mods/M27AI/lua/M27Utilities.lua')
local M27Logic = import('/mods/M27AI/lua/AI/M27GeneralLogic.lua')
local M27Overseer = import('/mods/M27AI/lua/AI/M27Overseer.lua')
local M27Team = import('/mods/M27AI/lua/AI/M27Team.lua')
local M27EngineerOverseer = import('/mods/M27AI/lua/AI/M27EngineerOverseer.lua')
local M27Conditions = import('/mods/M27AI/lua/AI/M27CustomConditions.lua')
local M27EconomyOverseer = import('/mods/M27AI/lua/AI/M27EconomyOverseer.lua')
local M27PlatoonUtilities = import('/mods/M27AI/lua/AI/M27PlatoonUtilities.lua')
local M27Config = import('/mods/M27AI/lua/M27Config.lua')
local M27AirOverseer = import('/mods/M27AI/lua/AI/M27AirOverseer.lua')



--aiBrian variables
refiPriorityPondRef = 'M27PriorityPondRef' --against aibrain, returns the pond ref (naval segment group) that we think is most important to that aibrain (only recorded for M27 brains)
reftiPondThreatToUs = 'M27PondThreatToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the 'mex value' of that pond when considering mexes within 40% of our base (mod distance).  Only recorded for ponds where we have identified a naval yard build location
reftiPondValueToUs = 'M27PondValueToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the expected value of the pond if we have naval control of it (so ignores distance reductions that are used to decide if we want to build navy there in the first place)
refbEnemyNavyPreventingBuildingNavy = 'M27PondEnemyNavyNearBuildLocation' --against aibrain, true if enemy has navy near to the build location

--Unit varaibles
refiAssignedPond = 'M27PondAssigned' --set against a unit to reflect the pond it is in; set to 0 if not in a pond
reftiTeamRefsUpdatedFor = 'M27UpdatedTeamRefs' --Reflects M27 team ref numbers that have recorded the unit against a pond
refbTempIsUnderwater = 'M27IsUnderwater' --Temporary for units - set when analysing naval threats only, so can refer to it later in code
refbRechargeShield = 'M27NavyRechargeShield' --against unit, true if want to recharge shield
reftoAssignedShields = 'M27NavyAssignedShields' --against unit, table of all shields assigned to support this unit
reftoAssignedStealth = 'M27NavyAssignedStealth' --against unit, table of all stealth boats assigned to support this unit
refoSupportTarget = 'M27NavySupportTarget' --against unit, the unit that it is supporting (e.g. for a shield this would be the unit it is shielding)

--Naval factory 'avoid moving onto land and dying' variables
refbCheckedFactoryForNearbyLand = 'M27NavyCheckedFactoryForNearbyLand' --true if we have checked for nearby land when a unit has just been built by a naval factory
reftInitialFactoryRallyPointOverride = 'M27NavyInitialFactoryRallyPointOverride' --If we have nearby land then this should be a location near to where units get built that has water in it, to hopefully avoid units moving onto land and dying

--TeamData variables (references are to tTeamData[aiBrain.M27Team] - see M27Team

--Global variables
iMinPondSize = 1000 --1000 is a small pond that probably barely fits a couple of naval factories

tPondDetails = {} --[a] = the naval pathing group; returns subtable of various information on ponds; Global information on ponds (requiring at least 200 space
subrefPondSize = 'PondSize'
subrefPondMinX = 'PondMinX'
subrefPondMinZ = 'PondMinZ'
subrefPondMaxX = 'PondMaxX'
subrefPondMaxZ = 'PondMaxZ'
subrefPondMidpoint = 'PondMidpoint'
subrefPondNearbyBrains = 'PondNearbyBrains'
subrefPondMexInfo = 'PondMexInfo'
subrefMexLocation = 'PondMexLocation'
subrefMexDistance = 'PondMexDistance'
subrefMexDFDistance = 'PondMexDFDistance'
subrefMexDFUnblockedLocation = 'PondMexDFLocation' --i.e. the closest location we found where a DF unit should be able to hit the mex
subrefMexIndirectDistance = 'PondMexIndirectDistance'
subrefMexIndirectUnblockedLocation = 'PondMexIndirectLocation' --i.e. the closest location we found where an indirect unit should be able to hit the mex
subrefBuildLocationByStartPosition = 'PondBuildLocationByStart' --Subtable, key is start position number, which stores the build location for that start position (will only record for M27 brain start



function CheckForPondNearNavalUnit(oUnit)
    --Looks at area around unit to see if in a recognised pond, if so then updates pathing of all points in the area.  Returns the revised pond (or 0 if no revised one found)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'CheckForPondNearNavalUnit'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)


    local iPond = 0
    local tStartPosition = oUnit:GetPosition()
    local sLocationRef = M27Utilities.ConvertLocationToReference(tStartPosition)
    local sPathing = M27UnitInfo.refPathingTypeNavy
    if bDebugMessages == true then LOG(sFunctionRef..': About to check pathing for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' if we havent already checked. sLocationRef='..sLocationRef..'; tManualPathingChecks for this='..repru(M27MapInfo.tManualPathingChecks[sPathing][sLocationRef])) end
    if not(M27MapInfo.tManualPathingChecks[sPathing][sLocationRef]) then
        M27MapInfo.tManualPathingChecks[sPathing][sLocationRef] = {tStartPosition[1], tStartPosition[2], tStartPosition[3]}

        --Can we find a nearby pond?
        local iAlternativePond
        local tAlternativeLocation
        local iInterval = 2
        local iMaxSearch = 8 --Tried 4 but an under construction unit at a naval fac doesnt register as being in the same pond
        if EntityCategoryContains(categories.NAVAL, oUnit.UnitId) and oUnit:GetFractionComplete() < 1 then iMaxSearch = 16 end
        local iSegmentSize = M27MapInfo.iSizeOfBaseLevelSegment
        if bDebugMessages == true then LOG(sFunctionRef..': About to search for nearby location that is in a recognised pond. iInterval='..iInterval..'; iMaxSearch='..iMaxSearch..'; iSegmentSize='..iSegmentSize) end
        local bFoundValidMatch = false

        for iModX = -iMaxSearch, iMaxSearch, iInterval do
            for iModZ = -iMaxSearch, iMaxSearch, iInterval do
                tAlternativeLocation = {tStartPosition[1] + iModX, 0, tStartPosition[3] + iModZ}
                iAlternativePond = M27MapInfo.GetSegmentGroupOfLocation(sPathing, tAlternativeLocation)
                if bDebugMessages == true then LOG(sFunctionRef..': iModX='..iModX..'; iModZ='..iModZ..'; tAlternativeLocation='..repru(tAlternativeLocation)..'; Dist to start position='..M27Utilities.GetDistanceBetweenPositions(tStartPosition, tAlternativeLocation)..'; iAlternativePond='..iAlternativePond) end
                if tPondDetails[iAlternativePond] and (tPondDetails[iAlternativePond][subrefPondSize] or 0) >= iMinPondSize then
                    bFoundValidMatch = true
                    iPond = iAlternativePond
                    --Have a replacement pond to use
                    local iBaseSegmentX, iBaseSegmentZ = M27MapInfo.GetPathingSegmentFromPosition(tAlternativeLocation)
                    local iMinX, iMaxX, iMinZ, iMaxZ
                    if iModX < 0 then iMinX = iModX iMaxX = 0
                    elseif iModX > 0 then iMinX = 0 iMaxX = iModX
                    else iMinX = 0 iMaxX = 0
                    end

                    if iModZ < 0 then iMinZ = iModX iMaxZ = 0
                    elseif iModZ > 0 then iMinZ = 0 iMaxZ = iModX
                    else iMinZ = 0 iMaxZ = 0
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Valid pond, will draw in blue and update all nearby pond references from start position to here')
                        M27Utilities.DrawLocation(tAlternativeLocation, nil, 1, 200)
                    end

                    for iXAdj = iMinX / iSegmentSize, iMaxX / iSegmentSize, 1 do
                        for iZAdj = iMinZ / iSegmentSize, iMaxZ / iSegmentSize, 1 do
                            if not(tPondDetails[M27MapInfo.tPathingSegmentGroupBySegment[sPathing][iBaseSegmentX + iXAdj][iBaseSegmentZ + iZAdj]]) or (tPondDetails[M27MapInfo.tPathingSegmentGroupBySegment[sPathing][iBaseSegmentX + iXAdj][iBaseSegmentZ + iZAdj]] or 0) < iMinPondSize then
                                if M27MapInfo.tPathingSegmentGroupBySegment[sPathing][iBaseSegmentX + iXAdj] then
                                    M27MapInfo.tPathingSegmentGroupBySegment[sPathing][iBaseSegmentX + iXAdj][iBaseSegmentZ + iZAdj] = iPond
                                    if bDebugMessages == true then
                                        local iSegmentX = iBaseSegmentX + iXAdj
                                        local iSegmentZ = iBaseSegmentX + iZAdj
                                        local tSegmentLocation = M27MapInfo.GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
                                        LOG(sFunctionRef..': Updating pond for segment X='..iSegmentX..'; Z='..iSegmentZ..' to pond '..iPond..'; whill draw in white, position='..repru(tSegmentLocation))

                                        M27Utilities.DrawLocation(tSegmentLocation, nil, 7, 200)
                                    end
                                end
                            end
                        end
                    end
                    --Make sure we update our current position segment as well
                    local iStartSegmentX, iStartSegmentZ = M27MapInfo.GetPathingSegmentFromPosition(tStartPosition)
                    M27MapInfo.tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ] = iPond
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Updating start position pond to '..iPond..' and colouring in white, iStartSegmentX='..iStartSegmentX..'; iStartSegmentZ='..iStartSegmentZ)
                        M27Utilities.DrawLocation(tStartPosition, nil, 7, 200)
                    end
                    break
                elseif bDebugMessages == true then
                    LOG(sFunctionRef..': Location not valid pond, will draw in red')
                    M27Utilities.DrawLocation(tAlternativeLocation, nil, 2, 200)
                end
            end
            if bFoundValidMatch then break end
        end

    end


    return iPond
end

function RecordPonds()
    --Call after recording all pathfinding for the map
    --intended to record key information on any ponds of interest

    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPonds'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local tbUnderwaterGroup = {}
    local tSegmentPosition

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code. Does map have water='..tostring(M27MapInfo.bMapHasWater)) end

    if M27MapInfo.bMapHasWater then
        --Record the size and dimensions of every pond
        for iSegmentX, tSubtable in M27MapInfo.tPathingSegmentGroupBySegment[M27UnitInfo.refPathingTypeNavy] do
            for iSegmentZ, iPathingGroup in tSubtable do
                if not(tPondDetails[iPathingGroup]) then

                    tPondDetails[iPathingGroup] = {}
                    --Are we actually underwater?
                    tbUnderwaterGroup[iPathingGroup] = M27MapInfo.IsUnderwater(M27MapInfo.GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) --GetPosition returns the terrain height
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering pathing group '..iPathingGroup..'; is this underwater='..tostring(tbUnderwaterGroup[iPathingGroup])) end
                    if tbUnderwaterGroup[iPathingGroup] then
                        tPondDetails[iPathingGroup][subrefPondMinX] = 100000
                        tPondDetails[iPathingGroup][subrefPondMinZ] = 100000
                        tPondDetails[iPathingGroup][subrefPondMaxX] = 0
                        tPondDetails[iPathingGroup][subrefPondMaxZ] = 0
                        tPondDetails[iPathingGroup][subrefPondSize] = 0
                        tPondDetails[iPathingGroup][subrefPondNearbyBrains] = {}
                        tPondDetails[iPathingGroup][subrefPondMidpoint] = {}
                        tPondDetails[iPathingGroup][subrefPondMexInfo] = {}
                    end
                end

                if tbUnderwaterGroup[iPathingGroup] then
                    tSegmentPosition = M27MapInfo.GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
                    tPondDetails[iPathingGroup][subrefPondSize] = tPondDetails[iPathingGroup][subrefPondSize] + 1
                    tPondDetails[iPathingGroup][subrefPondMinX] = math.min(tPondDetails[iPathingGroup][subrefPondMinX], tSegmentPosition[1])
                    tPondDetails[iPathingGroup][subrefPondMinZ] = math.min(tPondDetails[iPathingGroup][subrefPondMinZ], tSegmentPosition[3])
                    tPondDetails[iPathingGroup][subrefPondMaxX] = math.max(tPondDetails[iPathingGroup][subrefPondMaxX], tSegmentPosition[1])
                    tPondDetails[iPathingGroup][subrefPondMaxZ] = math.max(tPondDetails[iPathingGroup][subrefPondMaxZ], tSegmentPosition[3])
                end
            end
        end

        --Clear out any ponds that are empty
        local bRemoveBlankPonds = true
        while bRemoveBlankPonds do
            bRemoveBlankPonds = false
            for iPathingGroup, tSubtable in tPondDetails do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to clear out a pond due to being too small, iPathingGroup='..iPathingGroup..'; tSubtable[subrefPondSize]='..(tSubtable[subrefPondSize] or 'nil')) end
                if not(tSubtable) or (tSubtable[subrefPondSize] or 0) <= 1 then
                    bRemoveBlankPonds = true
                    tPondDetails[iPathingGroup] = nil
                    break
                end
            end
        end

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Is the tPondDetails table empty=' .. tostring(M27Utilities.IsTableEmpty(tPondDetails)))
        end
        if M27Utilities.IsTableEmpty(tPondDetails) == false then
            local iMaxBrainDist = 175
            local iMaxMexDist = 200 --range of aeon missile ship
            local iPondMexCount
            local iCurMexDist
            local tiDistToTry = { 24, 40, 56, 88, 120, 145, iMaxMexDist }
            local bInRange
            local iAngleInterval = 45
            local tNearbyWater
            local tPossibleWaterPosition
            local iPrevDist
            local tShotStartPosition
            local tShotEndPosition
            local iAOE

            --Want a brain in case we end up using the alternative 'line is blocked' built in functionality
            local aiBrain
            for iBrain, oBrain in ArmyBrains do
                if oBrain.M27AI then
                    aiBrain = oBrain
                    break
                end
            end
            if not (aiBrain) then
                for iBrain, oBrain in ArmyBrains do
                    aiBrain = oBrain
                    break
                end
            end

            for iPathingGroup, tPondSubtable in tPondDetails do
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering pond group ' .. iPathingGroup .. '; Pond size=' .. (tPondSubtable[subrefPondSize] or 'nil'))
                end
                if (tPondSubtable[subrefPondSize] or 0) >= iMinPondSize then
                    --Pond is large enough for us to consider tracking; record information of interest for the pond:
                    iPondMexCount = 0
                    tPondSubtable[subrefPondMidpoint] = { (tPondDetails[iPathingGroup][subrefPondMinX] + tPondDetails[iPathingGroup][subrefPondMaxX]) * 0.5, M27MapInfo.iMapWaterHeight, (tPondDetails[iPathingGroup][subrefPondMinZ] + tPondDetails[iPathingGroup][subrefPondMaxZ]) * 0.5 }
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Recording pond, will check how many mexes are nearby. Pond midpoint=' .. repru(tPondSubtable[subrefPondMidpoint]) .. '; Pond min X-Z=' .. tPondDetails[iPathingGroup][subrefPondMinX] .. '-' .. tPondDetails[iPathingGroup][subrefPondMinZ] .. '; Max X-Z=' .. tPondDetails[iPathingGroup][subrefPondMaxX] .. '-' .. tPondDetails[iPathingGroup][subrefPondMaxZ])
                    end

                    --Details of brains that are near to the pond
                    for iBrain, oBrain in ArmyBrains do
                        if not (M27Logic.IsCivilianBrain(oBrain)) then
                            --Are we within 175 of the square covering the pond?
                            if M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][1] >= tPondSubtable[subrefPondMinX] - iMaxBrainDist and M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][1] <= tPondSubtable[subrefPondMaxX] + iMaxBrainDist and M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][3] >= tPondSubtable[subrefPondMinZ] - iMaxBrainDist and M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][3] <= tPondSubtable[subrefPondMaxZ] + iMaxBrainDist then
                                table.insert(tPondSubtable[subrefPondSize][subrefPondNearbyBrains], oBrain)
                            end
                        end
                    end


                    --Details of all mexes near enough to the pond to be of interest
                    for iMex, tMex in M27MapInfo.MassPoints do
                        bInRange = false

                        if tMex[1] >= tPondSubtable[subrefPondMinX] - iMaxMexDist and tMex[1] <= tPondSubtable[subrefPondMaxX] + iMaxMexDist and tMex[3] >= tPondSubtable[subrefPondMinZ] - iMaxMexDist and tMex[3] <= tPondSubtable[subrefPondMaxZ] + iMaxMexDist then
                            --See how far away the water is
                            for iEntry, iDist in tiDistToTry do
                                for iAngleAdjust = iAngleInterval, 360, iAngleInterval do
                                    tPossibleWaterPosition = M27Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true, true) --Gets terrainheight rather than surface height
                                    if M27MapInfo.IsUnderwater(tPossibleWaterPosition, false, M27MapInfo.iMinWaterDepth) then
                                        --Have a match, record the mex details:
                                        bInRange = true
                                        iCurMexDist = iDist

                                        --Record initial mex details:
                                        iPondMexCount = iPondMexCount + 1
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount] = {}
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexLocation] = { tMex[1], tMex[2], tMex[3] }

                                        --Do we expect to be able to hit the mex from here? a UEF Frigate y height is 1.1, while a t1 mex is 1.4; cant be bothered to check height of weapon and mex bone, and will vary based on how far away we are as well
                                        tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                        tShotEndPosition = { tMex[1], tMex[2] + 1.1, tMex[3] }

                                        iAOE = 0
                                        if iCurMexDist >= 30 then
                                            iAOE = 1
                                        end --most destroyers have an aoe attack (except sera)

                                        if M27Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, iAOE) then
                                            tShotStartPosition[2] = tShotStartPosition[2] + 8
                                            tShotEndPosition[2] = tShotEndPosition[2] + 8
                                            if M27Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                                --cant hit with df or indirect
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = 10000
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                            else
                                                --Can hit with indirect but not DF, so consider whether if we move further back we can then hit
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}

                                                --Find the point at which DF can hit, if any, in intervals of 5, assuming at max range we can hit
                                                local iMaxDistAdjust = math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5))
                                                tPossibleWaterPosition = M27Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iMaxDistAdjust, true, true)
                                                if M27MapInfo.IsUnderwater(tPossibleWaterPosition, false, M27MapInfo.iMinWaterDepth) then
                                                    tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                    if M27Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                                        --Assume wont find any match
                                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                                    else
                                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iMaxDistAdjust
                                                        --Refine the distance by moving closer
                                                        for iDFDistAdjust = 5, math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5)), 5 do
                                                            tPossibleWaterPosition = M27Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iDFDistAdjust, true, true)
                                                            tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                            if not (M27Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1)) then
                                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iDFDistAdjust
                                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                                                break
                                                            end
                                                        end
                                                    end
                                                else
                                                    --Assume wont find any match as if move really far back we are not on water
                                                    tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                                end
                                            end

                                            if bDebugMessages == true and tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] then
                                                LOG(sFunctionRef .. ' Drawing start in white and end in orangy pink')
                                                M27Utilities.DrawLocation({ tShotStartPosition[1], tShotStartPosition[2] - 8, tShotStartPosition[3] }, nil, 7, 100, nil)
                                                M27Utilities.DrawLocation({ tShotEndPosition[1], tShotEndPosition[2] - 8, tShotEndPosition[3] }, nil, 8, 100, nil)
                                            end
                                        else
                                            --DF can hit from cur position so assume indirect can as well
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iCurMexDist
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                        end

                                        --Refine the distance - see if can get any closer
                                        if iEntry == 1 then
                                            iPrevDist = 0
                                        else
                                            iPrevDist = tiDistToTry[iEntry - 1]
                                        end
                                        for iShortDist = iPrevDist + 1, iDist - 1, 1 do
                                            tPossibleWaterPosition = M27Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true)
                                            if M27MapInfo.IsUnderwater(tPossibleWaterPosition, false, M27MapInfo.iMinWaterDepth) then
                                                iCurMexDist = iShortDist
                                                break
                                            end
                                        end

                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDistance] = iCurMexDist

                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Finished recording mex in range for pond ' .. iPathingGroup .. '; iPondMexCount=' .. iPondMexCount .. '; full mex table of info=' .. repru(tPondSubtable[subrefPondMexInfo][iPondMexCount]))
                                        end
                                        break
                                    end
                                end
                                if bInRange then
                                    break
                                end
                            end
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considered Mex ' .. repru(tMex) .. '; bInRange=' .. tostring(bInRange))
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording all ponds, repr='..reprs(tPondDetails)) end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function RecordPondToExpandTo(aiBrain)
    --Calculates which pond we think is most important to hold
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPondToExpandTo'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    --if aiBrain:GetArmyIndex() == 7 or aiBrain:GetArmyIndex() == 6 then bDebugMessages = true end

    if M27Utilities.IsTableEmpty(tPondDetails) == false and not(aiBrain['M27ConsideredPonds']) then
        aiBrain['M27ConsideredPonds'] = true --Only do this once rather than every time we change nearest enemy
        aiBrain[reftiPondThreatToUs] = {}
        aiBrain[reftiPondValueToUs] = {}
        local iCurPondValue
        local iCurPondDefensiveValue --Value of mexes that are threatened by enemy if they get navy
        local iBestPondValue = 0
        local iBestPondRef

        local iDistanceThreshold = math.max(138, math.min(180, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.35))
        if not(aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand]) then iDistanceThreshold = iDistanceThreshold + 50 end

        local iFrigateRange = 28
        local iDestroyerRange = 60
        local iBattleshipRange = 128
        local iMissileShipRange = 150
        local iFrigateValue = 1
        local iDestroyerValue = 0.8
        local iBattleshipValue = 0.45
        local iMissileShipValue = 0.6

        local iEnemyDestroyerRange = 60
        local iEnemyBattleshipRange = 128
        local iEnemyMissileShipRange = 150


        if aiBrain:GetFactionIndex() == M27UnitInfo.refFactionUEF then
            iBattleshipRange = 150
        elseif aiBrain:GetFactionIndex() == M27UnitInfo.refFactionCybran then
            iDestroyerRange = 80
            iMissileShipRange = 0
        elseif aiBrain:GetFactionIndex() == M27UnitInfo.refFactionAeon then
            iMissileShipRange = 200
            iMissileShipValue = iBattleshipValue
            --Seraphim - no change to default
        end

        local iEnemyBrainIndex = M27Logic.GetNearestEnemyIndex(aiBrain)
        if iEnemyBrainIndex == M27UnitInfo.refFactionUEF then
            iEnemyBattleshipRange = 150
        elseif iEnemyBrainIndex == M27UnitInfo.refFactionCybran then
            iEnemyDestroyerRange = 80
            iEnemyMissileShipRange = 0
        elseif iEnemyBrainIndex == M27UnitInfo.refFactionAeon then
            iEnemyMissileShipRange = 200
        end

        if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; Start of logic to consider the best pond. Emergency range='..(aiBrain[M27Overseer.refiModDistEmergencyRange] or 'nil')..'; Dist to enemy base='..(aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] or 'nil')) end
        local iMinModDistanceWanted = math.max(aiBrain[M27Overseer.refiModDistEmergencyRange] + 5, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.4)
        local iMidModDistance = aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.5
        local iBelowMidFactor = 0.3 --Reudces value of mex that is closer to our base than enemy base to this %, assuming it is above the iMinModDistanceWanted
        local iCurMexValue
        local iCurMexDefensiveValue
        local iCurModDistance
        local iDefensiveModDistanceMaxValue = math.max(120, math.min(300, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.4))

        local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])

        for iCurPondRef, tPondSubtable in tPondDetails do
            if M27Utilities.IsTableEmpty(tPondSubtable) == false then --redundancy, should have already removed blank ponds in previous step
                iCurPondValue = 0
                iCurPondDefensiveValue = 0
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPondRef='..iCurPondRef..'; Repru of subtable='..repru(tPondSubtable)..'; ai brain start point='..repru(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) end

                --Is the pond within 175 of our start position?  First see if X is within distance threshold:
                if math.abs(tPondSubtable[subrefPondMinX] - M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1]) <= iDistanceThreshold or math.abs(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1] - tPondSubtable[subrefPondMaxX]) <= iDistanceThreshold or (M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1] >= tPondSubtable[subrefPondMinX] and M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1] <= tPondSubtable[subrefPondMaxX]) then
                    --X is in range, is Z?
                    if math.abs(tPondSubtable[subrefPondMinZ] - M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3]) <= iDistanceThreshold or math.abs(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3] - tPondSubtable[subrefPondMaxZ]) <= iDistanceThreshold or (M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3] >= tPondSubtable[subrefPondMinZ] and M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3] <= tPondSubtable[subrefPondMaxZ]) then
                        --X and Z are in range


                        for iMex, tMexInfo in tPondSubtable[subrefPondMexInfo] do
                            iCurMexValue = 0
                            iCurMexDefensiveValue = 0
                            if tMexInfo[subrefMexDFDistance] <= iBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then
                                --Can reach this mex with a ship, so it will have at least some value
                                if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexValue = iFrigateValue
                                elseif tMexInfo[subrefMexDFDistance] <= iDestroyerRange then iCurMexValue = iDestroyerValue
                                elseif tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then iCurMexValue = iMissileShipValue
                                else iCurMexValue = iBattleshipValue
                                end
                            end

                            --Adjust mex value based on distance
                            iCurModDistance = M27Overseer.GetDistanceFromStartAdjustedForDistanceFromMid(aiBrain, tMexInfo[subrefMexLocation])
                            if iCurMexValue > 0 then
                                if iCurModDistance <  iMinModDistanceWanted then iCurMexValue = 0
                                else
                                    if iCurModDistance < iMidModDistance then
                                        iCurMexValue = iCurMexValue * iBelowMidFactor
                                    end
                                end
                                iCurPondValue = iCurPondValue + iCurMexValue
                            end


                            --Get defensive value
                            if iCurModDistance <= iDefensiveModDistanceMaxValue then
                                if tMexInfo[subrefMexDFDistance] <= iEnemyBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then
                                    --Can reach this mex with a ship, so it will have at least some value
                                    if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexDefensiveValue = iFrigateValue
                                    elseif tMexInfo[subrefMexDFDistance] <= iEnemyDestroyerRange then iCurMexDefensiveValue = iDestroyerValue
                                    elseif tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then iCurMexDefensiveValue = iMissileShipValue
                                    else iCurMexDefensiveValue = iBattleshipValue
                                    end
                                end
                                iCurPondDefensiveValue = iCurPondDefensiveValue + iCurMexDefensiveValue
                            end

                        end

                        --Increase vlaue if in part of pond likely to be near enemy base
                        local tEnemyBase = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                        local iEnemyBaseThreshold = math.max(iBattleshipRange, iMissileShipRange - 10)
                        if math.abs(tPondSubtable[subrefPondMinX] - tEnemyBase[1]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[1] - tPondSubtable[subrefPondMaxX]) <= iEnemyBaseThreshold or (tEnemyBase[1] >= tPondSubtable[subrefPondMinX] and tEnemyBase[1] <= tPondSubtable[subrefPondMaxX]) then
                            --X is in range, is Z?
                            if math.abs(tPondSubtable[subrefPondMinZ] - tEnemyBase[3]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[3] - tPondSubtable[subrefPondMaxZ]) <= iEnemyBaseThreshold or (tEnemyBase[3] >= tPondSubtable[subrefPondMinZ] and tEnemyBase[3] <= tPondSubtable[subrefPondMaxZ]) then
                                iCurPondValue = math.max(iCurPondValue * 1.2, iCurPondValue + 2)
                                if bDebugMessages == true then LOG(sFunctionRef..': Can probably hit enemy base with navy so increasing pond value by 20%') end
                            end
                        end


                        if bDebugMessages == true then LOG(sFunctionRef..': Have a pond that is in range of our start position, value based on mexes in range pre adjust='..iCurPondValue) end
                        --Do we have sufficient value to consider?
                        if iCurPondValue >= 4 or iCurPondDefensiveValue >= 4 then
                            if iCurPondValue <= 0 then iCurPondValue = 0.1 end --Pond has defensive value so greater than 0
                            --Adjust value based on how close the naval build location would be for this pond
                            if not(tPondSubtable[subrefBuildLocationByStartPosition]) then
                                tPondSubtable[subrefBuildLocationByStartPosition] = {}
                            end
                            local tNavalBuildArea = {}
                            local iAngleToCentre = M27Utilities.GetAngleFromAToB(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], tPondSubtable[subrefPondMidpoint])
                            local iDistInterval = 8
                            local iBuildingInterval = 4
                            local tPossibleLocationBase
                            local tPossibleBuildLocation
                            local bHaveValidLocation = false
                            if bDebugMessages == true then LOG(sFunctionRef..': About to search for location to build naval factory for iCurPondRef='..iCurPondRef..'; iDistInterval='..iDistInterval..'; Angle='..iAngleToCentre..'; Midpoint='..repru(tPondSubtable[subrefPondMidpoint])..'; Start position='..repru(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) end
                            for iDistToTravel = iDistInterval, math.max(iDistInterval, math.floor(M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], tPondSubtable[subrefPondMidpoint]) / iDistInterval) * iDistInterval), iDistInterval do
                                for iAngleAdjust = 0, 170, 10 do
                                    for iAngleFactor = -1, 1, 2 do
                                        tPossibleLocationBase = M27Utilities.MoveInDirection(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], iAngleToCentre + iAngleAdjust * iAngleFactor, iDistToTravel, true, true)
                                        if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tPossibleLocationBase) == iCurPondRef then
                                            --Try and find somewhere around here to build a naval factory
                                            for iBuildingAdjustX = 0, iBuildingInterval, 1 do
                                                for iBuildingAdjustZ = 0, iBuildingInterval, 1 do
                                                    for iXFactor = -1, 1, 2 do
                                                        for iZFactor = -1, 1, 2 do
                                                            tPossibleBuildLocation = {tPossibleLocationBase[1] + iBuildingAdjustX * iXFactor, 0, tPossibleLocationBase[3] + iBuildingAdjustZ * iZFactor}
                                                            tPossibleBuildLocation[2] = GetSurfaceHeight(tPossibleBuildLocation[1], tPossibleBuildLocation[3])
                                                            if aiBrain:CanBuildStructureAt('ueb0103', tPossibleBuildLocation) then
                                                                bHaveValidLocation = true
                                                                tNavalBuildArea = {tPossibleBuildLocation[1], tPossibleBuildLocation[2], tPossibleBuildLocation[3]}
                                                                if bDebugMessages == true then
                                                                    LOG(sFunctionRef..': Have valid location='..repru(tPossibleBuildLocation)..'; will draw in white')
                                                                    M27Utilities.DrawLocation(tPossibleBuildLocation, nil, 1, 100, 2)
                                                                end
                                                                break
                                                            else
                                                                if bDebugMessages == true then
                                                                    LOG(sFunctionRef..': Have invalid location='..repru(tPossibleBuildLocation)..'; will draw in red')
                                                                    M27Utilities.DrawLocation(tPossibleBuildLocation, nil, 2, 100, 2)
                                                                end
                                                            end
                                                        end
                                                        if bHaveValidLocation then break end
                                                    end
                                                    if bHaveValidLocation then break end

                                                end
                                                if bHaveValidLocation then break end
                                            end
                                            if iAngleAdjust == 0 or bHaveValidLocation then break end
                                        elseif bDebugMessages == true then
                                            LOG(sFunctionRef..': Failed pathing group='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tPossibleLocationBase)..'; iCurPondRef='..iCurPondRef..'; Amphibious iPathingGroupWanted='..iPathingGroupWanted..'; will draw in gold')
                                            M27Utilities.DrawLocation(tPossibleLocationBase, nil, 4, 100, 2)
                                        end
                                        if bHaveValidLocation then break end
                                    end
                                    if bHaveValidLocation then break end
                                end
                                if bHaveValidLocation then break end
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': Finsihed searching for naval build area, is table empty='..tostring(M27Utilities.IsTableEmpty(tNavalBuildArea))) end


                            if M27Utilities.IsTableEmpty(tNavalBuildArea) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': tNavalBuildArea pre adjust='..repru(tNavalBuildArea)) end
                                --Move towards base to help with cliff building if we have cliffs
                                local bHaveNearbyCliff = false
                                local iDistToMoveTarget = M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], tNavalBuildArea)
                                local iAngleFromTarget = M27Utilities.GetAngleFromAToB(tNavalBuildArea, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                local tCliffPositionCheck
                                local sPathing = M27UnitInfo.refPathingTypeAmphibious
                                local iStartPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(sPathing,M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])

                                if iDistToMoveTarget > 1 then
                                    for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                        tCliffPositionCheck = M27Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false)
                                        if not(M27MapInfo.GetSegmentGroupOfLocation(sPathing, tCliffPositionCheck) == iStartPathingGroup) then
                                            bHaveNearbyCliff = true
                                            break
                                        end

                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bHaveNearbyCliff='..tostring(bHaveNearbyCliff)) end
                                if bHaveNearbyCliff then
                                    --Try to move closer to base
                                    local tLastValidPosition = {tNavalBuildArea[1], tNavalBuildArea[2], tNavalBuildArea[3]}
                                    local tAlternativePosition

                                    for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                        tAlternativePosition = M27Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false)
                                        if not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tAlternativePosition) == iCurPondRef) then
                                            break
                                        else
                                            --Can we build here?
                                            if aiBrain:CanBuildStructureAt('ueb0103', tAlternativePosition) then
                                                tLastValidPosition = {tAlternativePosition[1], tAlternativePosition[2], tAlternativePosition[3]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have an alternative position that is closer to our base, iDistAdjust='..iDistAdjust) end
                                            else
                                                break
                                            end
                                        end
                                    end
                                    tNavalBuildArea = tLastValidPosition


                                end



                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Have a naval build area='..repru(tNavalBuildArea)..'; will draw large square around it in blue')
                                    M27Utilities.DrawLocation(tNavalBuildArea, nil, nil, 200, 10)
                                end
                                tPondSubtable[subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber] = tNavalBuildArea

                                --Record pond value before distance adjustments - i.e. if we already have navy somewhere, this is how much the pond is worth to us
                                aiBrain[reftiPondValueToUs][iCurPondRef] = iCurPondValue
                                --Adjust pond value based on distance to us - used only for decision on whether to choose as a pond we want


                                --Can we path here amphibiously?
                                if not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, tNavalBuildArea) == iPathingGroupWanted) then
                                    iCurPondValue = 0
                                    if bDebugMessages == true then LOG(sFunctionRef..': We cant path here amphibiously') end
                                else
                                    --Adjust value based on distance
                                    local iDistToBuildArea = M27Utilities.GetDistanceBetweenPositions(tNavalBuildArea, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                    if iDistToBuildArea <= 50 then iCurPondValue = iCurPondValue * 1.1
                                    else
                                        iCurPondValue = iCurPondValue * math.max(0.1, 1 - 0.4 * iDistToBuildArea / iDistanceThreshold)
                                    end

                                    --Are we close enough to enemy base to be in danger and we can land path to enemy base?
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dist to nearest enemy base='..aiBrain[M27Overseer.refiDistanceToNearestEnemyBase]..'; Can path with land='..tostring(aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand])..'; Dist from naval build location to enemy base='..M27Utilities.GetDistanceBetweenPositions(tNavalBuildArea, M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain))) end
                                    if aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand] then
                                        --Reduce value of pond if enemy base is close for land anyway
                                        if aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] <= 300 then
                                            iCurPondValue = iCurPondValue * 0.5
                                        end
                                        if M27Utilities.GetDistanceBetweenPositions(tNavalBuildArea, M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)) <= 200 then
                                            iCurPondValue = 0
                                        end
                                    end
                                end
                            else
                                iCurPondValue = 0
                            end
                            aiBrain[reftiPondThreatToUs][iCurPondRef] = iCurPondDefensiveValue
                            if bDebugMessages == true then LOG(sFunctionRef..': Pond value after getting naval build area='..iCurPondValue..'; Defensive value='..(aiBrain[reftiPondThreatToUs][iCurPondRef] or 'nil')) end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Pond value is too low to be worth considering') end
                            iCurPondValue = 0
                        end
                    end
                end
                if iCurPondValue > iBestPondValue then
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating the best pond ref to be '..iCurPondRef..'; as the cur pond value '..iCurPondValue..' is more than the prev best of '..iBestPondValue) end
                    iBestPondRef = iCurPondRef
                    iBestPondValue = iCurPondValue

                end
            end
        end
        if iBestPondRef and iBestPondValue >= 4 then
            aiBrain[refiPriorityPondRef] = iBestPondRef
            if bDebugMessages == true then
                LOG(sFunctionRef..': Have a priority pond ref='..aiBrain[refiPriorityPondRef]..'; will draw a square in orangy pink for the build position='..repru(tPondDetails[aiBrain[refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber]))
                M27Utilities.DrawLocation(tPondDetails[aiBrain[refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber], nil, 8, 200, 10)
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function RemoveUnitFromAssignedPond(oUnit)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RemoveUnitFromAssignedPond'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if oUnit[refiAssignedPond] then --redundancy
        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
        if oUnit[reftiTeamRefsUpdatedFor] then
            local aiBrain = oUnit:GetAIBrain()
            local iFriendlyTeamRef
            if aiBrain.M27AI then iFriendlyTeamRef = aiBrain.M27Team end
            if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyTeamRef='..(iFriendlyTeamRef or 'nil')..'; Assigend pond='..(oUnit[refiAssignedPond] or 'nil')) end

            if not(oUnit[refiAssignedPond] == 0) then
                for iM27TeamUpdatingFor, bValue in  oUnit[reftiTeamRefsUpdatedFor] do
                    if iFriendlyTeamRef == iM27TeamUpdatingFor then
                        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][oUnit[refiAssignedPond]]) == false then --redundancy
                            for iRecordedUnit, oRecordedUnit in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][oUnit[refiAssignedPond]] do
                                if oRecordedUnit == oUnit then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' from list of friendly units in pond '..oUnit[refiAssignedPond]..' for team '..aiBrain.M27Team) end
                                    table.remove(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][oUnit[refiAssignedPond]], iRecordedUnit)
                                    break
                                end
                            end
                        end
                    else
                        if M27Utilities.IsTableEmpty(M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][oUnit[refiAssignedPond]]) == false then --redundancy
                            for iRecordedUnit, oRecordedUnit in M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][oUnit[refiAssignedPond]] do
                                if oRecordedUnit == oUnit then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' from list of enemy units in pond '..oUnit[refiAssignedPond]..' for team '..iM27TeamUpdatingFor) end
                                    table.remove(M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][oUnit[refiAssignedPond]], iRecordedUnit)
                                    break
                                end
                            end
                        end
                    end
                end
            end
            oUnit[reftiTeamRefsUpdatedFor] = {}
        end
        oUnit[refiAssignedPond] = nil
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function AddUnitToPond(oUnit, iCurPond, iM27TeamUpdatingFor, bIsEnemy)
    --Updates table of friendly and enemy units for oUnit; only records units if they are in a recognised pond

    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'AddUnitToPond'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPond='..iCurPond..'; iM27TeamUpdatingFor='..iM27TeamUpdatingFor..'; bIsEnemy='..tostring((bIsEnemy or false))..'; repr of oUnit[reftiTeamRefsUpdatedFor]='..repru(oUnit[reftiTeamRefsUpdatedFor])..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end

    if not(oUnit[reftiTeamRefsUpdatedFor]) then
        oUnit[reftiTeamRefsUpdatedFor] = {}
    end

    function AddToFriendlyUnitList()

        if not(iCurPond == 0) then
            if not(M27Team.tTeamData[oUnit:GetAIBrain().M27Team][M27Team.reftFriendlyUnitsByPond][iCurPond]) then M27Team.tTeamData[oUnit:GetAIBrain().M27Team][M27Team.reftFriendlyUnitsByPond][iCurPond] = {} end
            table.insert(M27Team.tTeamData[oUnit:GetAIBrain().M27Team][M27Team.reftFriendlyUnitsByPond][iCurPond], oUnit)
        end
        oUnit[reftiTeamRefsUpdatedFor][oUnit:GetAIBrain().M27Team] = true
    end

    if bIsEnemy then

        oUnit[reftiTeamRefsUpdatedFor][iM27TeamUpdatingFor] = true
        if not(iCurPond == 0) then
            if not(M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][iCurPond]) then M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][iCurPond] = {} end
            table.insert(M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][iCurPond], oUnit)
        end
        if not(oUnit[refiAssignedPond]) and oUnit:GetAIBrain().M27AI then
            AddToFriendlyUnitList()
        end

    else
        AddToFriendlyUnitList()
    end

    oUnit[refiAssignedPond] = iCurPond
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function UpdateUnitPond(oUnit, iM27TeamUpdatingFor, bIsEnemy, iPondRefOverride)
    --Check the unit's pond; ignore this for non-M27 friendly units
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPond'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    --if oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit) == 'xes02051' and oUnit:GetAIBrain():GetArmyIndex() == 2 and GetGameTimeSeconds() >= 840 then bDebugMessages = true end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, bIsEnemy='..tostring((bIsEnemy or false))..'; Unit brain index='..oUnit:GetAIBrain():GetArmyIndex()..'; Unit assigned pond='..(oUnit[refiAssignedPond] or 'nil')..'; Contains fixed pond category='..tostring(EntityCategoryContains(M27UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId))) end

    if bIsEnemy or (oUnit:GetAIBrain().M27AI and (not(oUnit[refiAssignedPond]) or not(EntityCategoryContains(M27UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId)))) then --and not(oUnit[reftiTeamRefsUpdatedFor][iM27TeamUpdatingFor])) then
        local iCurPond = iPondRefOverride or M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': bIsEnemy='..tostring(bIsEnemy)..'; Updating for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPondRefOverride='..(iPondRefOverride or 'nil')..'; iCurPond='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end --LOG('iCurPond pre adj='..(iCurPond or 'nil'))
        --if tPondDetails[iCurPond] then LOG('Pond size='..(tPondDetails[iCurPond][subrefPondSize] or 'nil')) end
        if not(tPondDetails[iCurPond]) or (tPondDetails[iCurPond][subrefPondSize] or 0) <= iMinPondSize then
            --If have a naval unit that isnt amphibious then update pathing
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have details for the pond recorded, if its a naval unit then will check for if there is a pond nearby') end
            if EntityCategoryContains(categories.NAVAL * categories.MOBILE - categories.HOVER - categories.AMPHIBIOUS - categories.AIR - categories.LAND, oUnit.UnitId) then
                iCurPond = CheckForPondNearNavalUnit(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after checking for pond near naval unit='..iCurPond) end
            else
                iCurPond = 0
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after updating for naval unit and min pond size='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end
        if iCurPond > 0 then
            oUnit[M27UnitInfo.reftLastKnownPosition] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Updated unit last known position') end
        end
        if oUnit[refiAssignedPond] then
            if not(iCurPond == oUnit[refiAssignedPond]) then
                if bDebugMessages == true then LOG('Removing unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' from old pond '..(oUnit[refiAssignedPond] or 'nil')..' and adding to new pond iCurPond='..iCurPond) end
                RemoveUnitFromAssignedPond(oUnit)
                AddUnitToPond(oUnit, iCurPond, iM27TeamUpdatingFor, bIsEnemy)
            elseif not(oUnit[reftiTeamRefsUpdatedFor][iM27TeamUpdatingFor]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM27TeamUpdatingFor, bIsEnemy)
            end
        else
            if iCurPond > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM27TeamUpdatingFor, bIsEnemy)
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetPrimaryEnemyPondBaseLocation(aiBrain, iPond)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPrimaryEnemyPondBaseLocation'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPond='..iPond..'; Is priamry enemy naval unit valid='..tostring(M27UnitInfo.IsUnitValid(M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryEnemyNavalUnitByPond][iPond]))..'; Time since last updated='..GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastEnemyNavalBaseUpdateByPond][iPond] or -100)) end

    if M27UnitInfo.IsUnitValid(M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryEnemyNavalUnitByPond][iPond]) and GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastEnemyNavalBaseUpdateByPond][iPond] or -100) < 5 then
        if bDebugMessages == true then LOG(sFunctionRef..': Still have valid enemy priamry naval unit so will retrun stored value='..repru(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond])) end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond]
    elseif GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastEnemyNavalBaseUpdateByPond][iPond] or -100) < 5 and M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond]) and M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Not long since last did this so will return stored value='..repru(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond])) end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond]
    else
        --Want to update - either unit has changed or it has been at least 5s since we last updated
        M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastEnemyNavalBaseUpdateByPond][iPond] = GetGameTimeSeconds()
        local tOurBase = M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond]


        --Does the enemy have no units? If so, then get the enemy base furthest away
        local oEnemyFocusUnit
        local tEnemyBase
        if bDebugMessages == true then LOG(sFunctionRef..': Will refresh the locaiton. tOurBase='..repru(tOurBase)..'; Is table of enemy units for pond '..iPond..' empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond]))) end
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond]) == false then
            local tEnemyFactories = EntityCategoryFilterDown(M27UnitInfo.refCategoryNavalFactory, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond])
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy factories empty='..tostring(M27Utilities.IsTableEmpty(tEnemyFactories))) end
            if M27Utilities.IsTableEmpty(tEnemyFactories) then
                --Does the enemy have T2+ navy? If so then pick the furthest away such unit as the 'base'
                local tEnemyT2PlusNavy = EntityCategoryFilterDown(M27UnitInfo.refCategoryAllNavy - categories.TECH1, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond])
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy T2plus navy empty='..tostring(M27Utilities.IsTableEmpty(tEnemyT2PlusNavy))) end
                if M27Utilities.IsTableEmpty(tEnemyT2PlusNavy) == false then
                    local iFurthestDist = 0
                    local iCurDist
                    for iUnit, oUnit in tEnemyT2PlusNavy do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions((oUnit[M27UnitInfo.reftLastKnownPosition] or oUnit:GetPosition()), tOurBase)
                        if iCurDist > iFurthestDist then
                            iFurthestDist = iCurDist
                            oEnemyFocusUnit = oUnit
                        end
                    end

                else

                    --Enemy has no T2+ navy and no naval factories, target nearest naval unit of any kind
                    local iCurDist
                    local iClosestDist = 100000
                    for iUnit, oUnit in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond] do
                        if M27UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit[M27UnitInfo.reftLastKnownPosition] or oUnit:GetPosition(), tOurBase)
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oEnemyFocusUnit = oUnit
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has no factories or T2plus navy, will just get any unit as focus unit. Is unit valid='..tostring(M27UnitInfo.IsUnitValid(oEnemyFocusUnit))) end
                end
            else
                --Enemy has naval factory; Get the highest tech nearest naval factory
                local iHighestEnemyNavalFac = 1
                for iUnit, oUnit in tEnemyFactories do
                    iHighestEnemyNavalFac = math.max(M27UnitInfo.GetUnitTechLevel(oUnit), iHighestEnemyNavalFac)
                    if iHighestEnemyNavalFac >= 3 then break end
                end

                local tHighestFactories = EntityCategoryFilterDown(M27UnitInfo.ConvertTechLevelToCategory(iHighestEnemyNavalFac), tEnemyFactories)
                local iCurDist
                local iClosestDist = 100000
                for iUnit, oUnit in tHighestFactories do
                    iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oEnemyFocusUnit = oUnit
                    end
                end
            end
        else
            --No enemy units so need to get base baesd on aibrain start position - will do later as do this if no T2+ naval units as well
        end

        if not(M27UnitInfo.IsUnitValid(oEnemyFocusUnit)) and not(tEnemyBase) then
            --Get furthest away enemy brain naval build location
            if bDebugMessages == true then LOG(sFunctionRef..': Will get furthest away enemy base build location as no enemy focus unit or enemy base') end
            local iFurthestDist = 0
            local iCurDist
            if M27Utilities.IsTableEmpty(tPondDetails[iPond][subrefBuildLocationByStartPosition]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': All start positions for pond '..iPond..'='..repru(tPondDetails[iPond][subrefBuildLocationByStartPosition])..'; will now find out if any belong to enemy brains') end
                for iBrain, oBrain in aiBrain[M27Overseer.toEnemyBrains] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..': Index='..oBrain:GetArmyIndex()..'; Start position='..(oBrain.M27StartPositionNumber or 'nil')) end
                    if M27Utilities.IsTableEmpty(tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber]) == false then
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber], tOurBase)
                        if iCurDist > iFurthestDist then
                            tEnemyBase = {tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber][1], tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber][2], tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber][3]}
                            iFurthestDist = iCurDist
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tEnemyBase after checking for pond build locations='..repru(tEnemyBase)) end
            if not(tEnemyBase) then
                --Dont have a build location for the naval pond, use the nearest enemy aiBrain base itself as the pond base
                if bDebugMessages == true then LOG(sFunctionRef..': Dont have enemy pond build location so will try and determine the closest enemy brain base') end
                local iClosestDist = 100000
                for iBrain, oBrain in aiBrain[M27Overseer.toEnemyBrains] do
                    iCurDist = M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber], tOurBase)
                    if iCurDist < iClosestDist then
                        tEnemyBase = {M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][1], M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][2], M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][3]}
                        iClosestDist = iCurDist
                    end
                end
            end
        end


        M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryEnemyNavalUnitByPond][iPond] = oEnemyFocusUnit --i.e. sets to nil if no focus unit
        if oEnemyFocusUnit then
            M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond] = (oEnemyFocusUnit[M27UnitInfo.reftLastKnownPosition] or oEnemyFocusUnit:GetPosition())
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return {M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond][1], M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond][2], M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond][3]}
        else
            M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond] = { tEnemyBase[1], tEnemyBase[2], tEnemyBase[3] }
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return tEnemyBase
        end
    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd) --redundancy
end


function GetPrimaryNavalFactory(aiBrain, iPond)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPrimaryNavalFactory'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code. do we already have a valid primary naval factory for pond '..iPond..'='..tostring(M27UnitInfo.IsUnitValid(M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond]))..'; Time of last update='..GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][iPond][M27Team.refiTimeOfLastPrimaryNavalUpdateByPond] or -100)) end
    if M27UnitInfo.IsUnitValid(M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond]) and GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][iPond][M27Team.refiTimeOfLastPrimaryNavalUpdateByPond] or -100) < 5 then
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond]
    else
        local iDistanceCap = 200
        local oPrimaryFactory
        local oPreviousPrimary = M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond]
        if not(M27UnitInfo.IsUnitValid(oPreviousPrimary)) then oPreviousPrimary = nil end
        if bDebugMessages == true then LOG(sFunctionRef..': Is the table of friendly units for this pond empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond]))) end
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond]) then
            --Will return nil
        else
            local tExistingNavalFactory = EntityCategoryFilterDown(M27UnitInfo.refCategoryNavalFactory, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond])
            local tFactoriesCloseToNavalBase = {}
            local tNavalBase = tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber]
            if M27Utilities.IsTableEmpty(tNavalBase) then
                --Do we have teammates with a naval base start position?
                for iBrain, oBrain in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyActiveM27Brains] do
                    tNavalBase = tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber]
                    if M27Utilities.IsTableEmpty(tNavalBase) == false then break end
                end
                if M27Utilities.IsTableEmpty(tNavalBase) then
                    --Try all defeated M27 brains
                    for iBrain, oBrain in ArmyBrains do
                        if oBrain.M27AI and oBrain.M27IsDefeated and IsAlly(aiBrain:GetArmyIndex(), oBrain:GetArmyIndex()) then
                            tNavalBase = tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber]
                            if M27Utilities.IsTableEmpty(tNavalBase) == false then break end
                        end
                    end
                    if M27Utilities.IsTableEmpty(tNavalBase) then

                        --Just use our start position
                        M27Utilities.ErrorHandler('Couldnt find naval build location for any teammate so will just use our start position to avoid error')
                        tNavalBase = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                    end
                end
            end
            local iCurTechLevel

            if bDebugMessages == true then LOG(sFunctionRef..': Is the table of naval factories empty='..tostring(M27Utilities.IsTableEmpty(tExistingNavalFactory))) end

            if M27Utilities.IsTableEmpty(tExistingNavalFactory) == false then
                local iHighestTechFactory = 1
                for iFactory, oFactory in tExistingNavalFactory do
                    if M27UnitInfo.IsUnitValid(oFactory) then
                        iCurTechLevel = M27UnitInfo.GetUnitTechLevel(oFactory)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering factory '..oFactory.UnitId..M27UnitInfo.GetUnitLifetimeCount(oFactory)..'; Dist to naval base='..M27Utilities.GetDistanceBetweenPositions(oFactory:GetPosition(), tNavalBase)..'; iDistanceCap='..iDistanceCap) end

                        if M27Utilities.GetDistanceBetweenPositions(oFactory:GetPosition(), tNavalBase) <= iDistanceCap then
                            iHighestTechFactory = math.max(iHighestTechFactory, M27UnitInfo.GetUnitTechLevel(oFactory))
                            table.insert(tFactoriesCloseToNavalBase, oFactory)
                        end
                    end
                end

                if M27Utilities.IsTableEmpty(tFactoriesCloseToNavalBase) then tFactoriesCloseToNavalBase = tExistingNavalFactory end
                if M27UnitInfo.GetUnitTechLevel(oPreviousPrimary) >= iHighestTechFactory and M27UnitInfo.IsUnitValid(oPreviousPrimary) then
                    oPrimaryFactory = oPreviousPrimary
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of factories close to naval base empty='..tostring(M27Utilities.IsTableEmpty(tFactoriesCloseToNavalBase))) end
                    if M27Utilities.IsTableEmpty(tFactoriesCloseToNavalBase) == false then

                        local iClosestDistToTarget = 10000
                        local iCurDistToTarget

                        for iFactory, oFactory in tFactoriesCloseToNavalBase do
                            if not(oPrimaryFactory) then oPrimaryFactory = oFactory end --Redundancy in case below fails to find anything
                            if oFactory:IsUnitState('Upgrading') then
                                oPrimaryFactory = oFactory
                                break
                            else
                                if M27UnitInfo.GetUnitTechLevel(oFactory) >= iHighestTechFactory then
                                    iCurDistToTarget = M27Utilities.GetDistanceBetweenPositions(oFactory:GetPosition(), tNavalBase)
                                    if iCurDistToTarget < iClosestDistToTarget then
                                        iClosestDistToTarget = iCurDistToTarget
                                        oPrimaryFactory = oFactory
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Have we got a valid primary factory now='..tostring(M27UnitInfo.IsUnitValid(oPrimaryFactory))) end
            if oPrimaryFactory then
                M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond] = oPrimaryFactory:GetPosition()
            end
        end

        M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond] = oPrimaryFactory
        if oPrimaryFactory then M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastPrimaryNavalUpdateByPond][iPond] = GetGameTimeSeconds()
        else
            --No primary factory - set a base location if we dont have one already
            if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond]) then
                if M27Utilities.IsTableEmpty(tPondDetails[iPond][subrefBuildLocationByStartPosition]) or M27Utilities.IsTableEmpty(tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber]) then
                    M27Utilities.ErrorHandler('Dont have a build location for our start position, will just set the backup location to be our base')
                    M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond] = {M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][2], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3]}
                else

                    M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond] = {tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber][1], tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber][2], tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber][3]}
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Returning primary naval factory '..(oPrimaryFactory.UnitId or 'nil')..(M27UnitInfo.GetUnitLifetimeCount(oPrimaryFactory) or 'nil')) end

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return oPrimaryFactory
    end
end

function ReassignNavalEngineer(oEngineer)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReassignNavalEngineer'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --Intended to give an order to an engineer already assigned to a pond, on a team basis
    --Note - this doesnt decide original assignment - that is done in the main engineer reassignment code; once an engineer has been assigned to pond naval duties though this function takes over

    --if M27EngineerOverseer.GetEngineerUniqueCount(oEngineer) == 21 and GetGameTimeSeconds() >= 600 then bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, for oEngineer='..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..M27EngineerOverseer.GetEngineerUniqueCount(oEngineer)..'; Pond assigned='..(oEngineer[refiAssignedPond] or 'nil')..'; Engineer unit state='..M27Logic.GetUnitState(oEngineer)) end

    local aiBrain = oEngineer:GetAIBrain()
    local oPrimaryFactory = GetPrimaryNavalFactory(aiBrain, oEngineer[refiAssignedPond])
    if not(oPrimaryFactory) then
        --No naval factories near us so no longer have the engineer assigned to the pond
        oEngineer[refiAssignedPond] = nil
        M27Utilities.IssueTrackedClearCommands({oEngineer})
        M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngineer, true)
        if bDebugMessages == true then LOG(sFunctionRef..': No naval factory so clearing engineer assigned pond and trackers') end
    else
        local oActionTargetObject
        local iCurLoopCount = 0
        local iCurrentConditionToTry = 0
        local iCurLandFactories = 0
        local iMaxEngisWanted
        local iActionToAssign
        local iMinEngiTechLevelWanted = 1
        local iSearchRangeForNearestEngi
        local iExistingEngineersAssigned
        local oExistingBuilder
        local tActionTargetLocation

        --Common conditions
        local bHaveLowMass = M27Conditions.HaveLowMass(aiBrain)
        local bHaveLowPower = false

        if aiBrain[M27EconomyOverseer.refbStallingEnergy] or GetGameTimeSeconds() - aiBrain[M27EconomyOverseer.refiLastEnergyStall] <= 20 then
            if bDebugMessages == true then LOG(sFunctionRef..': Have low power as recently stalled') end
            bHaveLowPower = true
        else
            if aiBrain:GetEconomyStoredRatio('ENERGY') < 0.99 and (aiBrain:GetEconomyStored('ENERGY') < 1000 or aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome] <= 0) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have low power as dont have much stored') end
                bHaveLowPower = true
            end
        end
        if bHaveLowPower and aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= 50000 then bHaveLowPower = false end


        while iCurLoopCount <= 100 do
            iCurLoopCount = iCurLoopCount + 1
            if iCurLoopCount >= 99 then M27Utilities.ErrorHandler('Infinite loop') break end

            iCurrentConditionToTry = iCurrentConditionToTry + 1


            --Set defaults
            iMaxEngisWanted = 1
            iMinEngiTechLevelWanted = 1
            iActionToAssign = nil
            oExistingBuilder = nil
            tActionTargetLocation = nil

            if iCurrentConditionToTry == 1 then
                --Assist primary factory (so it mvoes closer)
                if M27Utilities.GetDistanceBetweenPositions(oPrimaryFactory:GetPosition(), oEngineer:GetPosition()) >= 150 then
                    iActionToAssign = M27EngineerOverseer.refActionAssistNavalFactory
                    oActionTargetObject = oPrimaryFactory
                    iMaxEngisWanted = 100
                end
            elseif iCurrentConditionToTry == 2 then
                iActionToAssign = M27EngineerOverseer.refActionAssistNavalFactory --always want some engis assisting naval factory
                oActionTargetObject = oPrimaryFactory
                --Primary factory is upgrading
                if oPrimaryFactory:IsUnitState('Upgrading') then
                    iMaxEngisWanted = 8 * M27UnitInfo.GetUnitTechLevel(oPrimaryFactory)
                    if bHaveLowMass then iMaxEngisWanted = iMaxEngisWanted * 0.5 end
                else
                    iMaxEngisWanted = 5 * M27UnitInfo.GetUnitTechLevel(oPrimaryFactory)
                    if bHaveLowMass then iMaxEngisWanted = iMaxEngisWanted * 0.5 end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Want to be assisting naval fac with iMaxEngisWanted='..iMaxEngisWanted) end
            elseif iCurrentConditionToTry == 3 then
                --Lack sonar
                if not(bHaveLowPower) then
                    local iSonarRangeWanted = 80
                    if M27UnitInfo.GetUnitTechLevel(oPrimaryFactory) >= 2 then iSonarRangeWanted = 180 end
                    local tSonarInPond = EntityCategoryFilterDown(M27UnitInfo.refCategorySonar, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][oEngineer[refiAssignedPond]])
                    local bHaveSonarCoverageWanted = false

                    if M27Utilities.IsTableEmpty(tSonarInPond) == false then
                        local iCurSonarRange
                        for iUnit, oUnit in tSonarInPond do
                            iCurSonarRange = oUnit:GetBlueprint().Intel.Sonar or 0
                            if iCurSonarRange >= iSonarRangeWanted and iCurSonarRange - M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oPrimaryFactory:GetPosition()) >= iSonarRangeWanted then
                                bHaveSonarCoverageWanted = true
                                break
                            end
                        end
                    end
                    if not(bHaveSonarCoverageWanted) then
                        if M27UnitInfo.GetUnitTechLevel(oPrimaryFactory) >= 2 then
                            iActionToAssign = M27EngineerOverseer.refActionBuildT2Sonar
                            iMinEngiTechLevelWanted = 2
                        else
                            iActionToAssign = M27EngineerOverseer.refActionBuildT1Sonar
                        end
                    end
                    if iActionToAssign then
                        iMaxEngisWanted = 3
                        if bHaveLowMass then iMaxEngisWanted = 1 end
                        tActionTargetLocation = oPrimaryFactory:GetPosition()
                    end
                end
            else --Spare action
                if bDebugMessages == true then LOG(sFunctionRef..': Issuing spare naval action') end
                iActionToAssign = M27EngineerOverseer.refActionNavalSpareAction
                iMaxEngisWanted = 100
            end

            if iActionToAssign then

                --Check we havent recently failed to assign this action
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Have iActionToAssign=' .. iActionToAssign)
                end
                if aiBrain[M27EngineerOverseer.refiTimeOfLastFailure][iActionToAssign] and GetGameTimeSeconds() - aiBrain[M27EngineerOverseer.refiTimeOfLastFailure][iActionToAssign] <= 9 then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Time since last failure=' .. GetGameTimeSeconds() - aiBrain[M27EngineerOverseer.refiTimeOfLastFailure][iActionToAssign])
                    end
                    iActionToAssign = nil
                end
            end
            if iActionToAssign then
                iExistingEngineersAssigned = 0
                if iActionToAssign and aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef] and aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][iActionToAssign] and M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][iActionToAssign]) == false then
                    --Cant use table.getn for this table so do manually:
                    for iRef, tEngSubtable in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][iActionToAssign] do
                        if tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][refiAssignedPond] == oEngineer[refiAssignedPond] then
                            iExistingEngineersAssigned = iExistingEngineersAssigned + 1
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Engineer assigned=' .. tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef].UnitId .. M27UnitInfo.GetUnitLifetimeCount(tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]) .. '; UC=' .. M27EngineerOverseer.GetEngineerUniqueCount(tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]) .. '; Engineer action=' .. (tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refiEngineerCurrentAction] or 'nil'))
                            end
                            if tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refbPrimaryBuilder] then
                                oExistingBuilder = tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]
                            end
                        end
                    end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iExistingEngineersAssigned=' .. iExistingEngineersAssigned .. '; iMaxEngisWanted=' .. iMaxEngisWanted)
                end
                if iExistingEngineersAssigned < iMaxEngisWanted then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Want to assign more engis, if action is to buidl factory then will tell engis to assist existing builder. iActionToAssign=' .. iActionToAssign .. '; iExistingEngineersAssigned=' .. iExistingEngineersAssigned)
                    end
                    if iActionToAssign == M27EngineerOverseer.refActionBuildNavalFactory and iExistingEngineersAssigned > 0 then
                        oActionTargetObject = oExistingBuilder
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Will tell engis to assist existing builder ' .. oExistingBuilder.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oExistingBuilder))
                        end
                    end
                    if not(tActionTargetLocation) then
                        if oActionTargetObject then tActionTargetLocation = oActionTargetObject:GetPosition()
                        else
                            tActionTargetLocation = oEngineer:GetPosition()
                        end
                    end

                    --if are building a factory then check if already have engineer assigned, in which case will assist that
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': About to assign ' .. iActionToAssign .. ' action to the engineer ' .. oEngineer.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oEngineer) .. '; UC=' .. M27EngineerOverseer.GetEngineerUniqueCount(oEngineer))
                        if oActionTargetObject then LOG(sFunctionRef..': oActionTargetObject='..(oActionTargetObject.UnitId..M27UnitInfo.GetUnitLifetimeCount(oActionTargetObject))) end
                    end

                    M27EngineerOverseer.AssignActionToEngineer(aiBrain, oEngineer, iActionToAssign, tActionTargetLocation, oActionTargetObject, iCurrentConditionToTry)
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Too many engineers assigned so will change action to nil') end
                    iActionToAssign = nil
                end
            end

            if iActionToAssign then
                break
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ShouldWeRefreshUnitOrder(oUnit, iOrderType, tOrderLocation, oOrderUnit)
    local bRefreshOrder = true

    if oUnit[M27UnitInfo.refbSpecialMicroActive] then
        bRefreshOrder = false
    else
        if oUnit[M27PlatoonUtilities.refiLastOrderType] == iOrderType then
            if oOrderUnit then
                if oOrderUnit == oUnit[M27UnitInfo.refoLastOrderUnitTarget] and not(M27Logic.IsUnitIdle(oUnit, false, true, false, false)) then
                    bRefreshOrder = false
                end
            else
                --LOG('ShouldWeRefresh: Unit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; tOrderLocation='..repru(tOrderLocation)..'; Unit last order target='..repru(oUnit[M27UnitInfo.reftLastOrderTarget]))
                local iDistThreshold = 5
                if EntityCategoryContains(M27UnitInfo.refCategoryMobileLandShield, oUnit.UnitId) then iDistThreshold = 2.5
                elseif iOrderType == M27PlatoonUtilities.refiOrderIssueGroundAttack then iDistThreshold = 0.5
                end
                if ((oUnit[M27UnitInfo.refiDFRange] or 0) > 100 or (oUnit[M27UnitInfo.refiIndirectRange] or 0) > 100) and M27Utilities.GetAngleDifference(M27Utilities.GetAngleFromAToB(oUnit:GetPosition(), oUnit[M27UnitInfo.reftLastOrderTarget]), M27Utilities.GetAngleFromAToB(oUnit:GetPosition(), tOrderLocation)) <= 23 then iDistThreshold = 30 end
                if M27Utilities.GetDistanceBetweenPositions(tOrderLocation, oUnit[M27UnitInfo.reftLastOrderTarget]) <= iDistThreshold then
                    if not(M27Logic.IsUnitIdle(oUnit, false, true, false, false)) then
                        bRefreshOrder = false
                    end
                end
            end
        end
    end
    return bRefreshOrder
end

function MoveUnitTowardsTarget(oUnit, tTarget, bAttackMove, sOrderDesc)
    --sOrderDesc - used to update unit name for debugging

    --Do we want to change the current order?
    local iOrderType
    if bAttackMove then
        iOrderType = M27PlatoonUtilities.refiOrderIssueAggressiveMove
    else
        iOrderType = M27PlatoonUtilities.refiOrderIssueMove
    end
    local tAltTarget
    if oUnit[M27UnitInfo.refiTimeConstructed] and GetGameTimeSeconds() - oUnit[M27UnitInfo.refiTimeConstructed] <= 30 then
        if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTarget) >= 250 then
            local tAltTarget = M27Utilities.MoveInDirection(oUnit:GetPosition(), M27Utilities.GetAngleFromAToB(oUnit:GetPosition(), tTarget), 250, true, false)
            if not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tTarget) == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tAltTarget)) then
                tAltTarget = nil
            else
                sOrderDesc = sOrderDesc..'Alt'
            end
        end
    end
    local bRefreshOrder = ShouldWeRefreshUnitOrder(oUnit, iOrderType, (tAltTarget or tTarget), nil)
    --LOG('Move Unit Towards Target: oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; bRefreshOrder='..tostring(bRefreshOrder)..'; sOrderDesc='..(sOrderDesc or 'nil')..'; iOrderType='..iOrderType..'; bAttackMove='..tostring(bAttackMove)..'; Unit last order type='..(oUnit[M27PlatoonUtilities.refiLastOrderType] or 'nil')..'; Distance to last target='..M27Utilities.GetDistanceBetweenPositions((oUnit[M27UnitInfo.reftLastOrderTarget] or {0,0,0}), tTarget)..'; tAltTarget='..repru(tAltTarget)..'; tTarget='..repru(tTarget))
    if bRefreshOrder then
        M27Utilities.IssueTrackedClearCommands({oUnit})
        oUnit[M27UnitInfo.refoLastOrderUnitTarget] = nil
        if bAttackMove then
            IssueAggressiveMove({oUnit}, (tAltTarget or tTarget))
        else
            IssueMove({oUnit}, (tAltTarget or tTarget))
        end
        oUnit[M27PlatoonUtilities.refiLastOrderType] = iOrderType
        if tAltTarget then
            oUnit[M27UnitInfo.reftLastOrderTarget] = {tAltTarget[1], tAltTarget[2], tAltTarget[3]}
        else
            oUnit[M27UnitInfo.reftLastOrderTarget] = {tTarget[1], tTarget[2], tTarget[3]}
        end
        if M27Config.M27ShowUnitNames then M27PlatoonUtilities.UpdateUnitNames({ oUnit}, oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..': Navy: '..(sOrderDesc or 'nil'), true) end
    end
end

function TellUnitToAttackTarget(oUnit, oTarget, sOrderDesc)
    local bRefreshOrder = ShouldWeRefreshUnitOrder(oUnit, M27PlatoonUtilities.refiOrderIssueAttack, oTarget:GetPosition(), oTarget)
    --LOG('TellUnitToAttackTarget: oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; oTarget='..oTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oTarget)..'; bRefreshOrder='..tostring(bRefreshOrder))
    if bRefreshOrder then
        M27Utilities.IssueTrackedClearCommands({oUnit})
        IssueAttack({oUnit}, oTarget)
        oUnit[M27PlatoonUtilities.refiLastOrderType] = M27PlatoonUtilities.refiOrderIssueAttack
        oUnit[M27UnitInfo.reftLastOrderTarget] = oTarget:GetPosition()
        oUnit[M27UnitInfo.refoLastOrderUnitTarget] = oTarget
        if M27Config.M27ShowUnitNames then M27PlatoonUtilities.UpdateUnitNames({ oUnit}, oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..': Navy: '..(sOrderDesc or 'nil'), true) end
    end
end

function TellUnitToAttackGround(oUnit, tPosition, sOrderDesc)
    local bRefreshOrder = ShouldWeRefreshUnitOrder(oUnit, M27PlatoonUtilities.refiOrderIssueGroundAttack, tPosition)
    --LOG('TellUnitToAttackTarget: oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; oTarget='..oTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oTarget)..'; bRefreshOrder='..tostring(bRefreshOrder))
    if bRefreshOrder then
        M27Utilities.IssueTrackedClearCommands({oUnit})
        IssueAttack({oUnit}, {tPosition[1], GetSurfaceHeight(tPosition[1], tPosition[3]), tPosition[3]})
        oUnit[M27PlatoonUtilities.refiLastOrderType] = M27PlatoonUtilities.refiOrderIssueGroundAttack
        oUnit[M27UnitInfo.reftLastOrderTarget] = tPosition
        oUnit[M27UnitInfo.refoLastOrderUnitTarget] = nil
        if M27Config.M27ShowUnitNames then M27PlatoonUtilities.UpdateUnitNames({ oUnit}, oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..': Navy: '..(sOrderDesc or 'nil'), true) end
    end
end

function RemoveShieldAssignment(oShield)
    local oUnitToSupport = oShield[refoSupportTarget]
    if M27UnitInfo.IsUnitValid(oUnitToSupport) and M27Utilities.IsTableEmpty(oUnitToSupport[reftoAssignedShields]) == false then
        for iSupportingShield, oSupportingShield in oUnitToSupport[reftoAssignedShields] do
            if oSupportingShield == oShield then
                table.remove(oUnitToSupport[reftoAssignedShields], iSupportingShield)
                break
            end
        end
    end
    oShield[refoSupportTarget] = nil
end
function RemoveStealthAssignment(oStealth)
    local oUnitToSupport = oStealth[refoSupportTarget]
    if M27UnitInfo.IsUnitValid(oUnitToSupport) and M27Utilities.IsTableEmpty(oUnitToSupport[reftoAssignedStealth]) == false then
        for iSupportingStealth, oSupportingStealth in oUnitToSupport[reftoAssignedStealth] do
            if oSupportingStealth == oStealth then
                table.remove(oUnitToSupport[reftoAssignedStealth], iSupportingStealth)
                break
            end
        end
    end
    oStealth[refoSupportTarget] = nil
end

function AddShieldAssignment(oUnitToSupport, oClosestShield, tOurBase)
    --Assignes closest shield to support oUnitToSupport and gets it to move there, by reference to our base
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddShieldAssignment'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if M27UnitInfo.IsUnitValid(oUnitToSupport) then --Redundancy
        --Are we already assigned a support target that is different? If so then remove cur assignment
        if oClosestShield[refoSupportTarget] then
            if not(oClosestShield[refoSupportTarget] == oUnitToSupport) then
                RemoveShieldAssignment(oClosestShield)
            end
        end
        oClosestShield[refoSupportTarget] = oUnitToSupport
        if not(oUnitToSupport[reftoAssignedShields]) then oUnitToSupport[reftoAssignedShields] = {} end
        table.insert(oUnitToSupport[reftoAssignedShields], oClosestShield)

        --Move the shield so it covers the unit if it doesnt already
        local iShieldRadius = oClosestShield:GetBlueprint().Defense.Shield.ShieldSize * 0.39 --e.g. shield boat shield doesnt actually cover 50% but is much shorter
        local iTargetSpeed = oUnitToSupport:GetBlueprint().Physics.MaxSpeed
        --local iDistToTarget = M27Utilities.GetDistanceBetweenPositions(oClosestShield:GetPosition(), oUnitToSupport:GetPosition())
        local iDistFromTarget = math.max(2, iShieldRadius - iTargetSpeed * 1.5)
        if iDistFromTarget <= 2 then iDistFromTarget = -2 end

        --if iDistFromTarget > 2 then
            local tMoveTarget = M27Utilities.MoveInDirection(oUnitToSupport:GetPosition(), M27Utilities.GetAngleFromAToB(oUnitToSupport:GetPosition(), tOurBase), iDistFromTarget, true, false)
            MoveUnitTowardsTarget(oClosestShield, tMoveTarget, false, 'S:'..oUnitToSupport.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToSupport))
            if bDebugMessages == true then LOG(sFunctionRef..': oClosestShield='..oClosestShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestShield)..'; oUnitToSupport='..oUnitToSupport.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToSupport)..'; Our position='..repru(oClosestShield:GetPosition())..'; Unit to support posiiton='..repru(oUnitToSupport:GetPosition())..'; Distance to position='..M27Utilities.GetDistanceBetweenPositions(oClosestShield:GetPosition(), oUnitToSupport:GetPosition())..'; iShieldRadius='..iShieldRadius..'; iTargetSpeed='..iTargetSpeed..'; iDistFromTarget='..iDistFromTarget..'; tMoveTarget='..repru(tMoveTarget)) end
        --else
            --Need to be so close to the target that probably want to be infront of it rather than behind - decided to leave as the lower speed means cant keep up

            --GuardTarget(oClosestShield, oUnitToSupport)
        --end
    else
        M27Utilities.ErrorHandler('Passed invalid unit to support for shield assignment')
    end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function AddStealthAssignment(oUnitToSupport, oClosestStealth, tOurBase)
    --Assignes closest stealth to support oUnitToSupport and gets it to move there, by reference to our base
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddStealthAssignment'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if M27UnitInfo.IsUnitValid(oUnitToSupport) then --Redundancy
        --Are we already assigned a support target that is different? If so then remove cur assignment
        if oClosestStealth[refoSupportTarget] then
            if not(oClosestStealth[refoSupportTarget] == oUnitToSupport) then
                RemoveStealthAssignment(oClosestStealth)
            end
        end
        oClosestStealth[refoSupportTarget] = oUnitToSupport
        if not(oUnitToSupport[reftoAssignedStealth]) then oUnitToSupport[reftoAssignedStealth] = {} end
        table.insert(oUnitToSupport[reftoAssignedStealth], oClosestStealth)

        --Move the stealth so it covers the unit if it doesnt already
        local iStealthRadius = oClosestStealth:GetBlueprint().Intel.RadarStealthFieldRadius * 0.8
        local iTargetSpeed = oUnitToSupport:GetBlueprint().Physics.MaxSpeed
        --local iDistToTarget = M27Utilities.GetDistanceBetweenPositions(oClosestStealth:GetPosition(), oUnitToSupport:GetPosition())
        local iDistFromTarget = math.max(2, iStealthRadius - iTargetSpeed * 1.5 - 3)
        if iDistFromTarget <= 2 then iDistFromTarget = -2 end

        --if iDistFromTarget > 2 then
        local tMoveTarget = M27Utilities.MoveInDirection(oUnitToSupport:GetPosition(), M27Utilities.GetAngleFromAToB(oUnitToSupport:GetPosition(), tOurBase), iDistFromTarget, true, false)
        MoveUnitTowardsTarget(oClosestStealth, tMoveTarget, false, 'St:'..oUnitToSupport.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToSupport))
        if bDebugMessages == true then LOG(sFunctionRef..': oClosestStealth='..oClosestStealth.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestStealth)..'; oUnitToSupport='..oUnitToSupport.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToSupport)..'; Our position='..repru(oClosestStealth:GetPosition())..'; Unit to support posiiton='..repru(oUnitToSupport:GetPosition())..'; Distance to position='..M27Utilities.GetDistanceBetweenPositions(oClosestStealth:GetPosition(), oUnitToSupport:GetPosition())..'; iStealthRadius='..iStealthRadius..'; iTargetSpeed='..iTargetSpeed..'; iDistFromTarget='..iDistFromTarget..'; tMoveTarget='..repru(tMoveTarget)..'; Distance to move target='..M27Utilities.GetDistanceBetweenPositions(tMoveTarget, oClosestStealth:GetPosition())) end
        --else
        --Need to be so close to the target that probably want to be infront of it rather than behind - decided to leave as the lower speed means cant keep up

        --GuardTarget(oClosestStealth, oUnitToSupport)
        --end
    else
        M27Utilities.ErrorHandler('Passed invalid unit to support for stealth assignment')
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end



function ManageTeamNavy(aiBrain, iTeam, iPond)
    --Decides what to do with our naval units, as well as recording information such as the nearest enemy naval unit

    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageTeamNavy'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if GetGameTimeSeconds() >= 900 and M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]) == false and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategorySubmarine * categories.TECH2, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])) == false then bDebugMessages = true M27Config.M27ShowUnitNames = true end
    --if GetGameTimeSeconds() >= 480 then bDebugMessages = true end
    --if GetGameTimeSeconds() >= 840 and (aiBrain:GetArmyIndex() == 2 or aiBrain:GetArmyIndex() == 4) then bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for iTeam='..iTeam..'; Brain='..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()..'; GameTime='..GetGameTimeSeconds()..'; iPond='..iPond) end

    local iNavalStrategy = M27Team.refiNavalStrategyRetreat --Default (e.g. including if we have no navy)



    local oClosestEnemyUnit
    local oClosestEnemyCombatUnit
    local oClosestSurfaceEnemy
    local oClosestEnemySurfaceCombat
    local oClosestSubmersibleEnemy
    local oClosestFriendlyUnitToEnemyBase

    local iFriendlyDistToEnemy
    local tOurBase

    local oPrimaryFactory = GetPrimaryNavalFactory(aiBrain, iPond)
    if oPrimaryFactory then tOurBase = oPrimaryFactory:GetPosition()
    else
        tOurBase = {M27Team.tTeamData[iTeam][M27Team.reftBackupBaseLocationByPond][iPond][1], M27Team.tTeamData[iTeam][M27Team.reftBackupBaseLocationByPond][iPond][2], M27Team.tTeamData[iTeam][M27Team.reftBackupBaseLocationByPond][iPond][3]}
    end

    local tEnemyBase = GetPrimaryEnemyPondBaseLocation(aiBrain, iPond)
    local iAngleToEnemy = M27Utilities.GetAngleFromAToB(tOurBase, tEnemyBase)

    local iMiniThreatThreshold = 0 --Threat level at which should treat a threat as a mini-threat that can be ignored by our main naval force
    local tMiniThreatEnemyUnits = {} --Enemy units that have so little threat we dont want to waste time attacking them with our main naval force
    local tEnemyNavalExcludingMiniThreats = {} --All enemy units in pond except for those classified as mini threats
    local tFriendlyNavalExcludingIntercept = {} --all units except those that are dealing with mini threats
    local tMiniThreatFriendlyUnits = {} --Units assigned to deal with enemy mini threat
    local refbMiniFriendlyUnit = 'M27NavyMinimalThreatFriendlyUnit' --true if unit has been assigned previously as part of a mini threat intercept force

    function ClearMiniThreatFlagFromAllAssignedUnits()
        if M27Utilities.IsTableEmpty(tMiniThreatFriendlyUnits) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Not attacking with mini response so will clear the flag from friendly units') end
            for iUnit, oUnit in tMiniThreatFriendlyUnits do
                table.insert(tFriendlyNavalExcludingIntercept, oUnit)
                oUnit[refbMiniFriendlyUnit] = false
            end
            tMiniThreatFriendlyUnits = nil
        end
    end





    local tBaseDefenceUnits = {} --Units assigned to deal with enemy threat that is near our naval factory
    local iEnemyMiniThreatCumulativeThreat = 0 --Cumulative threat value of units that are being ignored as mini threats
    local refbIgnoreUnit = 'M27NavyMinimalThreatEnemyUnit'
    local refbBaseDefenceUnit = 'M27NavyBaseDefenceUnit' --true if unit has been assigned previously to defend our naval factory


    if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]) == false then
        --remove up to 100 obsolete units each cycle
        local bRemoveUnits = true
        local iRemovedUnits = 0
        while bRemoveUnits do
            bRemoveUnits = false
            for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond] do

                if not(M27UnitInfo.IsUnitValid(oUnit)) then
                    bRemoveUnits = true
                    iRemovedUnits = iRemovedUnits + 1
                    table.remove(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond], iUnit)
                end
            end
            if iRemovedUnits >= 100 then break end
        end

        if iRemovedUnits == 0 or M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]) == false then
            --First assign any units that were part of a minithreat before
            local tUnitsToConsider = EntityCategoryFilterDown(categories.MOBILE * categories.NAVAL * categories.DIRECTFIRE + categories.MOBILE * categories.NAVAL * categories.INDIRECTFIRE + categories.MOBILE * categories.NAVAL * categories.ANTINAVY, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
            if M27Utilities.IsTableEmpty(tUnitsToConsider) then
                tUnitsToConsider = M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]
            end

            for iUnit, oUnit in tUnitsToConsider do
                if bDebugMessages == true then LOG(sFunctionRef..': Recording units into different initial tables, oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refbMiniFriendlyUnit]='..tostring(oUnit[refbMiniFriendlyUnit] or false)..'; oUnit[refbBaseDefenceUnit]='..tostring(oUnit[refbBaseDefenceUnit] or false)) end
                if oUnit[refbMiniFriendlyUnit] then
                    table.insert(tMiniThreatFriendlyUnits, oUnit)
                elseif oUnit[refbBaseDefenceUnit] then
                    table.insert(tBaseDefenceUnits, oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' is already flagged for base defence so adding it to tBaseDefenceUnits') end
                else
                    table.insert(tFriendlyNavalExcludingIntercept, oUnit)
                end
            end


            local iClosestDistance = 100000
            local iCurDistToEnemyBase

            if M27Utilities.IsTableEmpty(tFriendlyNavalExcludingIntercept) then
                tFriendlyNavalExcludingIntercept = tMiniThreatFriendlyUnits
                if M27Utilities.IsTableEmpty(tMiniThreatFriendlyUnits) then
                    tFriendlyNavalExcludingIntercept = tBaseDefenceUnits
                end
            end
            for iUnit, oUnit in tFriendlyNavalExcludingIntercept do
                iCurDistToEnemyBase = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)
                if iCurDistToEnemyBase < iClosestDistance then
                    oClosestFriendlyUnitToEnemyBase = oUnit
                    iClosestDistance = iCurDistToEnemyBase
                end
            end
            iFriendlyDistToEnemy = iClosestDistance
        end
        M27Team.tTeamData[iTeam][M27Team.refiFriendlyNavalThreatByPond][iPond] = M27Logic.GetCombatThreatRating(aiBrain, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond], false, nil, nil, false, false, false, false, true, false, false)
        iMiniThreatThreshold = M27Team.tTeamData[iTeam][M27Team.refiFriendlyNavalThreatByPond][iPond] * 0.1
        if iMiniThreatThreshold < 100 then iMiniThreatThreshold = 0 end
        if bDebugMessages == true then LOG(sFunctionRef..': Friendly naval threat='..M27Team.tTeamData[iTeam][M27Team.refiFriendlyNavalThreatByPond][iPond]..'; Mini threat threshold='..iMiniThreatThreshold) end
    else
        M27Team.tTeamData[iTeam][M27Team.refiFriendlyNavalThreatByPond][iPond] = 0
    end
    M27Team.tTeamData[iTeam][M27Team.refoClosestFriendlyUnitToEnemyByPond][iPond] = oClosestFriendlyUnitToEnemyBase

    --Enemies near naval factory logic
    local tNavalFactorySurfaceThreats = {}
    --Dont bother checking if our navy is retreating, as they should end up close to our factory anyway
    if bDebugMessages == true then LOG(sFunctionRef..': About to consider if we should check for units near our factory. Is oClosestFriendlyUnitToEnemyBase valid='..tostring(M27UnitInfo.IsUnitValid(oClosestFriendlyUnitToEnemyBase))..'; Last strategy='..(M27Team.tTeamData[iTeam][M27Team.refiLastNavalStrategy][iPond] or 'nil')) end
    if oClosestFriendlyUnitToEnemyBase and not(M27Team.tTeamData[iTeam][M27Team.refiLastNavalStrategy][iPond] == M27Team.refiNavalStrategyRetreat) then
        local iSearchRange = 90
        local iUnitsWanted = 1
        local tFriendlyPotentialDefenders = {}
        local bUsedExistingDestroyer = false
        if bDebugMessages == true then LOG(sFunctionRef..': Is filtered table of base defence units for destroyers empty='..tostring(M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryDestroyer, tBaseDefenceUnits)))) end
        if M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryDestroyer, tBaseDefenceUnits)) == false then
            --Use destroyer already assigned to defend
            for iUnit, oUnit in tBaseDefenceUnits do
                table.insert(tFriendlyPotentialDefenders, oUnit)
                bUsedExistingDestroyer = true
                if bDebugMessages == true then LOG(sFunctionRef..': Adding destroyer unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to tFriendlyPotentialDefenders') end
            end
        else
            tFriendlyPotentialDefenders = EntityCategoryFilterDown(M27UnitInfo.refCategoryDestroyer, tFriendlyNavalExcludingIntercept)
            if M27Utilities.IsTableEmpty(tFriendlyPotentialDefenders) then
                iUnitsWanted = 2 --want 2 frigates as 1 may not be enough
                iSearchRange = 45 --no point searching further given frigates have poor range
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of base defence units empty='..tostring(M27Utilities.IsTableEmpty(tBaseDefenceUnits))) end
                if M27Utilities.IsTableEmpty(tBaseDefenceUnits) == false then
                    for iUnit, oUnit in tBaseDefenceUnits do
                        table.insert(tFriendlyPotentialDefenders, oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding frigate unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to tFriendlyPotentialDefenders') end
                    end
                else
                    tFriendlyPotentialDefenders = EntityCategoryFilterDown(M27UnitInfo.refCategoryFrigate, tFriendlyNavalExcludingIntercept)
                    if bDebugMessages == true then LOG(sFunctionRef..': Set M27Utilities.IsTableEmpty(tBaseDefenceUnits) to be frigates in our main naval force') end
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is table of friendly potential defenders empty='..tostring(M27Utilities.IsTableEmpty(tFriendlyPotentialDefenders))) end

        if M27Utilities.IsTableEmpty(tFriendlyPotentialDefenders) == false then
            local tPotentialSurfaceThreats = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandCombat + M27UnitInfo.refCategoryIndirectT2Plus + categories.COMMAND, tOurBase, iSearchRange, 'Enemy')
            if bDebugMessages == true then LOG(sFunctionRef..': Is tPotentialSurfaceThreats empty='..tostring(M27Utilities.IsTableEmpty(tPotentialSurfaceThreats))..'; tOurBase='..repru(tOurBase)..'; iSearchRange='..iSearchRange) end
            if M27Utilities.IsTableEmpty(tPotentialSurfaceThreats) == false then
                --Update actual naval threats based on which of these is not underwater
                for iUnit, oUnit in tPotentialSurfaceThreats do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is underwtaer='..tostring(M27UnitInfo.IsUnitUnderwater(oUnit))) end
                    if not(M27UnitInfo.IsUnitUnderwater(oUnit)) then
                        table.insert(tNavalFactorySurfaceThreats, oUnit)
                        if bDebugMessages == true then LOG(sFunctionRef..': Adding unit to list of surface threats') end
                    end
                end

                if M27Utilities.IsTableEmpty(tNavalFactorySurfaceThreats) == false then
                    local iThreatValue = M27Logic.GetCombatThreatRating(aiBrain, tNavalFactorySurfaceThreats, false, nil, nil, false, false, false, false, true, false, false)

                    if bDebugMessages == true then LOG(sFunctionRef..': Threat around naval fac iThreatValue='..iThreatValue..'; Size of enemy threat table='..table.getn(tNavalFactorySurfaceThreats)..'; size of friendly defenders='..table.getn(tFriendlyPotentialDefenders)) end
                    if iThreatValue >= 1200 or table.getn(tNavalFactorySurfaceThreats) >= 12 then
                        --Want more than 1 unit - do we only ahve 1u nit assigned atm?
                        if bDebugMessages == true then LOG(sFunctionRef..': bUsedExistingDestroyer='..tostring(bUsedExistingDestroyer)) end
                        if bUsedExistingDestroyer and table.getn(tFriendlyPotentialDefenders) == 1 then
                            local tExtraPotentialDefenders = EntityCategoryFilterDown(M27UnitInfo.refCategoryDestroyer, tFriendlyNavalExcludingIntercept)

                            if M27Utilities.IsTableEmpty(tExtraPotentialDefenders) == false then
                                for iUnit, oUnit in tExtraPotentialDefenders do
                                    table.insert(tFriendlyPotentialDefenders, oUnit)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Size of tFriendlyPotentialDefenders after including any other destroyers='..table.getn(tFriendlyPotentialDefenders)..'; Is tExtraPotentialDefenders empty='..tostring(M27Utilities.IsTableEmpty(tExtraPotentialDefenders))) end
                        end

                        iUnitsWanted = math.min(table.getn(tFriendlyPotentialDefenders), 2)
                    end
                    --Select the unit(s) for base defence based on which ones are closest to our base
                    local tiDistToBaseByFriendlyDefenderRef = {}
                    for iUnit, oUnit in tFriendlyPotentialDefenders do
                        tiDistToBaseByFriendlyDefenderRef[iUnit] = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)
                    end
                    tBaseDefenceUnits = {}
                    for iUnitRef, iDistance in M27Utilities.SortTableByValue(tiDistToBaseByFriendlyDefenderRef, false) do
                        table.insert(tBaseDefenceUnits, tFriendlyPotentialDefenders[iUnitRef])
                        tFriendlyPotentialDefenders[iUnitRef][refbBaseDefenceUnit] = true
                        iUnitsWanted = iUnitsWanted - 1
                        if bDebugMessages == true then LOG(sFunctionRef..': Added unit '..tFriendlyPotentialDefenders[iUnitRef].UnitId..M27UnitInfo.GetUnitLifetimeCount(tFriendlyPotentialDefenders[iUnitRef])..' to tBaseDefenceUnits. iDistance='..iDistance..'; refbBaseDefenceUnit='..tostring(tFriendlyPotentialDefenders[iUnitRef][refbBaseDefenceUnit])) end
                        if iUnitsWanted <= 0 then break end
                    end
                end
            end
        end
    end


    --If no threats to naval fac then clear the flag of any defenders so next cycle theyll be made available
    if M27Utilities.IsTableEmpty(tNavalFactorySurfaceThreats) then
        if bDebugMessages == true then LOG(sFunctionRef..': No surface threats so if have any base defence units will clear the flag, is tBaseDefenceUnits empty='..tostring(M27Utilities.IsTableEmpty(tBaseDefenceUnits))) end
        if M27Utilities.IsTableEmpty(tBaseDefenceUnits) == false then
            for iUnit, oUnit in tBaseDefenceUnits do
                oUnit[refbBaseDefenceUnit] = false
                if bDebugMessages == true then LOG(sFunctionRef..': Clearing oUnit of defence flag, oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
            end
            tBaseDefenceUnits = nil
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Have surface threats, si table of base defence units empty='..tostring(M27Utilities.IsTableEmpty(tBaseDefenceUnits))) end
        if M27Utilities.IsTableEmpty(tBaseDefenceUnits) == false then
            --Attack move to the closest enemy unit
            local oClosestEnemy = M27Utilities.GetNearestUnit(tNavalFactorySurfaceThreats, tOurBase)
            local iAngleFromEnemyToBase = M27Utilities.GetAngleFromAToB(oClosestEnemy:GetPosition(), tOurBase)
            local iDistFromEnemyToBase = M27Utilities.GetDistanceBetweenPositions(oClosestEnemy:GetPosition(), tOurBase)
            local tPositionToMoveTo
            if bDebugMessages == true then LOG(sFunctionRef..': Closest land enemy to our naval fac='..oClosestEnemy.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemy)..'; iAngleFromEnemyToBase='..iAngleFromEnemyToBase..'; iDistFromEnemyToBase='..iDistFromEnemyToBase) end
            for iUnit, oUnit in tBaseDefenceUnits do
                oUnit[refbBaseDefenceUnit] = true --redundancy
                tPositionToMoveTo = M27Utilities.MoveInDirection(oClosestEnemy:GetPosition(), iAngleFromEnemyToBase, math.min(iDistFromEnemyToBase + 10, M27UnitInfo.GetNavalDirectAndSubRange(oUnit) - 5), true, false)
                if oUnit[M27UnitInfo.refbLastShotBlocked] or M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase) >= 50 then
                    MoveUnitTowardsTarget(oUnit, tPositionToMoveTo, false, 'MDefend')
                    if bDebugMessages == true then LOG(sFunctionRef..': Ordering unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to move to '..repru(tPositionToMoveTo)) end
                else
                    MoveUnitTowardsTarget(oUnit, tPositionToMoveTo, true, 'ADefend')
                    if bDebugMessages == true then LOG(sFunctionRef..': Ordering unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to attack move to '..repru(tPositionToMoveTo)) end
                end
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to update list of enemy units in pond nad calculate closest enemy unit. Is the table empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]))) end

    if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]) == false then
        --remove up to 100 obsolete units each cycle
        local bRemoveUnits = true
        local iRemovedUnits = 0
        while bRemoveUnits do
            bRemoveUnits = false
            for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                if not(M27UnitInfo.IsUnitValid(oUnit)) then
                    bRemoveUnits = true
                    iRemovedUnits = iRemovedUnits + 1
                    table.remove(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond], iUnit)
                end
            end
            if iRemovedUnits >= 100 then break end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iRemovedUnits='..iRemovedUnits..'; Is table empty now='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]))..'; tOurBase='..repru(tOurBase)..'; Dist to aiBrain '..aiBrain.Nickname..' land base start pos='..M27Utilities.GetDistanceBetweenPositions(tOurBase, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])..'; ai Brain start position='..repru(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) end
        if iRemovedUnits == 0 or M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Time since last updated positions of enemy units in pond='..(GetGameTimeSeconds() - (M27Team.tTeamData[iTeam][M27Team.refiTimeOfLastNavalUnitCheckByPond] or 0))) end
            if iRemovedUnits < 20 and GetGameTimeSeconds() - (M27Team.tTeamData[iTeam][M27Team.refiTimeOfLastNavalUnitCheckByPond] or 0) >= 1 then --Refresh unit locations, but dont do the refresh if we removed >=20 units since we may still have invalid units here
                if bDebugMessages == true then LOG(sFunctionRef..': WIll update each unit position in the pond') end
                M27Team.tTeamData[iTeam][M27Team.refiTimeOfLastNavalUnitCheckByPond] = GetGameTimeSeconds()
                for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                    if M27Utilities.CanSeeUnit(aiBrain, oUnit, true) then
                        UpdateUnitPond(oUnit, iTeam, true)
                    end
                end
            end
            if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]) == false then
                --Split enemy units into those that can ignore (due to being a tiny threat), and those that want to try and deal with
                local tEnemyUnitRefsByDistance = {} --[key] will be the iUnit ref when cycling through eachg unit in the tEnemyUnitsByPond, and will return the distance from our base

                --Get closest enemy unit, and also update units last known position
                local iClosestDistance = 100000
                local iClosestSurfaceDistance = 100000
                local iClosestEnemyCombatDistance = 100000
                local iClosestSubmersibleDistance = 100000
                local iCurDistToOurBase
                local tUnitPosition
                local refiTempNavalRef = 'M27NavyTempNavalRef' --against unit, stores the location in the reftEnemyUnitsByPond table
                local bIsUnitUnderwater
                --First clalculate each enemy unit's distance to our naval base and record in a table that we can then sort to exclude minimal threats
                for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                    iCurDistToOurBase = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)
                    tEnemyUnitRefsByDistance[iUnit] = iCurDistToOurBase
                    oUnit[refiTempNavalRef] = iUnit
                end

                if iMiniThreatThreshold == 0 then
                    for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                        table.insert(tEnemyNavalExcludingMiniThreats, oUnit)
                    end
                else
                    --Exclude minimal threats - first sort by distance so only consider the first 15 units for exclusion
                    local tEnemyUnitsByGroup = {}
                    local tEnemyThreatByGroup = {}
                    local iGroupCount = 0
                    local iCurGroup
                    local iCurDist
                    local iClosestDist
                    local bCreateNewGroup
                    local iUnitCount = 0
                    local iUnitLimit = 30 --i.e. will consider up to 30 units; if changing this number review subsequent code to make sure not setting it too low

                    for iUnitRef, iDistance in M27Utilities.SortTableByValue(tEnemyUnitRefsByDistance, false) do
                        --Do we have a group that this unit is near?
                        bCreateNewGroup = true
                        if iGroupCount > 0 then
                            iClosestDist = 10000
                            for iGroup, tUnits in tEnemyUnitsByGroup do
                                iCurDist = M27Utilities.GetDistanceBetweenPositions(tUnits[1]:GetPosition(), M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond][iUnitRef]:GetPosition())
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    iCurGroup = iGroup
                                end
                            end
                            if iClosestDist <= 120 then
                                bCreateNewGroup = false
                                table.insert(tEnemyUnitsByGroup[iCurGroup], M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond][iUnitRef])
                            end
                        end
                        if bCreateNewGroup then
                            iGroupCount = iGroupCount + 1
                            tEnemyUnitsByGroup[iGroupCount] = {}
                            iCurGroup = iGroupCount
                            table.insert(tEnemyUnitsByGroup[iCurGroup], M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond][iUnitRef])
                        end

                        iUnitCount = iUnitCount + 1
                        if iUnitCount >= iUnitLimit or iGroupCount >= 10 then break end --For performance reasons dont want to group every unit
                    end

                    --Have sorted the nearest units into groups, now consider if can ignore the groups (which will already be ordered by distance to our base)
                    if iGroupCount == 0 then --redundancy
                        for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                            table.insert(tEnemyNavalExcludingMiniThreats, oUnit)
                        end
                    else
                        local iCumulativeUnitCount = 0
                        local iExcludedGroupCount = 0
                        local iCumulativeThreat = 0
                        for iGroup, tUnits in tEnemyUnitsByGroup do
                            --Stop if the closest unit in this group is close to our front position
                            tEnemyThreatByGroup[iGroup] = M27Logic.GetCombatThreatRating(aiBrain, tUnits, false, nil, nil, false, false, false, false, true, false, false)
                            if tEnemyThreatByGroup[iGroup] >= 250 and M27Utilities.GetDistanceBetweenPositions(M27Team.tTeamData[iTeam][M27Team.refoClosestFriendlyUnitToEnemyByPond][iPond]:GetPosition(), tUnits[1]:GetPosition()) <= 50 then
                                --Enemy has some form of threat and is near our front unit so want to engage with main navy as wont be a detour to attack it
                                break
                            else


                                iCumulativeUnitCount = iCumulativeUnitCount + table.getn(tUnits)
                                if iCumulativeUnitCount <= iUnitLimit - 5 then
                                    tEnemyThreatByGroup[iGroup] = M27Logic.GetCombatThreatRating(aiBrain, tUnits, false, nil, nil, false, false, false, false, true, false, false)
                                    if tEnemyThreatByGroup[iGroup] + iCumulativeThreat < iMiniThreatThreshold and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.FACTORY, tUnits)) then
                                        --Ignore this for our main force and instead get a small subforce to deal with it
                                        iCumulativeThreat = iCumulativeThreat + tEnemyThreatByGroup[iGroup]
                                        for iUnit, oUnit in tUnits do
                                            oUnit[refbIgnoreUnit] = true
                                        end
                                        iExcludedGroupCount = iExcludedGroupCount + 1
                                    else
                                        --Threat is too great so stop looking for threats to ignore
                                        break
                                    end
                                else
                                    break
                                end
                            end
                        end
                        if iExcludedGroupCount == 0 then
                            for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                                table.insert(tEnemyNavalExcludingMiniThreats, oUnit)
                            end
                        else
                            for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                                if oUnit[refbIgnoreUnit] then
                                    table.insert(tMiniThreatEnemyUnits, oUnit)
                                else
                                    table.insert(tEnemyNavalExcludingMiniThreats, oUnit)
                                end
                            end
                        end
                        if M27Utilities.IsTableEmpty(tEnemyNavalExcludingMiniThreats) then
                            --Dont have any main navla force to consider so have the main naval force also consider the mini threats
                            tEnemyNavalExcludingMiniThreats = tMiniThreatEnemyUnits
                        else
                            iEnemyMiniThreatCumulativeThreat = iCumulativeThreat
                        end
                    end
                end
                --Decide on what friendly units to assign to the mini threat
                if bDebugMessages == true then LOG(sFunctionRef..': Is the table of minithreatenemyunits empty='..tostring(M27Utilities.IsTableEmpty(tMiniThreatEnemyUnits))) end
                if M27Utilities.IsTableEmpty(tMiniThreatEnemyUnits) == false then
                    --GetCombatThreatRating(aiBrain, tUnits, bMustBeVisibleToIntelOrSight, iMassValueOfBlipsOverride, iSoloBlipMassOverride, bIndirectFireThreatOnly, bJustGetMassValue, bBlueprintThreat, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly)
                    local iMiniEnemySurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tMiniThreatEnemyUnits, false, nil, nil, false,                      false,              false,          false,          true,       false,              false)
                    local iMiniEnemySubmersibleThreat = M27Logic.GetCombatThreatRating(aiBrain, tMiniThreatEnemyUnits, false, nil, nil, false, false, false, false, false, true, false)
                    local iMiniNavyFriendlySurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tMiniThreatFriendlyUnits, false, nil, nil, false,            false,              false,          false,          true,       false,              false)
                    local iMiniNavyFriendlyAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, tMiniThreatFriendlyUnits, false, nil, nil, false, false, false, true, false, false, false)
                    local iMiniSurfaceThreatWanted = math.max(1, iMiniEnemySurfaceThreat * 1.65)
                    local iMiniAntiNavyThreatWanted = iMiniEnemySubmersibleThreat * 1.65
                    --Increase enemy threats by 65% so we should easily win the fight

                    if bDebugMessages == true then LOG(sFunctionRef..': About to allocate units to fight mini threats. iMiniAntiNavyThreatWanted='..iMiniAntiNavyThreatWanted..'; iMiniNavyFriendlyAntiNavyThreat='..iMiniNavyFriendlyAntiNavyThreat..'; iMiniSurfaceThreatWanted='..iMiniSurfaceThreatWanted..'; iMiniNavyFriendlySurfaceThreat='..iMiniNavyFriendlySurfaceThreat..'; iMiniEnemySurfaceThreat='..iMiniEnemySurfaceThreat..'; iMiniEnemySubmersibleThreat='..iMiniEnemySubmersibleThreat) end

                    if iMiniAntiNavyThreatWanted > iMiniNavyFriendlyAntiNavyThreat or iMiniSurfaceThreatWanted > iMiniNavyFriendlySurfaceThreat or (iMiniNavyFriendlyAntiNavyThreat + iMiniNavyFriendlySurfaceThreat) == 0 then
                        local tFriendlyT2AndLowerMainNavy = EntityCategoryFilterDown(M27UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M27UnitInfo.refCategoryNavalSurface * categories.ANTINAVY - categories.ANTIAIR - categories.TECH3 - categories.EXPERIMENTAL, tFriendlyNavalExcludingIntercept)
                        if bDebugMessages == true then LOG(sFunctionRef..': Is table of T2 and lower navy empty='..tostring(M27Utilities.IsTableEmpty(tFriendlyT2AndLowerMainNavy))) end
                        if M27Utilities.IsTableEmpty(tFriendlyT2AndLowerMainNavy) == false then
                            if iMiniAntiNavyThreatWanted > iMiniNavyFriendlyAntiNavyThreat then
                                --Need more antinaval units assigned to mini navy intercept force
                                local tFriendlyAntiNavy = EntityCategoryFilterDown(categories.ANTINAVY, tFriendlyT2AndLowerMainNavy)
                                if bDebugMessages == true then LOG(sFunctionRef..': Want more antinavy threat. Is tFriendlyAntiNavy empty='..tostring(M27Utilities.IsTableEmpty(tFriendlyAntiNavy))) end
                                if M27Utilities.IsTableEmpty(tFriendlyAntiNavy) == false then
                                    local iCurAntiNavyThreat
                                    for iUnit, oUnit in tFriendlyAntiNavy do
                                        iCurAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, { oUnit }, false, nil, nil, false, false, false, true, false, false, false)
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering friendly unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurAntiNavyThreat='..iCurAntiNavyThreat) end
                                        if iCurAntiNavyThreat > 0 then
                                            iMiniNavyFriendlyAntiNavyThreat = iMiniNavyFriendlyAntiNavyThreat + iCurAntiNavyThreat
                                            iMiniNavyFriendlySurfaceThreat = iMiniNavyFriendlySurfaceThreat + M27Logic.GetCombatThreatRating(aiBrain, { oUnit }, false, nil, nil, false,            false,              false,          false,          true,       false,              false)
                                            table.insert(tMiniThreatFriendlyUnits, oUnit)
                                            oUnit[refbMiniFriendlyUnit] = true
                                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to mini navy response, iMiniNavyFriendlyAntiNavyThreat='..iMiniNavyFriendlyAntiNavyThreat..'; iMiniNavyFriendlySurfaceThreat='..iMiniNavyFriendlySurfaceThreat) end
                                            if iMiniNavyFriendlyAntiNavyThreat >= iMiniAntiNavyThreatWanted then break end
                                            --Will be removed from main friendly navy group below
                                        end
                                    end
                                end

                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if want more surface threat. iMiniSurfaceThreatWanted='..iMiniSurfaceThreatWanted..'; iMiniNavyFriendlySurfaceThreat='..iMiniNavyFriendlySurfaceThreat) end
                        if iMiniSurfaceThreatWanted > iMiniNavyFriendlySurfaceThreat then
                            local iCurSurfaceThreat
                            for iUnit, oUnit in tFriendlyT2AndLowerMainNavy do
                                --check not already added from antinavy approach above
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is already allocated as mini unit='..tostring(oUnit[refbMiniFriendlyUnit])) end
                                if not(oUnit[refbMiniFriendlyUnit]) then
                                    --GetCombatThreatRating(aiBrain, tUnits, bMustBeVisibleToIntelOrSight, iMassValueOfBlipsOverride, iSoloBlipMassOverride, bIndirectFireThreatOnly, bJustGetMassValue, bBlueprintThreat, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly)
                                    iCurSurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, { oUnit }, false, nil, nil,                          false,            false,              false,          false,          true,       false,              false)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit surface threat='..iCurSurfaceThreat) end
                                    if iCurSurfaceThreat > 0 then
                                        table.insert(tMiniThreatFriendlyUnits, oUnit)
                                        oUnit[refbMiniFriendlyUnit] = true
                                        iMiniNavyFriendlySurfaceThreat = iMiniNavyFriendlySurfaceThreat + iCurSurfaceThreat
                                        if bDebugMessages == true then LOG(sFunctionRef..': Unit added to mini response, iMiniNavyFriendlySurfaceThreat='..iMiniNavyFriendlySurfaceThreat) end
                                        if iMiniNavyFriendlySurfaceThreat > iMiniSurfaceThreatWanted then break end
                                    end
                                end
                            end
                        end
                    end

                    --Assign orders to the mini navy intercept force - do this based on lower threat to above (so if e.g. we take a bit of damage we dont turn and run and wait for a new unit)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning units to mini navy response, will consider whether to attack with it. iMiniNavyFriendlySurfaceThreat='..iMiniNavyFriendlySurfaceThreat..'; iMiniEnemySurfaceThreat='..iMiniEnemySurfaceThreat..'; iMiniNavyFriendlyAntiNavyThreat='..iMiniNavyFriendlyAntiNavyThreat..'; iMiniEnemySubmersibleThreat='..iMiniEnemySubmersibleThreat) end
                    if iMiniNavyFriendlySurfaceThreat >= iMiniEnemySurfaceThreat and iMiniNavyFriendlyAntiNavyThreat >= iMiniEnemySubmersibleThreat then
                        --Attack nearest enemy mini naval threat
                        local oNearestEnemyMiniThreat = M27Utilities.GetNearestUnit(tMiniThreatEnemyUnits, tOurBase)
                        local tClosestEnemyTargetToUse = M27Utilities.MoveTowardsTarget(oNearestEnemyMiniThreat:GetPosition(), tOurBase, 5, M27Utilities.GetAngleFromAToB(oNearestEnemyMiniThreat:GetPosition(), tOurBase))
                        if bDebugMessages == true then LOG(sFunctionRef..': oNearestEnemyMiniThreat='..oNearestEnemyMiniThreat.UnitId..M27UnitInfo.GetUnitLifetimeCount(oNearestEnemyMiniThreat)..'; tClosestEnemyTargetToUse='..repru(tClosestEnemyTargetToUse)..'; Position of closest threat='..repru(oNearestEnemyMiniThreat:GetPosition())) end
                        for iUnit, oUnit in tMiniThreatFriendlyUnits do
                            --Attack move to near the target
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to move to closest enemy') end
                            MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, not(oUnit[M27UnitInfo.refbLastShotBlocked]), 'MNAGetInRange')
                        end
                    end
                else
                    --Clear the mini threat flag from all friendly units
                    ClearMiniThreatFlagFromAllAssignedUnits()
                end

                --Record nearest enemy threat (ignoring mini threats)

                for iUnit, oUnit in tEnemyNavalExcludingMiniThreats do
                    iCurDistToOurBase = tEnemyUnitRefsByDistance[oUnit[refiTempNavalRef]]
                    if iCurDistToOurBase < iClosestDistance then
                        oClosestEnemyUnit = oUnit
                        iClosestDistance = iCurDistToOurBase
                    end
                    --Below is redundancy as shouldve already updated this when checking if the unit was added to the pond
                    if not(oUnit[M27UnitInfo.reftLastKnownPosition]) then --or M27Utilities.CanSeeUnit(aiBrain, oUnit, true) then
                        tUnitPosition = oUnit:GetPosition()
                        oUnit[M27UnitInfo.reftLastKnownPosition] = {tUnitPosition[1], tUnitPosition[2], tUnitPosition[3]}
                    end
                    oUnit[refbTempIsUnderwater] = M27UnitInfo.IsUnitUnderwater(oUnit)

                    if not(oUnit[refbTempIsUnderwater]) then
                        if iCurDistToOurBase < iClosestSurfaceDistance then
                            iClosestSurfaceDistance = iCurDistToOurBase
                            oClosestSurfaceEnemy = oUnit
                            if EntityCategoryContains(categories.DIRECTFIRE + categories.INDIRECTFIRE + categories.ANTINAVY, oUnit.UnitId) then oClosestEnemySurfaceCombat = oUnit end
                        end
                    else
                        if iCurDistToOurBase < iClosestSubmersibleDistance then
                            iClosestSubmersibleDistance = iCurDistToOurBase
                            oClosestSubmersibleEnemy = oUnit
                        end
                    end

                    if iCurDistToOurBase < iClosestEnemyCombatDistance then
                        if math.max(M27UnitInfo.GetNavalDirectAndSubRange(oUnit), oUnit[M27UnitInfo.refiIndirectRange]) > 0 then
                            iClosestEnemyCombatDistance = iCurDistToOurBase
                            oClosestEnemyCombatUnit = oUnit
                        end
                    end
                end
                --Update the last known position of the closest unit if we dont have visibility of it currently but have intel coverage of where it last was
                if M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit) and not(M27Utilities.CanSeeUnit(aiBrain, oClosestEnemyCombatUnit, true)) then
                    if M27Logic.GetIntelCoverageOfPosition(aiBrain, oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition], 1, false) then
                        oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition] = {oClosestEnemyCombatUnit:GetPosition()[1], oClosestEnemyCombatUnit:GetPosition()[2], oClosestEnemyCombatUnit:GetPosition()[3]}
                        if bDebugMessages == true then LOG(sFunctionRef..': Have intel coverage of last known position so know unit not htere, have updated last known position') end
                    else
                        --Is our closest friendly unit near here?
                        if M27UnitInfo.IsUnitValid(oClosestFriendlyUnitToEnemyBase) then
                            local iDistToClosestEnemyUnit = M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToEnemyBase:GetPosition(), oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition])
                            local oClosestUnitBP = oClosestFriendlyUnitToEnemyBase:GetBlueprint()
                            local iClosestUnitIntel = math.max(oClosestUnitBP.Intel.SonarRadius or 0, oClosestUnitBP.Intel.VisionRadius or 0, oClosestUnitBP.Intel.WaterVisionRadius or 0, oClosestUnitBP.Intel.RadarRadius or 0)
                            if bDebugMessages == true then LOG(sFunctionRef..': iClosestUnitIntel='..iClosestUnitIntel..'; iDistToClosestEnemyUnit='..iDistToClosestEnemyUnit..'; Will consider updating last known position') end
                            if iDistToClosestEnemyUnit <= iClosestUnitIntel then
                                oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition] = {oClosestEnemyCombatUnit:GetPosition()[1], oClosestEnemyCombatUnit:GetPosition()[2], oClosestEnemyCombatUnit:GetPosition()[3]}
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating nearest enemy unit (ignoring mini threats)='..oClosestEnemyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; iClosestDistance='..iClosestDistance..'; Position of closest enemy unit='..repru(oClosestEnemyUnit:GetPosition())) end
            else
                ClearMiniThreatFlagFromAllAssignedUnits()
            end
        else
            ClearMiniThreatFlagFromAllAssignedUnits()
        end
    end
    M27Team.tTeamData[iTeam][M27Team.refoClosestEnemyNavalUnitByPond][iPond] = oClosestEnemyUnit --sets to nil if have none
    if oClosestEnemyUnit then
        M27Team.tTeamData[iTeam][M27Team.refiEnemyNavalThreatByPond][iPond] = M27Logic.GetCombatThreatRating(aiBrain, M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond], false, nil, nil, false, false, false, false, true, false, false)
    else
        M27Team.tTeamData[iTeam][M27Team.refiEnemyNavalThreatByPond][iPond] = 0
    end


    local iOurBestDFRange = 0
    local iOurBestIndirectRange = 0
    local bConsiderBombardment = false
    local bHaveAlreadyUpdatedRanges = false


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, GameTime='..GetGameTimeSeconds()..'; is table of friendly units for pond '..iPond..' empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]))..'; Is table of enemy units empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]))..'; Do we have a valid enemy closest unit='..tostring(M27UnitInfo.IsUnitValid(oClosestEnemyUnit))..'; Do we have a valid friendly unit='..tostring(M27UnitInfo.IsUnitValid(oClosestFriendlyUnitToEnemyBase))) end
    local iSupportNavyCategory = M27UnitInfo.refCategorySupportNavy - categories.DIRECTFIRE - categories.INDIRECTFIRE - categories.ANTINAVY --e.g. aircraft carriers without any attack and shield boats


    local bAllOutSubAttack = false
    local bTorpsInRangeOfFrontAA = false
    local bTorpsCloseToFrontUnit = false
    local bAANotNearFrontUnit = false
    local oClosestFriendlyAA
    local tFriendlyAA
    local tEnemyExperimentalAir

    --Update naval units based on those being used for mini intercept
    tFriendlyNavalExcludingIntercept = {}
    if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]) == false then
        for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond] do
            if not(oUnit[refbMiniFriendlyUnit]) and not(oUnit[refbBaseDefenceUnit]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Friendly unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' isnt being used by mini response or base defence so adding it to main table') end
                table.insert(tFriendlyNavalExcludingIntercept, oUnit)
            end
        end
    end

    --If torp bombers are near our front unit then want to retreat navy
    if M27UnitInfo.IsUnitValid(oClosestFriendlyUnitToEnemyBase) and (aiBrain[M27AirOverseer.refbEnemyHasBuiltTorpedoBombers] or aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] >= 5000) then

        --Update list of enemy torp bombers
        local tActiveTorpBombers
        if aiBrain[M27AirOverseer.refbEnemyHasBuiltTorpedoBombers] then
            tActiveTorpBombers = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryTorpBomber, oClosestFriendlyUnitToEnemyBase:GetPosition(), 200, 'Enemy')
            if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers]) then
                M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers] = tActiveTorpBombers
                if M27Utilities.IsTableEmpty(tActiveTorpBombers) == false then
                    local tUnitPos
                    for iUnit, oUnit in  M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers] do
                        tUnitPos = oUnit:GetPosition()
                        oUnit[M27UnitInfo.reftLastKnownPosition] = {tUnitPos[1], tUnitPos[2], tUnitPos[3]}
                    end
                end
            else
                local bKeepUpdating = true
                local tUnitPos
                while bKeepUpdating do
                    bKeepUpdating = false

                    for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers] do
                        if not(M27UnitInfo.IsUnitValid(oUnit)) then
                            table.remove(M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers], iUnit)
                            if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers]) == false then
                                bKeepUpdating = true
                            end
                            break
                        elseif M27Utilities.CanSeeUnit(aiBrain, oUnit, true) then
                            tUnitPos = oUnit:GetPosition()
                            oUnit[M27UnitInfo.reftLastKnownPosition] = {tUnitPos[1], tUnitPos[2], tUnitPos[3]}
                        end
                    end
                end
                if M27Utilities.IsTableEmpty(tActiveTorpBombers) == false then
                    local bIncludeUnit
                    for iUnit, oUnit in tActiveTorpBombers do
                        bIncludeUnit = true
                        for iExistingBomber, oExistingBomber in M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers] do
                            if oExistingBomber == oUnit then bIncludeUnit = false break end
                        end
                        if bIncludeUnit then
                            table.insert(M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers], oUnit)
                            tUnitPos = oUnit:GetPosition()
                            oUnit[M27UnitInfo.reftLastKnownPosition] = {tUnitPos[1], tUnitPos[2], tUnitPos[3]}
                        end
                    end
                end
            end
        end

        --Update AA if enemy has torp bombers
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy torp bombers empty after removing old entries='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers]))) end
        local tEnemyRelevantAirThreats = {}
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers]) == false then
            for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyTorpBombers] do
                table.insert(tEnemyRelevantAirThreats, oUnit)
            end
        end
        local tEnemyGunshipsNearFront = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryGunship, oClosestFriendlyUnitToEnemyBase:GetPosition(), 100, 'Enemy')
        if M27Utilities.IsTableEmpty(tEnemyGunshipsNearFront) == false then
            for iUnit, oUnit in tEnemyGunshipsNearFront do
                table.insert(tEnemyRelevantAirThreats, oUnit)
            end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': checking for enemy air experimentals, highest enemy air threat='..aiBrain[M27AirOverseer.refiHighestEnemyAirThreat]) end
        if aiBrain[M27AirOverseer.refiHighestEnemyAirThreat] >= 20000 then
            --Enemy might have experimental air - if we lack air control or enough of an air threat to deal with it, consider sending navy back
            tEnemyExperimentalAir = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryAirNonScout * categories.EXPERIMENTAL, tOurBase, M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase) + 50, 'Enemy')
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy experimental air empty='..tostring(M27Utilities.IsTableEmpty(tEnemyExperimentalAir))) end
            if M27Utilities.IsTableEmpty(tEnemyExperimentalAir) == false then
                for iUnit, oUnit in tEnemyExperimentalAir do
                    table.insert(tEnemyRelevantAirThreats, oUnit)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is tEnemyRelevantAirThreats empty='..tostring(M27Utilities.IsTableEmpty(tEnemyRelevantAirThreats))) end
        if M27Utilities.IsTableEmpty(tEnemyRelevantAirThreats) == false then
            tFriendlyAA = EntityCategoryFilterDown(categories.ANTIAIR, tFriendlyNavalExcludingIntercept)
            local iClosestTorpToFront = 10000
            if M27Utilities.IsTableEmpty(tFriendlyAA) == false then
                --First get any subs that have AA to surface
                local bGivenSurfaceOrder = false


                local tSubAA = EntityCategoryFilterDown(categories.SUBMERSIBLE, tFriendlyAA)
                if bDebugMessages == true then LOG(sFunctionRef..': Is tSubAA empty='..tostring(M27Utilities.IsTableEmpty(tSubAA))) end
                if M27Utilities.IsTableEmpty(tSubAA) == false then
                    for iUnit, oUnit in tSubAA do
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering sub AA unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; Special micro='..tostring(oUnit[M27UnitInfo.refbSpecialMicroActive])..'; Is underwater='..tostring(M27UnitInfo.IsUnitUnderwater(oUnit))) end
                        if not(oUnit[M27UnitInfo.refbSpecialMicroActive]) and M27UnitInfo.IsUnitUnderwater(oUnit) then
                            M27UnitInfo.ToggleUnitDiveOrSurfaceStatus(oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have given surface order to the unit') end
                            bGivenSurfaceOrder = true
                        end
                    end
                end
                if bGivenSurfaceOrder then
                    M27Team.tTeamData[iTeam][M27Team.refbHaveGivenSurfaceOrderToSubs] = true
                end


                oClosestFriendlyAA = M27Utilities.GetNearestUnit(tFriendlyAA, oClosestFriendlyUnitToEnemyBase:GetPosition())
                --Are enemy torps within AA range of this unit, or our front unit?
                local iClosestTorpToAA = 10000
                local iCurDist
                local iTorpBomberRangeThreshold = M27UnitInfo.GetUnitAARange(oClosestFriendlyAA)
                if bDebugMessages == true then LOG(sFunctionRef..': iTorpBomberRangeThreshold='..iTorpBomberRangeThreshold..'; oClosestFriendlyAA used to determine this='..oClosestFriendlyAA.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestFriendlyAA)..'; AA range of this unit='..M27UnitInfo.GetUnitAARange(oClosestFriendlyAA)) end

                for iUnit, oUnit in tEnemyRelevantAirThreats do

                    iCurDist = M27Utilities.GetDistanceBetweenPositions((oUnit[M27UnitInfo.reftLastKnownPosition] or oUnit:GetPosition()), oClosestFriendlyUnitToEnemyBase:GetPosition())
                    if iCurDist < iClosestTorpToFront then
                        iClosestTorpToFront = iCurDist
                    end
                    if oClosestFriendlyUnitToEnemyBase == oClosestFriendlyAA then iClosestTorpToAA = iClosestTorpToFront
                    else
                        iCurDist = M27Utilities.GetDistanceBetweenPositions((oUnit[M27UnitInfo.reftLastKnownPosition] or oUnit:GetPosition()), oClosestFriendlyAA:GetPosition())
                        if iCurDist < iClosestTorpToAA then
                            iClosestTorpToAA = iCurDist
                            if iClosestTorpToAA <= iTorpBomberRangeThreshold then break end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering relevant air threat '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurDist='..iCurDist..'; iClosestTorpToAA='..iClosestTorpToAA) end
                end
                local iCloseToFrontDistance = 100
                if M27Utilities.IsTableEmpty(tEnemyExperimentalAir) == false then iCloseToFrontDistance = 150 end
                if iClosestTorpToAA <= iTorpBomberRangeThreshold then
                    bTorpsInRangeOfFrontAA = true
                    bTorpsCloseToFrontUnit = true
                elseif iClosestTorpToFront <= iCloseToFrontDistance then
                    bTorpsCloseToFrontUnit = true
                end
                if bDebugMessages == true then LOG(sFunctionRef..': oClosestFriendlyAA='..oClosestFriendlyAA.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestFriendlyAA)..'; iTorpBomberRangeThreshold='..iTorpBomberRangeThreshold..'; iClosestTorpToAA='..iClosestTorpToAA..'; iClosestTorpToFront='..iClosestTorpToFront..'; bTorpsInRangeOfFrontAA='..tostring(bTorpsInRangeOfFrontAA)..'; bTorpsCloseToFrontUnit='..tostring(bTorpsCloseToFrontUnit)..'; iTorpBomberRangeThreshold='..iTorpBomberRangeThreshold) end
            else
                bTorpsCloseToFrontUnit = true
                if bDebugMessages == true then LOG(sFunctionRef..': We have no friendly AA so assume torps are close to front unit as want to retreat to base') end
            end

            if bTorpsCloseToFrontUnit and not(bTorpsInRangeOfFrontAA) then
                --Is our AA close to our front unit?
                if not(oClosestFriendlyAA) then
                    bAANotNearFrontUnit = true
                else
                    local iDistFromAAToFront = M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyAA:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())
                    if iDistFromAAToFront >= math.min(60, iClosestTorpToFront + 30) then
                        bAANotNearFrontUnit = true
                    end
                end
            end
        else
            --Check if we have any surfaced subs that we want to unsurface
            if M27Team.tTeamData[iTeam][M27Team.refbHaveGivenSurfaceOrderToSubs] then
                M27Team.tTeamData[iTeam][M27Team.refbHaveGivenSurfaceOrderToSubs] = false
                local tAASubs = EntityCategoryFilterDown(categories.SUBMERSIBLE * categories.ANTIAIR, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
                if M27Utilities.IsTableEmpty(tAASubs) == false then
                    for iUnit, oUnit in tAASubs do
                        if not(M27UnitInfo.IsUnitUnderwater(oUnit)) then
                            M27UnitInfo.ToggleUnitDiveOrSurfaceStatus(oUnit)
                        end
                    end
                end
            end
        end
    end

    --Logic when under torp attack - ignore normal appraoch and move units based on where AA is, unless we are already within 75 of our base
    if bDebugMessages == true then LOG(sFunctionRef..': Checking if under torp attack. bTorpsInRangeOfFrontAA='..tostring(bTorpsInRangeOfFrontAA)..'; bTorpsCloseToFrontUnit='..tostring(bTorpsCloseToFrontUnit)..'; bAANotNearFrontUnit='..tostring(bAANotNearFrontUnit)..'; Distance of closest friendly unit to enemy base='..M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase)) end
    if (bTorpsInRangeOfFrontAA or (bTorpsCloseToFrontUnit and (bAANotNearFrontUnit or M27Utilities.IsTableEmpty(tEnemyExperimentalAir) == false))) and M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase) > 75 then
        bConsiderBombardment = false --redundancy
        local tNonAACombatAndSupport = EntityCategoryFilterDown(M27UnitInfo.refCategoryAllAmphibiousAndNavy - categories.ANTIAIR - categories.STRUCTURE - M27UnitInfo.refCategoryEngineer - categories.SHIELD, tFriendlyNavalExcludingIntercept)
        local tCombatDestination
        local tOtherAADestination
        if oClosestFriendlyAA then
            --Enemy has nearby torp bombers but we have AA unit, so consolidate main forces by AA, and either move closest friendly AA unit forwards if not in range, or back if in range
            tCombatDestination = M27Utilities.MoveInDirection(oClosestFriendlyAA:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyAA:GetPosition(), tOurBase), 15, true)
            tOtherAADestination = M27Utilities.MoveInDirection(oClosestFriendlyAA:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyAA:GetPosition(), tOurBase), 10, true)

            local bChaseExperimental = false
            local oExperimentalToChase
            if M27Utilities.IsTableEmpty(tEnemyExperimentalAir) == false then
                local iClosestExperimentalDistToBase = 10000
                local iCurDist
                for iUnit, oUnit in tEnemyExperimentalAir do
                    iCurDist = M27Utilities.GetDistanceBetweenPositions(tOurBase, oUnit:GetPosition())
                    if iCurDist < iClosestExperimentalDistToBase then
                        iClosestExperimentalDistToBase = iCurDist
                        oExperimentalToChase = oUnit
                    end
                end
                local iOurDistToBase = M27Utilities.GetDistanceBetweenPositions(tOurBase, oClosestFriendlyAA:GetPosition())
                if iOurDistToBase < iClosestExperimentalDistToBase and M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, oExperimentalToChase:GetPosition()) == iPond and M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyAA:GetPosition(), oExperimentalToChase:GetPosition()) <= 125 then
                    bChaseExperimental = true
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Have oClosestFriendlyAA so will set tOtherAADestination and tCombatDestination to near here. tCombatDestination='..repru(tCombatDestination)..'; Distance to our base for tCombatDestination='..M27Utilities.GetDistanceBetweenPositions(tCombatDestination, tOurBase)) end
            if bTorpsInRangeOfFrontAA then
                MoveUnitTowardsTarget(oClosestFriendlyAA, tOurBase, false, 'FrontAAToBase')
            elseif bChaseExperimental then
                MoveUnitTowardsTarget(oClosestFriendlyAA, oExperimentalToChase:GetPosition(), false, 'FrontAAExpChase')
            else
                MoveUnitTowardsTarget(oClosestFriendlyAA, oClosestFriendlyUnitToEnemyBase:GetPosition(), false, 'FrontAAToFront')
            end
        else
            --Enemy has torp bombers but we have no AA unit, so retreat to base
            tCombatDestination = tOurBase
            tOtherAADestination = tOurBase
        end

        --Issue move orders to everything except front unit (which we already gave orders to above)
        if M27Utilities.IsTableEmpty(tFriendlyAA) == false then
            for iUnit, oUnit in tFriendlyAA do
                if not(oUnit == oClosestFriendlyAA) then
                    MoveUnitTowardsTarget(oUnit, tOtherAADestination, false, 'OtherAAMove')
                end
            end
        end
        if M27Utilities.IsTableEmpty(tNonAACombatAndSupport) == false then
            for iUnit, oUnit in tNonAACombatAndSupport do
                if bDebugMessages == true then LOG(sFunctionRef..': About to tell nonAA combat and support unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to move to combat destination') end
                MoveUnitTowardsTarget(oUnit, tCombatDestination, false, 'RunFromBomber')
            end
        end



    else

        if bDebugMessages == true then LOG(sFunctionRef..': No torpedo bombers that are running from. Is closest enemy valid='..tostring(M27UnitInfo.IsUnitValid(oClosestEnemyUnit))..'; Is closest friendly valid='..tostring(M27UnitInfo.IsUnitValid(oClosestFriendlyUnitToEnemyBase))) end
        if M27UnitInfo.IsUnitValid(oClosestEnemyUnit) and M27UnitInfo.IsUnitValid(oClosestFriendlyUnitToEnemyBase) then
            --Record friendly and enemy units of relevance, then decide what action we want to take at a global level

            local tNavalThreatByTypeAndRange = {} --[x] is unit type, [y] is range, then [z] is subref for surface, antinaval, split by friendly and enemy
            --Unit type
            local refiTypeAll = 1
            local refiTypeMobileNavy = 2
            local refiTypeSubmersible = 3
            --Threat type
            local refiFriendlyThreatSurface = 1 --if changing these then udpate code as well as have hardcoded some of these references
            local refiFriendlyThreatAntiNavy = 2
            local refiEnemyThreatSurface = 3
            local refiEnemyThreatAntiNavy = 4

            local tiRangesUsed = {} --all ranges used by us or enemy




            function GetUnitTypes(oUnit)
                if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then
                    return {refiTypeAll, refiTypeMobileNavy, refiTypeSubmersible}
                elseif EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                    return {refiTypeAll, refiTypeMobileNavy}
                else
                    return {refiTypeAll}
                end
            end

            local bUseIndirectRangeIfHigher = false --If nearest enemy is a torpedo launcher then this will be true
            local bUseAntiNavyRangeOnly = false --If nearest enemy is submersible then will only refer to antinavy range
            if EntityCategoryContains(categories.STRUCTURE - categories.SUBMERSIBLE, oClosestEnemyUnit.UnitId) or (oClosestEnemyCombatUnit and EntityCategoryContains(categories.STRUCTURE - categories.SUBMERSIBLE, oClosestEnemyCombatUnit.UnitId)) then bUseIndirectRangeIfHigher = true
            elseif EntityCategoryContains(categories.SUBMERSIBLE + categories.AMPHIBIOUS * categories.MOBILE - categories.HOVER, oClosestEnemyUnit.UnitId) then
                if M27UnitInfo.IsUnitUnderwater(oClosestEnemyUnit) then
                    bUseAntiNavyRangeOnly = true
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef..': bUseIndirectRangeIfHigher after checking if nearest enemy unit or nearest enemy combat unit is a non-submersible structure='..tostring(bUseIndirectRangeIfHigher or false)..'; oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; is closets enemy combat unit valid='..tostring(M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit)))
                if M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit) then
                    LOG(sFunctionRef..': oClosestEnemyCombatUnit='..oClosestEnemyCombatUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyCombatUnit))
                end
            end

            function RecordUnitInNavalThreatTable(oUnit, bIsEnemy)

                local tiCurUnitTypes = GetUnitTypes(oUnit)
                local iThreatRefMod = 0
                if bIsEnemy then iThreatRefMod = 2 end
                local bInclude
                local iCurUnitRange = 0
                local iCurThreat = 0

                if bDebugMessages == true then LOG(sFunctionRef..': About to record threat by range for oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; refiTypeAll='..refiTypeAll..'; tiCurUnitTypes='..repru(tiCurUnitTypes)) end

                for _, iUnitType in tiCurUnitTypes do --want to record both for typeall, and for the curunittype where curunittype is dif to typeall
                    if not(tNavalThreatByTypeAndRange[iUnitType]) then tNavalThreatByTypeAndRange[iUnitType] = {} end
                    bInclude = false
                    --Do we have the right unit type?
                    if iUnitType == refiTypeAll then
                        bInclude = true
                    elseif iUnitType == refiTypeMobileNavy then
                        if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                            bInclude = true
                        end
                    else
                        if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then
                            bInclude = true
                        end
                    end
                    if bInclude then
                        for iThreatTypeRef = 1 + iThreatRefMod, 2 + iThreatRefMod, 1 do
                            if not(oUnit[M27UnitInfo.refiDFRange]) then iCurUnitRange = (GetNavalDirectAndSubRange(oUnit) or 0) end --Redundancy, hopefully have already calculated range before
                            if iThreatTypeRef == refiFriendlyThreatSurface or iThreatTypeRef == refiEnemyThreatSurface then

                                if bUseIndirectRangeIfHigher and iThreatTypeRef == refiFriendlyThreatSurface then
                                    iCurUnitRange = math.max(oUnit[M27UnitInfo.refiDFRange], oUnit[M27UnitInfo.refiAntiNavyRange], oUnit[M27UnitInfo.refiIndirectRange])
                                else
                                    iCurUnitRange = math.max(oUnit[M27UnitInfo.refiDFRange], oUnit[M27UnitInfo.refiAntiNavyRange])
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitRange='..iCurUnitRange..'; Combat threat rating='..M27Logic.GetCombatThreatRating(aiBrain, { oUnit}, false, nil, nil, false, false, false, false, true, false, false)) end
                                if iCurUnitRange > 0 then
                                    --GetCombatThreatRating(aiBrain, tUnits, bMustBeVisibleToIntelOrSight, iMassValueOfBlipsOverride, iSoloBlipMassOverride, bIndirectFireThreatOnly, bJustGetMassValue, bBlueprintThreat, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly)
                                    iCurThreat = M27Logic.GetCombatThreatRating(aiBrain, { oUnit}, false, nil, nil, false, false, false, false, true, false, false)
                                end

                            else
                                --Only want antinavy
                                iCurUnitRange = oUnit[M27UnitInfo.refiAntiNavyRange]
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitRange after checking only antinavy='..iCurUnitRange) end
                                if iCurUnitRange > 0 then
                                    iCurThreat = M27Logic.GetCombatThreatRating(aiBrain, { oUnit }, false, nil, nil, false, false, false, true, false, false, false)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iThreatTypeRef='..iThreatTypeRef..'; iThreatRefMod='..iThreatRefMod..'; iUnitType='..iUnitType..'; iCurThreat='..iCurThreat..'; iCurUnitRange='..iCurUnitRange) end

                            tiRangesUsed[iCurUnitRange] = iCurUnitRange
                            if not(tNavalThreatByTypeAndRange[iUnitType][iCurUnitRange]) then tNavalThreatByTypeAndRange[iUnitType][iCurUnitRange] = {} end

                            tNavalThreatByTypeAndRange[iUnitType][iCurUnitRange][iThreatTypeRef] = (tNavalThreatByTypeAndRange[iUnitType][iCurUnitRange][iThreatTypeRef] or 0) + iCurThreat

                        end
                    end
                end
            end


            local tFriendliesNearFront = {}
            local tFriendlyNearbyReinforcements = {}
            local tFriendlyFurtherAwayReinforcements = {}
            local tEnemiesBetweenUsAndBase = {}
            local tEnemiesNearClosestEnemyUnit = {}
            local iFriendlySearchRangeBase = 30
            local iNavyInPond = 0
            local tNavyInPond = EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer,  tFriendlyNavalExcludingIntercept)
            if M27Utilities.IsTableEmpty(tNavyInPond) == false then
                iNavyInPond = table.getn(tNavyInPond)
            end


            if iNavyInPond >= 10 then iFriendlySearchRangeBase = iFriendlySearchRangeBase + math.min(25, iNavyInPond) end
            local iNearbyReinforcementSearchBase = iFriendlySearchRangeBase + 50
            local iEnemySearchRangeBase = 60
            local iEnemySearchRangeShort = 30
            local iCurDist
            local iCurRange
            local iOurBestSurfaceRange = 0
            local iOurBestSubmersibleRange = 0
            local iOurBestSurfaceAntiNavyRange = 0
            --Already have iOurBestIndirectRange defined earlier, along with our best DF range
            local iEnemyBestSurfaceRange = 0
            local iEnemyBestAntiNavyRange = 0
            local iEnemyBestSubmersibleRange = 0
            local iEnemyBestIndirectRange = 0
            --Get friendly units
            if bDebugMessages == true then LOG(sFunctionRef..': About to identify all units that are close to '..oClosestFriendlyUnitToEnemyBase.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestFriendlyUnitToEnemyBase)) end
            bHaveAlreadyUpdatedRanges = true
            for iUnit, oUnit in tFriendlyNavalExcludingIntercept do
                if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and oUnit:GetFractionComplete() >= 1 then
                    iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())
                    iCurRange = M27UnitInfo.GetNavalDirectAndSubRange(oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': Distance between friendly unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to front unit='..iCurDist..'; Range='..iCurRange) end
                    if iCurDist - iCurRange <= iNearbyReinforcementSearchBase then
                        if iCurDist - iCurRange <= iFriendlySearchRangeBase then
                            table.insert(tFriendliesNearFront, oUnit)
                            RecordUnitInNavalThreatTable(oUnit, false)
                        else
                            table.insert(tFriendlyNearbyReinforcements, oUnit)
                        end
                        iOurBestSurfaceRange = math.max(iOurBestSurfaceRange, iCurRange)
                        if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then
                            iOurBestSubmersibleRange = math.max(iOurBestSubmersibleRange, oUnit[M27UnitInfo.refiAntiNavyRange])
                        else
                            iOurBestSurfaceAntiNavyRange = math.max(iOurBestSurfaceAntiNavyRange, oUnit[M27UnitInfo.refiAntiNavyRange])
                        end
                    else
                        table.insert(tFriendlyFurtherAwayReinforcements, oUnit)
                    end
                    iOurBestIndirectRange = math.max(iOurBestIndirectRange, oUnit[M27UnitInfo.refiIndirectRange])
                    iOurBestDFRange = math.max(iOurBestDFRange, oUnit[M27UnitInfo.refiDFRange])


                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Is table of nearby friendly reinforcements empty=' .. tostring(M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements)) .. '; Is table of friendlies near front empty=' .. tostring(M27Utilities.IsTableEmpty(tFriendliesNearFront)) .. ' tEnemyBase=' .. repru(tEnemyBase))
            end

            if M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements) == false or M27Utilities.IsTableEmpty(tFriendliesNearFront) == false or M27Utilities.IsTableEmpty(tFriendlyFurtherAwayReinforcements) == false then
                local iDistToBase
                if bDebugMessages == true then LOG(sFunctionRef..': About to record details of enemy units of relevance; will either consider those naval units if we are attacking base, or those around hte nearest enemy combat unit if we are attacking nearest enemy unit') end


                for iUnit, oUnit in tEnemyNavalExcludingMiniThreats do
                    iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())
                    iDistToBase = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)
                    iCurRange = M27UnitInfo.GetNavalDirectAndSubRange(oUnit)
                    if iCurDist - iCurRange - iEnemySearchRangeBase <= iFriendlyDistToEnemy or iDistToBase - iCurRange - iEnemySearchRangeShort <= iFriendlyDistToEnemy then
                        table.insert(tEnemiesBetweenUsAndBase, oUnit)
                        iEnemyBestSurfaceRange = math.max(iEnemyBestSurfaceRange, iCurRange)
                        iEnemyBestAntiNavyRange = math.max(iEnemyBestAntiNavyRange, oUnit[M27UnitInfo.refiAntiNavyRange])
                        if EntityCategoryContains(M27UnitInfo.refCategorySubmarine, oUnit.UnitId) then
                            iEnemyBestSubmersibleRange = math.max(iEnemyBestSubmersibleRange, oUnit[M27UnitInfo.refiAntiNavyRange])
                        end
                        iEnemyBestIndirectRange = math.max(iEnemyBestIndirectRange, oUnit[M27UnitInfo.refiIndirectRange])
                    end
                    --Is the enemy near the closet enemy unit
                    if oClosestEnemyCombatUnit and M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestEnemyCombatUnit:GetPosition()) + iCurRange <= iEnemySearchRangeBase then
                        table.insert(tEnemiesNearClosestEnemyUnit, oUnit)
                        RecordUnitInNavalThreatTable(oUnit, true)
                    end

                end

                --Can we win with an all out attack?
                local iOurSurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendliesNearFront, false, nil, nil, false, false, false, false, true, false, false)
                local iOurAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendliesNearFront, false, nil, nil, false, false, false, true, false, false, false)
                local iEnemySurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesBetweenUsAndBase, false, nil, nil, false, false, false, false, true, false, false)
                local tEnemyTorpedoLauncherThreats = EntityCategoryFilterDown(M27UnitInfo.refCategoryTorpedoLauncher, tEnemiesBetweenUsAndBase)

                local iEnemySurfaceTorpedoDefenceThreat = 0
                local iEnemyTorpedoMaxRange = 0
                if M27Utilities.IsTableEmpty(tEnemyTorpedoLauncherThreats) == false then
                    iEnemySurfaceTorpedoDefenceThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemyTorpedoLauncherThreats, false, nil, nil, false, false, false, false, true, false, false)
                    for iUnit, oUnit in tEnemyTorpedoLauncherThreats do
                        iEnemyTorpedoMaxRange = math.max(iEnemyTorpedoMaxRange, M27UnitInfo.GetNavalDirectAndSubRange(oUnit))
                    end

                    if iEnemyTorpedoMaxRange < math.max(iOurBestIndirectRange, iOurBestSurfaceRange, iOurBestSubmersibleRange) then
                        if bDebugMessages == true then LOG(sFunctionRef..': We have units that outrange enemy torpedo threat so will ignore it for deciding if we can launch an all out attack. iEnemySurfaceTorpedoDefenceThreat='..iEnemySurfaceTorpedoDefenceThreat) end
                        iEnemySurfaceThreat = iEnemySurfaceThreat - iEnemySurfaceTorpedoDefenceThreat
                    end
                end




                local iEnemySubmersibleThreat = 0
                if iEnemyBestAntiNavyRange > 0 then
                    iEnemySubmersibleThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesBetweenUsAndBase, false, nil, nil, false, false, false, false, false, true, false)
                end

                --Do we win in both theatres, and have significanlty more threat?
                local bAllOutAttack = false
                --bAllOutSubAttack = false --Recorded above; Set to true if we arent doing an all out at tack, but think our subs can still do an all out attack
                local bAttackNearbyEnemies = false --If dont have enough to beat every naval unit between us and enemy base, but do have enough to take on the nearest enemies, then will use this
                local bIgnoreEnemySubs = false
                local bConsolidateForces = false --used to determine unit task description for now (to help with debugging)

                local iMinSurfaceFactorWanted = 1.15 + math.max(-0.1, 0.01 * (iFriendlyDistToEnemy - iOurBestSurfaceRange - 25))
                if iMinSurfaceFactorWanted > 1.3 then
                    local iFactorCap = 3 - math.min(1.7, iOurSurfaceThreat / 1000)
                    iMinSurfaceFactorWanted = math.min(iMinSurfaceFactorWanted, iFactorCap)
                end

                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering if we want an all out attack. iMinSurfaceFactorWanted=' .. iMinSurfaceFactorWanted .. '; iOurSurfaceThreat=' .. iOurSurfaceThreat .. '; iEnemySurfaceThreat=' .. iEnemySurfaceThreat .. '; iEnemySurfaceThreat*factor=' .. iEnemySurfaceThreat * iMinSurfaceFactorWanted..'; Size of tFriendliesNearFront='..table.getn(tFriendliesNearFront))
                    if iOurAntiNavyThreat > 0 then
                        LOG(sFunctionRef..': Will list out every unit with antinavy threat')
                        local iCurAntiNavy
                        for iUnit, oUnit in tFriendliesNearFront do
                            iCurAntiNavy = M27Logic.GetCombatThreatRating(aiBrain, { oUnit}, false, nil, nil, false, false, false, true, false, false, false)
                            if iCurAntiNavy > 0 then
                                LOG(sFunctionRef..': Unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' with fraction complete '..oUnit:GetFractionComplete()..' has antinavy threat of '..iCurAntiNavy)
                            end
                        end
                    end
                end
                if iOurSurfaceThreat > iEnemySurfaceThreat * iMinSurfaceFactorWanted then
                    --Do we have enough antinavy?
                    if iEnemySubmersibleThreat == 0 or iOurAntiNavyThreat > iEnemySubmersibleThreat then
                        bAllOutAttack = true
                    else
                        --Can we ignore antinavy and take out the naval fac?
                        if iOurSurfaceThreat > iEnemySurfaceThreat * 2 then
                            if (iFriendlyDistToEnemy <= 200 and iEnemySubmersibleThreat < 0.1 * iOurSurfaceThreat) or iEnemySubmersibleThreat < 0.05 * iOurSurfaceThreat then
                                bIgnoreEnemySubs = true
                                bAllOutAttack = true
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Still consider all out attack if enemy has surface unit close to our base. bAllOutAttack='..tostring(bAllOutAttack)..'; Is oClosestSurfaceEnemy valid='..tostring(M27UnitInfo.IsUnitValid(oClosestSurfaceEnemy))) end




                if not(bAllOutAttack) and oClosestSurfaceEnemy then
                    --Still do all out attack if enemy has surface unit close to being in range of us
                    if bDebugMessages == true then LOG(sFunctionRef..': oClosestSurfaceEnemy='..oClosestSurfaceEnemy.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestSurfaceEnemy)..'; Dist to our base='..M27Utilities.GetDistanceBetweenPositions(oClosestSurfaceEnemy:GetPosition(), tOurBase)..'; iEnemyBestSurfaceRange='..iEnemyBestSurfaceRange..'; iEnemyBestIndirectRange='..iEnemyBestIndirectRange) end
                    if M27Utilities.GetDistanceBetweenPositions(oClosestSurfaceEnemy:GetPosition(), tOurBase) <= 40 +  math.max(iEnemyBestSurfaceRange, iEnemyBestIndirectRange) then
                        bAllOutAttack = true
                        bAttackNearbyEnemies = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Will attack nearby enemies') end
                    end
                end

                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iOurSurfaceThreat=' .. iOurSurfaceThreat .. '; iEnemySUrfaceThreat=' .. iEnemySurfaceThreat .. '; iOurAntiNavyThreat=' .. iOurAntiNavyThreat .. '; iEnemySubmersibleThreat=' .. iEnemySubmersibleThreat .. '; bAllOutAttack=' .. tostring(bAllOutAttack) .. '; WIll list out every unit in our main naval force and their threat value')
                    if M27Utilities.IsTableEmpty(tFriendliesNearFront) == false then
                        for iUnit, oUnit in tFriendlyNavalExcludingIntercept do
                            if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and M27UnitInfo.IsUnitValid(oUnit) then
                                LOG(sFunctionRef .. ': Unit ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. '; Surface threat=' .. M27Logic.GetCombatThreatRating(aiBrain, { oUnit }, false, nil, nil, false, false, false, false, true, false, false))
                            end
                        end
                    end
                    LOG(sFunctionRef..': tNavalThreatByTypeAndRange repr='..repru(tNavalThreatByTypeAndRange))
                end
                local iOurSubmersibleThreat = 0
                if not (bAllOutAttack) then
                    --Do we still want to attack with subs?
                    iOurSubmersibleThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendliesNearFront, false, nil, nil, false, false, false, false, false, true, false)
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want an all out sub attack. iOurSubmersibleThreat='..iOurSubmersibleThreat..'; iEnemySubmersibleThreat='..iEnemySubmersibleThreat) end
                    if iOurSubmersibleThreat > iEnemySubmersibleThreat * 1.5 then
                        local iEnemyAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesBetweenUsAndBase, false, nil, nil, false, false, false, true, false, false, false)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have stronger subs than enemy; checking their antinavy. now. iEnemyAntiNavyThreat='..iEnemyAntiNavyThreat) end
                        if iOurSubmersibleThreat > iEnemyAntiNavyThreat * 1.5 then
                            bAllOutSubAttack = true
                        end
                    end
                end
                --If dont have enough for all out attack, consider attacking nearest enemy unit if we can attack it without leaving our naval yard vulnerable
                if not(bAllOutSubAttack) and not(bAllOutAttack) and oClosestEnemyCombatUnit then
                    local iDistToClosestEnemyCombat =  M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())
                    local iClosestFriendlyDistToEnemyBase = M27Utilities.GetDistanceBetweenPositions(tEnemyBase, oClosestFriendlyUnitToEnemyBase:GetPosition())
                    local iDistThreshold = math.max(iClosestFriendlyDistToEnemyBase * 0.4, math.min(iClosestFriendlyDistToEnemyBase * 0.6, 300))
                    if iOurSurfaceThreat >= 30000 then
                        if iOurSurfaceThreat >= 60000 then

                            iDistThreshold = math.max(iDistThreshold, M27Utilities.GetDistanceBetweenPositions(tEnemyBase, tOurBase) * 0.7, 350)
                        elseif iOurSurfaceThreat >= 45000 then
                            iDistThreshold = math.max(iDistThreshold, M27Utilities.GetDistanceBetweenPositions(tEnemyBase, tOurBase) * 0.6, 325)
                        else
                            iDistThreshold = math.max(iDistThreshold, M27Utilities.GetDistanceBetweenPositions(tEnemyBase, tOurBase) * 0.5, 300)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we can either attack without leaving navla yard vulnerable, or have so much threat that we want to attack. iDistThreshold='..iDistThreshold..'; iDistToClosestEnemyCombat='..iDistToClosestEnemyCombat) end
                    if iDistToClosestEnemyCombat <= iDistThreshold then
                        local iDistToOurNavalBase = M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase)
                        if bDebugMessages == true then LOG(sFunctionRef..': iDistToOurNavalBase='..iDistToOurNavalBase..'; iClosestFriendlyDistToEnemyBase='..iClosestFriendlyDistToEnemyBase..'; Dist between closest enemy combat unit and our base='..M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit:GetPosition(), tOurBase)) end
                        if iDistToClosestEnemyCombat + iDistToOurNavalBase < iClosestFriendlyDistToEnemyBase and iDistToClosestEnemyCombat + M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit:GetPosition(), tOurBase) <= math.max(iDistThreshold, iClosestFriendlyDistToEnemyBase * 1.45) then

                            local iSurfaceThreatOfNearbyEnemies = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesNearClosestEnemyUnit, false, nil, nil, false, false, false, false, true, false, false)
                            local iAntiNavyThreatOfNearbyEnemies = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesNearClosestEnemyUnit, false, nil, nil, false, false, false, true, false, false, false)

                            if iOurSurfaceThreat > iSurfaceThreatOfNearbyEnemies * iMinSurfaceFactorWanted then
                                bAllOutAttack = true
                                bAttackNearbyEnemies = true
                            elseif iOurSubmersibleThreat > iAntiNavyThreatOfNearbyEnemies then
                                bAllOutSubAttack = true
                                bAttackNearbyEnemies = true
                            elseif iOurSurfaceThreat >= 30000 then --3-4 battleships in size
                                bAllOutAttack = true
                                bAttackNearbyEnemies = true
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we can take on nearest enemy unit with an all out attack. iSurfaceThreatOfNearbyEnemies='..iSurfaceThreatOfNearbyEnemies..'; iAntiNavyThreatOfNearbyEnemies='..iAntiNavyThreatOfNearbyEnemies..'; iOurSurfaceThreat='..iOurSurfaceThreat..'; iOurSubmersibleThreat='..iOurSubmersibleThreat..'; bAllOutAttack after considering='..tostring(bAllOutAttack)..'; bAllOutSubAttack='..tostring(bAllOutSubAttack)..'; bAttackNearbyEnemies='..tostring(bAttackNearbyEnemies)) end
                        end
                    end
                end

                local tGlobalNavalDestination
                local tDestinationForShortRangeUnits --If doing an all out attack/all out sub attack, units whose range is below the min range for engagement should instead go to this destination

                local iRangeOfClosestFriendlyUnit
                local iEnemyUnitTypeRef
                local iOurUnitTypeRef
                local iEnemyThreatRef
                local iOurThreatRef

                if not(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange]) then M27UnitInfo.GetNavalDirectAndSubRange(oClosestFriendlyUnitToEnemyBase) end --redundancy

                if bAllOutSubAttack and EntityCategoryContains(categories.SUBMERSIBLE, oClosestFriendlyUnitToEnemyBase.UnitId) then
                    iRangeOfClosestFriendlyUnit = oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange]
                    iEnemyUnitTypeRef = refiTypeAll
                    iOurUnitTypeRef = refiTypeSubmersible
                    iEnemyThreatRef = refiEnemyThreatAntiNavy
                    iOurThreatRef = refiFriendlyThreatAntiNavy

                elseif bAllOutAttack then
                    if bUseIndirectRangeIfHigher then
                        iRangeOfClosestFriendlyUnit = math.max(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiDFRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiIndirectRange])
                    else
                        iRangeOfClosestFriendlyUnit = math.max(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiDFRange])
                    end

                    iEnemyUnitTypeRef = refiTypeAll
                    iOurUnitTypeRef = refiTypeMobileNavy
                    iEnemyThreatRef = refiEnemyThreatSurface
                    iOurThreatRef = refiFriendlyThreatSurface

                end
                local iMinRangeForEngagement = 0
                local iOurCumulativeThreat = 0
                local iEnemyCumulativeThreat = 0
                local tiOurRatioVsEnemyByRange = {}
                --local tiOurAbsoluteThreatExcessByRange = {}
                local iBestRangeRatio = 0
                local iBestRangeDistance
                if bDebugMessages == true then LOG(sFunctionRef..': If we are doing an all out attack want to check our minimum engagement range. iOurThreatRef='..(iOurThreatRef or 'nil')..'; iOurUnitTypeRef='..(iOurUnitTypeRef or 'nil')..'; iEnemyUnitTypeRef='..(iEnemyUnitTypeRef or 'nil')..'; iEnemyThreatRef='..(iEnemyThreatRef or 'nil')..'; bAllOutSubAttack='..tostring(bAllOutSubAttack)..'; bAllOutAttack='..tostring(bAllOutAttack)) end

                if iOurThreatRef then --Proxy for if have set something above
                    --Calc min engagement range
                    local iRatioCap = 100
                    local iUseAbsoluteNotRatioThreshold = 10000
                    local bUseAbsoluteDifference = false
                    local iRatioCapForLowThreat = 1.3
                    local iLowThreatThreshold = 1500 --If have below this, then will cap the ratio if in ratio mode
                    --Dont want to use ratios below a certain threshold to avoid e.g. a cruiser trying to solo enemy frigates, but do want to engage at destroyer range if we have destroyers and enemy doesnt; since ceruisers have lower threat 1.5k should mean 1 cruiser is below threshold but 1 destroyer is above
                    if iOurSurfaceThreat <= iUseAbsoluteNotRatioThreshold then
                        bUseAbsoluteDifference = true
                        iRatioCap = iUseAbsoluteNotRatioThreshold
                    end
                    for iEntry, iRange in M27Utilities.SortTableByValue(tiRangesUsed, true) do
                        if not(tNavalThreatByTypeAndRange[iOurUnitTypeRef]) then tNavalThreatByTypeAndRange[iOurUnitTypeRef] = {} end
                        if not(tNavalThreatByTypeAndRange[iOurUnitTypeRef][iRange]) then tNavalThreatByTypeAndRange[iOurUnitTypeRef][iRange] = {} end
                        if not(tNavalThreatByTypeAndRange[iEnemyUnitTypeRef]) then tNavalThreatByTypeAndRange[iEnemyUnitTypeRef] = {} end
                        if not(tNavalThreatByTypeAndRange[iEnemyUnitTypeRef][iRange]) then tNavalThreatByTypeAndRange[iEnemyUnitTypeRef][iRange] = {} end

                        iOurCumulativeThreat = iOurCumulativeThreat + (tNavalThreatByTypeAndRange[iOurUnitTypeRef][iRange][iOurThreatRef] or 0)
                        iEnemyCumulativeThreat = iEnemyCumulativeThreat +  (tNavalThreatByTypeAndRange[iEnemyUnitTypeRef][iRange][iEnemyThreatRef] or 0)
                        if bUseAbsoluteDifference then
                            tiOurRatioVsEnemyByRange[iRange] = math.min(iRatioCap, iOurCumulativeThreat - iEnemyCumulativeThreat)
                        else
                            if iOurCumulativeThreat == 0 then
                                tiOurRatioVsEnemyByRange[iRange] = 0
                            elseif iEnemyCumulativeThreat == 0 then
                                tiOurRatioVsEnemyByRange[iRange] = iRatioCap
                            else
                                if iOurCumulativeThreat <= iLowThreatThreshold then tiOurRatioVsEnemyByRange[iRange] = math.min(iRatioCapForLowThreat, iRatioCap, iOurCumulativeThreat / iEnemyCumulativeThreat)
                                else
                                    tiOurRatioVsEnemyByRange[iRange] = math.min(iRatioCap, iOurCumulativeThreat / iEnemyCumulativeThreat)
                                end
                            end
                        end
                        --tiOurAbsoluteThreatExcessByRange[iRange] = iOurCumulativeThreat - iEnemyCumulativeThreat
                        if tiOurRatioVsEnemyByRange[iRange] >= iBestRangeRatio then
                            iBestRangeDistance = iRange
                            iBestRangeRatio = tiOurRatioVsEnemyByRange[iRange]
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iRange='..iRange..'; iOurCumulativeThreat='..iOurCumulativeThreat..'; iLowThreatThreshold='..iLowThreatThreshold..'; iRatioCap='..iRatioCap..'; iEnemyCumulativeThreat='..iEnemyCumulativeThreat..'; tiOurRatioVsEnemyByRange[iRange]='..tiOurRatioVsEnemyByRange[iRange]..'; iBestRangeRatio='..iBestRangeRatio..'; iBestRangeDistance='..(iBestRangeDistance or 'nil')) end
                    end

                    iMinRangeForEngagement = math.min(110, (iBestRangeDistance or 0)) --Can engagement min range based on range of Aeon battleship, so all battleships should be able to engage
                    if bDebugMessages == true then LOG(sFunctionRef..': Set min range for engagement to iBestRangeDistance='..(iBestRangeDistance or 'nil')) end
                end

                --Reduce min range for engagement to 0 if enemy near our base
                if M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit) and M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit:GetPosition(), tOurBase) <= math.max(oClosestEnemyCombatUnit[M27UnitInfo.refiDFRange], oClosestEnemyCombatUnit[M27UnitInfo.refiIndirectRange], oClosestEnemyCombatUnit[M27UnitInfo.refiAntiNavyRange]) + 30 then
                    iMinRangeForEngagement = 0
                end

                --Get the target enemy position:

                local tClosestEnemyTargetToUse
                if M27UnitInfo.IsUnitValid(oClosestSurfaceEnemy) and M27Utilities.CanSeeUnit(aiBrain, oClosestSurfaceEnemy) then UpdateUnitPond(oClosestSurfaceEnemy, iTeam, true) end  --Redundancy to update how far away it is in case delay with central logic
                if M27UnitInfo.IsUnitValid(oClosestEnemyUnit) and M27Utilities.CanSeeUnit(aiBrain, oClosestEnemyUnit) then
                    UpdateUnitPond(oClosestEnemyUnit, iTeam, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Have updated unit pond for closest enemy unit='..oClosestEnemyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; Distance between last known position and cur position (shoudl be 0)='..M27Utilities.GetDistanceBetweenPositions(oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition], oClosestEnemyUnit:GetPosition())) end
                end --Redundancy to update how far away it is in case delay in updating all units
                if M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit) and M27Utilities.CanSeeUnit(aiBrain, oClosestEnemyCombatUnit) then
                    UpdateUnitPond(oClosestEnemyCombatUnit, iTeam, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Have updated unit pond for closest enemy combat unit='..oClosestEnemyCombatUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyCombatUnit)..'; Dist to last known position (shoudl be 0)='..M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit:GetPosition(), oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition])) end
                end --Redundancy to update how far away it is in case delay in updating all units
                if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; Last known position='..repru(oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition])..'; Is visible='..tostring(M27Utilities.CanSeeUnit(aiBrain, oClosestEnemyUnit, true))..'; Distance between cur position and last known position='..M27Utilities.GetDistanceBetweenPositions(oClosestEnemyUnit:GetPosition(), oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition])) end

                local bChargeEnemyBase = false --true if we decide to ignore closest enemies and just go for neemy base, e.g. if have far more threat


                if bAttackNearbyEnemies and not(bAllOutSubAttack) and oClosestEnemySurfaceCombat and (M27Utilities.CanSeeUnit(aiBrain, oClosestEnemySurfaceCombat)  or M27Utilities.GetDistanceBetweenPositions(oClosestEnemySurfaceCombat[M27UnitInfo.reftLastKnownPosition], oClosestEnemySurfaceCombat:GetPosition()) <= 50) then tClosestEnemyTargetToUse = oClosestEnemySurfaceCombat[M27UnitInfo.reftLastKnownPosition]
                elseif bAttackNearbyEnemies and bAllOutSubAttack and oClosestEnemyCombatUnit and (M27Utilities.CanSeeUnit(aiBrain, oClosestEnemyUnit)  or M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition], oClosestEnemyCombatUnit:GetPosition()) <= 50) then tClosestEnemyTargetToUse = oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition]
                else
                    --If we massively outnumber enemy naval threat then just go for the enemy naval factories
                    if bDebugMessages == true then LOG(sFunctionRef..': If massively outnumber enemy in navy and likely have battleships then target enemy naval factory. iOurSurfaceThreat='..iOurSurfaceThreat..'; iEnemySurfaceThreat='..iEnemySurfaceThreat) end
                    if iOurSurfaceThreat > iEnemySurfaceThreat * 3.5 and iOurSurfaceThreat >= 30000 then
                        local tEnemyFactories = EntityCategoryFilterDown(M27UnitInfo.refCategoryNavalFactory, tEnemyNavalExcludingMiniThreats)
                        if M27Utilities.IsTableEmpty(tEnemyFactories) == false then
                            bChargeEnemyBase = true
                            tClosestEnemyTargetToUse = M27Utilities.GetNearestUnit(tEnemyFactories, tOurBase):GetPosition()
                            if bDebugMessages == true then LOG(sFunctionRef..': Will target closest enemy unit='..M27Utilities.GetNearestUnit(tEnemyFactories, tOurBase).UnitId..M27UnitInfo.GetUnitLifetimeCount(M27Utilities.GetNearestUnit(tEnemyFactories, tOurBase))) end
                        end
                    end
                    if M27Utilities.IsTableEmpty(tClosestEnemyTargetToUse) then
                        if M27Utilities.GetDistanceBetweenPositions(oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition], oClosestEnemyUnit:GetPosition()) > 50 then
                            local tVisibleEnemiesAroundFrontUnit = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategorySurfaceAmphibiousCombat, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.max(iEnemyBestSurfaceRange, iEnemyBestAntiNavyRange, 70) + 20)
                            if M27Utilities.IsTableEmpty(tVisibleEnemiesAroundFrontUnit) then
                                --No nearby visible neemies, target enemy base
                                tClosestEnemyTargetToUse = { tEnemyBase[1], tEnemyBase[2], tEnemyBase[3] }
                                if bDebugMessages == true then LOG(sFunctionRef..': No visible enemies, will target enemy base instead of closest enemy for tClosestEnemyTargetToUse') end
                            else
                                --Get closest visible enemy
                                tClosestEnemyTargetToUse = M27Utilities.GetNearestUnit(tVisibleEnemiesAroundFrontUnit, oClosestFriendlyUnitToEnemyBase:GetPosition()):GetPosition()
                                if bDebugMessages == true then LOG(sFunctionRef..': Have visible enemies so setting tClosestEnemyTargetToUse to this') end
                            end
                        else
                            tClosestEnemyTargetToUse = { oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition][1], oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition][2], oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition][3] }
                            if bDebugMessages == true then LOG(sFunctionRef..': Setting closest enemy target to its last known position') end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Do we have a min engagement range of more than 0? iMinRangeForEngagement='..(iMinRangeForEngagement or 'nil')..'; tClosestEnemyTargetToUse='..repru(tClosestEnemyTargetToUse)..'; Dist between here and tenemybase='..M27Utilities.GetDistanceBetweenPositions(tEnemyBase, tClosestEnemyTargetToUse)..'; iMinRangeForEngagement='..(iMinRangeForEngagement or 'nil')..'; is table of enemy units near front empty='..tostring(M27Utilities.IsTableEmpty(tFriendliesNearFront))) end


                --If we only want to do an all out attack for certain ranged units, then work out where units with a shorter range should go, or if they should do an all out attack as well due ot the enemy being close to our long range unit

                if iMinRangeForEngagement > 0 and M27Utilities.IsTableEmpty(tFriendliesNearFront) == false then
                    local iDistanceBehindFrontUnitWanted = 12
                    local oNearestFriendlyWithSufficientRange
                    local iCurDistToEnemy
                    local iClosestDistToEnemy = 10000
                    local iCurRange
                    for iUnit, oUnit in tFriendliesNearFront do
                        if bAllOutSubAttack then
                            if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then iCurRange = oUnit[M27UnitInfo.refiAntiNavyRange] end
                        elseif bUseIndirectRangeIfHigher then --general all out attack that can include indirect range as nearest unit is structure
                            iCurRange = math.max(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiDFRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiIndirectRange])
                        else --general all out attack
                            iCurRange = math.max(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiDFRange])
                        end
                        if iCurRange >= iMinRangeForEngagement then
                            iCurDistToEnemy = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tClosestEnemyTargetToUse)
                            if iCurDistToEnemy < iClosestDistToEnemy then
                                oNearestFriendlyWithSufficientRange = oUnit
                            end
                        end
                    end
                    if not(oNearestFriendlyWithSufficientRange) and iRangeOfClosestFriendlyUnit < iMinRangeForEngagement then
                        --Backup for rare cases where no unit with enough range
                        iDistanceBehindFrontUnitWanted = 30
                        tDestinationForShortRangeUnits = M27Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase), iDistanceBehindFrontUnitWanted, true, false)
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont have a nearest friendly unit with sufficient range, so will set the destination for short range units equal to the position of the nearest unit to enemy base') end
                    else
                        --Is the enemy front unit almost within range?
                        local iEnemyRange
                        if bAllOutSubAttack then iEnemyRange = oClosestEnemyUnit[M27UnitInfo.refiAntiNavyRange]
                        else
                            iEnemyRange = math.max(oClosestEnemyUnit[M27UnitInfo.refiAntiNavyRange], oClosestEnemyUnit[M27UnitInfo.refiDFRange])
                        end
                        if M27Utilities.GetDistanceBetweenPositions(oNearestFriendlyWithSufficientRange:GetPosition(), tClosestEnemyTargetToUse) + iEnemyRange + iDistanceBehindFrontUnitWanted - 4 > iMinRangeForEngagement then
                            iMinRangeForEngagement = 0 --Dont want a minimum range as enemy almost in range
                            iDistanceBehindFrontUnitWanted = 30
                            if bDebugMessages == true then LOG(sFunctionRef..': Dont want a minimum range as enemy almost in range so will set short range unit destination equal to 30 behind the front unit') end
                        end
                        tDestinationForShortRangeUnits = M27Utilities.MoveInDirection(oNearestFriendlyWithSufficientRange:GetPosition(), M27Utilities.GetAngleFromAToB(oNearestFriendlyWithSufficientRange:GetPosition(), tOurBase), iDistanceBehindFrontUnitWanted, true, false)

                    end
                else
                    --Placehodler - dont expect to use this
                    tDestinationForShortRangeUnits = M27Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase), 30, true, false)
                    if bDebugMessages == true then LOG(sFunctionRef..': Not doing all out attack, will just record tDestinationForShortRangeUnits as being the closest friendly unit to enemy so dont have nil value') end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished determining tDestinationForShortRangeUnits='..repru(tDestinationForShortRangeUnits)) end

                if bAllOutAttack then
                    iNavalStrategy = M27Team.refiNavalStrategyAttack
                    local oNearestThreatToConsider
                    local bAttackNearestThreatInstead = false

                    --Do we want to attack the enemy base or the enemy naval unit?
                    if bIgnoreEnemySubs and EntityCategoryContains(categories.SUBMERSIBLE, oClosestEnemyUnit.UnitId) then
                        --Get closest non-submersible threat
                        oNearestThreatToConsider = oClosestSurfaceEnemy
                    else
                        oNearestThreatToConsider = oClosestEnemyUnit
                    end
                    if oNearestThreatToConsider then
                        if M27Utilities.GetDistanceBetweenPositions(oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition], tOurBase) + M27UnitInfo.GetNavalDirectAndSubRange(oNearestThreatToConsider) - 10 <= iFriendlyDistToEnemy + M27UnitInfo.GetNavalDirectAndSubRange(oClosestFriendlyUnitToEnemyBase) then
                            --Special case - avoid navy all heading towards a really old position of a unit - approximate by comparing the actual position to last known position and not proceeding if it is more than 50 away
                            if M27Utilities.GetDistanceBetweenPositions(oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition], oNearestThreatToConsider:GetPosition()) <= 50 then
                                bAttackNearestThreatInstead = true
                            end
                        end
                    end

                    if bAttackNearestThreatInstead then
                        --Attack nearest enemy unit - move to just before actual position if we have seen the unit
                        if M27Utilities.CanSeeUnit(aiBrain, oNearestThreatToConsider, true) then
                            tGlobalNavalDestination = M27Utilities.MoveInDirection(oNearestThreatToConsider:GetPosition(), M27Utilities.GetAngleFromAToB(oNearestThreatToConsider:GetPosition(), tOurBase), 4, true, false)
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to attack nearest threat, so global naval destination is nearest enemy threat') end
                        else
                            tGlobalNavalDestination = { oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition][1], oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition][2], oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition][3] }
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to attack nearest enemy and cant see it wil global naval destination is last known position') end
                        end
                    else
                        --Attack enemy base
                        tGlobalNavalDestination = tEnemyBase
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to attack enemy base so global naval destination is enemy base') end
                        --Bombardment mode instead if enemy has no base and minimal threat vs ours
                        if iEnemySurfaceThreat + iEnemyMiniThreatCumulativeThreat <= 1000 and (iEnemySurfaceThreat + iEnemyMiniThreatCumulativeThreat) * 8 <= iOurSurfaceThreat and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.STRUCTURE, tEnemyNavalExcludingMiniThreats)) then
                            bConsiderBombardment = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy has less than 1k in threat and 1/8 of our threat so will consider bomardment mode') end
                        elseif iOurSurfaceThreat >= 25000 and (iEnemySurfaceThreat + iEnemyMiniThreatCumulativeThreat) * 8 <= iOurSurfaceThreat and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryNavalFactory, tEnemyNavalExcludingMiniThreats)) then
                            bConsiderBombardment = true
                            if bDebugMessages == true then LOG(sFunctionRef..': We have at least 25k threat and 8 times enemy threat so will consider bombardment') end
                        end

                    end
                else
                    --If we meet up with nearby reinforcements will we have enough surface threat?
                    local iReinforcementSurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendlyNearbyReinforcements, false, nil, nil, false, false, false, false, true, false, false)
                    local iReinforcementAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendlyNearbyReinforcements, false, nil, nil, false, false, false, true, false, false, false)
                    iOurSurfaceThreat = iOurSurfaceThreat + iReinforcementSurfaceThreat
                    iOurAntiNavyThreat = iOurAntiNavyThreat + iReinforcementAntiNavyThreat
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Our threats after increasing for reinforcements: iOurSurfaceThreat=' .. iOurSurfaceThreat .. '; iOurAntiNavyThreat=' .. iOurAntiNavyThreat)
                        if M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements) == false then
                            LOG(sFunctionRef .. ': Size of tFriendlyNearbyReinforcements=' .. table.getn(tFriendlyNearbyReinforcements))
                        end
                    end

                    if (iReinforcementSurfaceThreat > 0 or iReinforcementAntiNavyThreat > 0) and iOurSurfaceThreat >= iEnemySurfaceThreat * 1.1 and iOurAntiNavyThreat >= iEnemySubmersibleThreat then
                        --Consolidate forces
                        bConsolidateForces = true
                        local tTablesOfUnitsToAverage = {}
                        if M27Utilities.IsTableEmpty(tFriendliesNearFront) == false then
                            local tMobileFriendliesNearFront = EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendliesNearFront)
                            if M27Utilities.IsTableEmpty(tMobileFriendliesNearFront) == false then
                                table.insert(tTablesOfUnitsToAverage, tMobileFriendliesNearFront)
                            end
                        end
                        if M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements) == false then
                            local tMobileFriendliesNearFront = EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendlyNearbyReinforcements)
                            if M27Utilities.IsTableEmpty(tMobileFriendliesNearFront) == false then
                                table.insert(tTablesOfUnitsToAverage, tMobileFriendliesNearFront)
                            end
                        end
                        if M27Utilities.IsTableEmpty(tTablesOfUnitsToAverage) == false and table.getn(tTablesOfUnitsToAverage) > 0 and (iOurAntiNavyThreat > 0 or iEnemySubmersibleThreat == 0) then

                            tGlobalNavalDestination = M27Utilities.GetAveragePositionOfMultipleTablesOfUnits(tTablesOfUnitsToAverage)
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to consolidate our forces so will set global naval destination based on this') end
                        else
                            tGlobalNavalDestination = { tOurBase[1], tOurBase[2], tOurBase[3] }
                            if bDebugMessages == true then LOG(sFunctionRef..': want to retreat to our base so will set global naval destination accordingly') end
                        end

                        if bDebugMessages == true then
                            local iUnits = 0
                            for iUnitTable, tUnitTable in tTablesOfUnitsToAverage do
                                iUnits = iUnits + table.getn(tUnitTable)
                            end
                            LOG(sFunctionRef .. ': Want to consolidate nearby reinforcement forces, will set global naval destination to move to average location of mobile unites=' .. repru(tGlobalNavalDestination) .. '; size of UnitsToAverage=' .. iUnits)
                        end
                    else
                        --If we include all reinforcements do we have enough threat?
                        local iReinforcementSurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendlyFurtherAwayReinforcements, false, nil, nil, false, false, false, false, true, false, false)
                        local iReinforcementAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendlyFurtherAwayReinforcements, false, nil, nil, false, false, false, true, false, false, false)
                        iOurSurfaceThreat = iOurSurfaceThreat + iReinforcementSurfaceThreat
                        iOurAntiNavyThreat = iOurAntiNavyThreat + iReinforcementAntiNavyThreat

                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Our threats after increasing for further away reinforcements: iOurSurfaceThreat=' .. iOurSurfaceThreat .. '; iOurAntiNavyThreat=' .. iOurAntiNavyThreat)
                        end
                        if (iReinforcementSurfaceThreat > 0 or iReinforcementAntiNavyThreat > 0) and iOurSurfaceThreat >= iEnemySurfaceThreat * 1.1 and iOurAntiNavyThreat >= iEnemySubmersibleThreat then
                            --Consolidate forces
                            bConsolidateForces = true
                            local tTablesOfUnitsToAverage = {}
                            if M27Utilities.IsTableEmpty(tFriendliesNearFront) == false then
                                local tMobileFriendliesNearFront = EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendliesNearFront)
                                if M27Utilities.IsTableEmpty(tMobileFriendliesNearFront) == false then
                                    table.insert(tTablesOfUnitsToAverage, tMobileFriendliesNearFront)
                                end
                            end
                            if M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements) == false then
                                local tMobileFriendliesNearFront = EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendlyNearbyReinforcements)
                                if M27Utilities.IsTableEmpty(tMobileFriendliesNearFront) == false then
                                    table.insert(tTablesOfUnitsToAverage, tMobileFriendliesNearFront)
                                end
                            end
                            if M27Utilities.IsTableEmpty(tFriendlyFurtherAwayReinforcements) == false then
                                local tMobileFriendliesNearFront = EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendlyFurtherAwayReinforcements)
                                if M27Utilities.IsTableEmpty(tMobileFriendliesNearFront) == false then
                                    table.insert(tTablesOfUnitsToAverage, tMobileFriendliesNearFront)
                                end
                            end

                            if M27Utilities.IsTableEmpty(tTablesOfUnitsToAverage) == false then
                                tGlobalNavalDestination = M27Utilities.GetAveragePositionOfMultipleTablesOfUnits(tTablesOfUnitsToAverage)

                                if bDebugMessages == true then
                                    local iUnits = 0
                                    for iUnitTable, tUnitTable in tTablesOfUnitsToAverage do
                                        iUnits = iUnits + table.getn(tUnitTable)
                                    end
                                    LOG(sFunctionRef .. ': Global naval destination - Want to consolidate all reinforcement forces, will move to average location of mobile unites=' .. repru(tGlobalNavalDestination) .. '; size of UnitsToAverage=' .. iUnits)
                                end
                            else
                                tGlobalNavalDestination = { tOurBase[1], tOurBase[2], tOurBase[3] }
                                if bDebugMessages == true then LOG(sFunctionRef..': Want to move to our base as global naval destination') end
                            end
                        else

                            --Retreat

                            tGlobalNavalDestination = M27Utilities.MoveInDirection(tOurBase, iAngleToEnemy, 40, true, false)
                            --If not in same pond then reduce dist to 5 and try in opposite direction
                            if not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tGlobalNavalDestination) == iPond) then
                                for iAngleMod = 0, 315, 45 do
                                    tGlobalNavalDestination = M27Utilities.MoveInDirection(tOurBase, iAngleToEnemy + iAngleMod, 8, true, false)
                                    if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tGlobalNavalDestination) == iPond then
                                        break
                                    end
                                end
                            end
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Want to retreat, will set global naval destination so we run to base=' .. repru(tGlobalNavalDestination))
                            end
                        end
                    end
                end

                --Decide individually if units should move to the destination or move away from the enemy (if kiting) - handle submersible units separately


                ---->>>>SUBMERSIBLES<<<----
                local tBaseRallyPoint = M27Utilities.MoveInDirection(tOurBase, M27Utilities.GetAngleFromAToB(tOurBase, tEnemyBase), 8, true, false)
                if not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tBaseRallyPoint) == iPond) then
                    for iAngleMod = 45, 315, 45 do
                        tBaseRallyPoint = M27Utilities.MoveInDirection(tOurBase, iAngleToEnemy + iAngleMod, 8, true, false)
                        if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tGlobalNavalDestination) == iPond then
                            break
                        end
                    end
                end

                local tOurSubmersibles = EntityCategoryFilterDown(M27UnitInfo.refCategorySubmarine, tFriendlyNavalExcludingIntercept)
                if bDebugMessages == true then LOG(sFunctionRef..': About to send orders to any subs we have. bAllOutSubAttack='..tostring(bAllOutSubAttack)..'; Is table of our submersibles empty='..tostring(M27Utilities.IsTableEmpty(tOurSubmersibles))) end
                --Want to get all subs for below (regardless of if close or reinforcement) - will have already decided above whether to attack or not with subs

                if M27Utilities.IsTableEmpty(tOurSubmersibles) == false then
                    --Assign actions to subs
                    --If in all out attack mode or outrange enemy then move to be in attack range
                    local iMaxDistanceWithinAttackRangeWanted = nil
                    local iMinDistanceWithinAttackRangeWanted = nil

                    --Update ranges wanted - keep as nil if want to ignore nearest enemy unit

                    if iOurBestSubmersibleRange > iEnemyBestAntiNavyRange then
                        iMaxDistanceWithinAttackRangeWanted = 0.5
                        iMinDistanceWithinAttackRangeWanted = -7.5
                        if iOurBestSubmersibleRange - 8 > iEnemyBestAntiNavyRange then
                            iMinDistanceWithinAttackRangeWanted = iMinDistanceWithinAttackRangeWanted + 3
                            iMaxDistanceWithinAttackRangeWanted = iMaxDistanceWithinAttackRangeWanted + 3
                        end
                    elseif bAllOutAttack or bAllOutSubAttack then
                        iMaxDistanceWithinAttackRangeWanted = 8.5
                        iMinDistanceWithinAttackRangeWanted = 1.3
                    end

                    if iMaxDistanceWithinAttackRangeWanted then
                        --Want to either move towards enemy or do kiting retreat
                        --Move towards nearest enemy unit until within range
                        local iCurDistToClosestEnemy
                        for iUnit, oUnit in tOurSubmersibles do
                            --Do we want to engage the enemy?
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering submersible unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; AntiNavyRange='..(oUnit[M27UnitInfo.refiAntiNavyRange] or 'nil')..'; iMinRangeForEngagement='..iMinRangeForEngagement) end
                            if oUnit[M27UnitInfo.refiAntiNavyRange] < iMinRangeForEngagement then
                                MoveUnitTowardsTarget(oUnit, tDestinationForShortRangeUnits, false, 'ShortRange')
                            else
                                iCurDistToClosestEnemy = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tClosestEnemyTargetToUse)
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToClosestEnemy='..iCurDistToClosestEnemy..'; iMaxDistanceWithinAttackRangeWanted='..iMaxDistanceWithinAttackRangeWanted..'; oUnit[M27UnitInfo.refiAntiNavyRange]='..(oUnit[M27UnitInfo.refiAntiNavyRange] or 'nil')) end
                                if iCurDistToClosestEnemy + iMaxDistanceWithinAttackRangeWanted < oUnit[M27UnitInfo.refiAntiNavyRange] then
                                    if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase) <= 20 then
                                        MoveUnitTowardsTarget(oUnit, tBaseRallyPoint, not(oUnit[M27UnitInfo.refbLastShotBlocked]), 'ASKitingRetreat')
                                    else
                                        MoveUnitTowardsTarget(oUnit, tBaseRallyPoint, false, 'MSKitingRetreat')
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and move to tBaseRallyPoint='..repru(tBaseRallyPoint)..' as a kiting retreat') end
                                    end
                                elseif iCurDistToClosestEnemy + iMinDistanceWithinAttackRangeWanted < oUnit[M27UnitInfo.refiAntiNavyRange] then
                                    --Attack-move to target
                                    MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, not(oUnit[M27UnitInfo.refbLastShotBlocked]), 'ASGetInRange')
                                else
                                    --Move towards target (non-attack move)
                                    MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, false, 'MSGetInRange')
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and move to tClosestEnemyTargetToUse='..repru(tClosestEnemyTargetToUse)..'; Our position='..repru(oUnit:GetPosition())..'; oUnit[M27UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M27UnitInfo.refbSpecialMicroActive])..'; oUnit[M27UnitInfo.reftLastOrderTarget]='..repru(oUnit[M27UnitInfo.reftLastOrderTarget])) end
                                end
                            end
                        end
                    else
                        --We dont outrange enemy, and htink we will lose if we will attack, so retreat
                        local sOrderDesc = 'MainRetreat'
                        if bConsolidateForces then
                            sOrderDesc = 'Consolidate'
                        end
                        for iUnit, oUnit in tOurSubmersibles do
                            MoveUnitTowardsTarget(oUnit, tGlobalNavalDestination, false, sOrderDesc)
                        end
                    end
                end

                ---->>>>SURFACE NAVY<<<----
                if not (bConsiderBombardment) then
                    local tOurSurfaceCombatNavy = EntityCategoryFilterDown(M27UnitInfo.refCategoryMobileNavalSurface - iSupportNavyCategory, tFriendlyNavalExcludingIntercept)
                    if M27Utilities.IsTableEmpty(tOurSurfaceCombatNavy) == false then

                        local iMaxDistanceWithinAttackRangeWanted = nil
                        local iMinDistanceWithinAttackRangeWanted = nil

                        --Update ranges wanted - keep as nil if want to ignore nearest enemy unit
                        --Do we outrange the enemy with our attack?
                        if iOurBestSurfaceRange > math.max(iEnemyBestSurfaceRange, iEnemyBestAntiNavyRange) then
                            --Is the nearest enemy a surface unit, or alternatively do we outrange the enemy with our antinavy?
                            if not (M27UnitInfo.IsUnitUnderwater(oClosestEnemyUnit)) then
                                if iOurBestSurfaceRange >= 100 then --Dealing with battleship, so allow a bit more of a margin before flee
                                    iMaxDistanceWithinAttackRangeWanted = 7.5
                                    iMinDistanceWithinAttackRangeWanted = -0.5
                                    if iOurSurfaceThreat > iEnemySurfaceThreat * 2.5 and iOurSurfaceThreat >= 20000 then
                                        iMaxDistanceWithinAttackRangeWanted = 20
                                    end
                                else
                                    iMaxDistanceWithinAttackRangeWanted = 0.5
                                    iMinDistanceWithinAttackRangeWanted = -7.5
                                    if iOurBestSurfaceRange - 15 > iEnemyBestSurfaceRange then
                                        iMaxDistanceWithinAttackRangeWanted = iMaxDistanceWithinAttackRangeWanted + 3
                                        iMinDistanceWithinAttackRangeWanted = iMinDistanceWithinAttackRangeWanted + 3
                                    end
                                end
                            elseif iOurBestSurfaceAntiNavyRange > iEnemyBestSubmersibleRange then
                                iMaxDistanceWithinAttackRangeWanted = 0.5
                                iMinDistanceWithinAttackRangeWanted = -7.5
                            end
                            --Are we doing an all out attack and either we arent dealing with a sub, or we have an antinavy attack?
                        elseif bAllOutAttack and (not (M27UnitInfo.IsUnitUnderwater(oClosestEnemyUnit)) or iOurBestSurfaceAntiNavyRange > 0) then
                            iMaxDistanceWithinAttackRangeWanted = 8.5 --Refresh rate can be every 1.2s; frigates move at 6 speed; want min of 7.2 gap in distance threshold to avoid frigate not switching to attack-move when closing in on a stationery target
                            iMinDistanceWithinAttackRangeWanted = 1.3
                        end

                        --Reduce kiting if nearest unit is a structure since it cant pursue us
                        if iMinDistanceWithinAttackRangeWanted and EntityCategoryContains(categories.STRUCTURE, oClosestEnemyUnit.UnitId) then
                            iMinDistanceWithinAttackRangeWanted = math.max(iMinDistanceWithinAttackRangeWanted, 0)
                            if EntityCategoryContains(categories.DIRECTFIRE + categories.INDIRECTFIRE + categories.ANTINAVY, oClosestEnemyUnit.UnitId) then
                                iMaxDistanceWithinAttackRangeWanted = math.max(iMinDistanceWithinAttackRangeWanted + 4, iMinDistanceWithinAttackRangeWanted)
                            else
                                iMaxDistanceWithinAttackRangeWanted = math.max(iMinDistanceWithinAttackRangeWanted + 8, iMinDistanceWithinAttackRangeWanted)
                            end

                        end

                        --Reduce kiting difference if we have significantly more threat, and also have destoyers use antinavy range or DF range, whichever is lower
                        local bUseTorpedoRangeForDestroyers = false
                        if iOurSurfaceThreat > iEnemySurfaceThreat * 1.75 then
                            if not(iMaxDistanceWithinAttackRangeWanted) then
                                iMaxDistanceWithinAttackRangeWanted = 0.5
                                iMinDistanceWithinAttackRangeWanted = -7.5
                            end
                            bUseTorpedoRangeForDestroyers = true
                            iMaxDistanceWithinAttackRangeWanted = iMaxDistanceWithinAttackRangeWanted + 2
                        end

                        if bDebugMessages == true then LOG(sFunctionRef..': About to consider attacking with surface units, iOurBestSurfaceRange='..iOurBestSurfaceRange..'; iMaxDistanceWithinAttackRangeWanted='..(iMaxDistanceWithinAttackRangeWanted or 'nil')..'; iMinRangeForEngagement='..iMinRangeForEngagement..'; Is table of tEnemiesBetweenUsAndBase empty='..tostring(M27Utilities.IsTableEmpty(tEnemiesBetweenUsAndBase))) end

                        local tPotentialGroundFireTargets = {}

                        if M27Utilities.IsTableEmpty(tEnemiesBetweenUsAndBase) == false then
                            local tEnemySubs = EntityCategoryFilterDown(categories.SUBMERSIBLE, M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond])
                            if bDebugMessages == true then LOG(sFunctionRef..': Checking if have subs that want to ground fire, is table empty='..tostring(M27Utilities.IsTableEmpty(tEnemySubs))) end
                            if M27Utilities.IsTableEmpty(tEnemySubs) == false then
                                for iUnit, oUnit in tEnemySubs do
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy sub='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; Is underwater='..tostring(M27UnitInfo.IsUnitUnderwater(oUnit))..'; Unit state='..M27Logic.GetUnitState(oUnit)..'; Distance to closest friendly unit='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())..'; Can see unit='..tostring(M27Utilities.CanSeeUnit(aiBrain, oUnit, true))..'; Distance to last known position='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M27UnitInfo.reftLastKnownPosition])) end
                                    if M27UnitInfo.IsUnitUnderwater(oUnit) and not(oUnit:IsUnitState('Moving')) and M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition()) <= 125 then
                                        --Check either visible or close to last known position
                                        if M27Utilities.CanSeeUnit(aiBrain, oUnit, true) or M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit[M27UnitInfo.reftLastKnownPosition]) <= 1.8 then
                                            table.insert(tPotentialGroundFireTargets, oUnit)
                                            if bDebugMessages == true then LOG(sFunctionRef..': Added unit to list of potential ground fire targets') end
                                        end
                                    end
                                end
                            end
                        end

                        local bConsiderGroundFiring = false
                        local bHaveValidSurfaceCombat = M27UnitInfo.IsUnitValid(oClosestEnemySurfaceCombat)

                        if M27Utilities.IsTableEmpty(tPotentialGroundFireTargets) == false and M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit) and M27UnitInfo.IsUnitUnderwater(oClosestEnemyCombatUnit) then
                            bConsiderGroundFiring = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Is Potential ground fire targets empty='..tostring(M27Utilities.IsTableEmpty(tPotentialGroundFireTargets))..'; Is closest enemy combat unit underwater='..tostring(M27UnitInfo.IsUnitUnderwater(oClosestEnemyCombatUnit))..'; bConsiderGroundFiring='..tostring(bConsiderGroundFiring))
                            if oClosestEnemyCombatUnit then LOG('Closest enemy combat unit='..oClosestEnemyCombatUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyCombatUnit)) end
                        end

                        function ConsiderIssuingGroundFireOrder(oUnit)
                            --Returns true if gives a ground-fire order to the unit
                            if bConsiderGroundFiring and EntityCategoryContains(M27UnitInfo.refCategoryBattleship, oUnit.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to ground fire for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; Distance to closest enemy surface combat='..M27Utilities.GetDistanceBetweenPositions(oClosestEnemySurfaceCombat:GetPosition(), oUnit:GetPosition())..'; DF range='..oUnit[M27UnitInfo.refiDFRange]..'; oUnit[M27UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M27UnitInfo.refbLastShotBlocked])) end
                                --Have a unit that can ground fire, and the nearest enemy unit is underwater; if we have no surface naval units within our range then will issue ground fire order
                                if not(bHaveValidSurfaceCombat) or M27Utilities.GetDistanceBetweenPositions(oClosestEnemySurfaceCombat:GetPosition(), oUnit:GetPosition()) > oUnit[M27UnitInfo.refiDFRange] then
                                    local oGroundFireTarget
                                    for iSub, oSub in tPotentialGroundFireTargets do
                                        if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to groundfire sub '..oSub.UnitId..M27UnitInfo.GetUnitLifetimeCount(oSub)..' which is '..M27Utilities.GetDistanceBetweenPositions(oSub[M27UnitInfo.reftLastKnownPosition], oUnit:GetPosition())..' away from us based on its last known position. Is it water or flat to this sub='..tostring(M27MapInfo.IsWaterOrFlatAlongLine(oUnit:GetPosition(), oSub:GetPosition()))) end
                                        if M27Utilities.GetDistanceBetweenPositions(oSub[M27UnitInfo.reftLastKnownPosition], oUnit:GetPosition()) + 2 < oUnit[M27UnitInfo.refiDFRange] then
                                            --Check shot not blocked
                                            if M27MapInfo.IsWaterOrFlatAlongLine(oUnit:GetPosition(), oSub:GetPosition()) then
                                                --Isuse attack ground order
                                                TellUnitToAttackGround(oUnit, {oSub[M27UnitInfo.reftLastKnownPosition][1], oSub[M27UnitInfo.reftLastKnownPosition][2], oSub[M27UnitInfo.reftLastKnownPosition][3]}, 'GroundAttack')
                                                if bDebugMessages == true then LOG(sFunctionRef..': will ground fire the sub') end
                                                return true
                                            end
                                        end
                                    end
                                end

                            end
                            return false

                        end


                        if iMaxDistanceWithinAttackRangeWanted then
                            local iCurDistToClosestEnemy
                            --Want to either move towards enemy or do kiting retreat
                            --Move towards nearest enemy unit until within range
                            local iCurRange

                            --Get shortlist of priority structures if are charging at enemy base in case shot is blocked
                            local tPriorityTargets = {}
                            local oPriorityTarget
                            local iCurDistToPriority
                            local tEnemyPD = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT2PlusPD + M27UnitInfo.refCategoryTorpedoLauncher + M27UnitInfo.refCategoryFixedT2Arti, oClosestFriendlyUnitToEnemyBase:GetPosition(), 120, 'Enemy')
                            if bChargeEnemyBase then
                                tPriorityTargets = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT2PlusPD + M27UnitInfo.refCategoryTorpedoLauncher - categories.SUBMERSIBLE + M27UnitInfo.refCategoryFixedShield + M27UnitInfo.refCategoryFixedT2Arti + M27UnitInfo.refCategoryNavalFactory, tClosestEnemyTargetToUse, 120, 'Enemy')
                            end

                            function RetreatFromPD(oUnit)

                                if M27Utilities.IsTableEmpty(tEnemyPD) == false then
                                    for iPD, oPD in tEnemyPD do
                                        if bDebugMessages == true then LOG(sFunctionRef..': RetreatFromPD: oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; oPD='..oPD.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPD)..'; Dist between them='..M27Utilities.GetDistanceBetweenPositions(oPD:GetPosition(), oUnit:GetPosition())..'; Range of PD='..M27UnitInfo.GetNavalDirectAndSubRange(oPD)) end
                                        if M27Utilities.GetDistanceBetweenPositions(oPD:GetPosition(), oUnit:GetPosition()) - 8 <= M27UnitInfo.GetNavalDirectAndSubRange(oPD) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to retreat from PD') end
                                            MoveUnitTowardsTarget(oUnit, tOurBase, false, 'PDRetreat')
                                            return true
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': No PD to retreat from') end
                                return false

                            end






                            local bIndirectAttackBuilding

                            for iUnit, oUnit in tOurSurfaceCombatNavy do
                                --Do we want to engage the enemy with surface unit?
                                if not(oUnit[M27UnitInfo.refiDFRange]) then
                                    iCurRange = M27UnitInfo.GetNavalDirectAndSubRange(oUnit) --this line is for redundancy so dont need to worry about factoring in indirect as shoudl be a 1-off
                                    if bUseAntiNavyRangeOnly then iCurRange = oUnit[M27UnitInfo.refiAntiNavyRange] end
                                else
                                    if bUseIndirectRangeIfHigher then
                                        iCurRange = math.max(oUnit[M27UnitInfo.refiAntiNavyRange], oUnit[M27UnitInfo.refiDFRange], oUnit[M27UnitInfo.refiIndirectRange])
                                    elseif bUseAntiNavyRangeOnly then
                                        iCurRange = oUnit[M27UnitInfo.refiAntiNavyRange]
                                    else
                                        if bUseTorpedoRangeForDestroyers and oUnit[M27UnitInfo.refiAntiNavyRange] > 0 and oUnit[M27UnitInfo.refiDFRange] > 0 and EntityCategoryContains(M27UnitInfo.refCategoryDestroyer, oUnit.UnitId) then
                                            iCurRange = math.min(oUnit[M27UnitInfo.refiAntiNavyRange], oUnit[M27UnitInfo.refiDFRange])
                                        else
                                            iCurRange = math.max(oUnit[M27UnitInfo.refiAntiNavyRange], oUnit[M27UnitInfo.refiDFRange])
                                        end
                                    end
                                end
                                if iCurRange < iMinRangeForEngagement then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Below min engagneemnt range, iCurRange='..iCurRange..'; iMinRangeForEngagement='..iMinRangeForEngagement..'; will consider moving short range unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to the short range rally point') end
                                    if not(ConsiderIssuingGroundFireOrder(oUnit)) then
                                        MoveUnitTowardsTarget(oUnit, tDestinationForShortRangeUnits, false, 'ShortRange')
                                    end
                                else
                                    iCurDistToClosestEnemy = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tClosestEnemyTargetToUse)
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Have at least min engagement range '..iMinRangeForEngagement..', oUnit=' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. '; iCurDistToClosestEnemy=' .. iCurDistToClosestEnemy .. '; iMaxDistanceWithinAttackRangeWanted=' .. iMaxDistanceWithinAttackRangeWanted .. '; iMinDistanceWithinAttackRangeWanted=' .. iMinDistanceWithinAttackRangeWanted .. '; Range=' .. M27UnitInfo.GetNavalDirectAndSubRange(oUnit)..'; do we have support naval cat='..tostring(EntityCategoryContains(M27UnitInfo.refCategorySupportNavy, oUnit.UnitId))..'; iCurRange='..iCurRange)
                                    end
                                    if EntityCategoryContains(M27UnitInfo.refCategorySupportNavy, oUnit.UnitId) and M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition()) <= 40 then
                                        MoveUnitTowardsTarget(oUnit, tOurBase, false, 'SupportRetreat')
                                    elseif iCurDistToClosestEnemy + iMaxDistanceWithinAttackRangeWanted < iCurRange then
                                        --Kiting retreat unless are near our naval factory in which case do attack-move
                                        if not(ConsiderIssuingGroundFireOrder(oUnit)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering kiting retreat for unit unless close to our base in which case will attack move. Dist to our base='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)) end
                                            if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase) <= 20 then
                                                MoveUnitTowardsTarget(oUnit, tBaseRallyPoint, not(oUnit[M27UnitInfo.refbLastShotBlocked]), 'AKitingRetreat')
                                            else
                                                MoveUnitTowardsTarget(oUnit, tBaseRallyPoint, false, 'MKitingRetreat')
                                            end
                                        end
                                    elseif iCurDistToClosestEnemy + iMinDistanceWithinAttackRangeWanted < iCurRange then
                                        --Attack-move to target; however do issueattack if we are moving to enemy naval base
                                        if bChargeEnemyBase and iCurDistToClosestEnemy < iCurRange and (oUnit[M27UnitInfo.refbLastShotBlocked] or (oUnit[M27PlatoonUtilities.refiLastOrderType] == M27PlatoonUtilities.refiOrderIssueAttack and M27UnitInfo.IsUnitValid(oUnit[M27UnitInfo.refoLastOrderUnitTarget]))) then
                                            --Shot blocked and we are charging to enemy base so want to focus down the enemy base
                                            oPriorityTarget = nil
                                            if M27Utilities.IsTableEmpty(tPriorityTargets) == false then
                                                for iEnemy, oEnemy in tPriorityTargets do
                                                    iCurDistToPriority = M27Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                                                    if iCurDistToPriority <= iCurRange or (iCurDistToPriority - 6 <= iCurRange and not(oPriorityTarget)) then
                                                        --Is shot blocked?
                                                        if not(M27Logic.IsShotBlocked(oUnit, oEnemy)) then
                                                            oPriorityTarget = oEnemy
                                                            if iCurDistToPriority <= iCurRange then break end
                                                        end
                                                    end
                                                end
                                            end
                                            if bDebugMessages == true then LOG(sFunctionRef..': Shot was blocked so looking to see if have a nearly in range prioriyt target that isnt blocked; Is oPriorityTarget valid='..tostring(M27UnitInfo.IsUnitValid(oPriorityTarget))) end
                                            if oPriorityTarget and M27Utilities.GetDistanceBetweenPositions(oPriorityTarget:GetPosition(), oUnit:GetPosition()) - 6 <= iCurRange then
                                                TellUnitToAttackTarget(oUnit, oPriorityTarget, 'PBlocked')
                                                if bDebugMessages == true then LOG(sFunctionRef..': Want to attack specific unit='..oPriorityTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPriorityTarget)..' which is '..M27Utilities.GetDistanceBetweenPositions(oPriorityTarget:GetPosition(), oUnit:GetPosition())..' away from unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                            else
                                                MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, false, 'AGetInRange')
                                                if bDebugMessages == true then LOG(sFunctionRef..': no suitable target so will just move towards closest enemy target to use') end
                                            end
                                        else
                                            if not(ConsiderIssuingGroundFireOrder(oUnit)) then
                                                --Retreat if we are in range of any enemy PD
                                                if not(RetreatFromPD(oUnit)) then
                                                    --Attack move with missile ships to reduce risk that they hardly ever fire missile if keep moving closer and further from enemy
                                                    MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, (not(oUnit[M27UnitInfo.refbLastShotBlocked]) or EntityCategoryContains(M27UnitInfo.refCategoryMissileShip, oUnit.UnitId)), 'AGetInRange')
                                                end
                                            end
                                        end
                                    else
                                        --Do we have an indirect attack and enemy is within range? then move back
                                        if (oUnit[M27UnitInfo.refiIndirectRange] or 0) > iCurDistToClosestEnemy - 10 then
                                            MoveUnitTowardsTarget(oUnit, tOurBase, false, 'IndirectRetreat')
                                        elseif not(ConsiderIssuingGroundFireOrder(oUnit)) then
                                            --Move towards target (non-attack move)
                                            if not(RetreatFromPD(oUnit)) then
                                                --Exception - we are a unit with indirect range that has enemy shield or TMD in range
                                                bIndirectAttackBuilding = false
                                                if (oUnit[M27UnitInfo.refiIndirectRange] or 0) > 120 then

                                                    local tNearbyPriorityBuildings = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryFixedT2Arti + M27UnitInfo.refCategoryFixedShield + M27UnitInfo.refCategoryTMD + M27UnitInfo.refCategoryT2Mex + M27UnitInfo.refCategoryT3Mex + M27UnitInfo.refCategoryT3Power + M27UnitInfo.refCategoryExperimentalLevel - categories.MOBILE, oUnit:GetPosition(), oUnit[M27UnitInfo.refiIndirectRange] - 20, 'Enemy')
                                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit range is at least 120, is table ofn earby priority buildings empty='..tostring(M27Utilities.IsTableEmpty(tNearbyPriorityBuildings))) end
                                                    if M27Utilities.IsTableEmpty(tNearbyPriorityBuildings) == false then
                                                        bIndirectAttackBuilding = true
                                                        --Attack closest priority building
                                                        local oUnitToAttack
                                                        local tEnemyShieldsAndTMD = EntityCategoryFilterDown(M27UnitInfo.refCategoryFixedShield + M27UnitInfo.refCategoryTMD, tNearbyPriorityBuildings)
                                                        if M27Utilities.IsTableEmpty(tEnemyShieldsAndTMD) == false then
                                                            oUnitToAttack = M27Utilities.GetNearestUnit(tEnemyShieldsAndTMD, oUnit:GetPosition())
                                                        else
                                                            oUnitToAttack = M27Utilities.GetNearestUnit(tNearbyPriorityBuildings, oUnit:GetPosition())
                                                        end
                                                        TellUnitToAttackTarget(oUnit, oUnitToAttack, 'AUnit')
                                                    end
                                                end
                                                if not(bIndirectAttackBuilding) then
                                                    MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, false, 'MGetInRange')
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        else
                            --We dont outrange enemy, and htink we will lose if we will attack (e.g. we have no antinavy and are dealing with subs), so retreat/head to destination if are ignoring enemy subs
                            --exception is if we are a battleship that can ground-fire and we have nearby subs but not nearby units

                            local sOrderDesc = 'MainRetreat'
                            if bConsolidateForces then
                                sOrderDesc = 'Consolidate'
                                iNavalStrategy = M27Team.refiNavalStrategyConsolidate
                            end
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': About to order navy to go to tGlobalNavalDestination=' .. repru(tGlobalNavalDestination) .. '; bConsolidateForces=' .. tostring(bConsolidateForces))
                            end
                            for iUnit, oUnit in tOurSurfaceCombatNavy do
                                if not(ConsiderIssuingGroundFireOrder(oUnit)) then
                                    MoveUnitTowardsTarget(oUnit, tGlobalNavalDestination, false, sOrderDesc)
                                end
                            end
                        end
                    end
                end
            end
        elseif oClosestFriendlyUnitToEnemyBase then

            --Have destroyed all enemy naval units, focus on naval bombardment - do attack-move to closest enemy mex that enemy controls that we can hit with our current naval options
            local tOurFriendlyCombatUnits = EntityCategoryFilterDown(categories.DIRECTFIRE * categories.MOBILE + categories.INDIRECTFIRE * categories.MOBILE, tFriendlyNavalExcludingIntercept)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ' No enemy naval units detected, iEnemyMiniThreatCumulativeThreat='..iEnemyMiniThreatCumulativeThreat..'; will switch to considering if want bombardment mode. Is table of friendly combat units empty=' .. tostring(M27Utilities.IsTableEmpty(tOurFriendlyCombatUnits)))
            end
            if M27Utilities.IsTableEmpty(tOurFriendlyCombatUnits) == false then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': oClosestFriendlyUnit=' .. oClosestFriendlyUnitToEnemyBase.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oClosestFriendlyUnitToEnemyBase) .. '; Position=' .. repru(oClosestFriendlyUnitToEnemyBase:GetPosition()))
                end

                local oClosestEnemyMex

                for iUnit, oUnit in tOurFriendlyCombatUnits do
                    if oUnit:GetFractionComplete() >= 1 then
                        if not (bHaveAlreadyUpdatedRanges) then
                            M27UnitInfo.GetNavalDirectAndSubRange(oUnit)
                        end
                        iOurBestIndirectRange = math.max(iOurBestIndirectRange, oUnit[M27UnitInfo.refiIndirectRange])
                        iOurBestDFRange = math.max(iOurBestDFRange, oUnit[M27UnitInfo.refiDFRange])
                        oUnit[refbTempIsUnderwater] = M27UnitInfo.IsUnitUnderwater(oUnit)
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Friendly combat unit ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ': Is underwater=' .. tostring(oUnit[refbTempIsUnderwater]) .. '; DF range=' .. oUnit[M27UnitInfo.refiDFRange] .. '; Indirect range=' .. oUnit[M27UnitInfo.refiIndirectRange])
                        end
                    end
                end
            end
            if math.max(iOurBestDFRange, iOurBestIndirectRange) >= 25 then
                bConsiderBombardment = true
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Have units iwth at least 25 range so will consider bombardment mode')
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to consider bombardment. bConsiderBombardment='..tostring((bConsiderBombardment or false))) end
    if bConsiderBombardment then
        iNavalStrategy = M27Team.refiNavalStrategyBombard
        --Get the mex closest to our front unit that is within bombardment range


        local tFrontPosition = oClosestFriendlyUnitToEnemyBase:GetPosition()
        local iClosestMexDist = 100000
        local iCurDist
        local tEnemyBuildings
        local iClosestMexRef
        local iBombardmentSearchRange = math.max(22, (M27Team.tTeamData[iTeam][M27Team.refiLastBombardmentSearchRangeByPond][iPond] or 1))
        if iOurBestDFRange >= 60 then iBombardmentSearchRange = math.max(50, iBombardmentSearchRange) end
        local iBombardmentBuildingCategory = M27UnitInfo.refCategoryStructure
        local bIgnoreLowThreats = false
        if M27Team.tTeamData[iTeam][M27Team.refiFriendlyNavalThreatByPond][iPond] >= 8000 then
            iBombardmentBuildingCategory = iBombardmentBuildingCategory - categories.TECH1 + M27UnitInfo.refCategoryTorpedoLauncher
            bIgnoreLowThreats = true
        end
        if not (M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond]) then

            iBombardmentSearchRange = iBombardmentSearchRange + 2

        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': About to consider all mexes in range of the pond. iOurBestDFRange=' .. iOurBestDFRange .. '; iOurBestIndirectRange=' .. iOurBestIndirectRange .. '; iBombardmentSearchRange=' .. iBombardmentSearchRange)
        end
        local iMaxSearchRange
        for iMex, tMexInfo in tPondDetails[iPond][subrefPondMexInfo] do
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering mex that is ' .. M27Utilities.GetDistanceBetweenPositions(tMexInfo[subrefMexLocation], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) .. ' from our start position and ' .. M27Utilities.GetDistanceBetweenPositions(tMexInfo[subrefMexLocation], M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)) .. ' from enemy base. DF distance to hit mex=' .. tMexInfo[subrefMexDFDistance] .. '; Indirect distance=' .. tMexInfo[subrefMexIndirectDistance]..'; Is underwater='..tostring(M27MapInfo.IsUnderwater(tMexInfo[subrefMexLocation])))
            end
            if tMexInfo[subrefMexDFDistance] <= iOurBestDFRange or tMexInfo[subrefMexIndirectDistance] <= iOurBestIndirectRange then
                if not(M27MapInfo.IsUnderwater(tMexInfo[subrefMexLocation])) then
                    iCurDist = M27Utilities.GetDistanceBetweenPositions(tMexInfo[subrefMexLocation], tFrontPosition)
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': iCurDist to our closest navla unit=' .. iCurDist .. '; iClosestMexDist=' .. iClosestMexDist)
                    end
                    if iCurDist < iClosestMexDist then
                        --Does the enemy have any buildings near here?
                        iMaxSearchRange = 200
                        if tMexInfo[subrefMexIndirectDistance] <= iOurBestIndirectRange then
                            iMaxSearchRange = iOurBestIndirectRange - tMexInfo[subrefMexIndirectDistance]
                        end
                        if tMexInfo[subrefMexDFDistance] <= iOurBestDFRange and iOurBestDFRange >= iOurBestIndirectRange then
                            iMaxSearchRange = iOurBestDFRange - tMexInfo[subrefMexDFDistance]
                        end
                        iMaxSearchRange = math.max(2, iMaxSearchRange)
                        tEnemyBuildings = aiBrain:GetUnitsAroundPoint(iBombardmentBuildingCategory, tMexInfo[subrefMexLocation], math.min(iBombardmentSearchRange, iMaxSearchRange), 'Enemy')
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Is table of enemy buildings around mex empty=' .. tostring(M27Utilities.IsTableEmpty(tEnemyBuildings)))
                        end
                        if M27Utilities.IsTableEmpty(tEnemyBuildings) == false then
                            iClosestMexDist = iCurDist
                            iClosestMexRef = iMex
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering if any enemy mexes to bombard. iClosestMexRef=' .. (iClosestMexRef or 'nil'))
        end
        local tNonBombardmentRallyPoint = M27Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase), 20, true, false)
        local tBombardmentMainTarget
        local tBlockedShotBaseMoveLocation --Closest position to mex that we thought a shot wouldnt be blocked from
        local tBlockedShotActualMoveLocation --Moves back based on our current distance to the mex if we are further away
        local iDFMinRange
        local iIndirectMinRange
        local tClosestMex

        if iClosestMexRef then
            tClosestMex = { tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexLocation][1], tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexLocation][2], tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexLocation][3] }
            --Attack-move to nearest mex; for units that wont be in range to attack the mex position, attack-move towards our base by 10 below the bombardment range
            --tNonBombardmentRallyPoint = M27Utilities.MoveInDirection(tClosestMex, M27Utilities.GetAngleFromAToB(tClosestMex, tOurBase), math.max(iOurBestDFRange, iOurBestIndirectRange), true, false)
            tBombardmentMainTarget = tClosestMex
            iDFMinRange = tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance]
            if iDFMinRange == 0 then
                iDFMinRange = 150
            end
            iIndirectMinRange = tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexIndirectDistance]
            if iIndirectMinRange == 0 then
                iIndirectMinRange = 150
            end
            tBlockedShotBaseMoveLocation = (tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFUnblockedLocation] or tBombardmentMainTarget)


        else
            tBombardmentMainTarget = { tEnemyBase[1], tEnemyBase[2], tEnemyBase[3] }
            --tNonBombardmentRallyPoint = {tEnemyBase[1], tEnemyBase[2], tEnemyBase[3]}
            tBlockedShotBaseMoveLocation = nil --dont want to consider
            iDFMinRange = iOurBestDFRange
            iIndirectMinRange = iOurBestIndirectRange
            if bDebugMessages == true then LOG(sFunctionRef..': No mexes to consider so will just have the enemy base as the main bombardment target') end
        end

        if not (iClosestMexRef) and math.max(iOurBestDFRange, iOurBestIndirectRange) >= 60 then
            M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond] = false
        else
            --Treat as success even if didnt find anything if have poor range
            M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond] = true
        end
        M27Team.tTeamData[iTeam][M27Team.refiLastBombardmentSearchRangeByPond][iPond] = iBombardmentSearchRange
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Recorded whether or not our bombardment search range was a success. iClosestMexRef=' .. (iClosestMexRef or 'nil') .. '; iOurBestDFRange=' .. iOurBestDFRange .. '; iOurBestIndirectRange=' .. iOurBestIndirectRange .. '; iBombardmentSearchRange=' .. iBombardmentSearchRange .. '; M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond]=' .. tostring(M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond]) .. '; M27Team.tTeamData[iTeam][M27Team.refiLastBombardmentSearchRangeByPond][iPond]=' .. M27Team.tTeamData[iTeam][M27Team.refiLastBombardmentSearchRangeByPond][iPond])
        end




        --Send any non-submersible units to the location
        local tEnemyStructuresNearFrontUnit = aiBrain:GetUnitsAroundPoint(iBombardmentBuildingCategory, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.max(iIndirectMinRange + 50, iDFMinRange + 50, 150), 'Enemy')
        --local tEnemyDefences = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryPD + M27UnitInfo.refCategoryFixedT2Arti, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.max(iIndirectMinRange + 50, iDFMinRange + 50, 150), 'Enemy')
        local tEnemyDefences
        if M27Utilities.IsTableEmpty(tEnemyStructuresNearFrontUnit) == false then
            tEnemyDefences = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD + M27UnitInfo.refCategoryFixedT2Arti, tEnemyStructuresNearFrontUnit)
        end
        local bCheckForBuildingsToAttack = true
        local bCheckForDefences = false
        local bRetreatUnit
        if M27Utilities.IsTableEmpty(tEnemyStructuresNearFrontUnit) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': No enemy structures within a range of ' .. (math.max(iIndirectMinRange, iDFMinRange) + 50) .. ' of the unit closest to the enemy base. iIndirectMinRange=' .. iIndirectMinRange .. '; iDFMinRange=' .. iDFMinRange)
            end
            bCheckForBuildingsToAttack = false
        end
        --Add under construction experimentals to the buildings to attack
        local tEnemyExperimentals = aiBrain:GetUnitsAroundPoint(categories.EXPERIMENTAL - categories.STRUCTURE - M27UnitInfo.refCategorySatellite, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.max(iIndirectMinRange + 50, iDFMinRange + 50, 150), 'Enemy')
        if M27Utilities.IsTableEmpty(tEnemyExperimentals) == false then
            for iEnemy, oEnemy in tEnemyExperimentals do
                if oEnemy:GetFractionComplete() < 0.98 then
                    table.insert(tEnemyStructuresNearFrontUnit, oEnemy)
                end
            end
        end

        bCheckForDefences = not (M27Utilities.IsTableEmpty(tEnemyDefences))
        local bCheckForSurfaceUnits = false
        local iSurfaceUnitRangeCap = 100 --Will only look this far and reduce ground unit range to this to stop us staying too far away
        local tPotentialNearbyOtherSurfaceThreats = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandCombat + M27UnitInfo.refCategoryIndirectT2Plus - categories.TECH1, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.min(iSurfaceUnitRangeCap, math.max(math.min(50, iIndirectMinRange), iDFMinRange) + 15), 'Enemy')
        local tNearbyOtherSurfaceThreats = {}
        if M27Utilities.IsTableEmpty(tPotentialNearbyOtherSurfaceThreats) == false then
            for iUnit, oUnit in tPotentialNearbyOtherSurfaceThreats do
                if not(M27UnitInfo.IsUnitUnderwater(oUnit)) then
                    table.insert(tNearbyOtherSurfaceThreats, oUnit)
                end
            end
            if M27Utilities.IsTableEmpty(tNearbyOtherSurfaceThreats) == false then
                bCheckForSurfaceUnits = true
            end
        end

        local oBuildingToAttack
        local iDefencesHeadroom
        local bBlockedSoMove = false --If unit shot is blocked and it should be able to hit the mex then have it move to where we thought the shot would be able to hit from
        local iBlockedAngleFromMex
        local iBlockedDistanceFromMex
        if tBlockedShotBaseMoveLocation then
            iBlockedAngleFromMex = M27Utilities.GetAngleFromAToB(tBombardmentMainTarget, tBlockedShotBaseMoveLocation)
            if bDebugMessages == true then LOG(sFunctionRef..': iBlockedAngleFromMex='..iBlockedAngleFromMex..'; tBombardmentMainTarget='..repru(tBombardmentMainTarget)..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation)) end
            iBlockedDistanceFromMex = M27Utilities.GetDistanceBetweenPositions(tBombardmentMainTarget, tBlockedShotBaseMoveLocation)
        end
        local bEnemyUnitsNearlyInRange
        local tPotentialEnemyUnits
        local bDontCheckIfTargetUnderwater

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': About to search for bombardment targets, bCheckForBuildingsToAttack=' .. tostring(bCheckForBuildingsToAttack) .. '; tBombardmentMainTarget=' .. repru(tBombardmentMainTarget) .. '; tNonBombardmentRallyPoint=' .. repru(tNonBombardmentRallyPoint) .. '; iDFMinRange=' .. iDFMinRange .. '; iIndirectMinRange=' .. iIndirectMinRange..'; iBlockedAngleFromMex='..(iBlockedAngleFromMex or 'nil')..'; iBlockedDistanceFromMex='..(iBlockedDistanceFromMex or 'nil')..'; tBlockedShotBaseMoveLocation='..repru(tBlockedShotBaseMoveLocation))
        end

        for iUnit, oUnit in EntityCategoryFilterDown(M27UnitInfo.refCategoryMobileNavalSurface - iSupportNavyCategory, tFriendlyNavalExcludingIntercept) do
            bDontCheckIfTargetUnderwater = EntityCategoryContains(categories.ANTINAVY, oUnit.UnitId)
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering unit ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. '; is underwater=' .. tostring(oUnit[refbTempIsUnderwater]) .. '; oUnit[M27UnitInfo.refiDFRange]=' .. (oUnit[M27UnitInfo.refiDFRange] or 'nil') .. '; oUnit[M27UnitInfo.refiIndirectRange]=' .. (oUnit[M27UnitInfo.refiIndirectRange] or 'nil'))
            end
            if not (oUnit[refbTempIsUnderwater]) then
                if oUnit[M27UnitInfo.refiIndirectRange] == nil then
                    M27UnitInfo.GetNavalDirectAndSubRange(oUnit)
                end
                bRetreatUnit = false
                --Are we in range of enemy PD/T2 arti? If so then retreat
                if bCheckForDefences then
                    local iCurEnemyRange
                    local iCurEnemyDist
                    iDefencesHeadroom = 1000
                    for iDefence, oDefence in tEnemyDefences do
                        iCurEnemyRange = math.max(M27UnitInfo.GetNavalDirectAndSubRange(oDefence), oDefence[M27UnitInfo.refiIndirectRange])
                        iCurEnemyDist = M27Utilities.GetDistanceBetweenPositions(oDefence:GetPosition(), oUnit:GetPosition())
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering if oUnit=' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ' is in range of oDefence=' .. oDefence.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oDefence) .. '; iCurEnemyRange=' .. iCurEnemyRange .. '; iCurEnemyDist=' .. iCurEnemyDist .. '; Our DF/Indirect range=' .. math.max(oUnit[M27UnitInfo.refiIndirectRange], oUnit[M27UnitInfo.refiDFRange]))
                        end
                        iDefencesHeadroom = math.min(iDefencesHeadroom, iCurEnemyDist - iCurEnemyRange)
                        if iCurEnemyDist <= iCurEnemyRange or (iCurEnemyDist - 10 <= iCurEnemyRange and math.max((oUnit[M27UnitInfo.refiIndirectRange] or 0), (oUnit[M27UnitInfo.refiDFRange] or 0)) < (iCurEnemyRange or 0)) then
                            --Move away unless are a battleship and the enemy is more than 100 away
                            if not (iCurEnemyDist > 100 and EntityCategoryContains(M27UnitInfo.refCategoryMobileNavalSurface * categories.TECH3 * categories.BATTLESHIP, oUnit.UnitId)) then
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Want to retreat')
                                end
                                bRetreatUnit = true
                                break
                            end
                        end
                    end
                end
                if not(bRetreatUnit) and bCheckForSurfaceUnits then
                    local iCurEnemyRange
                    local iCurEnemyDist
                    iDefencesHeadroom = 1000
                    for iDefence, oDefence in tNearbyOtherSurfaceThreats do
                        iCurEnemyRange = math.min(iSurfaceUnitRangeCap, math.max(M27UnitInfo.GetNavalDirectAndSubRange(oDefence), oDefence[M27UnitInfo.refiIndirectRange]))
                        iCurEnemyDist = M27Utilities.GetDistanceBetweenPositions(oDefence:GetPosition(), oUnit:GetPosition())
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering if oUnit=' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ' is in range of oDefence=' .. oDefence.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oDefence) .. '; iCurEnemyRange=' .. iCurEnemyRange .. '; iCurEnemyDist=' .. iCurEnemyDist .. '; Our DF/Indirect range=' .. math.max(oUnit[M27UnitInfo.refiIndirectRange], oUnit[M27UnitInfo.refiDFRange]))
                        end
                        iDefencesHeadroom = math.min(iDefencesHeadroom, iCurEnemyDist - iCurEnemyRange)
                        if iCurEnemyDist <= iCurEnemyRange + 10 and math.max((oUnit[M27UnitInfo.refiIndirectRange] or 0), (oUnit[M27UnitInfo.refiDFRange] or 0)) < (iCurEnemyRange or 0) then
                            --Move away unless are a battleship and the enemy is more than 100 away
                            bRetreatUnit = true
                            break
                        end
                    end
                end

                local bChangedBlockedLocation = false

                if bRetreatUnit then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': WIll retreat ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ' towards our base as we are too close to enemy PD')
                    end
                    MoveUnitTowardsTarget(oUnit, tOurBase, false, 'RetreatFromSurface')
                else
                    if oUnit[M27UnitInfo.refiDFRange] >= iDFMinRange or oUnit[M27UnitInfo.refiIndirectRange] >= iIndirectMinRange then
                        --Attack-move to target, unless we already have a structure in range or our shot is blocked
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Checking if shot blocked for unit ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. '. tBlockedShotBaseMoveLocation=' .. repru(tBlockedShotBaseMoveLocation) .. '; oUnit[M27UnitInfo.refiDFRange]=' .. oUnit[M27UnitInfo.refiDFRange] .. '; oUnit[M27UnitInfo.refiIndirectRange]=' .. oUnit[M27UnitInfo.refiIndirectRange] .. '; oUnit[M27UnitInfo.refbLastShotBlocked]=' .. tostring(oUnit[M27UnitInfo.refbLastShotBlocked] or false))
                        end
                        if tBlockedShotBaseMoveLocation and oUnit[M27UnitInfo.refiDFRange] > oUnit[M27UnitInfo.refiIndirectRange] and oUnit[M27UnitInfo.refbLastShotBlocked] then
                            bBlockedSoMove = true
                            --Get location this unit should move to
                            --v61 - removed this line: tBlockedShotActualMoveLocation = M27Utilities.MoveInDirection(tBombardmentMainTarget, iBlockedAngleFromMex, math.max(iBlockedDistanceFromMex, M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombardmentMainTarget) + 4), true, false)
                            tBlockedShotActualMoveLocation = {tBlockedShotBaseMoveLocation[1], tBlockedShotBaseMoveLocation[2], tBlockedShotBaseMoveLocation[3]}
                            --Record that we have been blocked at this range if we are close to the angle wanted and have fired recenlty
                            if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; checking if we expected to be able to hit from here, and if so will increase the blocked distance. tClosestMex='..repru(tClosestMex)..'; Time='..GetGameTimeSeconds()..'; oUnit[M27UnitInfo.refiTimeOfLastCheck]='..(oUnit[M27UnitInfo.refiTimeOfLastCheck] or 'nil')..'; Angle dif='..M27Utilities.GetAngleDifference(M27Utilities.GetAngleFromAToB(tClosestMex, oUnit:GetPosition()), iBlockedAngleFromMex)..'; iBlockedAngleFromMex='..iBlockedAngleFromMex..'; Angle from unit to mex='..M27Utilities.GetAngleFromAToB(tClosestMex, oUnit:GetPosition())) end
                            if tClosestMex and (oUnit[M27UnitInfo.refiIndirectRange] or 0) == 0 and oUnit[M27UnitInfo.refiDFRange] >= iDFMinRange and GetGameTimeSeconds() - (oUnit[M27UnitInfo.refiTimeOfLastCheck] or 0) <= 2 and M27Utilities.GetAngleDifference(M27Utilities.GetAngleFromAToB(tClosestMex, oUnit:GetPosition()), iBlockedAngleFromMex) <= 8 then
                                local iDistToBlocked = M27Utilities.GetDistanceBetweenPositions(tBlockedShotActualMoveLocation, oUnit:GetPosition())
                                if bDebugMessages == true then LOG(sFunctionRef..': iDistToBlocked='..iDistToBlocked..'; tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance]='..tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance]..'; iBlockedDistanceFromMex (ie distance from the location to move to if shot is blocked, and the mex)='..iBlockedDistanceFromMex) end
                                if iDistToBlocked <= 5 then
                                    local tPotentialUnblockedLocation = M27Utilities.MoveInDirection(tClosestMex, iBlockedAngleFromMex, math.max(iBlockedDistanceFromMex + 2, tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance]), true, false)
                                    while not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tPotentialUnblockedLocation) == iPond) do
                                        tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance] = tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance] + 2
                                        tPotentialUnblockedLocation = M27Utilities.MoveInDirection(tClosestMex, iBlockedAngleFromMex, tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance], true, false)

                                        if tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance] >= 200 then break end
                                    end

                                    tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFUnblockedLocation] = {tPotentialUnblockedLocation[1], tPotentialUnblockedLocation[2], tPotentialUnblockedLocation[3]}
                                    bChangedBlockedLocation = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Have changed the unblocked location by increasing the distance. New DF distance='..tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance]) end
                                end
                            end


                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Will move to tBlockedShotActualMoveLocation=' .. repru(tBlockedShotActualMoveLocation)..'; Dist from tBlockedShotActualMoveLocation='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBlockedShotActualMoveLocation)..'; will draw in blue')
                                M27Utilities.DrawLocation(tBlockedShotActualMoveLocation)
                            end
                        else

                            oBuildingToAttack = nil
                            if bCheckForBuildingsToAttack then
                                local iDistToPriority
                                local iClosestDist = 100000
                                if M27Utilities.IsTableEmpty(tEnemyStructuresNearFrontUnit) == false then
                                    for iPriority, oPriority in tEnemyStructuresNearFrontUnit do
                                        iDistToPriority = M27Utilities.GetDistanceBetweenPositions(oPriority:GetPosition(), oUnit:GetPosition())
                                        if iDistToPriority < iClosestDist then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Considering oPriority='..oPriority.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPriority)..'; iDistToPriority='..iDistToPriority..'; Is unit underwater='..tostring(M27UnitInfo.IsUnitUnderwater(oPriority))) end
                                            if bDontCheckIfTargetUnderwater or not(M27UnitInfo.IsUnitUnderwater(oPriority)) then
                                                --Is our shot blocked if we try and shoot from either our current position (if in range and shot is blocked), or a similar angle if we arent in range?
                                                if oUnit[M27UnitInfo.refiDFRange] > oUnit[M27UnitInfo.refiIndirectRange] and ((oUnit[M27UnitInfo.refbLastShotBlocked] and iDistToPriority <= oUnit[M27UnitInfo.refiDFRange] and GetGameTimeSeconds() - (oUnit[M27UnitInfo.refiTimeOfLastCheck] or 0) <= 4) or M27Logic.IsShotBlocked(oUnit, oPriority)) then
                                                    --Blocked so dont want to try and attack this building
                                                    if bDebugMessages == true then LOG(sFunctionRef..': DF unit who we think will be blocked from firing at oPriority='..oPriority.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPriority)..' so will ignore oPriority') end
                                                else
                                                    iClosestDist = iDistToPriority
                                                    oBuildingToAttack = oPriority
                                                end
                                            end
                                        end
                                    end
                                end

                                if bDebugMessages == true then
                                    if oBuildingToAttack then
                                        LOG(sFunctionRef .. ': Considering whether to attack oBuildingToAttack=' .. oBuildingToAttack.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oBuildingToAttack) .. '; Distance to it=' .. M27Utilities.GetDistanceBetweenPositions(oBuildingToAttack:GetPosition(), oUnit:GetPosition()) .. '; Our DF range=' .. oUnit[M27UnitInfo.refiDFRange] .. '; Our Indirect range=' .. oUnit[M27UnitInfo.refiIndirectRange])
                                    else
                                        LOG(sFunctionRef..': Dont have a building to attack')
                                    end
                                end
                                if oBuildingToAttack and M27Utilities.GetDistanceBetweenPositions(oBuildingToAttack:GetPosition(), oUnit:GetPosition()) > math.max(oUnit[M27UnitInfo.refiDFRange], oUnit[M27UnitInfo.refiIndirectRange]) then
                                    --Not in range so dont give specific attack order
                                    oBuildingToAttack = nil
                                else
                                    --Consider overwriting with a priority target (e.g. TMD and shields)
                                    if iDefencesHeadroom >= 10 then
                                        local iPriorityCategory = M27UnitInfo.refCategoryFixedShield
                                        if EntityCategoryContains(M27UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                                            iPriorityCategory = iPriorityCategory + M27UnitInfo.refCategoryTMD
                                        end
                                        local tPriorityTargets = EntityCategoryFilterDown(iPriorityCategory, tEnemyStructuresNearFrontUnit)
                                        if M27Utilities.IsTableEmpty(tPriorityTargets) == false then

                                            for iPriority, oPriority in tPriorityTargets do
                                                iDistToPriority = M27Utilities.GetDistanceBetweenPositions(oPriority:GetPosition(), oUnit:GetPosition())
                                                if iDistToPriority < iClosestDist then
                                                    if bDontCheckIfTargetUnderwater or not(M27UnitInfo.IsUnitUnderwater(oPriority)) then
                                                        iClosestDist = iDistToPriority
                                                        if iDistToPriority - math.min(iDefencesHeadroom, 30) <= math.max(oUnit[M27UnitInfo.refiIndirectRange], oUnit[M27UnitInfo.refiDFRange]) then
                                                            oBuildingToAttack = oPriority
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if not (oBuildingToAttack) or (bBlockedSoMove and tBlockedShotActualMoveLocation) then
                            --ToDo - figure out solution to both cliff temporarily blocking (where if we dont attack-move we are ok)
                            --ToDo - and the converse where we are ok but if we move towards the target a cliff ends up blocking us until we move further away
                            if bBlockedSoMove then
                                MoveUnitTowardsTarget(oUnit, tBlockedShotActualMoveLocation, false, 'Blocked')
                            else
                                bEnemyUnitsNearlyInRange = false
                                if (oUnit[M27UnitInfo.refbLastShotBlocked] or (bIgnoreLowThreats and EntityCategoryContains(categories.TECH3 + M27UnitInfo.refCategoryMissileShip, oUnit.UnitId))) and M27Utilities.GetDistanceBetweenPositions(tBombardmentMainTarget, oUnit:GetPosition()) > math.max(oUnit[M27UnitInfo.refiDFRange], oUnit[M27UnitInfo.refiIndirectRange]) then
                                    --Check if enemy has non-air units near us that could hit us or if we can do an issuemove instead of attackmove to get within range of the desired location
                                    tPotentialEnemyUnits = aiBrain:GetUnitsAroundPoint(categories.DIRECTFIRE + categories.INDIRECTFIRE + categories.ANTINAVY - categories.AIR - M27UnitInfo.refCategoryFixedT3Arti - categories.SILO, oUnit:GetPosition(), aiBrain[M27Overseer.refiHighestMobileLandEnemyRange], 'Enemy')
                                    if M27Utilities.IsTableEmpty(tPotentialEnemyUnits) == false then
                                        for iEnemy, oEnemy in tPotentialEnemyUnits do
                                            if M27UnitInfo.GetNavalDirectAndSubRange(oUnit) + 5 <= M27Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition()) then
                                                bEnemyUnitsNearlyInRange = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': oEnemy='..oEnemy.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEnemy)..' is only '..M27Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..' from us and our range is '..M27UnitInfo.GetNavalDirectAndSubRange(oUnit)..' so will use attack move instead of move') end
                                                break
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Will bombard the target wit hthis unit.  Considering whether to move or attack for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; bIgnoreLowThreats='..tostring(bIgnoreLowThreats)..'; oUnit[M27UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M27UnitInfo.refbLastShotBlocked])..'; bEnemyUnitsNearlyInRange='..tostring(bEnemyUnitsNearlyInRange)..'; M27UnitInfo.GetUnitHealthPercent(oUnit)='..M27UnitInfo.GetUnitHealthPercent(oUnit)) end
                                if (bIgnoreLowThreats or oUnit[M27UnitInfo.refbLastShotBlocked]) and (not(bEnemyUnitsNearlyInRange) or M27UnitInfo.GetUnitHealthPercent(oUnit) >= 0.75) then
                                    MoveUnitTowardsTarget(oUnit, tBombardmentMainTarget, false, 'MBombard')
                                else
                                    MoveUnitTowardsTarget(oUnit, tBombardmentMainTarget, true, 'ABombard')
                                end
                            end
                        else
                            if bBlockedSoMove then --Redundancy (for if we somehow set this to true without a blocked location)
                                MoveUnitTowardsTarget(oUnit, tBombardmentMainTarget, false, 'MBBombard')
                            else
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Launching specific attack order on ' .. oBuildingToAttack.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oBuildingToAttack)..'; oUnit[M27UnitInfo.refbLastShotBlocked]='..tostring(oUnit[M27UnitInfo.refbLastShotBlocked]))
                                end
                                TellUnitToAttackTarget(oUnit, oBuildingToAttack, 'BAttack')
                            end
                        end
                    else
                        MoveUnitTowardsTarget(oUnit, tNonBombardmentRallyPoint, false, 'SRSupport') --Short range unit so dont want it to join in the bombardment
                    end
                end
            end
        end
    end

    ---->>>>Support units<<<<---
    --Move general support units towards front unit
    if bDebugMessages == true then LOG(sFunctionRef..': About to consider logic for support units. is oClosestFriendlyUnitToEnemyBase valid='..tostring(M27UnitInfo.IsUnitValid(oClosestFriendlyUnitToEnemyBase))) end
    if oClosestFriendlyUnitToEnemyBase then
        local tSupportUnits = EntityCategoryFilterDown(iSupportNavyCategory, tFriendlyNavalExcludingIntercept)
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of support navy empty='..tostring(M27Utilities.IsTableEmpty(tSupportUnits))) end
        if M27Utilities.IsTableEmpty(tSupportUnits) == false then
            local iDistToTravel = math.max(5, math.min(50, M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase)))

            local tSupportDestination = M27Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase), iDistToTravel, true, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Will send all support units to '..repru(tSupportDestination)..'; this was based on closest friendly unit to enemy base '..oClosestFriendlyUnitToEnemyBase.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestFriendlyUnitToEnemyBase)..'; which is at position'..repru(oClosestFriendlyUnitToEnemyBase:GetPosition())..' and tOurBase='..repru(tOurBase)..'; Angle between these='..M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase)) end
            local iCurShieldHealth, iMaxShieldHealth
            local iShieldPercent
            local tShieldsToAssign = {}
            local tStealthToAssign = {}

            for iUnit, oUnit in tSupportUnits do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit is a shield and if its available. oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
                if EntityCategoryContains(M27UnitInfo.refCategoryShieldBoat, oUnit.UnitId) then
                    --Check if want to be recharging shield
                    iCurShieldHealth, iMaxShieldHealth = M27UnitInfo.GetCurrentAndMaximumShield(oUnit)
                    iShieldPercent = iCurShieldHealth / iMaxShieldHealth
                    if oUnit[refbRechargeShield] then
                        if iShieldPercent >= 0.75 then oUnit[refbRechargeShield] = false end
                    else
                        if iShieldPercent <= 0.2 then
                            oUnit[refbRechargeShield] = true
                            RemoveShieldAssignment(oUnit)
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iMaxShieldHealth='..iMaxShieldHealth..'; iCurShieldHealth='..iCurShieldHealth..'; iShieldPercent='..iShieldPercent..'; RechargeShield='..tostring(oUnit[refbRechargeShield])) end

                    --Determine action based on if we want to recharge shield
                    if iMaxShieldHealth == 0 then --Redundancy
                        MoveUnitTowardsTarget(oUnit, tSupportDestination, false, 'GSupport')
                        if bDebugMessages == true then LOG(sFunctionRef..': Shield is empty so will go to support destination') end
                    else
                        if oUnit[refbRechargeShield] then
                            MoveUnitTowardsTarget(oUnit, tOurBase, false, 'SRecharge')
                            if bDebugMessages == true then LOG(sFunctionRef..': Shield needs recharging so will go to our base') end
                        else
                            --Want to assist a unit
                            table.insert(tShieldsToAssign, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have added unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of shields that will assign shortly') end
                        end
                    end
                elseif EntityCategoryContains(M27UnitInfo.refCategoryStealthBoat, oUnit.UnitId) then
                    --Cover the closest non-stealth boat mobile surface unit
                    table.insert(tStealthToAssign, oUnit)

                else
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Sending move command to oUnit=' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ' to ' .. repru(tSupportDestination))
                    end
                    MoveUnitTowardsTarget(oUnit, tSupportDestination, false, 'GSupport')
                end
            end


            ---->>>>SHIELD BOATS<<<<----
            --Assign shield units - decide on priority list, and then get the closest shield unit to this
            if M27Utilities.IsTableEmpty(tShieldsToAssign) == false then
                local tUnitsToShieldByPriority = {}
                local iCurPriority = 1
                local iSurfaceCombatCategory = M27UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M27UnitInfo.refCategoryNavalSurface * categories.INDIRECTFIRE + M27UnitInfo.refCategoryNavalSurface * categories.ANTINAVY
                local oClosestSurface1, oClosestSurface2, oClosestSurface3
                local iClosestSurface1 = 100000
                local iClosestSurface2 = 100000
                local iClosestSurface3 = 100000

                local iCurDist

                function AddUnitToPriorityList(oUnit)
                    table.insert(tUnitsToShieldByPriority, oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': Added unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to priority list, iCurPriority='..iCurPriority..'; Distance to enemy base='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)) end
                    iCurPriority = iCurPriority + 1
                end


                local tSurfaceCombat = EntityCategoryFilterDown(iSurfaceCombatCategory, tFriendlyNavalExcludingIntercept)
                if M27Utilities.IsTableEmpty(tSurfaceCombat) == false then
                    for iUnit, oUnit in tSurfaceCombat do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)
                        if iCurDist < iClosestSurface3 then
                            if iCurDist < iClosestSurface2 then
                                if iCurDist < iClosestSurface1 then
                                    oClosestSurface3 = oClosestSurface2
                                    iClosestSurface3 = iClosestSurface2
                                    oClosestSurface2 = oClosestSurface1
                                    iClosestSurface2 = iClosestSurface1
                                    oClosestSurface1 = oUnit
                                    iClosestSurface1 = iCurDist
                                else
                                    --Closet than 2 not 1
                                    oClosestSurface3 = oClosestSurface2
                                    iClosestSurface3 = iClosestSurface2
                                    oClosestSurface2 = oUnit
                                    iClosestSurface2 = iCurDist
                                end
                            else
                                oClosestSurface3 = oUnit
                                iClosestSurface3 = iCurDist
                            end
                        end
                    end
                end
                if oClosestSurface1 then AddUnitToPriorityList(oClosestSurface1) end
                local oClosestCruiser1, oClosestCruiser2
                local iClosestCruiser1 = 100000
                local iClosestCruiser2 = 100000
                local tCruisers = EntityCategoryFilterDown(M27UnitInfo.refCategoryCruiser, tFriendlyNavalExcludingIntercept)
                if M27Utilities.IsTableEmpty(tCruisers) == false then
                    for iUnit, oUnit in tCruisers do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)
                        if iCurDist < iClosestCruiser2 then
                            if iCurDist < iClosestCruiser1 then
                                oClosestCruiser2 = oClosestCruiser1
                                iClosestCruiser2 = iClosestCruiser1
                                oClosestCruiser1 = oUnit
                                iClosestCruiser1 = iCurDist
                            else
                                oClosestCruiser2 = oUnit
                                iClosestCruiser2 = iCurDist
                            end
                        end
                    end
                end
                if oClosestCruiser1 then AddUnitToPriorityList(oClosestCruiser1) end

                if not(bAllOutSubAttack) and not(EntityCategoryContains(M27UnitInfo.refCategoryCruiser + iSurfaceCombatCategory,oClosestFriendlyUnitToEnemyBase.UnitId)) then
                    AddUnitToPriorityList(oClosestFriendlyUnitToEnemyBase)
                end
                if oClosestSurface2 then AddUnitToPriorityList(oClosestSurface2) end
                if oClosestSurface3 then AddUnitToPriorityList(oClosestSurface3) end
                if oClosestCruiser2 then AddUnitToPriorityList(oClosestCruiser2) end


                --Find the nearest shield to each priority unit to shield
                local oClosestShield
                local iClosestShieldDist = 100000
                local iClosestShieldRef

                for iUnit, oUnit in tUnitsToShieldByPriority do
                    iClosestShieldDist = 100000
                    for iShield, oShield in tShieldsToAssign do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oUnit:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef..': Looking for closest shield to oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; shield='..oShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurDist='..iCurDist) end
                        if iCurDist < iClosestShieldDist then
                            iClosestShieldRef = iShield
                            oClosestShield = oShield
                            iClosestShieldDist = iCurDist
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will assign shield '..oClosestShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestShield)..' with aiBrain index='..oClosestShield:GetAIBrain():GetArmyIndex()..' to priority unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iClosestShieldDist='..iClosestShieldDist) end
                    AddShieldAssignment(oUnit, oClosestShield, tOurBase)
                    table.remove(tShieldsToAssign, iClosestShieldRef)
                    if M27Utilities.IsTableEmpty(tShieldsToAssign) then break end
                end
                --Assign any spare shields to the closest friendly unit to the front
                if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning shields to priority units. Is table of shields to assign empty='..tostring(M27Utilities.IsTableEmpty(tShieldsToAssign))) end
                if M27Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    local oRemainingUnitPriority = oClosestFriendlyUnitToEnemyBase
                    if bAllOutSubAttack and EntityCategoryContains(categories.SUBMERSIBLE + categories.AMPHIBIOUS - categories.HOVER, oClosestFriendlyUnitToEnemyBase.UnitId) then
                        local tSurfaceUnits
                        if M27Utilities.IsTableEmpty(tFriendlyNavalExcludingIntercept) == false then
                            tSurfaceUnits = EntityCategoryFilterDown(M27UnitInfo.refCategoryAllAmphibiousAndNavy - categories.SUBMERSIBLE, tFriendlyNavalExcludingIntercept)
                            if M27Utilities.IsTableEmpty(tSurfaceUnits) == false then
                                oRemainingUnitPriority = M27Utilities.GetNearestUnit(tSurfaceUnits, tEnemyBase)
                            else
                                M27Utilities.ErrorHandler('Dont have any surface units but should at least have the shields that are considering')
                            end
                        end
                    end
                    for iShield, oClosestShield in tShieldsToAssign do
                        if bDebugMessages == true then LOG(sFunctionRef..': Have no more priority units, assigning shield '..oClosestShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestShield)..' to oRemainingUnitPriority='..oRemainingUnitPriority.UnitId..M27UnitInfo.GetUnitLifetimeCount(oRemainingUnitPriority)) end
                        AddShieldAssignment(oRemainingUnitPriority, oClosestShield, tOurBase)
                    end
                end
            end

            ---->>>>Stealth boats<<<<----
            --Largely copy of shield boat logic, but done differently in case we ever want shield boats to cover submersible units
            if M27Utilities.IsTableEmpty(tStealthToAssign) == false then
                local tUnitsToStealthByPriority = {}
                local iCurPriority = 1
                local iSurfaceCombatCategory = M27UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M27UnitInfo.refCategoryNavalSurface * categories.INDIRECTFIRE + M27UnitInfo.refCategoryNavalSurface * categories.ANTINAVY
                local oClosestSurface1, oClosestSurface2, oClosestSurface3
                local iClosestSurface1 = 100000
                local iClosestSurface2 = 100000
                local iClosestSurface3 = 100000

                local iCurDist

                function AddUnitToPriorityList(oUnit)
                    table.insert(tUnitsToStealthByPriority, oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': Added unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to priority list, iCurPriority='..iCurPriority..'; Distance to enemy base='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)) end
                    iCurPriority = iCurPriority + 1
                end


                local tSurfaceCombat = EntityCategoryFilterDown(iSurfaceCombatCategory, tFriendlyNavalExcludingIntercept)
                if M27Utilities.IsTableEmpty(tSurfaceCombat) == false then
                    for iUnit, oUnit in tSurfaceCombat do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)
                        if iCurDist < iClosestSurface3 then
                            if iCurDist < iClosestSurface2 then
                                if iCurDist < iClosestSurface1 then
                                    oClosestSurface3 = oClosestSurface2
                                    iClosestSurface3 = iClosestSurface2
                                    oClosestSurface2 = oClosestSurface1
                                    iClosestSurface2 = iClosestSurface1
                                    oClosestSurface1 = oUnit
                                    iClosestSurface1 = iCurDist
                                else
                                    --Closet than 2 not 1
                                    oClosestSurface3 = oClosestSurface2
                                    iClosestSurface3 = iClosestSurface2
                                    oClosestSurface2 = oUnit
                                    iClosestSurface2 = iCurDist
                                end
                            else
                                oClosestSurface3 = oUnit
                                iClosestSurface3 = iCurDist
                            end
                        end
                    end
                end
                if oClosestSurface1 then AddUnitToPriorityList(oClosestSurface1) end
                local oClosestCruiser1, oClosestCruiser2
                local iClosestCruiser1 = 100000
                local iClosestCruiser2 = 100000
                local tCruisers = EntityCategoryFilterDown(M27UnitInfo.refCategoryCruiser, tFriendlyNavalExcludingIntercept)
                if M27Utilities.IsTableEmpty(tCruisers) == false then
                    for iUnit, oUnit in tCruisers do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)
                        if iCurDist < iClosestCruiser2 then
                            if iCurDist < iClosestCruiser1 then
                                oClosestCruiser2 = oClosestCruiser1
                                iClosestCruiser2 = iClosestCruiser1
                                oClosestCruiser1 = oUnit
                                iClosestCruiser1 = iCurDist
                            else
                                oClosestCruiser2 = oUnit
                                iClosestCruiser2 = iCurDist
                            end
                        end
                    end
                end
                if oClosestCruiser1 then AddUnitToPriorityList(oClosestCruiser1) end

                if not(bAllOutSubAttack) and not(EntityCategoryContains(M27UnitInfo.refCategoryCruiser + iSurfaceCombatCategory,oClosestFriendlyUnitToEnemyBase.UnitId)) then
                    AddUnitToPriorityList(oClosestFriendlyUnitToEnemyBase)
                end
                if oClosestSurface2 then AddUnitToPriorityList(oClosestSurface2) end
                if oClosestSurface3 then AddUnitToPriorityList(oClosestSurface3) end
                if oClosestCruiser2 then AddUnitToPriorityList(oClosestCruiser2) end


                --Find the nearest stealth to each priority unit to stealth
                local oClosestStealth
                local iClosestStealthDist = 100000
                local iClosestStealthRef

                for iUnit, oUnit in tUnitsToStealthByPriority do
                    iClosestStealthDist = 100000
                    for iStealth, oStealth in tStealthToAssign do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oStealth:GetPosition(), oUnit:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef..': Looking for closest stealth to oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; stealth='..oStealth.UnitId..M27UnitInfo.GetUnitLifetimeCount(oStealth)..'; iCurDist='..iCurDist) end
                        if iCurDist < iClosestStealthDist then
                            iClosestStealthRef = iStealth
                            oClosestStealth = oStealth
                            iClosestStealthDist = iCurDist
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will assign stealth '..oClosestStealth.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestStealth)..' with aiBrain index='..oClosestStealth:GetAIBrain():GetArmyIndex()..' to priority unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iClosestStealthDist='..iClosestStealthDist) end
                    AddStealthAssignment(oUnit, oClosestStealth, tOurBase)
                    table.remove(tStealthToAssign, iClosestStealthRef)
                    if M27Utilities.IsTableEmpty(tStealthToAssign) then break end
                end
                --Assign any spare stealth boats to the closest friendly unit to the front
                if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning stealth boats to priority units. Is table of stealth to assign empty='..tostring(M27Utilities.IsTableEmpty(tStealthToAssign))) end
                if M27Utilities.IsTableEmpty(tStealthToAssign) == false then
                    local oRemainingUnitPriority = oClosestFriendlyUnitToEnemyBase
                    if bAllOutSubAttack and EntityCategoryContains(categories.SUBMERSIBLE + categories.AMPHIBIOUS - categories.HOVER, oClosestFriendlyUnitToEnemyBase.UnitId) then
                        local tSurfaceUnits = EntityCategoryFilterDown(M27UnitInfo.refCategoryAllAmphibiousAndNavy - categories.SUBMIERSIBLE, tFriendlyNavalExcludingIntercept)
                        if M27Utilities.IsTableEmpty(tSurfaceUnits) == false then
                            oRemainingUnitPriority = M27Utilities.GetNearestUnit(tSurfaceUnits, tEnemyBase)
                        else
                            M27Utilities.ErrorHandler('Dont have any surface units but should at least have the stealth boats that are considering')
                        end
                    end
                    for iStealth, oClosestStealth in tStealthToAssign do
                        if bDebugMessages == true then LOG(sFunctionRef..': Have no more priority units, assigning stealth boat '..oClosestStealth.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestStealth)..' to oRemainingUnitPriority='..oRemainingUnitPriority.UnitId..M27UnitInfo.GetUnitLifetimeCount(oRemainingUnitPriority)) end
                        AddStealthAssignment(oRemainingUnitPriority, oClosestStealth, tOurBase)
                    end
                end
            end
        end

    end
    --Update naval strategy
    M27Team.tTeamData[iTeam][M27Team.refiLastNavalStrategy][iPond] = iNavalStrategy

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ManageNavyMainLoop(aiBrain)
    --aiBrain just used for functionality like getting the primary factory that in some cases requires an aibrain

    local bDebugMessages = false
    if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageNavyMainLoop'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local iTeam = aiBrain.M27Team
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iTeam=' .. (iTeam or 'nil') .. '; Is tTeamData empty=' .. tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData)) .. '; Do we have active naval manager=' .. tostring(M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] or false))
    end
    if not (M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager]) then
        local iTotalTicksWaited = 0
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Is the table of friendly units by pond empty=' .. tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond])))
        end
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond]) == false then
            for iPond, tFriendlyUnits in M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond] do
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Is table of friendly units empty for pond ' .. iPond .. '=' .. tostring(M27Utilities.IsTableEmpty(tFriendlyUnits)))
                end
                --if M27Utilities.IsTableEmpty(tFriendlyUnits) == false then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Running naval management for pond ' .. iPond)
                end
                ForkThread(ManageTeamNavy, aiBrain, iTeam, iPond)
                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] = true
                iTotalTicksWaited = iTotalTicksWaited + _G.MyM27Scheduler:WaitTicks(1, 2, 0.4)
                M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] = false
                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting after calling manage team navy for pond '..iPond..'; iTotalTicksWaited='..iTotalTicksWaited) end
                --end
            end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] = true
            iTotalTicksWaited = iTotalTicksWaited + _G.MyM27Scheduler:WaitTicks(math.max(1, 8 - iTotalTicksWaited), math.max(2, 10 - iTotalTicksWaited), 1) --Dont want to increase beyond 10 or can end up taking a full 1s longer in addition to this depending on how it aligns with aibrain refresh rate
            M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] = false
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Finished running for all ponds, iTotalTicksWaited='..iTotalTicksWaited) end
        end
    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetPondToFocusOn(aiBrain)
    --Returns nil if no pond to focus on
    local bDebugMessages = false
    if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPondToFocusOn'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local iPondWanted = aiBrain[refiAssignedPond] --default
    local iBestPondDefensiveValue = 0
    if iPondWanted then
        iBestPondDefensiveValue = (aiBrain[reftiPondThreatToUs][iPondWanted] or 0)
    end
    if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond]) == false then
        for iPondWithEnemies, tEnemyUnits in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond] do
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering iPondWithEnemies=' .. iPondWithEnemies .. '; Pond defensive value=' .. (aiBrain[reftiPondThreatToUs][iPondWithEnemies] or 'nil') .. '; iBestPondDefensiveValue=' .. iBestPondDefensiveValue .. '; Is tEnemyUnits empty=' .. tostring(M27Utilities.IsTableEmpty(tEnemyUnits)))
            end
            if (aiBrain[reftiPondThreatToUs][iPondWithEnemies] or 0) > iBestPondDefensiveValue and M27Utilities.IsTableEmpty(tEnemyUnits) == false then
                --Can we build on this pond easily?
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Have a pond with a threat to us of ' .. aiBrain[reftiPondThreatToUs][iPondWithEnemies] .. ' and enemy units in it. Do we have a build location for this pond=' .. repru(tPondDetails[iPondWithEnemies][subrefBuildLocationByStartPosition]) .. '; Our start number=' .. aiBrain.M27StartPositionNumber)
                end
                if M27Utilities.IsTableEmpty(tPondDetails[iPondWithEnemies][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber]) == false then
                    iPondWanted = iPondWithEnemies
                    iBestPondDefensiveValue = (aiBrain[reftiPondThreatToUs][iPondWithEnemies] or 0)
                end
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return iPondWanted
end

function GetShieldBoatsWanted(aiBrain, oFactory)
    --Returns the number wanted ignoring tech and power limitations, i.e. based solely on naval composition
    --oFactory can also just be a unit (e.g. the shield unit itself)
    local bDebugMessages = false
    if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetShieldBoatsWanted'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local iPond = oFactory[refiAssignedPond] or GetPondToFocusOn(aiBrain)

    function GetExistingCruisers()
        local iExistingCruisers = 0
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond]) == false then
            local tExistingCruisers = EntityCategoryFilterDown(M27UnitInfo.refCategoryCruiser, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond])
            if M27Utilities.IsTableEmpty(tExistingCruisers) == false then
                iExistingCruisers = table.getn(tExistingCruisers)
            end
        end
        return iExistingCruisers
    end


    local iShieldBoatsWanted = 0
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain index='..aiBrain:GetArmyIndex()..'; Factory='..oFactory.UnitId..M27UnitInfo.GetUnitLifetimeCount(oFactory)..'; iPond='..iPond..'; Naval threat for pond='..M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond]..'; iExistingCruisers='..GetExistingCruisers()) end
    if EntityCategoryContains(categories.UEF, oFactory.UnitId) then
        --1 for every 3.5k surface threat, provided have at least 1.5k threat
        if M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] >= 1750 then
            iShieldBoatsWanted = math.min(5, math.max(1, M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] / 3500))
        end
    elseif EntityCategoryContains(categories.AEON, oFactory.UnitId) then
        if M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] >= 1200 then
            iShieldBoatsWanted = math.min(5, math.max(1, M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] / 1500))
            local iExistingCruisers = GetExistingCruisers()
            if iExistingCruisers > 0 then iShieldBoatsWanted = iShieldBoatsWanted + math.min(3, iExistingCruisers) end
        end
    elseif EntityCategoryContains(categories.SERAPHIM, oFactory.UnitId) then
        if M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] >= 2000 then
            iShieldBoatsWanted = math.min(3, math.max(1, M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] / 2500))
            local iExistingCruisers = GetExistingCruisers()
            if iExistingCruisers > 0 then iShieldBoatsWanted = iShieldBoatsWanted + math.min(2, iExistingCruisers) end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return iShieldBoatsWanted
end
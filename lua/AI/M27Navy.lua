---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 17/08/2022 19:03
---
local M27MapInfo = import('/mods/M27AI/lua/AI/M27MapInfo.lua')
local M27UnitInfo = import('/mods/M27AI/lua/AI/M27UnitInfo.lua')
local M27Utilities = import('/mods/M27AI/lua/M27Utilities.lua')
local M27Logic = import('/mods/M27AI/lua/AI/M27GeneralLogic.lua')
local M27Overseer = import('/mods/M27AI/lua/AI/M27Overseer.lua')
local M27Team = import('/mods/M27AI/lua/AI/M27Team.lua')
local M27EngineerOverseer = import('/mods/M27AI/lua/AI/M27EngineerOverseer.lua')
local M27Conditions = import('/mods/M27AI/lua/AI/M27CustomConditions.lua')
local M27EconomyOverseer = import('/mods/M27AI/lua/AI/M27EconomyOverseer.lua')
local M27PlatoonUtilities = import('/mods/M27AI/lua/AI/M27PlatoonUtilities.lua')
local M27Config = import('/mods/M27AI/lua/M27Config.lua')



--aiBrian variables
refiPriorityPondRef = 'M27PriorityPondRef' --against aibrain, returns the pond ref (naval segment group) that we think is most important to that aibrain (only recorded for M27 brains)
reftiPondThreatToUs = 'M27PondThreatToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the 'mex value' of that pond when considering mexes within 40% of our base (mod distance).  Only recorded for ponds where we have identified a naval yard build location
reftiPondValueToUs = 'M27PondValueToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the expected value of the pond if we have naval control of it (so ignores distance reductions that are used to decide if we want to build navy there in the first place)
refbEnemyNavyPreventingBuildingNavy = 'M27PondEnemyNavyNearBuildLocation' --against aibrain, true if enemy has navy near to the build location

--Unit varaibles
refiAssignedPond = 'M27PondAssigned' --set against a unit to reflect the pond it is in; set to 0 if not in a pond
reftiTeamRefsUpdatedFor = 'M27UpdatedTeamRefs' --Reflects M27 team ref numbers that have recorded the unit against a pond
refbTempIsUnderwater = 'M27IsUnderwater' --Temporary for units - set when analysing naval threats only, so can refer to it later in code
refbRechargeShield = 'M27NavyRechargeShield' --against unit, true if want to recharge shield
reftoAssignedShields = 'M27NavyAssignedShields' --against unit, table of all shields assigned to support this unit
refoSupportTarget = 'M27NavySupportTarget' --against unit, the unit that it is supporting (e.g. for a shield this would be the unit it is shielding)

--TeamData variables (references are to tTeamData[aiBrain.M27Team] - see M27Team

--Global variables
iMinPondSize = 1000 --1000 is a small pond that probably barely fits a couple of naval factories

tPondDetails = {} --[a] = the naval pathing group; returns subtable of various information on ponds; Global information on ponds (requiring at least 200 space
subrefPondSize = 'PondSize'
subrefPondMinX = 'PondMinX'
subrefPondMinZ = 'PondMinZ'
subrefPondMaxX = 'PondMaxX'
subrefPondMaxZ = 'PondMaxZ'
subrefPondMidpoint = 'PondMidpoint'
subrefPondNearbyBrains = 'PondNearbyBrains'
subrefPondMexInfo = 'PondMexInfo'
subrefMexLocation = 'PondMexLocation'
subrefMexDistance = 'PondMexDistance'
subrefMexDFDistance = 'PondMexDFDistance'
subrefMexDFUnblockedLocation = 'PondMexDFLocation' --i.e. the closest location we found where a DF unit should be able to hit the mex
subrefMexIndirectDistance = 'PondMexIndirectDistance'
subrefMexIndirectUnblockedLocation = 'PondMexIndirectLocation' --i.e. the closest location we found where an indirect unit should be able to hit the mex
subrefBuildLocationByStartPosition = 'PondBuildLocationByStart' --Subtable, key is start position number, which stores the build location for that start position (will only record for M27 brain start



function CheckForPondNearNavalUnit(oUnit)
    --Looks at area around unit to see if in a recognised pond, if so then updates pathing of all points in the area.  Returns the revised pond (or 0 if no revised one found)
    local iPond = 0
    local tStartPosition = oUnit:GetPosition()
    local sLocationRef = M27Utilities.ConvertLocationToReference(tStartPosition)
    local sPathing = M27UnitInfo.refPathingTypeNavy
    if not(M27MapInfo.tManualPathingChecks[sPathing][sLocationRef]) then
        M27MapInfo.tManualPathingChecks[sPathing][sLocationRef] = {tStartPosition[1], tStartPosition[2], tStartPosition[3]}

        --Can we find a nearby pond?
        local iAlternativePond
        local tAlternativeLocation
        local iInterval = 4
        local iSegmentSize = M27MapInfo.iSizeOfBaseLevelSegment

        for iModX = -iInterval, iInterval, iInterval do
            for iModZ = -iInterval, iInterval, iInterval do
                tAlternativeLocation = {tStartPosition[1] + iModX, 0, tStartPosition[3] + iModZ}
                iAlternativePond = M27MapInfo.GetSegmentGroupOfLocation(sPathing, tAlternativeLocation)
                if tPondDetails[iAlternativePond] and (tPondDetails[iAlternativePond][subrefPondSize] or 0) >= iMinPondSize then
                    iPond = iAlternativePond
                    --Have a replacement pond to use
                    local iBaseSegmentX, iBaseSegmentZ = M27MapInfo.GetPathingSegmentFromPosition(tAlternativeLocation)
                    local iMinX, iMaxX, iMinZ, iMaxZ
                    if iModX < 0 then iMinX = iModX iMaxX = 0
                    elseif iModX > 0 then iMinX = 0 iMaxX = iModX
                    else iMinX = 0 iMaxX = 0
                    end

                    if iModZ < 0 then iMinZ = iModX iMaxZ = 0
                    elseif iModZ > 0 then iMinZ = 0 iMaxZ = iModX
                    else iMinZ = 0 iMaxZ = 0
                    end

                    for iXAdj = iMinX / iSegmentSize, iMaxX / iSegmentSize, 1 do
                        for iZAdj = iMinZ / iSegmentSize, iMaxZ / iSegmentSize, 1 do
                            if not(tPondDetails[M27MapInfo.tPathingSegmentGroupBySegment[sPathing][iBaseSegmentX + iXAdj][iBaseSegmentZ + iZAdj]]) or (tPondDetails[M27MapInfo.tPathingSegmentGroupBySegment[sPathing][iBaseSegmentX + iXAdj][iBaseSegmentZ + iZAdj]] or 0) < iMinPondSize then
                                M27MapInfo.tPathingSegmentGroupBySegment[sPathing][iBaseSegmentX + iXAdj][iBaseSegmentZ + iZAdj] = iPond
                            end
                        end
                    end
                    break
                end
            end
        end

    end


    return iPond
end

function RecordPonds()
    --Call after recording all pathfinding for the map
    --intended to record key information on any ponds of interest

    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPonds'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local tbUnderwaterGroup = {}
    local tSegmentPosition

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code. Does map have water='..tostring(M27MapInfo.bMapHasWater)) end

    if M27MapInfo.bMapHasWater then
        --Record the size and dimensions of every pond
        for iSegmentX, tSubtable in M27MapInfo.tPathingSegmentGroupBySegment[M27UnitInfo.refPathingTypeNavy] do
            for iSegmentZ, iPathingGroup in tSubtable do
                if not(tPondDetails[iPathingGroup]) then

                    tPondDetails[iPathingGroup] = {}
                    --Are we actually underwater?
                    tbUnderwaterGroup[iPathingGroup] = M27MapInfo.IsUnderwater(M27MapInfo.GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) --GetPosition returns the terrain height
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering pathing group '..iPathingGroup..'; is this underwater='..tostring(tbUnderwaterGroup[iPathingGroup])) end
                    if tbUnderwaterGroup[iPathingGroup] then
                        tPondDetails[iPathingGroup][subrefPondMinX] = 100000
                        tPondDetails[iPathingGroup][subrefPondMinZ] = 100000
                        tPondDetails[iPathingGroup][subrefPondMaxX] = 0
                        tPondDetails[iPathingGroup][subrefPondMaxZ] = 0
                        tPondDetails[iPathingGroup][subrefPondSize] = 0
                        tPondDetails[iPathingGroup][subrefPondNearbyBrains] = {}
                        tPondDetails[iPathingGroup][subrefPondMidpoint] = {}
                        tPondDetails[iPathingGroup][subrefPondMexInfo] = {}
                    end
                end

                if tbUnderwaterGroup[iPathingGroup] then
                    tSegmentPosition = M27MapInfo.GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
                    tPondDetails[iPathingGroup][subrefPondSize] = tPondDetails[iPathingGroup][subrefPondSize] + 1
                    tPondDetails[iPathingGroup][subrefPondMinX] = math.min(tPondDetails[iPathingGroup][subrefPondMinX], tSegmentPosition[1])
                    tPondDetails[iPathingGroup][subrefPondMinZ] = math.min(tPondDetails[iPathingGroup][subrefPondMinZ], tSegmentPosition[3])
                    tPondDetails[iPathingGroup][subrefPondMaxX] = math.max(tPondDetails[iPathingGroup][subrefPondMaxX], tSegmentPosition[1])
                    tPondDetails[iPathingGroup][subrefPondMaxZ] = math.max(tPondDetails[iPathingGroup][subrefPondMaxZ], tSegmentPosition[3])
                end
            end
        end

        --Clear out any ponds that are empty
        local bRemoveBlankPonds = true
        while bRemoveBlankPonds do
            bRemoveBlankPonds = false
            for iPathingGroup, tSubtable in tPondDetails do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to clear out a pond due to being too small, iPathingGroup='..iPathingGroup..'; tSubtable[subrefPondSize]='..(tSubtable[subrefPondSize] or 'nil')) end
                if not(tSubtable) or (tSubtable[subrefPondSize] or 0) <= 1 then
                    bRemoveBlankPonds = true
                    tPondDetails[iPathingGroup] = nil
                    break
                end
            end
        end

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Is the tPondDetails table empty=' .. tostring(M27Utilities.IsTableEmpty(tPondDetails)))
        end
        if M27Utilities.IsTableEmpty(tPondDetails) == false then
            local iMaxBrainDist = 175
            local iMaxMexDist = 200 --range of aeon missile ship
            local iPondMexCount
            local iCurMexDist
            local tiDistToTry = { 24, 40, 56, 88, 120, 145, iMaxMexDist }
            local bInRange
            local iAngleInterval = 45
            local tNearbyWater
            local tPossibleWaterPosition
            local iPrevDist
            local tShotStartPosition
            local tShotEndPosition
            local iAOE

            --Want a brain in case we end up using the alternative 'line is blocked' built in functionality
            local aiBrain
            for iBrain, oBrain in ArmyBrains do
                if oBrain.M27AI then
                    aiBrain = oBrain
                    break
                end
            end
            if not (aiBrain) then
                for iBrain, oBrain in ArmyBrains do
                    aiBrain = oBrain
                    break
                end
            end

            for iPathingGroup, tPondSubtable in tPondDetails do
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Considering pond group ' .. iPathingGroup .. '; Pond size=' .. (tPondSubtable[subrefPondSize] or 'nil'))
                end
                if (tPondSubtable[subrefPondSize] or 0) >= iMinPondSize then
                    --Pond is large enough for us to consider tracking; record information of interest for the pond:
                    iPondMexCount = 0
                    tPondSubtable[subrefPondMidpoint] = { (tPondDetails[iPathingGroup][subrefPondMinX] + tPondDetails[iPathingGroup][subrefPondMaxX]) * 0.5, M27MapInfo.iMapWaterHeight, (tPondDetails[iPathingGroup][subrefPondMinZ] + tPondDetails[iPathingGroup][subrefPondMaxZ]) * 0.5 }
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Recording pond, will check how many mexes are nearby. Pond midpoint=' .. repru(tPondSubtable[subrefPondMidpoint]) .. '; Pond min X-Z=' .. tPondDetails[iPathingGroup][subrefPondMinX] .. '-' .. tPondDetails[iPathingGroup][subrefPondMinZ] .. '; Max X-Z=' .. tPondDetails[iPathingGroup][subrefPondMaxX] .. '-' .. tPondDetails[iPathingGroup][subrefPondMaxZ])
                    end

                    --Details of brains that are near to the pond
                    for iBrain, oBrain in ArmyBrains do
                        if not (M27Logic.IsCivilianBrain(oBrain)) then
                            --Are we within 175 of the square covering the pond?
                            if M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][1] >= tPondSubtable[subrefPondMinX] - iMaxBrainDist and M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][1] <= tPondSubtable[subrefPondMaxX] + iMaxBrainDist and M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][3] >= tPondSubtable[subrefPondMinZ] - iMaxBrainDist and M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][3] <= tPondSubtable[subrefPondMaxZ] + iMaxBrainDist then
                                table.insert(tPondSubtable[subrefPondSize][subrefPondNearbyBrains], oBrain)
                            end
                        end
                    end


                    --Details of all mexes near enough to the pond to be of interest
                    for iMex, tMex in M27MapInfo.MassPoints do
                        bInRange = false

                        if tMex[1] >= tPondSubtable[subrefPondMinX] - iMaxMexDist and tMex[1] <= tPondSubtable[subrefPondMaxX] + iMaxMexDist and tMex[3] >= tPondSubtable[subrefPondMinZ] - iMaxMexDist and tMex[3] <= tPondSubtable[subrefPondMaxZ] + iMaxMexDist then
                            --See how far away the water is
                            for iEntry, iDist in tiDistToTry do
                                for iAngleAdjust = iAngleInterval, 360, iAngleInterval do
                                    tPossibleWaterPosition = M27Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true, true) --Gets terrainheight rather than surface height
                                    if M27MapInfo.IsUnderwater(tPossibleWaterPosition, false, M27MapInfo.iMinWaterDepth) then
                                        --Have a match, record the mex details:
                                        bInRange = true
                                        iCurMexDist = iDist

                                        --Record initial mex details:
                                        iPondMexCount = iPondMexCount + 1
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount] = {}
                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexLocation] = { tMex[1], tMex[2], tMex[3] }

                                        --Do we expect to be able to hit the mex from here? a UEF Frigate y height is 1.1, while a t1 mex is 1.4; cant be bothered to check height of weapon and mex bone, and will vary based on how far away we are as well
                                        tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                        tShotEndPosition = { tMex[1], tMex[2] + 1.1, tMex[3] }

                                        iAOE = 0
                                        if iCurMexDist >= 30 then
                                            iAOE = 1
                                        end --most destroyers have an aoe attack (except sera)

                                        if M27Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, iAOE) then
                                            tShotStartPosition[2] = tShotStartPosition[2] + 8
                                            tShotEndPosition[2] = tShotEndPosition[2] + 8
                                            if M27Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                                --cant hit with df or indirect
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = 10000
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                            else
                                                --Can hit with indirect but not DF, so consider whether if we move further back we can then hit
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}

                                                --Find the point at which DF can hit, if any, in intervals of 5, assuming at max range we can hit
                                                local iMaxDistAdjust = math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5))
                                                tPossibleWaterPosition = M27Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iMaxDistAdjust, true, true)
                                                if M27MapInfo.IsUnderwater(tPossibleWaterPosition, false, M27MapInfo.iMinWaterDepth) then
                                                    tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                    if M27Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1) then
                                                        --Assume wont find any match
                                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                                    else
                                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iMaxDistAdjust
                                                        --Refine the distance by moving closer
                                                        for iDFDistAdjust = 5, math.max(5, math.min(100, math.floor((150 - iCurMexDist) / 5) * 5)), 5 do
                                                            tPossibleWaterPosition = M27Utilities.MoveInDirection(tMex, iAngleAdjust, iDist + iDFDistAdjust, true, true)
                                                            tShotStartPosition = { tPossibleWaterPosition[1], GetSurfaceHeight(tPossibleWaterPosition[1], tPossibleWaterPosition[3]) + 1, tPossibleWaterPosition[3] }
                                                            if not (M27Logic.IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, 1)) then
                                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iDist + iDFDistAdjust
                                                                tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                                                break
                                                            end
                                                        end
                                                    end
                                                else
                                                    --Assume wont find any match as if move really far back we are not on water
                                                    tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = 10000
                                                end
                                            end

                                            if bDebugMessages == true and tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] then
                                                LOG(sFunctionRef .. ' Drawing start in white and end in orangy pink')
                                                M27Utilities.DrawLocation({ tShotStartPosition[1], tShotStartPosition[2] - 8, tShotStartPosition[3] }, nil, 7, 100, nil)
                                                M27Utilities.DrawLocation({ tShotEndPosition[1], tShotEndPosition[2] - 8, tShotEndPosition[3] }, nil, 8, 100, nil)
                                            end
                                        else
                                            --DF can hit from cur position so assume indirect can as well
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFDistance] = iCurMexDist
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectDistance] = iCurMexDist
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDFUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                            tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexIndirectUnblockedLocation] = {tShotStartPosition[1], tShotStartPosition[2], tShotStartPosition[3]}
                                        end

                                        --Refine the distance - see if can get any closer
                                        if iEntry == 1 then
                                            iPrevDist = 0
                                        else
                                            iPrevDist = tiDistToTry[iEntry - 1]
                                        end
                                        for iShortDist = iPrevDist + 1, iDist - 1, 1 do
                                            tPossibleWaterPosition = M27Utilities.MoveInDirection(tMex, iAngleAdjust, iDist, true)
                                            if M27MapInfo.IsUnderwater(tPossibleWaterPosition, false, M27MapInfo.iMinWaterDepth) then
                                                iCurMexDist = iShortDist
                                                break
                                            end
                                        end

                                        tPondSubtable[subrefPondMexInfo][iPondMexCount][subrefMexDistance] = iCurMexDist

                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Finished recording mex in range for pond ' .. iPathingGroup .. '; iPondMexCount=' .. iPondMexCount .. '; full mex table of info=' .. repru(tPondSubtable[subrefPondMexInfo][iPondMexCount]))
                                        end
                                        break
                                    end
                                end
                                if bInRange then
                                    break
                                end
                            end
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considered Mex ' .. repru(tMex) .. '; bInRange=' .. tostring(bInRange))
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording all ponds, repr='..reprs(tPondDetails)) end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function RecordPondToExpandTo(aiBrain)
    --Calculates which pond we think is most important to hold
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordPondToExpandTo'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    --if aiBrain:GetArmyIndex() == 7 or aiBrain:GetArmyIndex() == 6 then bDebugMessages = true end

    if M27Utilities.IsTableEmpty(tPondDetails) == false and not(aiBrain['M27ConsideredPonds']) then
        aiBrain['M27ConsideredPonds'] = true --Only do this once rather than every time we change nearest enemy
        aiBrain[reftiPondThreatToUs] = {}
        aiBrain[reftiPondValueToUs] = {}
        local iCurPondValue
        local iCurPondDefensiveValue --Value of mexes that are threatened by enemy if they get navy
        local iBestPondValue = 0
        local iBestPondRef

        local iDistanceThreshold = math.max(138, math.min(180, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.35))
        if not(aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand]) then iDistanceThreshold = iDistanceThreshold + 50 end

        local iFrigateRange = 28
        local iDestroyerRange = 60
        local iBattleshipRange = 128
        local iMissileShipRange = 150
        local iFrigateValue = 1
        local iDestroyerValue = 0.8
        local iBattleshipValue = 0.45
        local iMissileShipValue = 0.6

        local iEnemyDestroyerRange = 60
        local iEnemyBattleshipRange = 128
        local iEnemyMissileShipRange = 150


        if aiBrain:GetFactionIndex() == M27UnitInfo.refFactionUEF then
            iBattleshipRange = 150
        elseif aiBrain:GetFactionIndex() == M27UnitInfo.refFactionCybran then
            iDestroyerRange = 80
            iMissileShipRange = 0
        elseif aiBrain:GetFactionIndex() == M27UnitInfo.refFactionAeon then
            iMissileShipRange = 200
            iMissileShipValue = iBattleshipValue
            --Seraphim - no change to default
        end

        local iEnemyBrainIndex = M27Logic.GetNearestEnemyIndex(aiBrain)
        if iEnemyBrainIndex == M27UnitInfo.refFactionUEF then
            iEnemyBattleshipRange = 150
        elseif iEnemyBrainIndex == M27UnitInfo.refFactionCybran then
            iEnemyDestroyerRange = 80
            iEnemyMissileShipRange = 0
        elseif iEnemyBrainIndex == M27UnitInfo.refFactionAeon then
            iEnemyMissileShipRange = 200
        end

        if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; Start of logic to consider the best pond. Emergency range='..(aiBrain[M27Overseer.refiModDistEmergencyRange] or 'nil')..'; Dist to enemy base='..(aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] or 'nil')) end
        local iMinModDistanceWanted = math.max(aiBrain[M27Overseer.refiModDistEmergencyRange] + 5, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.4)
        local iMidModDistance = aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.5
        local iBelowMidFactor = 0.3 --Reudces value of mex that is closer to our base than enemy base to this %, assuming it is above the iMinModDistanceWanted
        local iCurMexValue
        local iCurMexDefensiveValue
        local iCurModDistance
        local iDefensiveModDistanceMaxValue = math.max(120, math.min(300, aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] * 0.4))

        local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])

        for iCurPondRef, tPondSubtable in tPondDetails do
            if M27Utilities.IsTableEmpty(tPondSubtable) == false then --redundancy, should have already removed blank ponds in previous step
                iCurPondValue = 0
                iCurPondDefensiveValue = 0
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPondRef='..iCurPondRef..'; Repru of subtable='..repru(tPondSubtable)..'; ai brain start point='..repru(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) end

                --Is the pond within 175 of our start position?  First see if X is within distance threshold:
                if math.abs(tPondSubtable[subrefPondMinX] - M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1]) <= iDistanceThreshold or math.abs(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1] - tPondSubtable[subrefPondMaxX]) <= iDistanceThreshold or (M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1] >= tPondSubtable[subrefPondMinX] and M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1] <= tPondSubtable[subrefPondMaxX]) then
                    --X is in range, is Z?
                    if math.abs(tPondSubtable[subrefPondMinZ] - M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3]) <= iDistanceThreshold or math.abs(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3] - tPondSubtable[subrefPondMaxZ]) <= iDistanceThreshold or (M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3] >= tPondSubtable[subrefPondMinZ] and M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3] <= tPondSubtable[subrefPondMaxZ]) then
                        --X and Z are in range


                        for iMex, tMexInfo in tPondSubtable[subrefPondMexInfo] do
                            iCurMexValue = 0
                            iCurMexDefensiveValue = 0
                            if tMexInfo[subrefMexDFDistance] <= iBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then
                                --Can reach this mex with a ship, so it will have at least some value
                                if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexValue = iFrigateValue
                                elseif tMexInfo[subrefMexDFDistance] <= iDestroyerRange then iCurMexValue = iDestroyerValue
                                elseif tMexInfo[subrefMexIndirectDistance] <= iMissileShipRange then iCurMexValue = iMissileShipValue
                                else iCurMexValue = iBattleshipValue
                                end
                            end

                            --Adjust mex value based on distance
                            iCurModDistance = M27Overseer.GetDistanceFromStartAdjustedForDistanceFromMid(aiBrain, tMexInfo[subrefMexLocation])
                            if iCurMexValue > 0 then
                                if iCurModDistance <  iMinModDistanceWanted then iCurMexValue = 0
                                else
                                    if iCurModDistance < iMidModDistance then
                                        iCurMexValue = iCurMexValue * iBelowMidFactor
                                    end
                                end
                                iCurPondValue = iCurPondValue + iCurMexValue
                            end


                            --Get defensive value
                            if iCurModDistance <= iDefensiveModDistanceMaxValue then
                                if tMexInfo[subrefMexDFDistance] <= iEnemyBattleshipRange or tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then
                                    --Can reach this mex with a ship, so it will have at least some value
                                    if tMexInfo[subrefMexDFDistance] <= iFrigateRange then iCurMexDefensiveValue = iFrigateValue
                                    elseif tMexInfo[subrefMexDFDistance] <= iEnemyDestroyerRange then iCurMexDefensiveValue = iDestroyerValue
                                    elseif tMexInfo[subrefMexIndirectDistance] <= iEnemyMissileShipRange then iCurMexDefensiveValue = iMissileShipValue
                                    else iCurMexDefensiveValue = iBattleshipValue
                                    end
                                end
                                iCurPondDefensiveValue = iCurPondDefensiveValue + iCurMexDefensiveValue
                            end

                        end

                        --Increase vlaue if in part of pond likely to be near enemy base
                        local tEnemyBase = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
                        local iEnemyBaseThreshold = math.max(iBattleshipRange, iMissileShipRange - 10)
                        if math.abs(tPondSubtable[subrefPondMinX] - tEnemyBase[1]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[1] - tPondSubtable[subrefPondMaxX]) <= iEnemyBaseThreshold or (tEnemyBase[1] >= tPondSubtable[subrefPondMinX] and tEnemyBase[1] <= tPondSubtable[subrefPondMaxX]) then
                            --X is in range, is Z?
                            if math.abs(tPondSubtable[subrefPondMinZ] - tEnemyBase[3]) <= iEnemyBaseThreshold or math.abs(tEnemyBase[3] - tPondSubtable[subrefPondMaxZ]) <= iEnemyBaseThreshold or (tEnemyBase[3] >= tPondSubtable[subrefPondMinZ] and tEnemyBase[3] <= tPondSubtable[subrefPondMaxZ]) then
                                iCurPondValue = math.max(iCurPondValue * 1.2, iCurPondValue + 2)
                                if bDebugMessages == true then LOG(sFunctionRef..': Can probably hit enemy base with navy so increasing pond value by 20%') end
                            end
                        end


                        if bDebugMessages == true then LOG(sFunctionRef..': Have a pond that is in range of our start position, value based on mexes in range pre adjust='..iCurPondValue) end
                        --Do we have sufficient value to consider?
                        if iCurPondValue >= 4 or iCurPondDefensiveValue >= 4 then
                            if iCurPondValue <= 0 then iCurPondValue = 0.1 end --Pond has defensive value so greater than 0
                            --Adjust value based on how close the naval build location would be for this pond
                            if not(tPondSubtable[subrefBuildLocationByStartPosition]) then
                                tPondSubtable[subrefBuildLocationByStartPosition] = {}
                            end
                            local tNavalBuildArea = {}
                            local iAngleToCentre = M27Utilities.GetAngleFromAToB(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], tPondSubtable[subrefPondMidpoint])
                            local iDistInterval = 8
                            local iBuildingInterval = 4
                            local tPossibleLocationBase
                            local tPossibleBuildLocation
                            local bHaveValidLocation = false
                            if bDebugMessages == true then LOG(sFunctionRef..': About to search for location to build naval factory for iCurPondRef='..iCurPondRef..'; iDistInterval='..iDistInterval..'; Angle='..iAngleToCentre..'; Midpoint='..repru(tPondSubtable[subrefPondMidpoint])..'; Start position='..repru(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) end
                            for iDistToTravel = iDistInterval, math.max(iDistInterval, math.floor(M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], tPondSubtable[subrefPondMidpoint]) / iDistInterval) * iDistInterval), iDistInterval do
                                for iAngleAdjust = 0, 170, 10 do
                                    for iAngleFactor = -1, 1, 2 do
                                        tPossibleLocationBase = M27Utilities.MoveInDirection(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], iAngleToCentre + iAngleAdjust * iAngleFactor, iDistToTravel, true, true)
                                        if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tPossibleLocationBase) == iCurPondRef then
                                            --Try and find somewhere around here to build a naval factory
                                            for iBuildingAdjustX = 0, iBuildingInterval, 1 do
                                                for iBuildingAdjustZ = 0, iBuildingInterval, 1 do
                                                    for iXFactor = -1, 1, 2 do
                                                        for iZFactor = -1, 1, 2 do
                                                            tPossibleBuildLocation = {tPossibleLocationBase[1] + iBuildingAdjustX * iXFactor, 0, tPossibleLocationBase[3] + iBuildingAdjustZ * iZFactor}
                                                            tPossibleBuildLocation[2] = GetSurfaceHeight(tPossibleBuildLocation[1], tPossibleBuildLocation[3])
                                                            if aiBrain:CanBuildStructureAt('ueb0103', tPossibleBuildLocation) then
                                                                bHaveValidLocation = true
                                                                tNavalBuildArea = {tPossibleBuildLocation[1], tPossibleBuildLocation[2], tPossibleBuildLocation[3]}
                                                                if bDebugMessages == true then
                                                                    LOG(sFunctionRef..': Have valid location='..repru(tPossibleBuildLocation)..'; will draw in white')
                                                                    M27Utilities.DrawLocation(tPossibleBuildLocation, nil, 1, 100, 2)
                                                                end
                                                                break
                                                            else
                                                                if bDebugMessages == true then
                                                                    LOG(sFunctionRef..': Have invalid location='..repru(tPossibleBuildLocation)..'; will draw in red')
                                                                    M27Utilities.DrawLocation(tPossibleBuildLocation, nil, 2, 100, 2)
                                                                end
                                                            end
                                                        end
                                                        if bHaveValidLocation then break end
                                                    end
                                                    if bHaveValidLocation then break end

                                                end
                                                if bHaveValidLocation then break end
                                            end
                                            if iAngleAdjust == 0 or bHaveValidLocation then break end
                                        elseif bDebugMessages == true then
                                            LOG(sFunctionRef..': Failed pathing group='..M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tPossibleLocationBase)..'; iCurPondRef='..iCurPondRef..'; Amphibious iPathingGroupWanted='..iPathingGroupWanted..'; will draw in gold')
                                            M27Utilities.DrawLocation(tPossibleLocationBase, nil, 4, 100, 2)
                                        end
                                        if bHaveValidLocation then break end
                                    end
                                    if bHaveValidLocation then break end
                                end
                                if bHaveValidLocation then break end
                            end

                            if bDebugMessages == true then LOG(sFunctionRef..': Finsihed searching for naval build area, is table empty='..tostring(M27Utilities.IsTableEmpty(tNavalBuildArea))) end


                            if M27Utilities.IsTableEmpty(tNavalBuildArea) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': tNavalBuildArea pre adjust='..repru(tNavalBuildArea)) end
                                --Move towards base to help with cliff building if we have cliffs
                                local bHaveNearbyCliff = false
                                local iDistToMoveTarget = M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber], tNavalBuildArea)
                                local iAngleFromTarget = M27Utilities.GetAngleFromAToB(tNavalBuildArea, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                local tCliffPositionCheck
                                local sPathing = M27UnitInfo.refPathingTypeAmphibious
                                local iStartPathingGroup = M27MapInfo.GetSegmentGroupOfLocation(sPathing,M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])

                                if iDistToMoveTarget > 1 then
                                    for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                        tCliffPositionCheck = M27Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false)
                                        if not(M27MapInfo.GetSegmentGroupOfLocation(sPathing, tCliffPositionCheck) == iStartPathingGroup) then
                                            bHaveNearbyCliff = true
                                            break
                                        end

                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bHaveNearbyCliff='..tostring(bHaveNearbyCliff)) end
                                if bHaveNearbyCliff then
                                    --Try to move closer to base
                                    local tLastValidPosition = {tNavalBuildArea[1], tNavalBuildArea[2], tNavalBuildArea[3]}
                                    local tAlternativePosition

                                    for iDistAdjust = 1, math.min(13, math.floor(iDistToMoveTarget)) do
                                        tAlternativePosition = M27Utilities.MoveInDirection(tNavalBuildArea, iAngleFromTarget, iDistAdjust, true, false)
                                        if not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tAlternativePosition) == iCurPondRef) then
                                            break
                                        else
                                            --Can we build here?
                                            if aiBrain:CanBuildStructureAt('ueb0103', tAlternativePosition) then
                                                tLastValidPosition = {tAlternativePosition[1], tAlternativePosition[2], tAlternativePosition[3]}
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have an alternative position that is closer to our base, iDistAdjust='..iDistAdjust) end
                                            else
                                                break
                                            end
                                        end
                                    end
                                    tNavalBuildArea = tLastValidPosition


                                end



                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': Have a naval build area='..repru(tNavalBuildArea)..'; will draw large square around it in blue')
                                    M27Utilities.DrawLocation(tNavalBuildArea, nil, nil, 200, 10)
                                end
                                tPondSubtable[subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber] = tNavalBuildArea

                                --Record pond value before distance adjustments - i.e. if we already have navy somewhere, this is how much the pond is worth to us
                                aiBrain[reftiPondValueToUs][iCurPondRef] = iCurPondValue
                                --Adjust pond value based on distance to us - used only for decision on whether to choose as a pond we want


                                --Can we path here amphibiously?
                                if not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, tNavalBuildArea) == iPathingGroupWanted) then
                                    iCurPondValue = 0
                                    if bDebugMessages == true then LOG(sFunctionRef..': We cant path here amphibiously') end
                                else
                                    --Adjust value based on distance
                                    local iDistToBuildArea = M27Utilities.GetDistanceBetweenPositions(tNavalBuildArea, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                    if iDistToBuildArea <= 50 then iCurPondValue = iCurPondValue * 1.1
                                    else
                                        iCurPondValue = iCurPondValue * math.max(0.1, 1 - 0.4 * iDistToBuildArea / iDistanceThreshold)
                                    end

                                    --Are we close enough to enemy base to be in danger and we can land path to enemy base?
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dist to nearest enemy base='..aiBrain[M27Overseer.refiDistanceToNearestEnemyBase]..'; Can path with land='..tostring(aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand])..'; Dist from naval build location to enemy base='..M27Utilities.GetDistanceBetweenPositions(tNavalBuildArea, M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain))) end
                                    if aiBrain[M27MapInfo.refbCanPathToEnemyBaseWithLand] then
                                        --Reduce value of pond if enemy base is close for land anyway
                                        if aiBrain[M27Overseer.refiDistanceToNearestEnemyBase] <= 300 then
                                            iCurPondValue = iCurPondValue * 0.5
                                        end
                                        if M27Utilities.GetDistanceBetweenPositions(tNavalBuildArea, M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)) <= 200 then
                                            iCurPondValue = 0
                                        end
                                    end
                                end
                            else
                                iCurPondValue = 0
                            end
                            aiBrain[reftiPondThreatToUs][iCurPondRef] = iCurPondDefensiveValue
                            if bDebugMessages == true then LOG(sFunctionRef..': Pond value after getting naval build area='..iCurPondValue..'; Defensive value='..(aiBrain[reftiPondThreatToUs][iCurPondRef] or 'nil')) end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Pond value is too low to be worth considering') end
                            iCurPondValue = 0
                        end
                    end
                end
                if iCurPondValue > iBestPondValue then
                    if bDebugMessages == true then LOG(sFunctionRef..': Updating the best pond ref to be '..iCurPondRef..'; as the cur pond value '..iCurPondValue..' is more than the prev best of '..iBestPondValue) end
                    iBestPondRef = iCurPondRef
                    iBestPondValue = iCurPondValue

                end
            end
        end
        if iBestPondRef and iBestPondValue >= 4 then
            aiBrain[refiPriorityPondRef] = iBestPondRef
            if bDebugMessages == true then
                LOG(sFunctionRef..': Have a priority pond ref='..aiBrain[refiPriorityPondRef]..'; will draw a square in orangy pink for the build position='..repru(tPondDetails[aiBrain[refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber]))
                M27Utilities.DrawLocation(tPondDetails[aiBrain[refiPriorityPondRef]][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber], nil, 8, 200, 10)
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function RemoveUnitFromAssignedPond(oUnit)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RemoveUnitFromAssignedPond'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if oUnit[refiAssignedPond] then --redundancy
        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
        if oUnit[reftiTeamRefsUpdatedFor] then
            local aiBrain = oUnit:GetAIBrain()
            local iFriendlyTeamRef
            if aiBrain.M27AI then iFriendlyTeamRef = aiBrain.M27Team end
            if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyTeamRef='..(iFriendlyTeamRef or 'nil')..'; Assigend pond='..(oUnit[refiAssignedPond] or 'nil')) end

            if not(oUnit[refiAssignedPond] == 0) then
                for iM27TeamUpdatingFor, bValue in  oUnit[reftiTeamRefsUpdatedFor] do
                    if iFriendlyTeamRef == iM27TeamUpdatingFor then
                        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][oUnit[refiAssignedPond]]) == false then --redundancy
                            for iRecordedUnit, oRecordedUnit in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][oUnit[refiAssignedPond]] do
                                if oRecordedUnit == oUnit then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' from list of friendly units in pond '..oUnit[refiAssignedPond]..' for team '..aiBrain.M27Team) end
                                    table.remove(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][oUnit[refiAssignedPond]], iRecordedUnit)
                                    break
                                end
                            end
                        end
                    else
                        if M27Utilities.IsTableEmpty(M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][oUnit[refiAssignedPond]]) == false then --redundancy
                            for iRecordedUnit, oRecordedUnit in M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][oUnit[refiAssignedPond]] do
                                if oRecordedUnit == oUnit then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Removing unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' from list of enemy units in pond '..oUnit[refiAssignedPond]..' for team '..iM27TeamUpdatingFor) end
                                    table.remove(M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][oUnit[refiAssignedPond]], iRecordedUnit)
                                    break
                                end
                            end
                        end
                    end
                end
            end
            oUnit[reftiTeamRefsUpdatedFor] = {}
        end
        oUnit[refiAssignedPond] = nil
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function AddUnitToPond(oUnit, iCurPond, iM27TeamUpdatingFor, bIsEnemy)
    --Updates table of friendly and enemy units for oUnit; only records units if they are in a recognised pond

    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'AddUnitToPond'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurPond='..iCurPond..'; iM27TeamUpdatingFor='..iM27TeamUpdatingFor..'; bIsEnemy='..tostring((bIsEnemy or false))..'; repr of oUnit[reftiTeamRefsUpdatedFor]='..repru(oUnit[reftiTeamRefsUpdatedFor])..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end

    if not(oUnit[reftiTeamRefsUpdatedFor]) then
        oUnit[reftiTeamRefsUpdatedFor] = {}
    end

    function AddToFriendlyUnitList()

        if not(iCurPond == 0) then
            if not(M27Team.tTeamData[oUnit:GetAIBrain().M27Team][M27Team.reftFriendlyUnitsByPond][iCurPond]) then M27Team.tTeamData[oUnit:GetAIBrain().M27Team][M27Team.reftFriendlyUnitsByPond][iCurPond] = {} end
            table.insert(M27Team.tTeamData[oUnit:GetAIBrain().M27Team][M27Team.reftFriendlyUnitsByPond][iCurPond], oUnit)
        end
        oUnit[reftiTeamRefsUpdatedFor][oUnit:GetAIBrain().M27Team] = true
    end

    if bIsEnemy then

        oUnit[reftiTeamRefsUpdatedFor][iM27TeamUpdatingFor] = true
        if not(iCurPond == 0) then
            if not(M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][iCurPond]) then M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][iCurPond] = {} end
            table.insert(M27Team.tTeamData[iM27TeamUpdatingFor][M27Team.reftEnemyUnitsByPond][iCurPond], oUnit)
        end
        if not(oUnit[refiAssignedPond]) and oUnit:GetAIBrain().M27AI then
            AddToFriendlyUnitList()
        end

    else
        AddToFriendlyUnitList()
    end

    oUnit[refiAssignedPond] = iCurPond
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function UpdateUnitPond(oUnit, iM27TeamUpdatingFor, bIsEnemy, iPondRefOverride)
    --Check the unit's pond; ignore this for non-M27 friendly units
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPond'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if bDebugMessages == true then M27Utilities.ErrorHandler('Audit trail', true) end

    --if oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit) == 'xes02051' and oUnit:GetAIBrain():GetArmyIndex() == 2 and GetGameTimeSeconds() >= 840 then bDebugMessages = true end

    if bIsEnemy or (oUnit:GetAIBrain().M27AI and (not(oUnit[refiAssignedPond]) or not(EntityCategoryContains(M27UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId)))) then --and not(oUnit[reftiTeamRefsUpdatedFor][iM27TeamUpdatingFor])) then
        local iCurPond = iPondRefOverride or M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': bIsEnemy='..tostring(bIsEnemy)..'; Updating for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPondRefOverride='..(iPondRefOverride or 'nil')..'; iCurPond='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end --LOG('iCurPond pre adj='..(iCurPond or 'nil'))
        --if tPondDetails[iCurPond] then LOG('Pond size='..(tPondDetails[iCurPond][subrefPondSize] or 'nil')) end
        if not(tPondDetails[iCurPond]) or (tPondDetails[iCurPond][subrefPondSize] or 0) <= iMinPondSize then
            --If have a naval unit that isnt amphibious then update pathing
            if EntityCategoryContains(categories.NAVAL * categories.MOBILE - categories.HOVER - categories.AMPHIBIOUS - categories.AIR - categories.LAND, oUnit.UnitId) then
                iCurPond = CheckForPondNearNavalUnit(oUnit)
            else
                iCurPond = 0
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after updating for naval unit and min pond size='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end
        if iCurPond > 0 then
            oUnit[M27UnitInfo.reftLastKnownPosition] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Updated unit last known position') end
        end
        if oUnit[refiAssignedPond] then
            if not(iCurPond == oUnit[refiAssignedPond]) then
                if bDebugMessages == true then LOG('Removing unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' from old pond '..(oUnit[refiAssignedPond] or 'nil')..' and adding to new pond iCurPond='..iCurPond) end
                RemoveUnitFromAssignedPond(oUnit)
                AddUnitToPond(oUnit, iCurPond, iM27TeamUpdatingFor, bIsEnemy)
            elseif not(oUnit[reftiTeamRefsUpdatedFor][iM27TeamUpdatingFor]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM27TeamUpdatingFor, bIsEnemy)
            end
        else
            if iCurPond > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM27TeamUpdatingFor, bIsEnemy)
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetPrimaryEnemyPondBaseLocation(aiBrain, iPond)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPrimaryEnemyPondBaseLocation'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPond='..iPond..'; Is priamry enemy naval unit valid='..tostring(M27UnitInfo.IsUnitValid(M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryEnemyNavalUnitByPond][iPond]))..'; Time since last updated='..GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastEnemyNavalBaseUpdateByPond][iPond] or -100)) end

    if M27UnitInfo.IsUnitValid(M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryEnemyNavalUnitByPond][iPond]) and GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastEnemyNavalBaseUpdateByPond][iPond] or -100) < 5 then
        if bDebugMessages == true then LOG(sFunctionRef..': Still have valid enemy priamry naval unit so will retrun stored value='..repru(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond])) end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond]
    elseif GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastEnemyNavalBaseUpdateByPond][iPond] or -100) < 5 and M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond]) and M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Not long since last did this so will return stored value='..repru(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond])) end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond]
    else
        --Want to update - either unit has changed or it has been at least 5s since we last updated
        M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastEnemyNavalBaseUpdateByPond][iPond] = GetGameTimeSeconds()
        local tOurBase = M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond]


        --Does the enemy have no units? If so, then get the enemy base furthest away
        local oEnemyFocusUnit
        local tEnemyBase
        if bDebugMessages == true then LOG(sFunctionRef..': Will refresh the locaiton. tOurBase='..repru(tOurBase)..'; Is table of enemy units for pond '..iPond..' empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond]))) end
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond]) == false then
            local tEnemyFactories = EntityCategoryFilterDown(M27UnitInfo.refCategoryNavalFactory, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond])
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy factories empty='..tostring(M27Utilities.IsTableEmpty(tEnemyFactories))) end
            if M27Utilities.IsTableEmpty(tEnemyFactories) then
                --Does the enemy have T2+ navy? If so then pick the furthest away such unit as the 'base'
                local tEnemyT2PlusNavy = EntityCategoryFilterDown(M27UnitInfo.refCategoryAllNavy - categories.TECH1, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond])
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy T2plus navy empty='..tostring(M27Utilities.IsTableEmpty(tEnemyT2PlusNavy))) end
                if M27Utilities.IsTableEmpty(tEnemyT2PlusNavy) == false then
                    local iFurthestDist = 0
                    local iCurDist
                    for iUnit, oUnit in tEnemyT2PlusNavy do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions((oUnit[M27UnitInfo.reftLastKnownPosition] or oUnit:GetPosition()), tOurBase)
                        if iCurDist > iFurthestDist then
                            iFurthestDist = iCurDist
                            oEnemyFocusUnit = oUnit
                        end
                    end

                else

                    --Enemy has no T2+ navy and no naval factories, target nearest naval unit of any kind
                    local iCurDist
                    local iClosestDist = 100000
                    for iUnit, oUnit in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond][iPond] do
                        if M27UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit[M27UnitInfo.reftLastKnownPosition] or oUnit:GetPosition(), tOurBase)
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oEnemyFocusUnit = oUnit
                            end
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy has no factories or T2plus navy, will just get any unit as focus unit. Is unit valid='..tostring(M27UnitInfo.IsUnitValid(oEnemyFocusUnit))) end
                end
            else
                --Enemy has naval factory; Get the highest tech nearest naval factory
                local iHighestEnemyNavalFac = 1
                for iUnit, oUnit in tEnemyFactories do
                    iHighestEnemyNavalFac = math.max(M27UnitInfo.GetUnitTechLevel(oUnit), iHighestEnemyNavalFac)
                    if iHighestEnemyNavalFac >= 3 then break end
                end

                local tHighestFactories = EntityCategoryFilterDown(M27UnitInfo.ConvertTechLevelToCategory(iHighestEnemyNavalFac), tEnemyFactories)
                local iCurDist
                local iClosestDist = 100000
                for iUnit, oUnit in tHighestFactories do
                    iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        oEnemyFocusUnit = oUnit
                    end
                end
            end
        else
            --No enemy units so need to get base baesd on aibrain start position - will do later as do this if no T2+ naval units as well
        end

        if not(M27UnitInfo.IsUnitValid(oEnemyFocusUnit)) and not(tEnemyBase) then
            --Get furthest away enemy brain naval build location
            if bDebugMessages == true then LOG(sFunctionRef..': Will get furthest away enemy base build location as no enemy focus unit or enemy base') end
            local iFurthestDist = 0
            local iCurDist
            if M27Utilities.IsTableEmpty(tPondDetails[iPond][subrefBuildLocationByStartPosition]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': All start positions for pond '..iPond..'='..repru(tPondDetails[iPond][subrefBuildLocationByStartPosition])..'; will now find out if any belong to enemy brains') end
                for iBrain, oBrain in aiBrain[M27Overseer.toEnemyBrains] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..': Index='..oBrain:GetArmyIndex()..'; Start position='..(oBrain.M27StartPositionNumber or 'nil')) end
                    if M27Utilities.IsTableEmpty(tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber]) == false then
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber], tOurBase)
                        if iCurDist > iFurthestDist then
                            tEnemyBase = {tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber][1], tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber][2], tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber][3]}
                            iFurthestDist = iCurDist
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tEnemyBase after checking for pond build locations='..repru(tEnemyBase)) end
            if not(tEnemyBase) then
                --Dont have a build location for the naval pond, use the nearest enemy aiBrain base itself as the pond base
                if bDebugMessages == true then LOG(sFunctionRef..': Dont have enemy pond build location so will try and determine the closest enemy brain base') end
                local iClosestDist = 100000
                for iBrain, oBrain in aiBrain[M27Overseer.toEnemyBrains] do
                    iCurDist = M27Utilities.GetDistanceBetweenPositions(M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber], tOurBase)
                    if iCurDist < iClosestDist then
                        tEnemyBase = {M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][1], M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][2], M27MapInfo.PlayerStartPoints[oBrain.M27StartPositionNumber][3]}
                        iClosestDist = iCurDist
                    end
                end
            end
        end


        M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryEnemyNavalUnitByPond][iPond] = oEnemyFocusUnit --i.e. sets to nil if no focus unit
        if oEnemyFocusUnit then
            M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond] = (oEnemyFocusUnit[M27UnitInfo.reftLastKnownPosition] or oEnemyFocusUnit:GetPosition())
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return {M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond][1], M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond][2], M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond][3]}
        else
            M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyBaseLocationByPond][iPond] = { tEnemyBase[1], tEnemyBase[2], tEnemyBase[3] }
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            return tEnemyBase
        end
    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd) --redundancy
end


function GetPrimaryNavalFactory(aiBrain, iPond)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPrimaryNavalFactory'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code. do we already have a valid primary naval factory for pond '..iPond..'='..tostring(M27UnitInfo.IsUnitValid(M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond]))..'; Time of last update='..GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][iPond][M27Team.refiTimeOfLastPrimaryNavalUpdateByPond] or -100)) end
    if M27UnitInfo.IsUnitValid(M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond]) and GetGameTimeSeconds() - (M27Team.tTeamData[aiBrain.M27Team][iPond][M27Team.refiTimeOfLastPrimaryNavalUpdateByPond] or -100) < 5 then
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond]
    else
        local iDistanceCap = 200
        local oPrimaryFactory
        local oPreviousPrimary = M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond]
        if not(M27UnitInfo.IsUnitValid(oPreviousPrimary)) then oPreviousPrimary = nil end
        if bDebugMessages == true then LOG(sFunctionRef..': Is the table of friendly units for this pond empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond]))) end
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond]) then
            --Will return nil
        else
            local tExistingNavalFactory = EntityCategoryFilterDown(M27UnitInfo.refCategoryNavalFactory, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond])
            local tFactoriesCloseToNavalBase = {}
            local tNavalBase = tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber]
            if M27Utilities.IsTableEmpty(tNavalBase) then
                --Do we have teammates with a naval base start position?
                for iBrain, oBrain in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyActiveM27Brains] do
                    tNavalBase = tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber]
                    if M27Utilities.IsTableEmpty(tNavalBase) == false then break end
                end
                if M27Utilities.IsTableEmpty(tNavalBase) then
                    --Try all defeated M27 brains
                    for iBrain, oBrain in ArmyBrains do
                        if oBrain.M27AI and oBrain.M27IsDefeated and IsAlly(aiBrain:GetArmyIndex(), oBrain:GetArmyIndex()) then
                            tNavalBase = tPondDetails[iPond][subrefBuildLocationByStartPosition][oBrain.M27StartPositionNumber]
                            if M27Utilities.IsTableEmpty(tNavalBase) == false then break end
                        end
                    end
                    if M27Utilities.IsTableEmpty(tNavalBase) then

                        --Just use our start position
                        M27Utilities.ErrorHandler('Couldnt find naval build location for any teammate so will just use our start position to avoid error')
                        tNavalBase = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
                    end
                end
            end
            local iCurTechLevel

            if bDebugMessages == true then LOG(sFunctionRef..': Is the table of naval factories empty='..tostring(M27Utilities.IsTableEmpty(tExistingNavalFactory))) end

            if M27Utilities.IsTableEmpty(tExistingNavalFactory) == false then
                local iHighestTechFactory = 1
                for iFactory, oFactory in tExistingNavalFactory do
                    if M27UnitInfo.IsUnitValid(oFactory) then
                        iCurTechLevel = M27UnitInfo.GetUnitTechLevel(oFactory)
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering factory '..oFactory.UnitId..M27UnitInfo.GetUnitLifetimeCount(oFactory)..'; Dist to naval base='..M27Utilities.GetDistanceBetweenPositions(oFactory:GetPosition(), tNavalBase)..'; iDistanceCap='..iDistanceCap) end

                        if M27Utilities.GetDistanceBetweenPositions(oFactory:GetPosition(), tNavalBase) <= iDistanceCap then
                            iHighestTechFactory = math.max(iHighestTechFactory, M27UnitInfo.GetUnitTechLevel(oFactory))
                            table.insert(tFactoriesCloseToNavalBase, oFactory)
                        end
                    end
                end

                if M27Utilities.IsTableEmpty(tFactoriesCloseToNavalBase) then tFactoriesCloseToNavalBase = tExistingNavalFactory end
                if M27UnitInfo.GetUnitTechLevel(oPreviousPrimary) >= iHighestTechFactory and M27UnitInfo.IsUnitValid(oPreviousPrimary) then
                    oPrimaryFactory = oPreviousPrimary
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of factories close to naval base empty='..tostring(M27Utilities.IsTableEmpty(tFactoriesCloseToNavalBase))) end
                    if M27Utilities.IsTableEmpty(tFactoriesCloseToNavalBase) == false then

                        local iClosestDistToTarget = 10000
                        local iCurDistToTarget

                        for iFactory, oFactory in tFactoriesCloseToNavalBase do
                            if not(oPrimaryFactory) then oPrimaryFactory = oFactory end --Redundancy in case below fails to find anything
                            if oFactory:IsUnitState('Upgrading') then
                                oPrimaryFactory = oFactory
                                break
                            else
                                if M27UnitInfo.GetUnitTechLevel(oFactory) >= iHighestTechFactory then
                                    iCurDistToTarget = M27Utilities.GetDistanceBetweenPositions(oFactory:GetPosition(), tNavalBase)
                                    if iCurDistToTarget < iClosestDistToTarget then
                                        iClosestDistToTarget = iCurDistToTarget
                                        oPrimaryFactory = oFactory
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Have we got a valid primary factory now='..tostring(M27UnitInfo.IsUnitValid(oPrimaryFactory))) end
            if oPrimaryFactory then
                M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond] = oPrimaryFactory:GetPosition()
            end
        end

        M27Team.tTeamData[aiBrain.M27Team][M27Team.refoPrimaryNavalFactoryByPond][iPond] = oPrimaryFactory
        if oPrimaryFactory then M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastPrimaryNavalUpdateByPond][iPond] = GetGameTimeSeconds()
        else
            --No primary factory - set a base location if we dont have one already
            if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond]) then
                if M27Utilities.IsTableEmpty(tPondDetails[iPond][subrefBuildLocationByStartPosition]) or M27Utilities.IsTableEmpty(tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber]) then
                    M27Utilities.ErrorHandler('Dont have a build location for our start position, will just set the backup location to be our base')
                    M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond] = {M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][1], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][2], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber][3]}
                else

                    M27Team.tTeamData[aiBrain.M27Team][M27Team.reftBackupBaseLocationByPond][iPond] = {tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber][1], tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber][2], tPondDetails[iPond][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber][3]}
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Returning primary naval factory '..(oPrimaryFactory.UnitId or 'nil')..(M27UnitInfo.GetUnitLifetimeCount(oPrimaryFactory) or 'nil')) end

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        return oPrimaryFactory
    end
end

function ReassignNavalEngineer(oEngineer)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReassignNavalEngineer'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --Intended to give an order to an engineer already assigned to a pond, on a team basis
    --Note - this doesnt decide original assignment - that is done in the main engineer reassignment code; once an engineer has been assigned to pond naval duties though this function takes over

    --if M27EngineerOverseer.GetEngineerUniqueCount(oEngineer) == 21 and GetGameTimeSeconds() >= 600 then bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, for oEngineer='..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..M27EngineerOverseer.GetEngineerUniqueCount(oEngineer)..'; Pond assigned='..(oEngineer[refiAssignedPond] or 'nil')..'; Engineer unit state='..M27Logic.GetUnitState(oEngineer)) end

    local aiBrain = oEngineer:GetAIBrain()
    local oPrimaryFactory = GetPrimaryNavalFactory(aiBrain, oEngineer[refiAssignedPond])
    if not(oPrimaryFactory) then
        --No naval factories near us so no longer have the engineer assigned to the pond
        oEngineer[refiAssignedPond] = nil
        M27Utilities.IssueTrackedClearCommands({oEngineer})
        M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngineer, true)
        if bDebugMessages == true then LOG(sFunctionRef..': No naval factory so clearing engineer assigned pond and trackers') end
    else
        local oActionTargetObject
        local iCurLoopCount = 0
        local iCurrentConditionToTry = 0
        local iCurLandFactories = 0
        local iMaxEngisWanted
        local iActionToAssign
        local iMinEngiTechLevelWanted = 1
        local iSearchRangeForNearestEngi
        local iExistingEngineersAssigned
        local oExistingBuilder
        local tActionTargetLocation

        --Common conditions
        local bHaveLowMass = M27Conditions.HaveLowMass(aiBrain)
        local bHaveLowPower = false

        if aiBrain[M27EconomyOverseer.refbStallingEnergy] or GetGameTimeSeconds() - aiBrain[M27EconomyOverseer.refiLastEnergyStall] <= 20 then
            if bDebugMessages == true then LOG(sFunctionRef..': Have low power as recently stalled') end
            bHaveLowPower = true
        else
            if aiBrain:GetEconomyStoredRatio('ENERGY') < 0.99 and (aiBrain:GetEconomyStored('ENERGY') < 1000 or aiBrain[M27EconomyOverseer.refiNetEnergyBaseIncome] <= 0) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have low power as dont have much stored') end
                bHaveLowPower = true
            end
        end
        if bHaveLowPower and aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] >= 50000 then bHaveLowPower = false end


        while iCurLoopCount <= 100 do
            iCurLoopCount = iCurLoopCount + 1
            if iCurLoopCount >= 99 then M27Utilities.ErrorHandler('Infinite loop') break end

            iCurrentConditionToTry = iCurrentConditionToTry + 1


            --Set defaults
            iMaxEngisWanted = 1
            iMinEngiTechLevelWanted = 1
            iActionToAssign = nil
            oExistingBuilder = nil
            tActionTargetLocation = nil

            if iCurrentConditionToTry == 1 then
                --Assist primary factory (so it mvoes closer)
                if M27Utilities.GetDistanceBetweenPositions(oPrimaryFactory:GetPosition(), oEngineer:GetPosition()) >= 150 then
                    iActionToAssign = M27EngineerOverseer.refActionAssistNavalFactory
                    oActionTargetObject = oPrimaryFactory
                    iMaxEngisWanted = 100
                end
            elseif iCurrentConditionToTry == 2 then
                iActionToAssign = M27EngineerOverseer.refActionAssistNavalFactory --always want some engis assisting naval factory
                oActionTargetObject = oPrimaryFactory
                --Primary factory is upgrading
                if oPrimaryFactory:IsUnitState('Upgrading') then
                    iMaxEngisWanted = 8 * M27UnitInfo.GetUnitTechLevel(oPrimaryFactory)
                    if bHaveLowMass then iMaxEngisWanted = iMaxEngisWanted * 0.5 end
                else
                    iMaxEngisWanted = 5 * M27UnitInfo.GetUnitTechLevel(oPrimaryFactory)
                    if bHaveLowMass then iMaxEngisWanted = iMaxEngisWanted * 0.5 end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Want to be assisting naval fac with iMaxEngisWanted='..iMaxEngisWanted) end
            elseif iCurrentConditionToTry == 3 then
                --Lack sonar
                if not(bHaveLowPower) then
                    local iSonarRangeWanted = 80
                    if M27UnitInfo.GetUnitTechLevel(oPrimaryFactory) >= 2 then iSonarRangeWanted = 180 end
                    local tSonarInPond = EntityCategoryFilterDown(M27UnitInfo.refCategorySonar, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][oEngineer[refiAssignedPond]])
                    local bHaveSonarCoverageWanted = false

                    if M27Utilities.IsTableEmpty(tSonarInPond) == false then
                        local iCurSonarRange
                        for iUnit, oUnit in tSonarInPond do
                            iCurSonarRange = oUnit:GetBlueprint().Intel.Sonar or 0
                            if iCurSonarRange >= iSonarRangeWanted and iCurSonarRange - M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oPrimaryFactory:GetPosition()) >= iSonarRangeWanted then
                                bHaveSonarCoverageWanted = true
                                break
                            end
                        end
                    end
                    if not(bHaveSonarCoverageWanted) then
                        if M27UnitInfo.GetUnitTechLevel(oPrimaryFactory) >= 2 then
                            iActionToAssign = M27EngineerOverseer.refActionBuildT2Sonar
                            iMinEngiTechLevelWanted = 2
                        else
                            iActionToAssign = M27EngineerOverseer.refActionBuildT1Sonar
                        end
                    end
                    if iActionToAssign then
                        iMaxEngisWanted = 3
                        if bHaveLowMass then iMaxEngisWanted = 1 end
                        tActionTargetLocation = oPrimaryFactory:GetPosition()
                    end
                end
            else --Spare action
                if bDebugMessages == true then LOG(sFunctionRef..': Issuing spare naval action') end
                iActionToAssign = M27EngineerOverseer.refActionNavalSpareAction
                iMaxEngisWanted = 100
            end

            if iActionToAssign then

                --Check we havent recently failed to assign this action
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Have iActionToAssign=' .. iActionToAssign)
                end
                if aiBrain[M27EngineerOverseer.refiTimeOfLastFailure][iActionToAssign] and GetGameTimeSeconds() - aiBrain[M27EngineerOverseer.refiTimeOfLastFailure][iActionToAssign] <= 9 then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Time since last failure=' .. GetGameTimeSeconds() - aiBrain[M27EngineerOverseer.refiTimeOfLastFailure][iActionToAssign])
                    end
                    iActionToAssign = nil
                end
            end
            if iActionToAssign then
                iExistingEngineersAssigned = 0
                if iActionToAssign and aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef] and aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][iActionToAssign] and M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][iActionToAssign]) == false then
                    --Cant use table.getn for this table so do manually:
                    for iRef, tEngSubtable in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][iActionToAssign] do
                        if tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][refiAssignedPond] == oEngineer[refiAssignedPond] then
                            iExistingEngineersAssigned = iExistingEngineersAssigned + 1
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Engineer assigned=' .. tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef].UnitId .. M27UnitInfo.GetUnitLifetimeCount(tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]) .. '; UC=' .. M27EngineerOverseer.GetEngineerUniqueCount(tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]) .. '; Engineer action=' .. (tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refiEngineerCurrentAction] or 'nil'))
                            end
                            if tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refbPrimaryBuilder] then
                                oExistingBuilder = tEngSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]
                            end
                        end
                    end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iExistingEngineersAssigned=' .. iExistingEngineersAssigned .. '; iMaxEngisWanted=' .. iMaxEngisWanted)
                end
                if iExistingEngineersAssigned < iMaxEngisWanted then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Want to assign more engis, if action is to buidl factory then will tell engis to assist existing builder. iActionToAssign=' .. iActionToAssign .. '; iExistingEngineersAssigned=' .. iExistingEngineersAssigned)
                    end
                    if iActionToAssign == M27EngineerOverseer.refActionBuildNavalFactory and iExistingEngineersAssigned > 0 then
                        oActionTargetObject = oExistingBuilder
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Will tell engis to assist existing builder ' .. oExistingBuilder.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oExistingBuilder))
                        end
                    end
                    if not(tActionTargetLocation) then
                        if oActionTargetObject then tActionTargetLocation = oActionTargetObject:GetPosition()
                        else
                            tActionTargetLocation = oEngineer:GetPosition()
                        end
                    end

                    --if are building a factory then check if already have engineer assigned, in which case will assist that
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': About to assign ' .. iActionToAssign .. ' action to the engineer ' .. oEngineer.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oEngineer) .. '; UC=' .. M27EngineerOverseer.GetEngineerUniqueCount(oEngineer))
                        if oActionTargetObject then LOG(sFunctionRef..': oActionTargetObject='..(oActionTargetObject.UnitId..M27UnitInfo.GetUnitLifetimeCount(oActionTargetObject))) end
                    end

                    M27EngineerOverseer.AssignActionToEngineer(aiBrain, oEngineer, iActionToAssign, tActionTargetLocation, oActionTargetObject, iCurrentConditionToTry)
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Too many engineers assigned so will change action to nil') end
                    iActionToAssign = nil
                end
            end

            if iActionToAssign then
                break
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ShouldWeRefreshUnitOrder(oUnit, iOrderType, tOrderLocation, oOrderUnit)
    local bRefreshOrder = true

    if oUnit[M27UnitInfo.refbSpecialMicroActive] then
        bRefreshOrder = false
    else
        if oUnit[M27PlatoonUtilities.refiLastOrderType] == iOrderType then
            if oOrderUnit then
                if oOrderUnit == oUnit[M27UnitInfo.refoLastOrderUnitTarget] and not(M27Logic.IsUnitIdle(oUnit, false, true, false, false)) then
                    bRefreshOrder = false
                end
            else
                --LOG('ShouldWeRefresh: Unit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; tOrderLocation='..repru(tOrderLocation)..'; Unit last order target='..repru(oUnit[M27UnitInfo.reftLastOrderTarget]))
                local iDistThreshold = 5
                if EntityCategoryContains(M27UnitInfo.refCategoryMobileLandShield, oUnit.UnitId) then iDistThreshold = 2.5 end
                if M27Utilities.GetDistanceBetweenPositions(tOrderLocation, oUnit[M27UnitInfo.reftLastOrderTarget]) <= 5 then
                    if not(M27Logic.IsUnitIdle(oUnit, false, true, false, false)) then
                        bRefreshOrder = false
                    end
                end
            end
        end
    end
    return bRefreshOrder
end

function MoveUnitTowardsTarget(oUnit, tTarget, bAttackMove, sOrderDesc)
    --sOrderDesc - used to update unit name for debugging

    --Do we want to change the current order?
    local iOrderType
    if bAttackMove then
        iOrderType = M27PlatoonUtilities.refiOrderIssueAggressiveMove
    else
        iOrderType = M27PlatoonUtilities.refiOrderIssueMove
    end
    local bRefreshOrder = ShouldWeRefreshUnitOrder(oUnit, iOrderType, tTarget, nil)
    --LOG('Move Unit Towards Target: oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; bRefreshOrder='..tostring(bRefreshOrder)..'; iOrderType='..iOrderType..'; bAttackMove='..tostring(bAttackMove)..'; Unit last order type='..(oUnit[M27PlatoonUtilities.refiLastOrderType] or 'nil')..'; Distance to last target='..M27Utilities.GetDistanceBetweenPositions((oUnit[M27UnitInfo.reftLastOrderTarget] or {0,0,0}), tTarget))
    if bRefreshOrder then
        M27Utilities.IssueTrackedClearCommands({oUnit})
        oUnit[M27UnitInfo.refoLastOrderUnitTarget] = nil
        if bAttackMove then
            IssueAggressiveMove({oUnit}, tTarget)
        else
            IssueMove({oUnit}, tTarget)
        end
        oUnit[M27PlatoonUtilities.refiLastOrderType] = iOrderType
        oUnit[M27UnitInfo.reftLastOrderTarget] = {tTarget[1], tTarget[2], tTarget[3]}
        if M27Config.M27ShowUnitNames then M27PlatoonUtilities.UpdateUnitNames({ oUnit}, oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..': Navy: '..(sOrderDesc or 'nil'), true) end
    end
end

function TellUnitToAttackTarget(oUnit, oTarget, sOrderDesc)
    local bRefreshOrder = ShouldWeRefreshUnitOrder(oUnit, M27PlatoonUtilities.refiOrderIssueAttack, oTarget:GetPosition(), oTarget)
    --LOG('TellUnitToAttackTarget: oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; oTarget='..oTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oTarget)..'; bRefreshOrder='..tostring(bRefreshOrder))
    if bRefreshOrder then
        M27Utilities.IssueTrackedClearCommands({oUnit})
        IssueAttack({oUnit}, oTarget)
        oUnit[M27PlatoonUtilities.refiLastOrderType] = M27PlatoonUtilities.refiOrderIssueAttack
        oUnit[M27UnitInfo.reftLastOrderTarget] = oTarget:GetPosition()
        oUnit[M27UnitInfo.refoLastOrderUnitTarget] = oTarget
        if M27Config.M27ShowUnitNames then M27PlatoonUtilities.UpdateUnitNames({ oUnit}, oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..': Navy: '..(sOrderDesc or 'nil'), true) end
    end
end

function RemoveShieldAssignment(oShield)
    local oUnitToSupport = oShield[refoSupportTarget]
    if M27UnitInfo.IsUnitValid(oUnitToSupport) and M27Utilities.IsTableEmpty(oUnitToSupport[reftoAssignedShields]) == false then
        for iSupportingShield, oSupportingShield in oUnitToSupport[reftoAssignedShields] do
            if oSupportingShield == oShield then
                table.remove(oUnitToSupport[reftoAssignedShields], iSupportingShield)
                break
            end
        end
    end
    oShield[refoSupportTarget] = nil
end

function AddShieldAssignment(oUnitToSupport, oClosestShield, tOurBase)
    --Assignes closest shield to support oUnitToSupport and gets it to move there, by reference to our base
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddShieldAssignment'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if M27UnitInfo.IsUnitValid(oUnitToSupport) then --Redundancy
        --Are we already assigned a support target that is different? If so then remove cur assignment
        if oClosestShield[refoSupportTarget] then
            if not(oClosestShield[refoSupportTarget] == oUnitToSupport) then
                RemoveShieldAssignment(oClosestShield)
            end
        end
        oClosestShield[refoSupportTarget] = oUnitToSupport
        if not(oUnitToSupport[reftoAssignedShields]) then oUnitToSupport[reftoAssignedShields] = {} end
        table.insert(oUnitToSupport[reftoAssignedShields], oClosestShield)

        --Move the shield so it covers the unit if it doesnt already
        local iShieldRadius = oClosestShield:GetBlueprint().Defense.Shield.ShieldSize * 0.39 --e.g. shield boat shield doesnt actually cover 50% but is much shorter
        local iTargetSpeed = oUnitToSupport:GetBlueprint().Physics.MaxSpeed
        --local iDistToTarget = M27Utilities.GetDistanceBetweenPositions(oClosestShield:GetPosition(), oUnitToSupport:GetPosition())
        local iDistFromTarget = math.max(2, iShieldRadius - iTargetSpeed * 1.5)
        if iDistFromTarget <= 2 then iDistFromTarget = -2 end

        --if iDistFromTarget > 2 then
            local tMoveTarget = M27Utilities.MoveInDirection(oUnitToSupport:GetPosition(), M27Utilities.GetAngleFromAToB(oUnitToSupport:GetPosition(), tOurBase), iDistFromTarget, true, false)
            MoveUnitTowardsTarget(oClosestShield, tMoveTarget, false, 'S:'..oUnitToSupport.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToSupport))
            if bDebugMessages == true then LOG(sFunctionRef..': oClosestShield='..oClosestShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestShield)..'; oUnitToSupport='..oUnitToSupport.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToSupport)..'; Our position='..repru(oClosestShield:GetPosition())..'; Unit to support posiiton='..repru(oUnitToSupport:GetPosition())..'; Distance to position='..M27Utilities.GetDistanceBetweenPositions(oClosestShield:GetPosition(), oUnitToSupport:GetPosition())..'; iShieldRadius='..iShieldRadius..'; iTargetSpeed='..iTargetSpeed..'; iDistFromTarget='..iDistFromTarget..'; tMoveTarget='..repru(tMoveTarget)) end
        --else
            --Need to be so close to the target that probably want to be infront of it rather than behind - decided to leave as the lower speed means cant keep up

            --GuardTarget(oClosestShield, oUnitToSupport)
        --end
    else
        M27Utilities.ErrorHandler('Passed invalid unit to support for shield assignment')
    end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end



function ManageTeamNavy(aiBrain, iTeam, iPond)
    --Decides what to do with our naval units, as well as recording information such as the nearest enemy naval unit

    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageTeamNavy'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if GetGameTimeSeconds() >= 1800 and M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]) == false and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.BATTLESHIP, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])) == false then bDebugMessages = true end
    --if GetGameTimeSeconds() >= 720 then bDebugMessages = true end
    --if GetGameTimeSeconds() >= 840 and (aiBrain:GetArmyIndex() == 2 or aiBrain:GetArmyIndex() == 4) then bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for iTeam='..iTeam..'; Brain='..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()..'; GameTime='..GetGameTimeSeconds()) end



    local oClosestEnemyUnit
    local oClosestEnemyCombatUnit
    local oClosestSurfaceEnemy
    local oClosestEnemySurfaceCombat
    local oClosestSubmersibleEnemy
    local oClosestFriendlyUnitToEnemyBase

    local iFriendlyDistToEnemy
    local tOurBase

    local oPrimaryFactory = GetPrimaryNavalFactory(aiBrain, iPond)
    if oPrimaryFactory then tOurBase = oPrimaryFactory:GetPosition()
    else
        tOurBase = {M27Team.tTeamData[iTeam][M27Team.reftBackupBaseLocationByPond][iPond][1], M27Team.tTeamData[iTeam][M27Team.reftBackupBaseLocationByPond][iPond][2], M27Team.tTeamData[iTeam][M27Team.reftBackupBaseLocationByPond][iPond][3]}
    end

    local tEnemyBase = GetPrimaryEnemyPondBaseLocation(aiBrain, iPond)
    local iAngleToEnemy = M27Utilities.GetAngleFromAToB(tOurBase, tEnemyBase)


    if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]) == false then
        --remove up to 5 obsolete units each cycle
        local bRemoveUnits = true
        local iRemovedUnits = 0
        while bRemoveUnits do
            bRemoveUnits = false
            for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond] do
                if not(M27UnitInfo.IsUnitValid(oUnit)) then
                    bRemoveUnits = true
                    iRemovedUnits = iRemovedUnits + 1
                    table.remove(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond], iUnit)
                end
            end
            if iRemovedUnits >= 5 then break end
        end

        if iRemovedUnits == 0 or M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]) == false then

            local iClosestDistance = 100000
            local iCurDistToEnemyBase
            local tUnitsToConsider = EntityCategoryFilterDown(categories.MOBILE * categories.NAVAL * categories.DIRECTFIRE + categories.MOBILE * categories.NAVAL * categories.INDIRECTFIRE + categories.MOBILE * categories.NAVAL * categories.ANTINAVY, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
            if M27Utilities.IsTableEmpty(tUnitsToConsider) then tUnitsToConsider = M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond] end
            for iUnit, oUnit in tUnitsToConsider do
                iCurDistToEnemyBase = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)
                if iCurDistToEnemyBase < iClosestDistance then
                    oClosestFriendlyUnitToEnemyBase = oUnit
                    iClosestDistance = iCurDistToEnemyBase
                end
            end
            iFriendlyDistToEnemy = iClosestDistance
        end
        M27Team.tTeamData[iTeam][M27Team.refiFriendlyNavalThreatByPond][iPond] = M27Logic.GetCombatThreatRating(aiBrain, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond], false, nil, nil, false, false, false, false, true, false, false)
    else
        M27Team.tTeamData[iTeam][M27Team.refiFriendlyNavalThreatByPond][iPond] = 0
    end
    M27Team.tTeamData[iTeam][M27Team.refoClosestFriendlyUnitToEnemyByPond][iPond] = oClosestFriendlyUnitToEnemyBase
    if bDebugMessages == true then LOG(sFunctionRef..': About to update list of enemy units in pond nad calculate closest enemy unit. Is the table empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]))) end

    if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]) == false then
        --remove up to 5 obsolete units each cycle
        local bRemoveUnits = true
        local iRemovedUnits = 0
        while bRemoveUnits do
            bRemoveUnits = false
            for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                if not(M27UnitInfo.IsUnitValid(oUnit)) then
                    bRemoveUnits = true
                    iRemovedUnits = iRemovedUnits + 1
                    table.remove(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond], iUnit)
                end
            end
            if iRemovedUnits >= 20 then break end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iRemovedUnits='..iRemovedUnits..'; Is table empty now='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]))..'; tOurBase='..repru(tOurBase)..'; Dist to aiBrain '..aiBrain.Nickname..' land base start pos='..M27Utilities.GetDistanceBetweenPositions(tOurBase, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])..'; ai Brain start position='..repru(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])) end
        if iRemovedUnits == 0 or M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Time since last updated positions of enemy units in pond='..(GetGameTimeSeconds() - (M27Team.tTeamData[iTeam][M27Team.refiTimeOfLastNavalUnitCheckByPond] or 0))) end
            if iRemovedUnits < 20 and GetGameTimeSeconds() - (M27Team.tTeamData[iTeam][M27Team.refiTimeOfLastNavalUnitCheckByPond] or 0) >= 1 then --Refresh unit locations, but dont do the refresh if we removed >=20 units since we may still have invalid units here
                if bDebugMessages == true then LOG(sFunctionRef..': WIll update each unit position in the pond') end
                M27Team.tTeamData[iTeam][M27Team.refiTimeOfLastNavalUnitCheckByPond] = GetGameTimeSeconds()
                for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                    if M27Utilities.CanSeeUnit(aiBrain, oUnit, true) then
                        UpdateUnitPond(oUnit, iTeam, true)
                    end
                end
            end
            if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]) == false then

                --Get closest enemy unit, and also update units last known position
                local iClosestDistance = 100000
                local iClosestSurfaceDistance = 100000
                local iClosestEnemyCombatDistance = 100000
                local iClosestSubmersibleDistance = 100000
                local iCurDistToOurBase
                local tUnitPosition
                local bIsUnitUnderwater
                for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                    iCurDistToOurBase = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)
                    if iCurDistToOurBase < iClosestDistance then
                        oClosestEnemyUnit = oUnit
                        iClosestDistance = iCurDistToOurBase
                    end
                    --Below is redundancy as shouldve already updated this when checking if the unit was added to the pond
                    if not(oUnit[M27UnitInfo.reftLastKnownPosition]) then --or M27Utilities.CanSeeUnit(aiBrain, oUnit, true) then
                        tUnitPosition = oUnit:GetPosition()
                        oUnit[M27UnitInfo.reftLastKnownPosition] = {tUnitPosition[1], tUnitPosition[2], tUnitPosition[3]}
                    end
                    oUnit[refbTempIsUnderwater] = M27UnitInfo.IsUnitUnderwater(oUnit)

                    if not(oUnit[refbTempIsUnderwater]) then
                        if iCurDistToOurBase < iClosestSurfaceDistance then
                            iClosestSurfaceDistance = iCurDistToOurBase
                            oClosestSurfaceEnemy = oUnit
                            if EntityCategoryContains(categories.DIRECTFIRE + categories.INDIRECTFIRE + categories.ANTINAVY, oUnit.UnitId) then oClosestEnemySurfaceCombat = oUnit end
                        end
                    else
                        if iCurDistToOurBase < iClosestSubmersibleDistance then
                            iClosestSubmersibleDistance = iCurDistToOurBase
                            oClosestSubmersibleEnemy = oUnit
                        end
                    end

                    if iCurDistToOurBase < iClosestEnemyCombatDistance then
                        if math.max(M27UnitInfo.GetNavalDirectAndSubRange(oUnit), oUnit[M27UnitInfo.refiIndirectRange]) > 0 then
                            iClosestEnemyCombatDistance = iCurDistToOurBase
                            oClosestEnemyCombatUnit = oUnit
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Finished calculating nearest enemy unit='..oClosestEnemyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; iClosestDistance='..iClosestDistance..'; Position of closest enemy unit='..repru(oClosestEnemyUnit:GetPosition())) end
            end
        end
    end
    M27Team.tTeamData[iTeam][M27Team.refoClosestEnemyNavalUnitByPond][iPond] = oClosestEnemyUnit --sets to nil if have none
    if oClosestEnemyUnit then
        M27Team.tTeamData[iTeam][M27Team.refiEnemyNavalThreatByPond][iPond] = M27Logic.GetCombatThreatRating(aiBrain, M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond], false, nil, nil, false, false, false, false, true, false, false)
    else
        M27Team.tTeamData[iTeam][M27Team.refiEnemyNavalThreatByPond][iPond] = 0
    end


    local iOurBestDFRange = 0
    local iOurBestIndirectRange = 0
    local bConsiderBombardment = false
    local bHaveAlreadyUpdatedRanges = false


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, GameTime='..GetGameTimeSeconds()..'; is table of friendly units for pond '..iPond..' empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]))..'; Is table of enemy units empty='..tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond]))..'; Do we have a valid enemy closest unit='..tostring(M27UnitInfo.IsUnitValid(oClosestEnemyUnit))..'; Do we have a valid friendly unit='..tostring(M27UnitInfo.IsUnitValid(oClosestFriendlyUnitToEnemyBase))) end
    local iSupportNavyCategory = M27UnitInfo.refCategorySupportNavy - categories.DIRECTFIRE - categories.INDIRECTFIRE - categories.ANTINAVY --e.g. aircraft carriers without any attack and shield boats


    local bAllOutSubAttack = false
    if M27UnitInfo.IsUnitValid(oClosestEnemyUnit) and M27UnitInfo.IsUnitValid(oClosestFriendlyUnitToEnemyBase) then
        --Record friendly and enemy units of relevance, then decide what action we want to take at a global level

        local tNavalThreatByTypeAndRange = {} --[x] is unit type, [y] is range, then [z] is subref for surface, antinaval, split by friendly and enemy
        --Unit type
        local refiTypeAll = 1
        local refiTypeMobileNavy = 2
        local refiTypeSubmersible = 3
        --Threat type
        local refiFriendlyThreatSurface = 1 --if changing these then udpate code as well as have hardcoded some of these references
        local refiFriendlyThreatAntiNavy = 2
        local refiEnemyThreatSurface = 3
        local refiEnemyThreatAntiNavy = 4

        local tiRangesUsed = {} --all ranges used by us or enemy




        function GetUnitTypes(oUnit)
            if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then
                return {refiTypeAll, refiTypeMobileNavy, refiTypeSubmersible}
            elseif EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                return {refiTypeAll, refiTypeMobileNavy}
            else
                return {refiTypeAll}
            end
        end

        local bUseIndirectRangeIfHigher = false --If nearest enemy is a torpedo launcher then this will be true
        if EntityCategoryContains(categories.STRUCTURE - categories.SUBMERSIBLE, oClosestEnemyUnit.UnitId) or (oClosestEnemyCombatUnit and EntityCategoryContains(categories.STRUCTURE - categories.SUBMERSIBLE, oClosestEnemyCombatUnit.UnitId)) then bUseIndirectRangeIfHigher = true end
        if bDebugMessages == true then
            LOG(sFunctionRef..': bUseIndirectRangeIfHigher after checking if nearest enemy unit or nearest enemy combat unit is a non-submersible structure='..tostring(bUseIndirectRangeIfHigher or false)..'; oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; is closets enemy combat unit valid='..tostring(M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit)))
            if M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit) then
                LOG(sFunctionRef..': oClosestEnemyCombatUnit='..oClosestEnemyCombatUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyCombatUnit))
            end
        end

        function RecordUnitInNavalThreatTable(oUnit, bIsEnemy)

            local tiCurUnitTypes = GetUnitTypes(oUnit)
            local iThreatRefMod = 0
            if bIsEnemy then iThreatRefMod = 2 end
            local bInclude
            local iCurUnitRange = 0
            local iCurThreat = 0

            if bDebugMessages == true then LOG(sFunctionRef..': About to record threat by range for oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; refiTypeAll='..refiTypeAll..'; tiCurUnitTypes='..repru(tiCurUnitTypes)) end

            for _, iUnitType in tiCurUnitTypes do --want to record both for typeall, and for the curunittype where curunittype is dif to typeall
                if not(tNavalThreatByTypeAndRange[iUnitType]) then tNavalThreatByTypeAndRange[iUnitType] = {} end
                bInclude = false
                --Do we have the right unit type?
                if iUnitType == refiTypeAll then
                    bInclude = true
                elseif iUnitType == refiTypeMobileNavy then
                    if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                        bInclude = true
                    end
                else
                    if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then
                        bInclude = true
                    end
                end
                if bInclude then
                    for iThreatTypeRef = 1 + iThreatRefMod, 2 + iThreatRefMod, 1 do
                        if not(oUnit[M27UnitInfo.refiDFRange]) then iCurUnitRange = (GetNavalDirectAndSubRange(oUnit) or 0) end --Redundancy, hopefully have already calculated range before
                        if iThreatTypeRef == refiFriendlyThreatSurface or iThreatTypeRef == refiEnemyThreatSurface then

                            if bUseIndirectRangeIfHigher and iThreatTypeRef == refiFriendlyThreatSurface then
                                iCurUnitRange = math.max(oUnit[M27UnitInfo.refiDFRange], oUnit[M27UnitInfo.refiAntiNavyRange], oUnit[M27UnitInfo.refiIndirectRange])
                            else
                                iCurUnitRange = math.max(oUnit[M27UnitInfo.refiDFRange], oUnit[M27UnitInfo.refiAntiNavyRange])
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitRange='..iCurUnitRange..'; Combat threat rating='..M27Logic.GetCombatThreatRating(aiBrain, { oUnit}, false, nil, nil, false, false, false, false, true, false, false)) end
                            if iCurUnitRange > 0 then
                                --GetCombatThreatRating(aiBrain, tUnits, bMustBeVisibleToIntelOrSight, iMassValueOfBlipsOverride, iSoloBlipMassOverride, bIndirectFireThreatOnly, bJustGetMassValue, bBlueprintThreat, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly)
                                iCurThreat = M27Logic.GetCombatThreatRating(aiBrain, { oUnit}, false, nil, nil, false, false, false, false, true, false, false)
                            end

                        else
                            --Only want antinavy
                            iCurUnitRange = oUnit[M27UnitInfo.refiAntiNavyRange]
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurUnitRange after checking only antinavy='..iCurUnitRange) end
                            if iCurUnitRange > 0 then
                                iCurThreat = M27Logic.GetCombatThreatRating(aiBrain, { oUnit }, false, nil, nil, false, false, false, true, false, false, false)
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': iThreatTypeRef='..iThreatTypeRef..'; iThreatRefMod='..iThreatRefMod..'; iUnitType='..iUnitType..'; iCurThreat='..iCurThreat..'; iCurUnitRange='..iCurUnitRange) end

                        tiRangesUsed[iCurUnitRange] = iCurUnitRange
                        if not(tNavalThreatByTypeAndRange[iUnitType][iCurUnitRange]) then tNavalThreatByTypeAndRange[iUnitType][iCurUnitRange] = {} end

                        tNavalThreatByTypeAndRange[iUnitType][iCurUnitRange][iThreatTypeRef] = (tNavalThreatByTypeAndRange[iUnitType][iCurUnitRange][iThreatTypeRef] or 0) + iCurThreat

                    end
                end
            end
        end


        local tFriendliesNearFront = {}
        local tFriendlyNearbyReinforcements = {}
        local tFriendlyFurtherAwayReinforcements = {}
        local tEnemiesBetweenUsAndBase = {}
        local tEnemiesNearClosestEnemyUnit = {}
        local iFriendlySearchRangeBase = 30
        local iNavyInPond = 0
        local tNavyInPond = EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer,  M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
        if M27Utilities.IsTableEmpty(tNavyInPond) == false then
            iNavyInPond = table.getn(tNavyInPond)
        end


        if iNavyInPond >= 10 then iFriendlySearchRangeBase = iFriendlySearchRangeBase + math.min(25, iNavyInPond) end
        local iNearbyReinforcementSearchBase = iFriendlySearchRangeBase + 50
        local iEnemySearchRangeBase = 60
        local iEnemySearchRangeShort = 30
        local iCurDist
        local iCurRange
        local iOurBestSurfaceRange = 0
        local iOurBestSubmersibleRange = 0
        local iOurBestSurfaceAntiNavyRange = 0
        --Already have iOurBestIndirectRange defined earlier, along with our best DF range
        local iEnemyBestSurfaceRange = 0
        local iEnemyBestAntiNavyRange = 0
        local iEnemyBestSubmersibleRange = 0
        local iEnemyBestIndirectRange = 0
        --Get friendly units
        if bDebugMessages == true then LOG(sFunctionRef..': About to identify all units that are close to '..oClosestFriendlyUnitToEnemyBase.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestFriendlyUnitToEnemyBase)) end
        bHaveAlreadyUpdatedRanges = true
        for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond] do
            if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and oUnit:GetFractionComplete() >= 1 then
                iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())
                iCurRange = M27UnitInfo.GetNavalDirectAndSubRange(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': Distance between friendly unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to front unit='..iCurDist..'; Range='..iCurRange) end
                if iCurDist - iCurRange <= iNearbyReinforcementSearchBase then
                    if iCurDist - iCurRange <= iFriendlySearchRangeBase then
                        table.insert(tFriendliesNearFront, oUnit)
                        RecordUnitInNavalThreatTable(oUnit, false)
                    else
                        table.insert(tFriendlyNearbyReinforcements, oUnit)
                    end
                    iOurBestSurfaceRange = math.max(iOurBestSurfaceRange, iCurRange)
                    if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then
                        iOurBestSubmersibleRange = math.max(iOurBestSubmersibleRange, oUnit[M27UnitInfo.refiAntiNavyRange])
                    else
                        iOurBestSurfaceAntiNavyRange = math.max(iOurBestSurfaceAntiNavyRange, oUnit[M27UnitInfo.refiAntiNavyRange])
                    end
                else
                    table.insert(tFriendlyFurtherAwayReinforcements, oUnit)
                end
                iOurBestIndirectRange = math.max(iOurBestIndirectRange, oUnit[M27UnitInfo.refiIndirectRange])
                iOurBestDFRange = math.max(iOurBestDFRange, oUnit[M27UnitInfo.refiDFRange])


            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Is table of nearby friendly reinforcements empty=' .. tostring(M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements)) .. '; Is table of friendlies near front empty=' .. tostring(M27Utilities.IsTableEmpty(tFriendliesNearFront)) .. ' tEnemyBase=' .. repru(tEnemyBase))
        end

        if M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements) == false or M27Utilities.IsTableEmpty(tFriendliesNearFront) == false or M27Utilities.IsTableEmpty(tFriendlyFurtherAwayReinforcements) == false then
            local iDistToBase
            if bDebugMessages == true then LOG(sFunctionRef..': About to record details of enemy units of relevance; will either consider those naval units if we are attacking base, or those around hte nearest enemy combat unit if we are attacking nearest enemy unit') end


            for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond] do
                iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())
                iDistToBase = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)
                iCurRange = M27UnitInfo.GetNavalDirectAndSubRange(oUnit)
                if iCurDist - iCurRange - iEnemySearchRangeBase <= iFriendlyDistToEnemy or iDistToBase - iCurRange - iEnemySearchRangeShort <= iFriendlyDistToEnemy then
                    table.insert(tEnemiesBetweenUsAndBase, oUnit)
                    iEnemyBestSurfaceRange = math.max(iEnemyBestSurfaceRange, iCurRange)
                    iEnemyBestAntiNavyRange = math.max(iEnemyBestAntiNavyRange, oUnit[M27UnitInfo.refiAntiNavyRange])
                    if EntityCategoryContains(M27UnitInfo.refCategorySubmarine, oUnit.UnitId) then
                        iEnemyBestSubmersibleRange = math.max(iEnemyBestSubmersibleRange, oUnit[M27UnitInfo.refiAntiNavyRange])
                    end
                    iEnemyBestIndirectRange = math.max(iEnemyBestIndirectRange, oUnit[M27UnitInfo.refiIndirectRange])
                end
                --Is the enemy near the closet enemy unit
                if oClosestEnemyCombatUnit and M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestEnemyCombatUnit:GetPosition()) + iCurRange <= iEnemySearchRangeBase then
                    table.insert(tEnemiesNearClosestEnemyUnit, oUnit)
                    RecordUnitInNavalThreatTable(oUnit, true)
                end

            end

            --Can we win with an all out attack?
            local iOurSurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendliesNearFront, false, nil, nil, false, false, false, false, true, false, false)
            local iOurAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendliesNearFront, false, nil, nil, false, false, false, true, false, false, false)
            local iEnemySurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesBetweenUsAndBase, false, nil, nil, false, false, false, false, true, false, false)
            local tEnemyTorpedoLauncherThreats = EntityCategoryFilterDown(M27UnitInfo.refCategoryTorpedoLauncher, tEnemiesBetweenUsAndBase)

            local iEnemySurfaceTorpedoDefenceThreat = 0
            local iEnemyTorpedoMaxRange = 0
            if M27Utilities.IsTableEmpty(tEnemyTorpedoLauncherThreats) == false then
                iEnemySurfaceTorpedoDefenceThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemyTorpedoLauncherThreats, false, nil, nil, false, false, false, false, true, false, false)
                for iUnit, oUnit in tEnemyTorpedoLauncherThreats do
                    iEnemyTorpedoMaxRange = math.max(iEnemyTorpedoMaxRange, M27UnitInfo.GetNavalDirectAndSubRange(oUnit))
                end

                if iEnemyTorpedoMaxRange < math.max(iOurBestIndirectRange, iOurBestSurfaceRange, iOurBestSubmersibleRange) then
                    if bDebugMessages == true then LOG(sFunctionRef..': We have units that outrange enemy torpedo threat so will ignore it for deciding if we can launch an all out attack. iEnemySurfaceTorpedoDefenceThreat='..iEnemySurfaceTorpedoDefenceThreat) end
                    iEnemySurfaceThreat = iEnemySurfaceThreat - iEnemySurfaceTorpedoDefenceThreat
                end
            end




            local iEnemySubmersibleThreat = 0
            if iEnemyBestAntiNavyRange > 0 then
                iEnemySubmersibleThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesBetweenUsAndBase, false, nil, nil, false, false, false, false, false, true, false)
            end

            --Do we win in both theatres, and have significanlty more threat?
            local bAllOutAttack = false
            --bAllOutSubAttack = false --Recorded above; Set to true if we arent doing an all out at tack, but think our subs can still do an all out attack
            local bAttackNearbyEnemies = false --If dont have enough to beat every naval unit between us and enemy base, but do have enough to take on the nearest enemies, then will use this
            local bIgnoreEnemySubs = false
            local bConsolidateForces = false --used to determine unit task description for now (to help with debugging)

            local iMinSurfaceFactorWanted = 1.15 + math.max(-0.1, 0.01 * (iFriendlyDistToEnemy - iOurBestSurfaceRange - 25))
            if iMinSurfaceFactorWanted > 1.3 then
                local iFactorCap = 3 - math.min(1.7, iOurSurfaceThreat / 1000)
                iMinSurfaceFactorWanted = math.min(iMinSurfaceFactorWanted, iFactorCap)
            end

            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering if we want an all out attack. iMinSurfaceFactorWanted=' .. iMinSurfaceFactorWanted .. '; iOurSurfaceThreat=' .. iOurSurfaceThreat .. '; iEnemySurfaceThreat=' .. iEnemySurfaceThreat .. '; iEnemySurfaceThreat*factor=' .. iEnemySurfaceThreat * iMinSurfaceFactorWanted..'; Size of tFriendliesNearFront='..table.getn(tFriendliesNearFront))
                if iOurAntiNavyThreat > 0 then
                    LOG(sFunctionRef..': Will list out every unit with antinavy threat')
                    local iCurAntiNavy
                    for iUnit, oUnit in tFriendliesNearFront do
                        iCurAntiNavy = M27Logic.GetCombatThreatRating(aiBrain, { oUnit}, false, nil, nil, false, false, false, true, false, false, false)
                        if iCurAntiNavy > 0 then
                            LOG(sFunctionRef..': Unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' with fraction complete '..oUnit:GetFractionComplete()..' has antinavy threat of '..iCurAntiNavy)
                        end
                    end
                end
            end
            if iOurSurfaceThreat > iEnemySurfaceThreat * iMinSurfaceFactorWanted then
                --Do we have enough antinavy?
                if iEnemySubmersibleThreat == 0 or iOurAntiNavyThreat > iEnemySubmersibleThreat then
                    bAllOutAttack = true
                else
                    --Can we ignore antinavy and take out the naval fac?
                    if iOurSurfaceThreat > iEnemySurfaceThreat * 2 then
                        if (iFriendlyDistToEnemy <= 200 and iEnemySubmersibleThreat < 0.1 * iOurSurfaceThreat) or iEnemySubmersibleThreat < 0.05 * iOurSurfaceThreat then
                            bIgnoreEnemySubs = true
                            bAllOutAttack = true
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Still consider all out attack if enemy has surface unit close to our base. bAllOutAttack='..tostring(bAllOutAttack)..'; Is oClosestSurfaceEnemy valid='..tostring(M27UnitInfo.IsUnitValid(oClosestSurfaceEnemy))) end
            if not(bAllOutAttack) and oClosestSurfaceEnemy then
                --Still do all out attack if enemy has surface unit close to being in range of us
                if bDebugMessages == true then LOG(sFunctionRef..': oClosestSurfaceEnemy='..oClosestSurfaceEnemy.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestSurfaceEnemy)..'; Dist to our base='..M27Utilities.GetDistanceBetweenPositions(oClosestSurfaceEnemy:GetPosition(), tOurBase)..'; iEnemyBestSurfaceRange='..iEnemyBestSurfaceRange..'; iEnemyBestIndirectRange='..iEnemyBestIndirectRange) end
                if M27Utilities.GetDistanceBetweenPositions(oClosestSurfaceEnemy:GetPosition(), tOurBase) <= 40 +  math.max(iEnemyBestSurfaceRange, iEnemyBestIndirectRange) then
                    bAllOutAttack = true
                    bAttackNearbyEnemies = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Will attack nearby enemies') end
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef .. ': iOurSurfaceThreat=' .. iOurSurfaceThreat .. '; iEnemySUrfaceThreat=' .. iEnemySurfaceThreat .. '; iOurAntiNavyThreat=' .. iOurAntiNavyThreat .. '; iEnemySubmersibleThreat=' .. iEnemySubmersibleThreat .. '; bAllOutAttack=' .. tostring(bAllOutAttack) .. '; WIll list out every unit in our main naval force and their threat value')
                if M27Utilities.IsTableEmpty(tFriendliesNearFront) == false then
                    for iUnit, oUnit in M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond] do
                        if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and M27UnitInfo.IsUnitValid(oUnit) then
                            LOG(sFunctionRef .. ': Unit ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. '; Surface threat=' .. M27Logic.GetCombatThreatRating(aiBrain, { oUnit }, false, nil, nil, false, false, false, false, true, false, false))
                        end
                    end
                end
                LOG(sFunctionRef..': tNavalThreatByTypeAndRange repr='..repru(tNavalThreatByTypeAndRange))
            end
            local iOurSubmersibleThreat = 0
            if not (bAllOutAttack) then
                --Do we still want to attack with subs?
                iOurSubmersibleThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendliesNearFront, false, nil, nil, false, false, false, false, false, true, false)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want an all out sub attack. iOurSubmersibleThreat='..iOurSubmersibleThreat..'; iEnemySubmersibleThreat='..iEnemySubmersibleThreat) end
                if iOurSubmersibleThreat > iEnemySubmersibleThreat * 1.5 then
                    local iEnemyAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesBetweenUsAndBase, false, nil, nil, false, false, false, true, false, false, false)
                    if bDebugMessages == true then LOG(sFunctionRef..': Have stronger subs than enemy; checking their antinavy. now. iEnemyAntiNavyThreat='..iEnemyAntiNavyThreat) end
                    if iOurSubmersibleThreat > iEnemyAntiNavyThreat * 1.5 then
                        bAllOutSubAttack = true
                    end
                end
            end
            --If dont have enough for all out attack, consider attacking nearest enemy unit if we can attack it without leaving our naval yard vulnerable
            if not(bAllOutSubAttack) and not(bAllOutAttack) and oClosestEnemyCombatUnit then
                local iDistToClosestEnemyCombat =  M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition())
                local iDistToEnemyBase = M27Utilities.GetDistanceBetweenPositions(tEnemyBase, oClosestFriendlyUnitToEnemyBase:GetPosition())
                if iDistToClosestEnemyCombat <= iDistToEnemyBase * 0.4 then
                    local iDistToOurNavalBase = M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase)
                    if iDistToClosestEnemyCombat + iDistToOurNavalBase < iDistToEnemyBase and iDistToClosestEnemyCombat + M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit:GetPosition(), tOurBase) <= iDistToEnemyBase * 1.45 then

                        local iSurfaceThreatOfNearbyEnemies = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesNearClosestEnemyUnit, false, nil, nil, false, false, false, false, true, false, false)
                        local iAntiNavyThreatOfNearbyEnemies = M27Logic.GetCombatThreatRating(aiBrain, tEnemiesNearClosestEnemyUnit, false, nil, nil, false, false, false, true, false, false, false)

                        if iOurSurfaceThreat > iSurfaceThreatOfNearbyEnemies * iMinSurfaceFactorWanted then
                            bAllOutAttack = true
                            bAttackNearbyEnemies = true
                        elseif iOurSubmersibleThreat > iAntiNavyThreatOfNearbyEnemies then
                            bAllOutSubAttack = true
                            bAttackNearbyEnemies = true
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if we can take on nearest enemy unit with an all out attack. iSurfaceThreatOfNearbyEnemies='..iSurfaceThreatOfNearbyEnemies..'; iAntiNavyThreatOfNearbyEnemies='..iAntiNavyThreatOfNearbyEnemies..'; iOurSurfaceThreat='..iOurSurfaceThreat..'; iOurSubmersibleThreat='..iOurSubmersibleThreat..'; bAllOutAttack after considering='..tostring(bAllOutAttack)..'; bAllOutSubAttack='..tostring(bAllOutSubAttack)..'; bAttackNearbyEnemies='..tostring(bAttackNearbyEnemies)) end
                    end
                end
            end

            local tGlobalNavalDestination
            local tDestinationForShortRangeUnits --If doing an all out attack/all out sub attack, units whose range is below the min range for engagement should instead go to this destination

            local iRangeOfClosestFriendlyUnit
            local iEnemyUnitTypeRef
            local iOurUnitTypeRef
            local iEnemyThreatRef
            local iOurThreatRef

            if not(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange]) then M27UnitInfo.GetNavalDirectAndSubRange(oClosestFriendlyUnitToEnemyBase) end --redundancy

            if bAllOutSubAttack and EntityCategoryContains(categories.SUBMERSIBLE, oClosestFriendlyUnitToEnemyBase.UnitId) then
                iRangeOfClosestFriendlyUnit = oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange]
                iEnemyUnitTypeRef = refiTypeAll
                iOurUnitTypeRef = refiTypeSubmersible
                iEnemyThreatRef = refiEnemyThreatAntiNavy
                iOurThreatRef = refiFriendlyThreatAntiNavy

            elseif bAllOutAttack then
                if bUseIndirectRangeIfHigher then
                    iRangeOfClosestFriendlyUnit = math.max(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiDFRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiIndirectRange])
                else
                    iRangeOfClosestFriendlyUnit = math.max(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiDFRange])
                end

                iEnemyUnitTypeRef = refiTypeAll
                iOurUnitTypeRef = refiTypeMobileNavy
                iEnemyThreatRef = refiEnemyThreatSurface
                iOurThreatRef = refiFriendlyThreatSurface

            end
            local iMinRangeForEngagement = 0
            local iOurCumulativeThreat = 0
            local iEnemyCumulativeThreat = 0
            local tiOurRatioVsEnemyByRange = {}
            --local tiOurAbsoluteThreatExcessByRange = {}
            local iBestRangeRatio = 0
            local iBestRangeDistance
            if bDebugMessages == true then LOG(sFunctionRef..': If we are doing an all out attack want to check our minimum engagement range. iOurThreatRef='..(iOurThreatRef or 'nil')..'; iOurUnitTypeRef='..(iOurUnitTypeRef or 'nil')..'; iEnemyUnitTypeRef='..(iEnemyUnitTypeRef or 'nil')..'; iEnemyThreatRef='..(iEnemyThreatRef or 'nil')..'; bAllOutSubAttack='..tostring(bAllOutSubAttack)..'; bAllOutAttack='..tostring(bAllOutAttack)) end

            if iOurThreatRef then --Proxy for if have set something above
                --Calc min engagement range
                local iRatioCap = 100
                local iUseAbsoluteNotRatioThreshold = 10000
                local bUseAbsoluteDifference = false
                local iRatioCapForLowThreat = 1.3
                local iLowThreatThreshold = 1500 --If have below this, then will cap the ratio if in ratio mode
                --Dont want to use ratios below a certain threshold to avoid e.g. a cruiser trying to solo enemy frigates, but do want to engage at destroyer range if we have destroyers and enemy doesnt; since ceruisers have lower threat 1.5k should mean 1 cruiser is below threshold but 1 destroyer is above
                if iOurSurfaceThreat <= iUseAbsoluteNotRatioThreshold then
                    bUseAbsoluteDifference = true
                    iRatioCap = iUseAbsoluteNotRatioThreshold
                end
                for iEntry, iRange in M27Utilities.SortTableByValue(tiRangesUsed, true) do
                    if not(tNavalThreatByTypeAndRange[iOurUnitTypeRef]) then tNavalThreatByTypeAndRange[iOurUnitTypeRef] = {} end
                    if not(tNavalThreatByTypeAndRange[iOurUnitTypeRef][iRange]) then tNavalThreatByTypeAndRange[iOurUnitTypeRef][iRange] = {} end
                    if not(tNavalThreatByTypeAndRange[iEnemyUnitTypeRef]) then tNavalThreatByTypeAndRange[iEnemyUnitTypeRef] = {} end
                    if not(tNavalThreatByTypeAndRange[iEnemyUnitTypeRef][iRange]) then tNavalThreatByTypeAndRange[iEnemyUnitTypeRef][iRange] = {} end

                    iOurCumulativeThreat = iOurCumulativeThreat + (tNavalThreatByTypeAndRange[iOurUnitTypeRef][iRange][iOurThreatRef] or 0)
                    iEnemyCumulativeThreat = iEnemyCumulativeThreat +  (tNavalThreatByTypeAndRange[iEnemyUnitTypeRef][iRange][iEnemyThreatRef] or 0)
                    if bUseAbsoluteDifference then
                        tiOurRatioVsEnemyByRange[iRange] = math.min(iRatioCap, iOurCumulativeThreat - iEnemyCumulativeThreat)
                    else
                        if iOurCumulativeThreat == 0 then
                            tiOurRatioVsEnemyByRange[iRange] = 0
                        elseif iEnemyCumulativeThreat == 0 then
                            tiOurRatioVsEnemyByRange[iRange] = iRatioCap
                        else
                            if iOurCumulativeThreat <= iLowThreatThreshold then tiOurRatioVsEnemyByRange[iRange] = math.min(iRatioCapForLowThreat, iRatioCap, iOurCumulativeThreat / iEnemyCumulativeThreat)
                            else
                                tiOurRatioVsEnemyByRange[iRange] = math.min(iRatioCap, iOurCumulativeThreat / iEnemyCumulativeThreat)
                            end
                        end
                    end
                    --tiOurAbsoluteThreatExcessByRange[iRange] = iOurCumulativeThreat - iEnemyCumulativeThreat
                    if tiOurRatioVsEnemyByRange[iRange] >= iBestRangeRatio then
                        iBestRangeDistance = iRange
                        iBestRangeRatio = tiOurRatioVsEnemyByRange[iRange]
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iRange='..iRange..'; iOurCumulativeThreat='..iOurCumulativeThreat..'; iLowThreatThreshold='..iLowThreatThreshold..'; iRatioCap='..iRatioCap..'; iEnemyCumulativeThreat='..iEnemyCumulativeThreat..'; tiOurRatioVsEnemyByRange[iRange]='..tiOurRatioVsEnemyByRange[iRange]..'; iBestRangeRatio='..iBestRangeRatio..'; iBestRangeDistance='..iBestRangeDistance) end
                end

                iMinRangeForEngagement = math.min(110, (iBestRangeDistance or 0)) --Can engagement min range based on range of Aeon battleship, so all battleships should be able to engage
                if bDebugMessages == true then LOG(sFunctionRef..': Set min range for engagement to iBestRangeDistance='..iBestRangeDistance) end
            end

            --Reduce min range for engagement to 0 if enemy near our base
            if M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit) and M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit:GetPosition(), tOurBase) <= math.max(oClosestEnemyCombatUnit[M27UnitInfo.refiDFRange], oClosestEnemyCombatUnit[M27UnitInfo.refiIndirectRange], oClosestEnemyCombatUnit[M27UnitInfo.refiAntiNavyRange]) + 30 then
                iMinRangeForEngagement = 0
            end

            --Get the target enemy position:

            local tClosestEnemyTargetToUse
            if M27UnitInfo.IsUnitValid(oClosestSurfaceEnemy) and M27Utilities.CanSeeUnit(aiBrain, oClosestSurfaceEnemy) then UpdateUnitPond(oClosestSurfaceEnemy, iTeam, true) end  --Redundancy to update how far away it is in case delay with central logic
            if M27UnitInfo.IsUnitValid(oClosestEnemyUnit) and M27Utilities.CanSeeUnit(aiBrain, oClosestEnemyUnit) then
                UpdateUnitPond(oClosestEnemyUnit, iTeam, true)
                if bDebugMessages == true then LOG(sFunctionRef..': Have updated unit pond for closest enemy unit='..oClosestEnemyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; Distance between last known position and cur position (shoudl be 0)='..M27Utilities.GetDistanceBetweenPositions(oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition], oClosestEnemyUnit:GetPosition())) end
            end --Redundancy to update how far away it is in case delay in updating all units
            if M27UnitInfo.IsUnitValid(oClosestEnemyCombatUnit) and M27Utilities.CanSeeUnit(aiBrain, oClosestEnemyCombatUnit) then
                UpdateUnitPond(oClosestEnemyCombatUnit, iTeam, true)
                if bDebugMessages == true then LOG(sFunctionRef..': Have updated unit pond for closest enemy combat unit='..oClosestEnemyCombatUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyCombatUnit)..'; Dist to last known position (shoudl be 0)='..M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit:GetPosition(), oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition])) end
            end --Redundancy to update how far away it is in case delay in updating all units
            if bDebugMessages == true then LOG(sFunctionRef..': oClosestEnemyUnit='..oClosestEnemyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestEnemyUnit)..'; Last known position='..repru(oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition])..'; Is visible='..tostring(M27Utilities.CanSeeUnit(aiBrain, oClosestEnemyUnit, true))..'; Distance between cur position and last known position='..M27Utilities.GetDistanceBetweenPositions(oClosestEnemyUnit:GetPosition(), oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition])) end

            local bChargeEnemyBase = false --true if we decide to ignore closest enemies and just go for neemy base, e.g. if have far more threat


            if bAttackNearbyEnemies and not(bAllOutSubAttack) and oClosestEnemySurfaceCombat and (M27Utilities.CanSeeUnit(aiBrain, oClosestEnemySurfaceCombat)  or M27Utilities.GetDistanceBetweenPositions(oClosestEnemySurfaceCombat[M27UnitInfo.reftLastKnownPosition], oClosestEnemySurfaceCombat:GetPosition()) <= 50) then tClosestEnemyTargetToUse = oClosestEnemySurfaceCombat[M27UnitInfo.reftLastKnownPosition]
            elseif bAttackNearbyEnemies and bAllOutSubAttack and oClosestEnemyCombatUnit and (M27Utilities.CanSeeUnit(aiBrain, oClosestEnemyUnit)  or M27Utilities.GetDistanceBetweenPositions(oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition], oClosestEnemyCombatUnit:GetPosition()) <= 50) then tClosestEnemyTargetToUse = oClosestEnemyCombatUnit[M27UnitInfo.reftLastKnownPosition]
            else
                --If we massively outnumber enemy naval threat then just go for the enemy naval factories
                if bDebugMessages == true then LOG(sFunctionRef..': If massively outnumber enemy in navy and likely have battleships then target enemy naval factory. iOurSurfaceThreat='..iOurSurfaceThreat..'; iEnemySurfaceThreat='..iEnemySurfaceThreat) end
                if iOurSurfaceThreat > iEnemySurfaceThreat * 3.5 and iOurSurfaceThreat >= 30000 then
                    local tEnemyFactories = EntityCategoryFilterDown(M27UnitInfo.refCategoryNavalFactory, M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond])
                    if M27Utilities.IsTableEmpty(tEnemyFactories) == false then
                        bChargeEnemyBase = true
                        tClosestEnemyTargetToUse = M27Utilities.GetNearestUnit(tEnemyFactories, tOurBase):GetPosition()
                        if bDebugMessages == true then LOG(sFunctionRef..': Will target closest enemy unit='..M27Utilities.GetNearestUnit(tEnemyFactories, tOurBase).UnitId..M27UnitInfo.GetUnitLifetimeCount(M27Utilities.GetNearestUnit(tEnemyFactories, tOurBase))) end
                    end
                end
                if M27Utilities.IsTableEmpty(tClosestEnemyTargetToUse) then
                    if M27Utilities.GetDistanceBetweenPositions(oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition], oClosestEnemyUnit:GetPosition()) > 50 then
                        local tVisibleEnemiesAroundFrontUnit = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategorySurfaceAmphibiousCombat, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.max(iEnemyBestSurfaceRange, iEnemyBestAntiNavyRange, 70) + 20)
                        if M27Utilities.IsTableEmpty(tVisibleEnemiesAroundFrontUnit) then
                            --No nearby visible neemies, target enemy base
                            tClosestEnemyTargetToUse = { tEnemyBase[1], tEnemyBase[2], tEnemyBase[3] }
                            if bDebugMessages == true then LOG(sFunctionRef..': No visible enemies, will target enemy base instead of closest enemy for tClosestEnemyTargetToUse') end
                        else
                            --Get closest visible enemy
                            tClosestEnemyTargetToUse = M27Utilities.GetNearestUnit(tVisibleEnemiesAroundFrontUnit, oClosestFriendlyUnitToEnemyBase:GetPosition()):GetPosition()
                            if bDebugMessages == true then LOG(sFunctionRef..': Have visible enemies so setting tClosestEnemyTargetToUse to this') end
                        end
                    else
                        tClosestEnemyTargetToUse = { oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition][1], oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition][2], oClosestEnemyUnit[M27UnitInfo.reftLastKnownPosition][3] }
                        if bDebugMessages == true then LOG(sFunctionRef..': Setting closest enemy target to its last known position') end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Do we have a min engagement range of more than 0? iMinRangeForEngagement='..(iMinRangeForEngagement or 'nil')..'; tClosestEnemyTargetToUse='..repru(tClosestEnemyTargetToUse)..'; Dist between here and tenemybase='..M27Utilities.GetDistanceBetweenPositions(tEnemyBase, tClosestEnemyTargetToUse)..'; iMinRangeForEngagement='..(iMinRangeForEngagement or 'nil')..'; is table of enemy units near front empty='..tostring(M27Utilities.IsTableEmpty(tFriendliesNearFront))) end


            --If we only want to do an all out attack for certain ranged units, then work out where units with a shorter range should go, or if they should do an all out attack as well due ot the enemy being close to our long range unit

            if iMinRangeForEngagement > 0 and M27Utilities.IsTableEmpty(tFriendliesNearFront) == false then
                local iDistanceBehindFrontUnitWanted = 12
                local oNearestFriendlyWithSufficientRange
                local iCurDistToEnemy
                local iClosestDistToEnemy = 10000
                local iCurRange
                for iUnit, oUnit in tFriendliesNearFront do
                    if bAllOutSubAttack then
                        if EntityCategoryContains(categories.SUBMERSIBLE, oUnit.UnitId) then iCurRange = oUnit[M27UnitInfo.refiAntiNavyRange] end
                    elseif bUseIndirectRangeIfHigher then --general all out attack that can include indirect range as nearest unit is structure
                        iCurRange = math.max(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiDFRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiIndirectRange])
                    else --general all out attack
                        iCurRange = math.max(oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiAntiNavyRange], oClosestFriendlyUnitToEnemyBase[M27UnitInfo.refiDFRange])
                    end
                    if iCurRange >= iMinRangeForEngagement then
                        iCurDistToEnemy = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tClosestEnemyTargetToUse)
                        if iCurDistToEnemy < iClosestDistToEnemy then
                            oNearestFriendlyWithSufficientRange = oUnit
                        end
                    end
                end
                if not(oNearestFriendlyWithSufficientRange) and iRangeOfClosestFriendlyUnit < iMinRangeForEngagement then
                    --Backup for rare cases where no unit with enough range
                    iDistanceBehindFrontUnitWanted = 30
                    tDestinationForShortRangeUnits = M27Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase), iDistanceBehindFrontUnitWanted, true, false)
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a nearest friendly unit with sufficient range, so will set the destination for short range units equal to the position of the nearest unit to enemy base') end
                else
                    --Is the enemy front unit almost within range?
                    local iEnemyRange
                    if bAllOutSubAttack then iEnemyRange = oClosestEnemyUnit[M27UnitInfo.refiAntiNavyRange]
                    else
                        iEnemyRange = math.max(oClosestEnemyUnit[M27UnitInfo.refiAntiNavyRange], oClosestEnemyUnit[M27UnitInfo.refiDFRange])
                    end
                    if M27Utilities.GetDistanceBetweenPositions(oNearestFriendlyWithSufficientRange:GetPosition(), tClosestEnemyTargetToUse) + iEnemyRange + iDistanceBehindFrontUnitWanted - 4 > iMinRangeForEngagement then
                        iMinRangeForEngagement = 0 --Dont want a minimum range as enemy almost in range
                        iDistanceBehindFrontUnitWanted = 30
                        if bDebugMessages == true then LOG(sFunctionRef..': Dont want a minimum range as enemy almost in range so will set short range unit destination equal to 30 behind the front unit') end
                    end
                    tDestinationForShortRangeUnits = M27Utilities.MoveInDirection(oNearestFriendlyWithSufficientRange:GetPosition(), M27Utilities.GetAngleFromAToB(oNearestFriendlyWithSufficientRange:GetPosition(), tOurBase), iDistanceBehindFrontUnitWanted, true, false)

                end
            else
                --Placehodler - dont expect to use this
                tDestinationForShortRangeUnits = M27Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase), 30, true, false)
                if bDebugMessages == true then LOG(sFunctionRef..': Not doing all out attack, will just record tDestinationForShortRangeUnits as being the closest friendly unit to enemy so dont have nil value') end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished determining tDestinationForShortRangeUnits='..repru(tDestinationForShortRangeUnits)) end

            if bAllOutAttack then
                local oNearestThreatToConsider
                local bAttackNearestThreatInstead = false

                --Do we want to attack the enemy base or the enemy naval unit?
                if bIgnoreEnemySubs and EntityCategoryContains(categories.SUBMERSIBLE, oClosestEnemyUnit.UnitId) then
                    --Get closest non-submersible threat
                    oNearestThreatToConsider = oClosestSurfaceEnemy
                else
                    oNearestThreatToConsider = oClosestEnemyUnit
                end
                if oNearestThreatToConsider then
                    if M27Utilities.GetDistanceBetweenPositions(oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition], tOurBase) + M27UnitInfo.GetNavalDirectAndSubRange(oNearestThreatToConsider) - 10 <= iFriendlyDistToEnemy + M27UnitInfo.GetNavalDirectAndSubRange(oClosestFriendlyUnitToEnemyBase) then
                        --Special case - avoid navy all heading towards a really old position of a unit - approximate by comparing the actual position to last known position and not proceeding if it is more than 50 away
                        if M27Utilities.GetDistanceBetweenPositions(oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition], oNearestThreatToConsider:GetPosition()) <= 50 then
                            bAttackNearestThreatInstead = true
                        end
                    end
                end

                if bAttackNearestThreatInstead then
                    --Attack nearest enemy unit - move to just before actual position if we have seen the unit
                    if M27Utilities.CanSeeUnit(aiBrain, oNearestThreatToConsider, true) then
                        tGlobalNavalDestination = M27Utilities.MoveInDirection(oNearestThreatToConsider:GetPosition(), M27Utilities.GetAngleFromAToB(oNearestThreatToConsider:GetPosition(), tOurBase), 4, true, false)
                    else
                        tGlobalNavalDestination = { oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition][1], oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition][2], oNearestThreatToConsider[M27UnitInfo.reftLastKnownPosition][3] }
                    end
                else
                    --Attack enemy base
                    tGlobalNavalDestination = tEnemyBase
                    --Bombardment mode instead if enemy has no base and minimal threat vs ours
                    if iEnemySurfaceThreat <= 1000 and iEnemySurfaceThreat * 8 <= iOurSurfaceThreat and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.STRUCTURE, M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond])) then
                        bConsiderBombardment = true
                    elseif iOurSurfaceThreat >= 25000 and iEnemySurfaceThreat * 8 <= iOurSurfaceThreat and M27Utilities.IsTableEmpty(EntityCategoryFilterDown(M27UnitInfo.refCategoryNavalFactory, M27Team.tTeamData[iTeam][M27Team.reftEnemyUnitsByPond][iPond])) then
                        bConsiderBombardment = true
                    end

                end
            else
                --If we meet up with nearby reinforcements will we have enough surface threat?
                local iReinforcementSurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendlyNearbyReinforcements, false, nil, nil, false, false, false, false, true, false, false)
                local iReinforcementAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendlyNearbyReinforcements, false, nil, nil, false, false, false, true, false, false, false)
                iOurSurfaceThreat = iOurSurfaceThreat + iReinforcementSurfaceThreat
                iOurAntiNavyThreat = iOurAntiNavyThreat + iReinforcementAntiNavyThreat
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Our threats after increasing for reinforcements: iOurSurfaceThreat=' .. iOurSurfaceThreat .. '; iOurAntiNavyThreat=' .. iOurAntiNavyThreat)
                    if M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements) == false then
                        LOG(sFunctionRef .. ': Size of tFriendlyNearbyReinforcements=' .. table.getn(tFriendlyNearbyReinforcements))
                    end
                end

                if (iReinforcementSurfaceThreat > 0 or iReinforcementAntiNavyThreat > 0) and iOurSurfaceThreat >= iEnemySurfaceThreat * 1.1 and iOurAntiNavyThreat >= iEnemySubmersibleThreat then
                    --Consolidate forces
                    bConsolidateForces = true
                    local tTablesOfUnitsToAverage = {}
                    if M27Utilities.IsTableEmpty(tFriendliesNearFront) == false then
                        table.insert(tTablesOfUnitsToAverage, EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendliesNearFront))
                    end
                    if M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements) == false then
                        table.insert(tTablesOfUnitsToAverage, EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendlyNearbyReinforcements))
                    end

                    tGlobalNavalDestination = M27Utilities.GetAveragePositionOfMultipleTablesOfUnits(tTablesOfUnitsToAverage)

                    if bDebugMessages == true then
                        local iUnits = 0
                        for iUnitTable, tUnitTable in tTablesOfUnitsToAverage do
                            iUnits = iUnits + table.getn(tUnitTable)
                        end
                        LOG(sFunctionRef .. ': Want to consolidate nearby reinforcement forces, will move to average location of mobile unites=' .. repru(tGlobalNavalDestination) .. '; size of UnitsToAverage=' .. iUnits)
                    end
                else
                    --If we include all reinforcements do we have enough threat?
                    local iReinforcementSurfaceThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendlyFurtherAwayReinforcements, false, nil, nil, false, false, false, false, true, false, false)
                    local iReinforcementAntiNavyThreat = M27Logic.GetCombatThreatRating(aiBrain, tFriendlyFurtherAwayReinforcements, false, nil, nil, false, false, false, true, false, false, false)
                    iOurSurfaceThreat = iOurSurfaceThreat + iReinforcementSurfaceThreat
                    iOurAntiNavyThreat = iOurAntiNavyThreat + iReinforcementAntiNavyThreat

                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Our threats after increasing for further away reinforcements: iOurSurfaceThreat=' .. iOurSurfaceThreat .. '; iOurAntiNavyThreat=' .. iOurAntiNavyThreat)
                    end
                    if (iReinforcementSurfaceThreat > 0 or iReinforcementAntiNavyThreat > 0) and iOurSurfaceThreat >= iEnemySurfaceThreat * 1.1 and iOurAntiNavyThreat >= iEnemySubmersibleThreat then
                        --Consolidate forces
                        bConsolidateForces = true
                        local tTablesOfUnitsToAverage = {}
                        if M27Utilities.IsTableEmpty(tFriendliesNearFront) == false then
                            table.insert(tTablesOfUnitsToAverage, EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendliesNearFront))
                        end
                        if M27Utilities.IsTableEmpty(tFriendlyNearbyReinforcements) == false then
                            table.insert(tTablesOfUnitsToAverage, EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendlyNearbyReinforcements))
                        end
                        if M27Utilities.IsTableEmpty(tFriendlyFurtherAwayReinforcements) == false then
                            table.insert(tTablesOfUnitsToAverage, EntityCategoryFilterDown(categories.MOBILE - M27UnitInfo.refCategoryEngineer, tFriendlyFurtherAwayReinforcements))
                        end

                        if M27Utilities.IsTableEmpty(tTablesOfUnitsToAverage) == false then
                            tGlobalNavalDestination = M27Utilities.GetAveragePositionOfMultipleTablesOfUnits(tTablesOfUnitsToAverage)

                            if bDebugMessages == true then
                                local iUnits = 0
                                for iUnitTable, tUnitTable in tTablesOfUnitsToAverage do
                                    iUnits = iUnits + table.getn(tUnitTable)
                                end
                                LOG(sFunctionRef .. ': Want to consolidate all reinforcement forces, will move to average location of mobile unites=' .. repru(tGlobalNavalDestination) .. '; size of UnitsToAverage=' .. iUnits)
                            end
                        else
                            tGlobalNavalDestination = { tOurBase[1], tOurBase[2], tOurBase[3] }
                        end
                    else

                        --Retreat

                        tGlobalNavalDestination = M27Utilities.MoveInDirection(tOurBase, iAngleToEnemy, 40, true, false)
                        --If not in same pond then reduce dist to 5 and try in opposite direction
                        if not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tGlobalNavalDestination) == iPond) then
                            for iAngleMod = 0, 315, 45 do
                                tGlobalNavalDestination = M27Utilities.MoveInDirection(tOurBase, iAngleToEnemy + iAngleMod, 8, true, false)
                                if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tGlobalNavalDestination) == iPond then
                                    break
                                end
                            end
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Want to retreat, will run to base=' .. repru(tGlobalNavalDestination))
                        end
                    end
                end
            end

            --Decide individually if units should move to the destination or move away from the enemy (if kiting) - handle submersible units separately


            ---->>>>SUBMERSIBLES<<<----
            local tBaseRallyPoint = M27Utilities.MoveInDirection(tOurBase, M27Utilities.GetAngleFromAToB(tOurBase, tEnemyBase), 8, true, false)
            if not(M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tBaseRallyPoint) == iPond) then
                for iAngleMod = 45, 315, 45 do
                    tBaseRallyPoint = M27Utilities.MoveInDirection(tOurBase, iAngleToEnemy + iAngleMod, 8, true, false)
                    if M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, tGlobalNavalDestination) == iPond then
                        break
                    end
                end
            end

            local tOurSubmersibles = EntityCategoryFilterDown(M27UnitInfo.refCategorySubmarine, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
            if bDebugMessages == true then LOG(sFunctionRef..': About to send orders to any subs we have. bAllOutSubAttack='..tostring(bAllOutSubAttack)..'; Is table of our submersibles empty='..tostring(M27Utilities.IsTableEmpty(tOurSubmersibles))) end
            --Want to get all subs for below (regardless of if close or reinforcement) - will have already decided above whether to attack or not with subs

            if M27Utilities.IsTableEmpty(tOurSubmersibles) == false then
                --Assign actions to subs
                --If in all out attack mode or outrange enemy then move to be in attack range
                local iMaxDistanceWithinAttackRangeWanted = nil
                local iMinDistanceWithinAttackRangeWanted = nil

                --Update ranges wanted - keep as nil if want to ignore nearest enemy unit

                if iOurBestSubmersibleRange > iEnemyBestAntiNavyRange then
                    iMaxDistanceWithinAttackRangeWanted = 0.5
                    iMinDistanceWithinAttackRangeWanted = -7.5
                elseif bAllOutAttack or bAllOutSubAttack then
                    iMaxDistanceWithinAttackRangeWanted = 8.5
                    iMinDistanceWithinAttackRangeWanted = 1.3
                end

                if iMaxDistanceWithinAttackRangeWanted then
                    --Want to either move towards enemy or do kiting retreat
                    --Move towards nearest enemy unit until within range
                    local iCurDistToClosestEnemy
                    for iUnit, oUnit in tOurSubmersibles do
                        --Do we want to engage the enemy?
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering submersible unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; AntiNavyRange='..(oUnit[M27UnitInfo.refiAntiNavyRange] or 'nil')..'; iMinRangeForEngagement='..iMinRangeForEngagement) end
                        if oUnit[M27UnitInfo.refiAntiNavyRange] < iMinRangeForEngagement then
                            MoveUnitTowardsTarget(oUnit, tDestinationForShortRangeUnits, false, 'ShortRange')
                        else
                            iCurDistToClosestEnemy = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tClosestEnemyTargetToUse)

                            if iCurDistToClosestEnemy + iMaxDistanceWithinAttackRangeWanted < oUnit[M27UnitInfo.refiAntiNavyRange] then
                                if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase) <= 20 then
                                    MoveUnitTowardsTarget(oUnit, tBaseRallyPoint, true, 'ASKitingRetreat')
                                else
                                    MoveUnitTowardsTarget(oUnit, tBaseRallyPoint, false, 'MSKitingRetreat')
                                end
                            elseif iCurDistToClosestEnemy + iMinDistanceWithinAttackRangeWanted < oUnit[M27UnitInfo.refiAntiNavyRange] then
                                --Attack-move to target
                                MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, true, 'AGetInRange')
                            else
                                --Move towards target (non-attack move)
                                MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, false, 'MGetInRange')
                            end
                        end
                    end
                else
                    --We dont outrange enemy, and htink we will lose if we will attack, so retreat
                    local sOrderDesc = 'MainRetreat'
                    if bConsolidateForces then
                        sOrderDesc = 'Consolidate'
                    end
                    for iUnit, oUnit in tOurSubmersibles do
                        MoveUnitTowardsTarget(oUnit, tGlobalNavalDestination, sOrderDesc)
                    end
                end
            end

            ---->>>>SURFACE NAVY<<<----
            if not (bConsiderBombardment) then
                local tOurSurfaceCombatNavy = EntityCategoryFilterDown(M27UnitInfo.refCategoryMobileNavalSurface - iSupportNavyCategory, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
                if M27Utilities.IsTableEmpty(tOurSurfaceCombatNavy) == false then

                    local iMaxDistanceWithinAttackRangeWanted = nil
                    local iMinDistanceWithinAttackRangeWanted = nil


                    --Update ranges wanted - keep as nil if want to ignore nearest enemy unit
                    --Do we outrange the enemy with our attack?
                    if iOurBestSurfaceRange > math.max(iEnemyBestSurfaceRange, iEnemyBestAntiNavyRange) then
                        --Is the nearest enemy a surface unit, or alternatively do we outrange the enemy with our antinavy?
                        if not (M27UnitInfo.IsUnitUnderwater(oClosestEnemyUnit)) then
                            if iOurBestSurfaceRange >= 100 then --Dealing with battleship, so allow a bit more of a margin before flee
                                iMaxDistanceWithinAttackRangeWanted = 7.5
                                iMinDistanceWithinAttackRangeWanted = -0.5
                                if iOurSurfaceThreat > iEnemySurfaceThreat * 2.5 and iOurSurfaceThreat >= 20000 then
                                    iMaxDistanceWithinAttackRangeWanted = 20
                                end
                            else
                                iMaxDistanceWithinAttackRangeWanted = 0.5
                                iMinDistanceWithinAttackRangeWanted = -7.5
                            end
                        elseif iOurBestSurfaceAntiNavyRange > iEnemyBestSubmersibleRange then
                            iMaxDistanceWithinAttackRangeWanted = 0.5
                            iMinDistanceWithinAttackRangeWanted = -7.5
                        end
                        --Are we doing an all out attack and either we arent dealing with a sub, or we have an antinavy attack?
                    elseif bAllOutAttack and (not (M27UnitInfo.IsUnitUnderwater(oClosestEnemyUnit)) or iOurBestSurfaceAntiNavyRange > 0) then
                        iMaxDistanceWithinAttackRangeWanted = 8.5 --Refresh rate can be every 1.2s; frigates move at 6 speed; want min of 7.2 gap in distance threshold to avoid frigate not switching to attack-move when closing in on a stationery target
                        iMinDistanceWithinAttackRangeWanted = 1.3
                    end

                    --Reduce kiting if nearest unit is a structure since it cant pursue us
                    if iMinDistanceWithinAttackRangeWanted and EntityCategoryContains(categories.STRUCTURE, oClosestEnemyUnit.UnitId) then
                        iMinDistanceWithinAttackRangeWanted = math.max(iMinDistanceWithinAttackRangeWanted, 0)
                        if EntityCategoryContains(categories.DIRECTFIRE + categories.INDIRECTFIRE + categories.ANTINAVY, oClosestEnemyUnit.UnitId) then
                            iMaxDistanceWithinAttackRangeWanted = math.max(iMinDistanceWithinAttackRangeWanted + 4, iMinDistanceWithinAttackRangeWanted)
                        else
                            iMaxDistanceWithinAttackRangeWanted = math.max(iMinDistanceWithinAttackRangeWanted + 8, iMinDistanceWithinAttackRangeWanted)
                        end

                    end

                    if bDebugMessages == true then LOG(sFunctionRef..': About to consider attacking with surface units, iOurBestSurfaceRange='..iOurBestSurfaceRange..'; iMaxDistanceWithinAttackRangeWanted='..(iMaxDistanceWithinAttackRangeWanted or 'nil')..'; iMinRangeForEngagement='..iMinRangeForEngagement) end

                    if iMaxDistanceWithinAttackRangeWanted then
                        local iCurDistToClosestEnemy
                        --Want to either move towards enemy or do kiting retreat
                        --Move towards nearest enemy unit until within range
                        local iCurRange

                        --Get shortlist of priority structures if are charging at enemy base in case shot is blocked
                        local tPriorityTargets = {}
                        local oPriorityTarget
                        local iCurDistToPriority
                        if bChargeEnemyBase then
                            tPriorityTargets = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT2PlusPD + M27UnitInfo.refCategoryTorpedoLauncher - categories.SUBMERSIBLE + M27UnitInfo.refCategoryFixedShield + M27UnitInfo.refCategoryFixedT2Arti + M27UnitInfo.refCategoryNavalFactory, tClosestEnemyTargetToUse, 120, 'Enemy')
                        end

                        for iUnit, oUnit in tOurSurfaceCombatNavy do
                            --Do we want to engage the enemy with surface unit?
                            if not(oUnit[M27UnitInfo.refiDFRange]) then iCurRange = M27UnitInfo.GetNavalDirectAndSubRange(oUnit) --this line is for redundancy so dont need to worry about factoring in indirect as shoudl be a 1-off
                            else
                                if bUseIndirectRangeIfHigher then
                                    iCurRange = math.max(oUnit[M27UnitInfo.refiAntiNavyRange], oUnit[M27UnitInfo.refiDFRange], oUnit[M27UnitInfo.refiIndirectRange])
                                else
                                    iCurRange = math.max(oUnit[M27UnitInfo.refiAntiNavyRange], oUnit[M27UnitInfo.refiDFRange])
                                end
                            end
                            if iCurRange < iMinRangeForEngagement then
                                if bDebugMessages == true then LOG(sFunctionRef..': iCurRange='..iCurRange..'; iMinRangeForEngagement='..iMinRangeForEngagement) end
                                MoveUnitTowardsTarget(oUnit, tDestinationForShortRangeUnits, false, 'ShortRange')
                            else
                                iCurDistToClosestEnemy = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tClosestEnemyTargetToUse)
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': oUnit=' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. '; iCurDistToClosestEnemy=' .. iCurDistToClosestEnemy .. '; iMaxDistanceWithinAttackRangeWanted=' .. iMaxDistanceWithinAttackRangeWanted .. '; iMinDistanceWithinAttackRangeWanted=' .. iMinDistanceWithinAttackRangeWanted .. '; Range=' .. M27UnitInfo.GetNavalDirectAndSubRange(oUnit))
                                end
                                if EntityCategoryContains(M27UnitInfo.refCategorySupportNavy, oUnit.UnitId) and M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oClosestFriendlyUnitToEnemyBase:GetPosition()) <= 40 then
                                    MoveUnitTowardsTarget(oUnit, tOurBase, false, 'SupportRetreat')
                                elseif iCurDistToClosestEnemy + iMaxDistanceWithinAttackRangeWanted < iCurRange then
                                    --Kiting retreat unless are near our naval factory in which case do attack-move
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering kiting retreat for unit unless close to our base in which case will attack move. Dist to our base='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)) end
                                    if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase) <= 20 then
                                        MoveUnitTowardsTarget(oUnit, tBaseRallyPoint, true, 'AKitingRetreat')
                                    else
                                        MoveUnitTowardsTarget(oUnit, tBaseRallyPoint, false, 'MKitingRetreat')
                                    end
                                elseif iCurDistToClosestEnemy + iMinDistanceWithinAttackRangeWanted < iCurRange then
                                    --Attack-move to target; however do issueattack if we are moving to enemy naval base
                                    if bChargeEnemyBase and iCurDistToClosestEnemy < iCurRange and (oUnit[M27UnitInfo.refbLastShotBlocked] or (oUnit[M27PlatoonUtilities.refiLastOrderType] == M27PlatoonUtilities.refiOrderIssueAttack and M27UnitInfo.IsUnitValid(oUnit[M27UnitInfo.refoLastOrderUnitTarget]))) then
                                        --Shot blocked and we are charging to enemy base so want to focus down the enemy base
                                        oPriorityTarget = nil
                                        if M27Utilities.IsTableEmpty(tPriorityTargets) == false then
                                            for iEnemy, oEnemy in tPriorityTargets do
                                                iCurDistToPriority = M27Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())
                                                if iCurDistToPriority <= iCurRange or (iCurDistToPriority - 6 <= iCurRange and not(oPriorityTarget)) then
                                                    --Is shot blocked?
                                                    if not(M27Logic.IsShotBlocked(oUnit, oEnemy)) then
                                                        oPriorityTarget = oEnemy
                                                        if iCurDistToPriority <= iCurRange then break end
                                                    end
                                                end
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Shot is blocked so looking to see if have a nearly in range prioriyt target; Is oPriorityTarget valid='..tostring(M27UnitInfo.IsUnitValid(oPriorityTarget))) end
                                        if oPriorityTarget and M27Utilities.GetDistanceBetweenPositions(oPriorityTarget:GetPosition(), oUnit:GetPosition()) - 6 <= iCurRange then
                                            TellUnitToAttackTarget(oUnit, oPriorityTarget, 'Blocked')
                                            if bDebugMessages == true then LOG(sFunctionRef..': Want to attack specific unit='..oPriorityTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oPriorityTarget)..' which is '..M27Utilities.GetDistanceBetweenPositions(oPriorityTarget:GetPosition(), oUnit:GetPosition())..' away from unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                        else
                                            MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, false, 'AGetInRange')
                                            if bDebugMessages == true then LOG(sFunctionRef..': no suitable target so will just move towards closest enemy target to use') end
                                        end
                                    else
                                        MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, true, 'AGetInRange')
                                    end
                                else
                                    --Move towards target (non-attack move)
                                    MoveUnitTowardsTarget(oUnit, tClosestEnemyTargetToUse, false, 'MGetInRange')
                                end
                            end
                        end
                    else
                        --We dont outrange enemy, and htink we will lose if we will attack, so retreat/head to destination if are ignoring enemy subs
                        local sOrderDesc = 'MainRetreat'
                        if bConsolidateForces then
                            sOrderDesc = 'Consolidate'
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': About to order navy to go to tGlobalNavalDestination=' .. repru(tGlobalNavalDestination) .. '; bConsolidateForces=' .. tostring(bConsolidateForces))
                        end
                        for iUnit, oUnit in tOurSurfaceCombatNavy do
                            MoveUnitTowardsTarget(oUnit, tGlobalNavalDestination, false, sOrderDesc)
                        end
                    end
                end
            end
        end
    elseif oClosestFriendlyUnitToEnemyBase then

        --Have destroyed all enemy naval units, focus on naval bombardment - do attack-move to closest enemy mex that enemy controls that we can hit with our current naval options
        local tOurFriendlyCombatUnits = EntityCategoryFilterDown(categories.DIRECTFIRE * categories.MOBILE + categories.INDIRECTFIRE * categories.MOBILE, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
        if bDebugMessages == true then
            LOG(sFunctionRef .. ' No enemy naval units detected, will switch to considering if want bombardment mode. Is table of friendly combat units empty=' .. tostring(M27Utilities.IsTableEmpty(tOurFriendlyCombatUnits)))
        end
        if M27Utilities.IsTableEmpty(tOurFriendlyCombatUnits) == false then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': oClosestFriendlyUnit=' .. oClosestFriendlyUnitToEnemyBase.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oClosestFriendlyUnitToEnemyBase) .. '; Position=' .. repru(oClosestFriendlyUnitToEnemyBase:GetPosition()))
            end

            local oClosestEnemyMex

            for iUnit, oUnit in tOurFriendlyCombatUnits do
                if not (bHaveAlreadyUpdatedRanges) then
                    M27UnitInfo.GetNavalDirectAndSubRange(oUnit)
                end
                iOurBestIndirectRange = math.max(iOurBestIndirectRange, oUnit[M27UnitInfo.refiIndirectRange])
                iOurBestDFRange = math.max(iOurBestDFRange, oUnit[M27UnitInfo.refiDFRange])
                oUnit[refbTempIsUnderwater] = M27UnitInfo.IsUnitUnderwater(oUnit)
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Friendly combat unit ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ': Is underwater=' .. tostring(oUnit[refbTempIsUnderwater]) .. '; DF range=' .. oUnit[M27UnitInfo.refiDFRange] .. '; Indirect range=' .. oUnit[M27UnitInfo.refiIndirectRange])
                end
            end
        end
        if math.max(iOurBestDFRange, iOurBestIndirectRange) >= 25 then
            bConsiderBombardment = true
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Have units iwth at least 25 range so will consider bombardment mode')
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to consider bombardment. bConsiderBombardment='..tostring((bConsiderBombardment or false))) end
    if bConsiderBombardment then
        --Get the mex closest to our front unit that is within bombardment range

        local tFrontPosition = oClosestFriendlyUnitToEnemyBase:GetPosition()
        local iClosestMexDist = 100000
        local iCurDist
        local tEnemyBuildings
        local iClosestMexRef
        local iBombardmentSearchRange = math.min(20, (M27Team.tTeamData[iTeam][M27Team.refiLastBombardmentSearchRangeByPond][iPond] or 1))
        if not (M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond]) then
            iBombardmentSearchRange = iBombardmentSearchRange + 1
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': About to consider all mexes in range of the pond. iOurBestDFRange=' .. iOurBestDFRange .. '; iOurBestIndirectRange=' .. iOurBestIndirectRange .. '; iBombardmentSearchRange=' .. iBombardmentSearchRange)
        end
        local iMaxSearchRange
        for iMex, tMexInfo in tPondDetails[iPond][subrefPondMexInfo] do
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering mex that is ' .. M27Utilities.GetDistanceBetweenPositions(tMexInfo[subrefMexLocation], M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) .. ' from our start position and ' .. M27Utilities.GetDistanceBetweenPositions(tMexInfo[subrefMexLocation], M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)) .. ' from enemy base. DF distance to hit mex=' .. tMexInfo[subrefMexDFDistance] .. '; Indirect distance=' .. tMexInfo[subrefMexIndirectDistance])
            end
            if tMexInfo[subrefMexDFDistance] <= iOurBestDFRange or tMexInfo[subrefMexIndirectDistance] <= iOurBestIndirectRange then
                iCurDist = M27Utilities.GetDistanceBetweenPositions(tMexInfo[subrefMexLocation], tFrontPosition)
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': iCurDist to our closest navla unit=' .. iCurDist .. '; iClosestMexDist=' .. iClosestMexDist)
                end
                if iCurDist < iClosestMexDist then
                    --Does the enemy have any buildings near here?
                    iMaxSearchRange = 200
                    if tMexInfo[subrefMexIndirectDistance] <= iOurBestIndirectRange then
                        iMaxSearchRange = iOurBestIndirectRange - tMexInfo[subrefMexIndirectDistance]
                    end
                    if tMexInfo[subrefMexDFDistance] <= iOurBestDFRange and iOurBestDFRange >= iOurBestIndirectRange then
                        iMaxSearchRange = iOurBestDFRange - tMexInfo[subrefMexDFDistance]
                    end
                    iMaxSearchRange = math.max(2, iMaxSearchRange)
                    tEnemyBuildings = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure, tMexInfo[subrefMexLocation], math.min(iBombardmentSearchRange, iMaxSearchRange), 'Enemy')
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Is table of enemy buildings around mex empty=' .. tostring(M27Utilities.IsTableEmpty(tEnemyBuildings)))
                    end
                    if M27Utilities.IsTableEmpty(tEnemyBuildings) == false then
                        iClosestMexDist = iCurDist
                        iClosestMexRef = iMex
                    end
                end
            end
        end

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Considering if any enemy mexes to bombard. iClosestMexRef=' .. (iClosestMexRef or 'nil'))
        end
        local tNonBombardmentRallyPoint = M27Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase), 20, true, false)
        local tBombardmentRallyPoint
        local tBlockedShotBaseMoveLocation --Closest position to mex that we thought a shot wouldnt be blocked from
        local tBlockedShotActualMoveLocation --Moves back based on our current distance to the mex if we are further away
        local iDFMinRange
        local iIndirectMinRange

        if iClosestMexRef then
            local tClosestMex = { tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexLocation][1], tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexLocation][2], tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexLocation][3] }
            --Attack-move to nearest mex; for units that wont be in range to attack the mex position, attack-move towards our base by 10 below the bombardment range
            --tNonBombardmentRallyPoint = M27Utilities.MoveInDirection(tClosestMex, M27Utilities.GetAngleFromAToB(tClosestMex, tOurBase), math.max(iOurBestDFRange, iOurBestIndirectRange), true, false)
            tBombardmentRallyPoint = tClosestMex
            iDFMinRange = tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFDistance]
            if iDFMinRange == 0 then
                iDFMinRange = 150
            end
            iIndirectMinRange = tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexIndirectDistance]
            if iIndirectMinRange == 0 then
                iIndirectMinRange = 150
            end
            tBlockedShotBaseMoveLocation = (tPondDetails[iPond][subrefPondMexInfo][iClosestMexRef][subrefMexDFUnblockedLocation] or tBombardmentRallyPoint)


        else
            tBombardmentRallyPoint = { tEnemyBase[1], tEnemyBase[2], tEnemyBase[3] }
            --tNonBombardmentRallyPoint = {tEnemyBase[1], tEnemyBase[2], tEnemyBase[3]}
            tBlockedShotBaseMoveLocation = nil --dont want to consider
            iDFMinRange = iOurBestDFRange
            iIndirectMinRange = iOurBestIndirectRange
        end

        if not (iClosestMexRef) and math.max(iOurBestDFRange, iOurBestIndirectRange) >= 60 then
            M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond] = false
        else
            --Treat as success even if didnt find anything if have poor range
            M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond] = true
        end
        M27Team.tTeamData[iTeam][M27Team.refiLastBombardmentSearchRangeByPond][iPond] = iBombardmentSearchRange
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Recorded whether or not our bombardment search range was a success. iClosestMexRef=' .. (iClosestMexRef or 'nil') .. '; iOurBestDFRange=' .. iOurBestDFRange .. '; iOurBestIndirectRange=' .. iOurBestIndirectRange .. '; iBombardmentSearchRange=' .. iBombardmentSearchRange .. '; M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond]=' .. tostring(M27Team.tTeamData[iTeam][M27Team.refbLastBombardmentSearchRangeSuccessByPond][iPond]) .. '; M27Team.tTeamData[iTeam][M27Team.refiLastBombardmentSearchRangeByPond][iPond]=' .. M27Team.tTeamData[iTeam][M27Team.refiLastBombardmentSearchRangeByPond][iPond])
        end




        --Send any non-submersible units to the location
        local tEnemyStructuresNearFrontUnit = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.max(iIndirectMinRange + 50, iDFMinRange + 50, 150), 'Enemy')
        --local tEnemyDefences = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryPD + M27UnitInfo.refCategoryFixedT2Arti, oClosestFriendlyUnitToEnemyBase:GetPosition(), math.max(iIndirectMinRange + 50, iDFMinRange + 50, 150), 'Enemy')
        local tEnemyDefences
        if M27Utilities.IsTableEmpty(tEnemyStructuresNearFrontUnit) == false then
            tEnemyDefences = EntityCategoryFilterDown(M27UnitInfo.refCategoryPD + M27UnitInfo.refCategoryFixedT2Arti, tEnemyStructuresNearFrontUnit)
        end
        local bCheckForBuildingsToAttack = true
        local bCheckForDefences = false
        local bRetreatUnit
        if M27Utilities.IsTableEmpty(tEnemyStructuresNearFrontUnit) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': No enemy structures within a range of ' .. (math.max(iIndirectMinRange, iDFMinRange) + 50) .. ' of the unit closest to the enemy base. iIndirectMinRange=' .. iIndirectMinRange .. '; iDFMinRange=' .. iDFMinRange)
            end
            bCheckForBuildingsToAttack = false
        end
        bCheckForDefences = not (M27Utilities.IsTableEmpty(tEnemyDefences))
        local oBuildingToAttack
        local iDefencesHeadroom
        local bBlockedSoMove = false --If unit shot is blocked and it should be able to hit the mex then have it move to where we thought the shot would be able to hit from
        local iBlockedAngleFromMex
        local iBlockedDistanceFromMex
        if tBlockedShotBaseMoveLocation then
            iBlockedAngleFromMex = M27Utilities.GetAngleFromAToB(tBombardmentRallyPoint, tBlockedShotBaseMoveLocation)
            iBlockedDistanceFromMex = M27Utilities.GetDistanceBetweenPositions(tBombardmentRallyPoint, tBlockedShotBaseMoveLocation)
        end

        if bDebugMessages == true then
            LOG(sFunctionRef .. ': About to search for bombardment targets, bCheckForBuildingsToAttack=' .. tostring(bCheckForBuildingsToAttack) .. '; tBombardmentRallyPoint=' .. repru(tBombardmentRallyPoint) .. '; tNonBombardmentRallyPoint=' .. repru(tNonBombardmentRallyPoint) .. '; iDFMinRange=' .. iDFMinRange .. '; iIndirectMinRange=' .. iIndirectMinRange)
        end

        for iUnit, oUnit in EntityCategoryFilterDown(M27UnitInfo.refCategoryMobileNavalSurface - iSupportNavyCategory, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond]) do
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering unit ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. '; is underwater=' .. tostring(oUnit[refbTempIsUnderwater]) .. '; oUnit[M27UnitInfo.refiDFRange]=' .. oUnit[M27UnitInfo.refiDFRange] .. '; oUnit[M27UnitInfo.refiIndirectRange]=' .. oUnit[M27UnitInfo.refiIndirectRange])
            end
            if not (oUnit[refbTempIsUnderwater]) then
                if oUnit[M27UnitInfo.refiIndirectRange] == nil then
                    M27UnitInfo.GetNavalDirectAndSubRange(oUnit)
                end
                bRetreatUnit = false
                --Are we in range of enemy PD/T2 arti? If so then retreat
                if bCheckForDefences then
                    local iCurEnemyRange
                    local iCurEnemyDist
                    iDefencesHeadroom = 1000
                    for iDefence, oDefence in tEnemyDefences do
                        iCurEnemyRange = math.max(M27UnitInfo.GetNavalDirectAndSubRange(oDefence), oDefence[M27UnitInfo.refiIndirectRange])
                        iCurEnemyDist = M27Utilities.GetDistanceBetweenPositions(oDefence:GetPosition(), oUnit:GetPosition())
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Considering if oUnit=' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ' is in range of oDefence=' .. oDefence.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oDefence) .. '; iCurEnemyRange=' .. iCurEnemyRange .. '; iCurEnemyDist=' .. iCurEnemyDist .. '; Our DF/Indirect range=' .. math.max(oUnit[M27UnitInfo.refiIndirectRange], oUnit[M27UnitInfo.refiDFRange]))
                        end
                        iDefencesHeadroom = math.min(iDefencesHeadroom, iCurEnemyDist - iCurEnemyRange)
                        if iCurEnemyDist <= iCurEnemyRange or (iCurEnemyDist - 10 <= iCurEnemyRange and math.max((oUnit[M27UnitInfo.refiIndirectRange] or 0), (oUnit[M27UnitInfo.refiDFRange] or 0)) < (iCurEnemyRange or 0)) then
                            --Move away unless are a battleship and the enemy is more than 100 away
                            if not (iCurEnemyDist > 100 and EntityCategoryContains(M27UnitInfo.refCategoryMobileNavalSurface * categories.TECH3 * categories.BATTLESHIP, oUnit.UnitId)) then
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Want to retreat')
                                end
                                bRetreatUnit = true
                                break
                            end
                        end
                    end
                end

                if bRetreatUnit then
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': WIll retreat ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ' towards our base as we are too close to enemy PD')
                    end
                    MoveUnitTowardsTarget(oUnit, tOurBase, false, 'RetreatFromPD')
                else
                    if oUnit[M27UnitInfo.refiDFRange] >= iDFMinRange or oUnit[M27UnitInfo.refiIndirectRange] >= iIndirectMinRange then
                        --Attack-move to target, unless we already have a structure in range or our shot is blocked
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': Checking if shot blocked for unit ' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. '. tBlockedShotBaseMoveLocation=' .. repru(tBlockedShotBaseMoveLocation) .. '; oUnit[M27UnitInfo.refiDFRange]=' .. oUnit[M27UnitInfo.refiDFRange] .. '; oUnit[M27UnitInfo.refiIndirectRange]=' .. oUnit[M27UnitInfo.refiIndirectRange] .. '; oUnit[M27UnitInfo.refbLastShotBlocked]=' .. tostring(oUnit[M27UnitInfo.refbLastShotBlocked] or false))
                        end
                        if tBlockedShotBaseMoveLocation and oUnit[M27UnitInfo.refiDFRange] > oUnit[M27UnitInfo.refiIndirectRange] and oUnit[M27UnitInfo.refbLastShotBlocked] then
                            bBlockedSoMove = true
                            --Get location this unit should move to
                            tBlockedShotActualMoveLocation = M27Utilities.MoveInDirection(tBombardmentRallyPoint, iBlockedAngleFromMex, math.max(iBlockedDistanceFromMex, M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBombardmentRallyPoint)), true, false)
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Will move to tBlockedShotActualMoveLocation=' .. repru(tBlockedShotActualMoveLocation))
                            end
                        else

                            oBuildingToAttack = nil
                            if bCheckForBuildingsToAttack then
                                oBuildingToAttack = M27Utilities.GetNearestUnit(tEnemyStructuresNearFrontUnit, oUnit:GetPosition(), aiBrain)
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Considering whether to attack oBuildingToAttack=' .. oBuildingToAttack.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oBuildingToAttack) .. '; Distance to it=' .. M27Utilities.GetDistanceBetweenPositions(oBuildingToAttack:GetPosition(), oUnit:GetPosition()) .. '; Our DF range=' .. oUnit[M27UnitInfo.refiDFRange] .. '; Our Indirect range=' .. oUnit[M27UnitInfo.refiIndirectRange])
                                end
                                if oBuildingToAttack and M27Utilities.GetDistanceBetweenPositions(oBuildingToAttack:GetPosition(), oUnit:GetPosition()) > math.max(oUnit[M27UnitInfo.refiDFRange], oUnit[M27UnitInfo.refiIndirectRange]) then
                                    --Not in range so dont give specific attack order
                                    oBuildingToAttack = nil
                                else
                                    --Consider overwriting with a priority target (e.g. TMD and shields)
                                    if iDefencesHeadroom >= 10 then
                                        local iPriorityCategory = M27UnitInfo.refCategoryFixedShield
                                        if EntityCategoryContains(M27UnitInfo.refCategoryMissileNavy, oUnit.UnitId) then
                                            iPriorityCategory = iPriorityCategory + M27UnitInfo.refCategoryTMD
                                        end
                                        local tPriorityTargets = EntityCategoryFilterDown(iPriorityCategory, tEnemyStructuresNearFrontUnit)
                                        if M27Utilities.IsTableEmpty(tPriorityTargets) == false then
                                            local oNearestPriority = M27Utilities.GetNearestUnit(tPriorityTargets, oUnit:GetPosition(), aiBrain)
                                            local iDistToPriority = M27Utilities.GetDistanceBetweenPositions(oNearestPriority:GetPosition(), oUnit:GetPosition())
                                            if iDistToPriority - math.min(iDefencesHeadroom, 30) <= math.max(oUnit[M27UnitInfo.refiIndirectRange], oUnit[M27UnitInfo.refiDFRange]) then
                                                oBuildingToAttack = oNearestPriority
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if not (oBuildingToAttack) or bBlockedSoMove then
                            --ToDo - figure out solution to both cliff temporarily blocking (where if we dont attack-move we are ok)
                            --ToDo - and the converse where we are ok but if we move towards the target a cliff ends up blocking us until we move further away
                            if bBlockedSoMove then
                                MoveUnitTowardsTarget(oUnit, tBlockedShotActualMoveLocation, false, 'Blocked')
                            else
                                MoveUnitTowardsTarget(oUnit, tBombardmentRallyPoint, true, 'Bombard')
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': Will bombard the target with this unit')
                                end
                            end
                        else
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Launching specific attack order on ' .. oBuildingToAttack.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oBuildingToAttack))
                            end
                            TellUnitToAttackTarget(oUnit, oBuildingToAttack, 'BAttack')
                        end
                    else
                        MoveUnitTowardsTarget(oUnit, tNonBombardmentRallyPoint, false, 'SRSupport') --Short range unit so dont want it to join in the bombardment
                    end
                end
            end
        end
    end

    ---->>>>Support units<<<<---
    --Move general support units towards front unit
    if oClosestFriendlyUnitToEnemyBase then
        local tSupportUnits = EntityCategoryFilterDown(iSupportNavyCategory, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
        if M27Utilities.IsTableEmpty(tSupportUnits) == false then
            local iDistToTravel = math.max(5, math.min(50, M27Utilities.GetDistanceBetweenPositions(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase)))

            local tSupportDestination = M27Utilities.MoveInDirection(oClosestFriendlyUnitToEnemyBase:GetPosition(), M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase), iDistToTravel, true, false)
            if bDebugMessages == true then LOG(sFunctionRef..': Will send all support units to '..repru(tSupportDestination)..'; this was based on closest friendly unit to enemy base '..oClosestFriendlyUnitToEnemyBase.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestFriendlyUnitToEnemyBase)..'; which is at position'..repru(oClosestFriendlyUnitToEnemyBase:GetPosition())..' and tOurBase='..repru(tOurBase)..'; Angle between these='..M27Utilities.GetAngleFromAToB(oClosestFriendlyUnitToEnemyBase:GetPosition(), tOurBase)) end
            local iCurShieldHealth, iMaxShieldHealth
            local iShieldPercent
            local tShieldsToAssign = {}

            for iUnit, oUnit in tSupportUnits do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if unit is a shield and if its available. oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
                if EntityCategoryContains(M27UnitInfo.refCategoryShieldBoat, oUnit.UnitId) then
                    --Check if want to be recharging shield
                    iCurShieldHealth, iMaxShieldHealth = M27UnitInfo.GetCurrentAndMaximumShield(oUnit)
                    iShieldPercent = iCurShieldHealth / iMaxShieldHealth
                    if oUnit[refbRechargeShield] then
                        if iShieldPercent >= 0.75 then oUnit[refbRechargeShield] = true end
                    else
                        if iShieldPercent <= 0.2 then
                            oUnit[refbRechargeShield] = true
                            RemoveShieldAssignment(oUnit)
                        end
                    end

                    --Determine action based on if we want to recharge shield
                    if iMaxShieldHealth == 0 then --Redundancy
                        MoveUnitTowardsTarget(oUnit, tSupportDestination, false, 'GSupport')
                        if bDebugMessages == true then LOG(sFunctionRef..': Shield is empty so will go to support destination') end
                    else
                        if oUnit[refbRechargeShield] then
                            MoveUnitTowardsTarget(oUnit, tOurBase, false, 'SRecharge')
                            if bDebugMessages == true then LOG(sFunctionRef..': Shield needs recharging so will go to our base') end
                        else
                            --Want to assist a unit
                            table.insert(tShieldsToAssign, oUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have added unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of shields that will assign shortly') end
                        end
                    end
                else
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': Sending move command to oUnit=' .. oUnit.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oUnit) .. ' to ' .. repru(tSupportDestination))
                    end
                    MoveUnitTowardsTarget(oUnit, tSupportDestination, false, 'GSupport')
                end
            end


            ---->>>>SHIELD BOATS<<<<----
            --Assign shield units - decide on priority list, and then get the closest shield unit to this
            if M27Utilities.IsTableEmpty(tShieldsToAssign) == false then
                local tUnitsToShieldByPriority = {}
                local iCurPriority = 1
                local iSurfaceCombatCategory = M27UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M27UnitInfo.refCategoryNavalSurface * categories.INDIRECTFIRE + M27UnitInfo.refCategoryNavalSurface * categories.ANTINAVY
                local oClosestSurface1, oClosestSurface2, oClosestSurface3
                local iClosestSurface1 = 100000
                local iClosestSurface2 = 100000
                local iClosestSurface3 = 100000

                local iCurDist

                function AddUnitToPriorityList(oUnit)
                    table.insert(tUnitsToShieldByPriority, oUnit)
                    if bDebugMessages == true then LOG(sFunctionRef..': Added unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' to priority list, iCurPriority='..iCurPriority..'; Distance to enemy base='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)) end
                    iCurPriority = iCurPriority + 1
                end


                local tSurfaceCombat = EntityCategoryFilterDown(iSurfaceCombatCategory, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
                if M27Utilities.IsTableEmpty(tSurfaceCombat) == false then
                    for iUnit, oUnit in tSurfaceCombat do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tEnemyBase)
                        if iCurDist < iClosestSurface3 then
                            if iCurDist < iClosestSurface2 then
                                if iCurDist < iClosestSurface1 then
                                    oClosestSurface3 = oClosestSurface2
                                    iClosestSurface3 = iClosestSurface2
                                    oClosestSurface2 = oClosestSurface1
                                    iClosestSurface2 = iClosestSurface1
                                    oClosestSurface1 = oUnit
                                    iClosestSurface1 = iCurDist
                                else
                                    --Closet than 2 not 1
                                    oClosestSurface3 = oClosestSurface2
                                    iClosestSurface3 = iClosestSurface2
                                    oClosestSurface2 = oUnit
                                    iClosestSurface2 = iCurDist
                                end
                            else
                                oClosestSurface3 = oUnit
                                iClosestSurface3 = iCurDist
                            end
                        end
                    end
                end
                if oClosestSurface1 then AddUnitToPriorityList(oClosestSurface1) end
                local oClosestCruiser1, oClosestCruiser2
                local iClosestCruiser1 = 100000
                local iClosestCruiser2 = 100000
                local tCruisers = EntityCategoryFilterDown(M27UnitInfo.refCategoryCruiser, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
                if M27Utilities.IsTableEmpty(tCruisers) == false then
                    for iUnit, oUnit in tCruisers do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tOurBase)
                        if iCurDist < iClosestCruiser2 then
                            if iCurDist < iClosestCruiser1 then
                                oClosestCruiser2 = oClosestCruiser1
                                iClosestCruiser2 = iClosestCruiser1
                                oClosestCruiser1 = oUnit
                                iClosestCruiser1 = iCurDist
                            else
                                oClosestCruiser2 = oUnit
                                iClosestCruiser2 = iCurDist
                            end
                        end
                    end
                end
                if oClosestCruiser1 then AddUnitToPriorityList(oClosestCruiser1) end

                if not(bAllOutSubAttack) and not(EntityCategoryContains(M27UnitInfo.refCategoryCruiser + iSurfaceCombatCategory,oClosestFriendlyUnitToEnemyBase.UnitId)) then
                    AddUnitToPriorityList(oClosestFriendlyUnitToEnemyBase)
                end
                if oClosestSurface2 then AddUnitToPriorityList(oClosestSurface2) end
                if oClosestSurface3 then AddUnitToPriorityList(oClosestSurface3) end
                if oClosestCruiser2 then AddUnitToPriorityList(oClosestCruiser2) end


                --Find the nearest shield to each priority unit to shield
                local oClosestShield
                local iClosestShieldDist = 100000
                local iClosestShieldRef

                for iUnit, oUnit in tUnitsToShieldByPriority do
                    iClosestShieldDist = 100000
                    for iShield, oShield in tShieldsToAssign do
                        iCurDist = M27Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oUnit:GetPosition())
                        if bDebugMessages == true then LOG(sFunctionRef..': Looking for closest shield to oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; shield='..oShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurDist='..iCurDist) end
                        if iCurDist < iClosestShieldDist then
                            iClosestShieldRef = iShield
                            oClosestShield = oShield
                            iClosestShieldDist = iCurDist
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Will assign shield '..oClosestShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestShield)..' with aiBrain index='..oClosestShield:GetAIBrain():GetArmyIndex()..' to priority unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; iClosestShieldDist='..iClosestShieldDist) end
                    AddShieldAssignment(oUnit, oClosestShield, tOurBase)
                    table.remove(tShieldsToAssign, iClosestShieldRef)
                    if M27Utilities.IsTableEmpty(tShieldsToAssign) then break end
                end
                --Assign any spare shields to the closest friendly unit to the front
                if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning shields to priority units. Is table of shields to assign empty='..tostring(M27Utilities.IsTableEmpty(tShieldsToAssign))) end
                if M27Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    local oRemainingUnitPriority = oClosestFriendlyUnitToEnemyBase
                    if bAllOutSubAttack and EntityCategoryContains(categories.SUBMERSIBLE + categories.AMPHIBIOUS - categories.HOVER, oClosestFriendlyUnitToEnemyBase.UnitId) then
                        local tSurfaceUnits = EntityCategoryFilterDown(M27UnitInfo.refCategoryAllAmphibiousAndNavy - categories.SUBMIERSIBLE, M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond][iPond])
                        if M27Utilities.IsTableEmpty(tSurfaceUnits) == false then
                            oRemainingUnitPriority = M27Utilities.GetNearestUnit(tSurfaceUnits, tEnemyBase)
                        else
                            M27Utilities.ErrorHandler('Dont have any surface units but should at least have the shields that are considering')
                        end
                    end
                    for iShield, oClosestShield in tShieldsToAssign do
                        if bDebugMessages == true then LOG(sFunctionRef..': Have no more priority units, assigning shield '..oClosetsShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oClosestShield)..' to oRemainingUnitPriority='..oRemainingUnitPriority.UnitId..M27UnitInfo.GetUnitLifetimeCount(oRemainingUnitPriority)) end
                        AddShieldAssignment(oRemainingUnitPriority, oClosestShield, tOurBase)
                    end
                end
            end
        end

    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function ManageNavyMainLoop(aiBrain)
    --aiBrain just used for functionality like getting the primary factory that in some cases requires an aibrain

    local bDebugMessages = false
    if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageNavyMainLoop'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local iTeam = aiBrain.M27Team
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': iTeam=' .. (iTeam or 'nil') .. '; Is tTeamData empty=' .. tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData)) .. '; Do we have active naval manager=' .. tostring(M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] or false))
    end
    if not (M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager]) then
        local iTotalTicksWaited = 0
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Is the table of friendly units by pond empty=' .. tostring(M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond])))
        end
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond]) == false then
            for iPond, tFriendlyUnits in M27Team.tTeamData[iTeam][M27Team.reftFriendlyUnitsByPond] do
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Is table of friendly units empty for pond ' .. iPond .. '=' .. tostring(M27Utilities.IsTableEmpty(tFriendlyUnits)))
                end
                --if M27Utilities.IsTableEmpty(tFriendlyUnits) == false then
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Running naval management for pond ' .. iPond)
                end
                ForkThread(ManageTeamNavy, aiBrain, iTeam, iPond)
                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] = true
                iTotalTicksWaited = iTotalTicksWaited + _G.MyM27Scheduler:WaitTicks(1, 2, 0.4)
                M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] = false
                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished waiting after calling manage team navy for pond '..iPond..'; iTotalTicksWaited='..iTotalTicksWaited) end
                --end
            end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
            M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] = true
            iTotalTicksWaited = iTotalTicksWaited + _G.MyM27Scheduler:WaitTicks(math.max(1, 8 - iTotalTicksWaited), math.max(2, 10 - iTotalTicksWaited), 1) --Dont want to increase beyond 10 or can end up taking a full 1s longer in addition to this depending on how it aligns with aibrain refresh rate
            M27Team.tTeamData[iTeam][M27Team.refbActiveNavalManager] = false
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
            if bDebugMessages == true then LOG(sFunctionRef..': Finished running for all ponds, iTotalTicksWaited='..iTotalTicksWaited) end
        end
    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function GetPondToFocusOn(aiBrain)
    --Returns nil if no pond to focus on
    local bDebugMessages = false
    if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPondToFocusOn'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local iPondWanted = aiBrain[refiAssignedPond] --default
    local iBestPondDefensiveValue = 0
    if iPondWanted then
        iBestPondDefensiveValue = (aiBrain[reftiPondThreatToUs][iPondWanted] or 0)
    end
    if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond]) == false then
        for iPondWithEnemies, tEnemyUnits in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftEnemyUnitsByPond] do
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Considering iPondWithEnemies=' .. iPondWithEnemies .. '; Pond defensive value=' .. (aiBrain[reftiPondThreatToUs][iPondWithEnemies] or 'nil') .. '; iBestPondDefensiveValue=' .. iBestPondDefensiveValue .. '; Is tEnemyUnits empty=' .. tostring(M27Utilities.IsTableEmpty(tEnemyUnits)))
            end
            if (aiBrain[reftiPondThreatToUs][iPondWithEnemies] or 0) > iBestPondDefensiveValue and M27Utilities.IsTableEmpty(tEnemyUnits) == false then
                --Can we build on this pond easily?
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': Have a pond with a threat to us of ' .. aiBrain[reftiPondThreatToUs][iPondWithEnemies] .. ' and enemy units in it. Do we have a build location for this pond=' .. repru(tPondDetails[iPondWithEnemies][subrefBuildLocationByStartPosition]) .. '; Our start number=' .. aiBrain.M27StartPositionNumber)
                end
                if M27Utilities.IsTableEmpty(tPondDetails[iPondWithEnemies][subrefBuildLocationByStartPosition][aiBrain.M27StartPositionNumber]) == false then
                    iPondWanted = iPondWithEnemies
                    iBestPondDefensiveValue = (aiBrain[reftiPondThreatToUs][iPondWithEnemies] or 0)
                end
            end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return iPondWanted
end

function GetShieldBoatsWanted(aiBrain, oFactory)
    --Returns the number wanted ignoring tech and power limitations, i.e. based solely on naval composition
    --oFactory can also just be a unit (e.g. the shield unit itself)
    local bDebugMessages = false
    if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetShieldBoatsWanted'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    local iPond = oFactory[refiAssignedPond] or GetPondToFocusOn(aiBrain)

    function GetExistingCruisers()
        local iExistingCruisers = 0
        if M27Utilities.IsTableEmpty(M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond]) == false then
            local tExistingCruisers = EntityCategoryFilterDown(M27UnitInfo.refCategoryCruiser, M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyUnitsByPond][iPond])
            if M27Utilities.IsTableEmpty(tExistingCruisers) == false then
                iExistingCruisers = table.getn(tExistingCruisers)
            end
        end
        return iExistingCruisers
    end


    local iShieldBoatsWanted = 0
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain index='..aiBrain:GetArmyIndex()..'; Factory='..oFactory.UnitId..M27UnitInfo.GetUnitLifetimeCount(oFactory)..'; iPond='..iPond..'; Naval threat for pond='..M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond]..'; iExistingCruisers='..GetExistingCruisers()) end
    if EntityCategoryContains(categories.UEF, oFactory.UnitId) then
        --1 for every 3.5k surface threat, provided have at least 1.5k threat
        if M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] >= 1750 then
            iShieldBoatsWanted = math.min(5, math.max(1, M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] / 3500))
        end
    elseif EntityCategoryContains(categories.AEON, oFactory.UnitId) then
        if M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] >= 1200 then
            iShieldBoatsWanted = math.min(5, math.max(1, M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] / 1500))
            local iExistingCruisers = GetExistingCruisers()
            if iExistingCruisers > 0 then iShieldBoatsWanted = iShieldBoatsWanted + math.min(3, iExistingCruisers) end
        end
    elseif EntityCategoryContains(categories.SERAPHIM, oFactory.UnitId) then
        if M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] >= 2000 then
            iShieldBoatsWanted = math.min(3, math.max(1, M27Team.tTeamData[aiBrain.M27Team][M27Team.refiFriendlyNavalThreatByPond][iPond] / 2500))
            local iExistingCruisers = GetExistingCruisers()
            if iExistingCruisers > 0 then iShieldBoatsWanted = iShieldBoatsWanted + math.min(2, iExistingCruisers) end
        end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return iShieldBoatsWanted
end
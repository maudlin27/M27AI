---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 09/10/2021 07:26
local BuildingTemplates = import('/lua/BuildingTemplates.lua').BuildingTemplates
local M27MapInfo = import('/mods/M27AI/lua/AI/M27MapInfo.lua')
local M27Utilities = import('/mods/M27AI/lua/M27Utilities.lua')
local M27PlatoonUtilities = import('/mods/M27AI/lua/AI/M27PlatoonUtilities.lua')
local AdjacencyBuffs = import("/lua/sim/adjacencybuffs.lua")

refPathingTypeAmphibious = 'Amphibious'
refPathingTypeNavy = 'Water'
refPathingTypeAir = 'Air'
refPathingTypeLand = 'Land'
refPathingTypeNone = 'None'
refPathingTypeAll = {refPathingTypeAmphibious, refPathingTypeNavy, refPathingTypeAir, refPathingTypeLand}

refiPathingCheckCount = 'M27UnitPathingCheckCount' --Increases by 1 each time do a pathing check on a unit
refiPathingCheckTime = 'M27UnitPathingCheckTime' --Total time taken for any pathing checks on this unit

--Special information
--[[refiLastTimeGotDistanceToStart = 'M27UnitDistToStartTime'
refiDistanceToStart = 'M27UnitDistToStartDist'
refiLastTimeGotDistanceToEnemy = 'M27UnitDistToEnemyTime'
refiDistanceToEnemyt = 'M27UnitDistToENemyDist'--]]
refbShieldIsDisabled = 'M27UnitShieldDisabled'
refbSpecialMicroActive = 'M27UnitSpecialMicroActive' --e.g. if dodging bombers
refiGameTimeToResetMicroActive = 'M27UnitGameTimeToResetMicro'
refiGameTimeMicroStarted = 'M27UnitGameTimeMicroStarted'
refbOverchargeOrderGiven = 'M27UnitOverchargeOrderGiven'
refiTimeOfLastOverchargeShot = 'M27UnitOverchargeShotFired' --gametime of actual firing of overcharge shot
refsUpgradeRef = 'M27UnitUpgradeRef' --If ACU starts an upgrade, it records the string reference here
refbPaused = 'M27UnitPaused' --true if paused due to poewr stall manager
refbRecentlyDealtDamage = 'M27UnitRecentlyDealtDamage' --true if dealt damage in last 5s
refiGameTimeDamageLastDealt = 'M27UnitTimeLastDealtDamage'
refoFactoryThatBuildThis = 'M27UnitFactoryThatBuildThis'
refbFullyUpgraded = 'M27UnitFullyUpgraded' --used on ACU to avoid running some checks every time it wants an upgrade
refbRecentlyRemovedHealthUpgrade = 'M27UnitRecentlyRemovedHealthUpgrade' --Used on ACU to flag if e.g. we removed T2 which will decrease our health
refbActiveMissileChecker = 'M27UnitMissileTracker' --True if are actively checking for missile targets
refbActiveSMDChecker = 'M27UnitSMDChecker' -- true if unit is checking for enemy SMD (use on nuke)
refbActiveTargetChecker = 'M27UnitActiveTargetChecker' --e.g. used for T3 fixed arti, Quantum optics, hive
refoLastTargetUnit = 'M27UnitLastTargetUnit' --e.g. indirect fire units will update this when given an IssueAttack order; hives will update when given a reclaim order; T3 arti will update when they are told to attack a specific unit
refsAdjacencyRef = 'M27UnitAdjacencyRef' --Used to store the adjacency reference for adjacency.lua so can easil lookup without needing to recalcaulte each time
reftAdjacencyPGensWanted = 'M27UnitAdjacentPGensWanted' --Table, [x] = subref: 1 = category wanted; 2 = buildlocation
refiSubrefCategory = 1 --for reftAdjacencyPGensWanted
refiSubrefBuildLocation = 2 --for reftAdjacencyPGensWanted
refiTimeOfLastCheck = 'M27UnitTimeOfLastCheck' --Currently used for T3 arti adjacency, when first detected enemy SMD, when last checked if shot was blocked, but could be used for other things if want
refiTimeLastFired = 'M27UnitTimeLastFired' --currently used for sniperbots and ACU, but could expand if wanted
refbLastShotBlocked = 'M27UnitLastShotBlocked' --Used for DF units to indicate if last shot was blocked
refiTimeOfLastSMDCheck = 'M27UnitTimeOfLastSMDCheck'
refbLastCoveredBySMD = 'M27UnitCoveredBySMD' --Used to record if unit was last covered by SMD
refbSniperRifleEnabled = 'M27UnitSniperRifleEnabled' --True if seraphim sniperbot has its long range sniperrifle enabled
refiTimeConstructed = 'M27UnitTimeConstructed' --Game seconds when unit was constructed; only called for M27 units
refsPathing = 'M27UnitPathing' --Pathing type of the unit
reftPathingGroupCount = 'M27UnitPathingGroupCount' --Count of the pathing groups the unit has been in
refiLastPathingGroup = 'M27UnitLastPathingGroup' --Last pathing group of the unit where there was sufficient count (done in platoon utilities)
reftLastLocationOfPathingGroup = 'M27UnitLastLocationOfPathingGroup' --Unit's position when it last had a pathing group with sufficient count
--refoOriginalBrainOwner = 'M27UnitOriginalOwner' --DO NOT USE - Looks like varaibles recorded against a unit pre-transfer get wiped out post-transfer; However also looks like units have a .oldowner field which should give this info
refbTreatAsVisible = 'M27UnitTreatAsVisible' --used for unseen T2PD that damages us - means we will calculate threat on it
reftLastKnownPosition = 'M27UnitLastKnownPosition' --Used for naval units to try and avoid AI cheating while giving it a basic memory
refbIsDangerousAA = 'M27UnitIsDangerousAA' --true if have added to table due to being dangeorus
reftbInArmyIndexBigThreatTable = 'M27UnitInBigThreatTable' --[x] is army index; true if have added unit to table of big threats for that army index
refiCaptureAttempts = 'M27UnitCaptureAttempts' --number of times an engineer has given a capture order against this unit

--Order related - used for navy (platoon uses platoon tracking)
reftLastOrderTarget = 'M27UnitLastOrderTarget' --location of last target (e.g. for issuemove)
refoLastOrderUnitTarget = 'M27UnitLastUnitOrderTarget' --Unit targeted (e.g. for issueattack)

--Strike damage/coordinated attack (currently used for sniperbots):
refiDFStrikeDamageAssigned = 'M27UnitDFStrikeDamage' --cumulative value of strike damage assigned to this unit
reftDFUnitsAttacking = 'M27UnitDFUnitsAttacking' --table of untis that have been told to attack this unit and are having their strike damage tracked
refoCoordinatedTarget = 'M27UnitCoordinatedTarget' --Unit that are targeting as part of a coordinated attack
refiStrikeDamage = 'M27UnitStrikeDamage' --Strike damage that have assigned to the coordinatedtarget
refiTimeOfLastStrikeDamageUpdate = 'M27UnitLastStrikeDamageUpdate' --Time that last updated the strike damage assigned to a unit

--TMD:
refbTMDChecked = 'M27TMDChecked' --Used against enemy TML to flag if we've already checked for TMD we want when it was first detected
reftPositionWhenTMDChecked = 'M27PositionTMDCheck' --Used for enemy TML and mobile long range missiles (e.g. cruisers) to flag if we've checked for TMD near the current position
reftTMLDefence = 'M27TMLDefence' --[sTMLRef] - returns either nil if not considered, or the unit object of TMD protecting it
reftTMLThreats = 'M27TMLThreats' --[sTMLRef] - returns object number of TML that is threatening this unit
refbCantBuildTMDNearby = 'M27CantBuildTMDNearby'
refiNearbyTMD = 'M27TMDNearby' --Number of friendly TMD nearby

--Recorded range (recorded for naval logic)
refiDFRange = 'M27UnitDFRange'
refiIndirectRange = 'M27UnitIndirectRange'
refiAntiNavyRange = 'M27UnitAntiNavyRange'

--Factions
refFactionUEF = 1
refFactionAeon = 2
refFactionCybran = 3
refFactionSeraphim = 4
refFactionNomads = 5
refFactionUnrecognised = 6

--Categories:
--Buildings - eco
refCategoryMex = categories.STRUCTURE * categories.MASSEXTRACTION - categories.NAVAL --Some mods add a naval mex which causes issues as we will try and build on land mexes without naval exclusion
refCategoryT1Mex = refCategoryMex * categories.TECH1
refCategoryT2Mex = refCategoryMex * categories.TECH2
refCategoryT3Mex = refCategoryMex * categories.TECH3
refCategoryHydro = categories.HYDROCARBON - categories.NAVAL

refCategoryPower = categories.STRUCTURE * categories.ENERGYPRODUCTION - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT1Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH1 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT2Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH2 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryT3Power = categories.STRUCTURE * categories.ENERGYPRODUCTION * categories.TECH3 - categories.EXPERIMENTAL - categories.HYDROCARBON
refCategoryMassStorage = categories.STRUCTURE * categories.MASSSTORAGE * categories.TECH1

refCategoryEnergyStorage = categories.STRUCTURE * categories.ENERGYSTORAGE
refCategoryParagon = categories.MASSPRODUCTION * categories.MASSFABRICATION * categories.EXPERIMENTAL
refCategoryMassFab = categories.MASSFABRICATION * categories.STRUCTURE - categories.MASSEXTRACTION - categories.EXPERIMENTAL

--Building - intel and misc
refCategoryAirStaging = categories.STRUCTURE * categories.AIRSTAGINGPLATFORM
refCategoryRadar = categories.STRUCTURE * categories.RADAR + categories.STRUCTURE * categories.OMNI
refCategoryT1Radar = refCategoryRadar * categories.TECH1
refCategoryT2Radar = refCategoryRadar * categories.TECH2
refCategoryT3Radar = refCategoryRadar * categories.TECH3 --+ categories.OMNI * categories.TECH3 (dont need this as refcategoryradar already includes omni)
refCategorySonar = categories.STRUCTURE * categories.SONAR + categories.MOBILESONAR
refCategoryT1Sonar = refCategorySonar * categories.TECH1
refCategoryT2Sonar = refCategorySonar * categories.TECH2
refCategoryT3Sonar = refCategorySonar * categories.TECH3
refCategoryStructure = categories.STRUCTURE - categories.WALL
refCategoryWall = categories.STRUCTURE * categories.WALL --NOTE: Some walls are props; this is for if want a wall that can build
refCategoryUnitsWithOmni = categories.OMNI + categories.COMMAND + categories.OVERLAYOMNI


--Building - factory
refCategoryLandFactory = categories.LAND * categories.FACTORY * categories.STRUCTURE
refCategoryAirFactory = categories.AIR * categories.FACTORY * categories.STRUCTURE - categories.ORBITALSYSTEM --Novax is an air factory, so excluded from being treated as an air factory by my logic
refCategoryNavalFactory = categories.NAVAL * categories.FACTORY * categories.STRUCTURE
refCategoryAllFactories = refCategoryLandFactory + refCategoryAirFactory + refCategoryNavalFactory
refCategoryAllHQFactories = refCategoryAllFactories - categories.SUPPORTFACTORY
refCategoryQuantumGateway = categories.STRUCTURE * categories.GATE * categories.TECH3 * categories.FACTORY

--Building - defensive
refCategoryT2PlusPD = categories.STRUCTURE * categories.DIRECTFIRE - categories.STRUCTURE * categories.DIRECTFIRE * categories.TECH1
refCategoryPD = categories.STRUCTURE * categories.DIRECTFIRE
refCategoryT3PD = refCategoryPD * categories.TECH3
refCategoryTMD = categories.STRUCTURE * categories.ANTIMISSILE - categories.SILO * categories.TECH3 --Not perfect but should pick up most TMD without picking up SMD
refCategoryFixedShield = categories.SHIELD * categories.STRUCTURE
refCategoryFixedT2Arti = categories.STRUCTURE * categories.INDIRECTFIRE * categories.ARTILLERY * categories.TECH2
refCategoryFixedT3Arti = categories.STRUCTURE * categories.INDIRECTFIRE * categories.ARTILLERY * categories.TECH3
refCategoryExperimentalArti = categories.EXPERIMENTAL * categories.ARTILLERY - categories.MOBILE * categories.UEF
refCategorySML = categories.NUKE * categories.SILO
refCategorySMD = categories.ANTIMISSILE * categories.SILO * categories.TECH3 * categories.STRUCTURE
refCategoryTML = categories.SILO * categories.STRUCTURE * categories.TECH2 - categories.ANTIMISSILE
refCategoryUnitsWithTMLUpgrade = categories.COMMAND * categories.UEF + categories.COMMAND * categories.SERAPHIM + categories.SUBCOMMANDER * categories.SERAPHIM
refCategoryNovaxCentre = categories.EXPERIMENTAL * categories.STRUCTURE * categories.ORBITALSYSTEM
refCategorySatellite = categories.EXPERIMENTAL * categories.SATELLITE
--refCategorySAM = categories.ANTIAIR * categories.STRUCTURE * categories.TECH3
refCategoryQuantumOptics = categories.INTELLIGENCE * categories.OPTICS * categories.AEON * categories.STRUCTURE * categories.TECH3 - refCategoryRadar

refCategoryUpgraded = refCategoryT2Radar + refCategoryT3Radar + refCategoryT2Sonar + refCategoryT3Sonar + refCategoryAllFactories * categories.TECH2 + refCategoryAllFactories * categories.TECH3 + refCategoryFixedShield * categories.TECH3 + refCategoryT2Mex + refCategoryT3Mex

--Land units
refCategoryScathis = categories.CYBRAN * categories.ARTILLERY * categories.EXPERIMENTAL
refCategoryExperimentalStructure = refCategoryScathis + categories.STRUCTURE * categories.EXPERIMENTAL
refCategoryLandExperimental = categories.EXPERIMENTAL * categories.MOBILE * categories.LAND - categories.CYBRAN * categories.ARTILLERY - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryMonkeylord = refCategoryLandExperimental * categories.BOT * categories.DIRECTFIRE - categories.SNIPER
refCategoryMegalith = refCategoryLandExperimental * categories.BOT * categories.DIRECTFIRE * categories.SNIPER
refCategoryMobileLand = categories.LAND * categories.MOBILE  - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryEngineer = categories.LAND * categories.MOBILE * categories.ENGINEER - categories.COMMAND - categories.FIELDENGINEER -categories.SUBCOMMANDER --Dont include sparkys as they cant build a lot of things, so just treat them as a combat unit that can reclaim
refCategoryRASSACU = categories.SUBCOMMANDER * categories.RASPRESET + categories.SUBCOMMANDER * categories.SERAPHIM
refCategoryRover = categories.POD * categories.ENGINEER * categories.MOBILE - categories.CONSTRUCTION -refCategoryEngineer
refCategoryHive = categories.STRUCTURE * categories.STATIONASSISTPOD * categories.ENGINEERSTATION
refCategoryKennel = categories.STRUCTURE * categories.ENGINEERSTATION * categories.PODSTAGINGPLATFORM
refCategoryEngineerStation = refCategoryRover + refCategoryHive + refCategoryKennel

refCategoryMAA = categories.LAND * categories.MOBILE * categories.ANTIAIR - categories.EXPERIMENTAL
refCategoryAttackBot = categories.LAND * categories.MOBILE * categories.DIRECTFIRE * categories.BOT + categories.LAND * categories.MOBILE * categories.TANK * categories.TECH1 * categories.SERAPHIM - refCategoryMAA -categories.REPAIR --(repair exclusion added as basic way to differentiate between mantis (which has repair category) and LAB; alternative way is to specify the fastest when choosing the blueprint to build
refCategoryDFTank = categories.LAND * categories.MOBILE * categories.DIRECTFIRE - categories.SCOUT - refCategoryMAA - categories.UNSELECTABLE - categories.UNTARGETABLE --NOTE: Need to specify slowest (so dont pick LAB)
refCategoryLandScout = categories.LAND * categories.MOBILE * categories.SCOUT
refCategoryCombatScout = categories.SERAPHIM * categories.SCOUT * categories.DIRECTFIRE
refCategoryIndirect = categories.LAND * categories.MOBILE * categories.INDIRECTFIRE - categories.DIRECTFIRE - refCategoryLandExperimental - refCategoryScathis - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryT3MobileArtillery = categories.ARTILLERY * categories.LAND * categories.MOBILE * categories.TECH3 - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryT3MML = categories.SILO * categories.MOBILE * categories.TECH3 * categories.LAND - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryFatboy = categories.EXPERIMENTAL * categories.UEF * categories.MOBILE * categories.LAND * categories.ARTILLERY - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryLandCombat = categories.MOBILE * categories.LAND * categories.DIRECTFIRE + categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH1 + categories.FIELDENGINEER + refCategoryFatboy + categories.SUBCOMMANDER - refCategoryEngineer -refCategoryLandScout -refCategoryMAA - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryAmphibiousCombat = refCategoryLandCombat * categories.HOVER + refCategoryLandCombat * categories.AMPHIBIOUS - categories.ANTISHIELD * categories.AEON --Dont include aeon T3 anti-shield here as it sucks unless against shields
refCategorySurfaceAmphibiousCombat = refCategoryLandCombat * categories.HOVER + categories.ANTINAVY * categories.LAND * categories.MOBILE - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryGroundAA = refCategoryMAA + categories.NAVAL * categories.ANTIAIR + categories.STRUCTURE * categories.ANTIAIR + categories.NAVALCARRIER * categories.EXPERIMENTAL
refCategoryStructureAA = categories.STRUCTURE * categories.ANTIAIR
refCategoryIndirectT2Plus = categories.MOBILE * categories.LAND * categories.INDIRECTFIRE - categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH1 - categories.DIRECTFIRE
refCategoryIndirectT2Below = categories.MOBILE * categories.INDIRECTFIRE * categories.LAND * categories.TECH1 + categories.MOBILE * categories.INDIRECTFIRE * categories.LAND * categories.TECH2
refCategoryIndirectT3 = categories.MOBILE * categories.LAND * categories.INDIRECTFIRE * categories.TECH3 - categories.DIRECTFIRE
--Obsidian special case with shields due to inconsistent categories:
refCategoryObsidian = categories.AEON * categories.TECH2 * categories.SHIELD * categories.DIRECTFIRE * categories.MOBILE * categories.LAND * categories.TANK --
refCategoryMobileLandShield = categories.LAND * categories.MOBILE * categories.SHIELD - refCategoryObsidian  --Miscategorised obsidian tank
refCategoryPersonalShield = categories.PERSONALSHIELD + refCategoryObsidian
refCategoryMobileLandStealth = categories.LAND * categories.MOBILE * categories.STEALTHFIELD - categories.EXPERIMENTAL --dont want monkeylords treated as a mobile stealth unit!
refCategorySniperBot = categories.MOBILE * categories.SNIPER * categories.LAND
refCategorySkirmisher = refCategorySniperBot * categories.TECH3 + refCategoryDFTank * categories.UEF * categories.TECH2 * categories.BOT + refCategoryDFTank * categories.CYBRAN * categories.TECH2 * categories.BOT - categories.BOMB --Mongoose, Hoplite, sniperbot
refCategoryShieldDisruptor = categories.LAND * categories.MOBILE * categories.ANTISHIELD


--Air units
refCategoryAirScout = categories.AIR * categories.SCOUT
refCategoryAirAA = categories.AIR * categories.ANTIAIR - categories.BOMBER - categories.GROUNDATTACK - categories.EXPERIMENTAL
refCategoryBomber = categories.AIR * categories.BOMBER - categories.ANTINAVY - categories.CANNOTUSEAIRSTAGING --excludes mercies
refCategoryFighterBomber = categories.AIR * categories.ANTIAIR * categories.BOMBER - categories.EXPERIMENTAL
refCategoryGunship = categories.AIR * categories.GROUNDATTACK
refCategoryNoFriendlyFireGunships = refCategoryGunship * categories.TECH3 + refCategoryGunship * categories.TECH1 + refCategoryGunship * categories.UEF * categories.TECH2 + refCategoryGunship * categories.SERAPHIM * categories.TECH2
refCategoryTorpBomber = categories.AIR * categories.BOMBER * categories.ANTINAVY
refCategoryAllAir = categories.MOBILE * categories.AIR - categories.UNTARGETABLE --Excludes novax
refCategoryAllNonExpAir = categories.MOBILE * categories.AIR * categories.TECH1 + categories.MOBILE * categories.AIR * categories.TECH2 + categories.MOBILE * categories.AIR * categories.TECH3
refCategoryAirNonScout = refCategoryAllAir - categories.SCOUT
refCategoryMercy = categories.HIGHPRIAIR * categories.AEON * categories.BOMBER * categories.TECH2
refCategoryTransport = categories.AIR * categories.TRANSPORTATION - categories.UEF * categories.GROUNDATTACK
refCategoryRestorer = refCategoryGunship * categories.ANTIAIR
refCategoryCzar = categories.AIR * categories.EXPERIMENTAL * categories.ANTIAIR * categories.AEON

--Naval units
refCategoryFrigate = categories.NAVAL * categories.FRIGATE
refCategoryNavalSurface = categories.NAVAL - categories.SUBMERSIBLE - categories.UNSELECTABLE - categories.UNTARGETABLE --NOTE: This includes structures (e.g. torp launcher and factory)
refCategoryMobileNavalSurface = refCategoryNavalSurface * categories.MOBILE
refCategoryAllNavy = categories.NAVAL - categories.UNSELECTABLE - categories.UNTARGETABLE
refCategoryNavalAA = refCategoryAllNavy * categories.ANTIAIR
refCategoryCruiser = categories.NAVAL * categories.CRUISER
refCategorySalem = categories.NAVAL * categories.AMPHIBIOUS * categories.DIRECTFIRE
refCategorySeraphimDestroyer = categories.SUBMERSIBLE * categories.DESTROYER
refCategoryDestroyer = categories.DESTROYER
refCategoryCruiserCarrier = refCategoryCruiser + categories.NAVAL * categories.NAVALCARRIER
refCategorySupportNavy = refCategoryCruiserCarrier + categories.SHIELD * categories.HOVER + categories.SHIELD * categories.NAVAL + categories.STEALTHFIELD * categories.HOVER + categories.STEALTHFIELD * categories.NAVAL --Intended for units we dont want on frontline unless in bombardment mode
refCategoryTorpedoLauncher = categories.ANTINAVY * categories.STRUCTURE
refCategoryAllAmphibiousAndNavy = categories.NAVAL + categories.AMPHIBIOUS + categories.HOVER + refCategoryTMD + refCategoryTorpedoLauncher + refCategorySonar + refCategoryStructureAA --NOTE: Structures have no category indicating whether they can be built on sea (instead they have aquatic ability) hence the need to include all structures
refCategoryPondFixedCategory = refCategoryNavalSurface - categories.AMPHIBIOUS * categories.MOBILE + refCategoryTMD + refCategoryTorpedoLauncher + refCategorySonar + refCategoryStructureAA
refCategoryNavyThatCanBeTorpedoed = categories.NAVAL + categories.AMPHIBIOUS + categories.STRUCTURE + categories.COMMAND + refCategoryEngineer - categories.HOVER --NOTE: Structures have no category indicating whether they can be built on sea (instead they have aquatic ability) hence the need to include all structures; Hover units cant be targeted
refCategoryTorpedoLandAndNavy = categories.ANTINAVY * categories.LAND + categories.ANTINAVY * categories.NAVAL + categories.OVERLAYANTINAVY * categories.LAND + categories.ANTINAVY * categories.STRUCTURE --If removing overlayantinavy then think up better solution for fatboy/experimentals so they dont run when in water
refCategoryMissileShip = categories.NAVAL * categories.SILO + categories.BATTLESHIP * categories.INDIRECTFIRE - categories.BATTLESHIP * categories.SERAPHIM --i.e. UEF+Sera cruisers, and nukesubs
refCategorySubmarine = categories.NAVAL * categories.SUBMERSIBLE * categories.ANTINAVY
refCategoryCooper = categories.NAVAL * categories.ANTINAVY * categories.TECH2 - categories.SUBMERSIBLE - categories.DESTROYER
refCategoryShieldBoat = categories.NAVAL * categories.SHIELD + categories.HOVER * categories.SHIELD --Includes mobile land shields that can hover
refCategoryStealthBoat = categories.NAVAL * categories.STEALTHFIELD
refCategoryBattlecruiser = categories.BATTLESHIP * categories.PRODUCTFA * categories.UEF
refCategoryBattleship = categories.BATTLESHIP - refCategoryBattlecruiser - refCategoryMissileShip


--Multi-category:
--Antinavy mobile units (can include land units - e.g for land factories to build antisub units)
refCategoryAntiNavy = categories.ANTINAVY * categories.STRUCTURE + categories.ANTINAVY * categories.MOBILE --for some reason get error message if just use antinavy, so need to be more restrictive
--Dangerous to land units, e.g. engieners look for these when deciding reclaim area
refCategoryDangerousToLand = refCategoryLandCombat + refCategoryIndirect + refCategoryAllNavy + refCategoryBomber + refCategoryGunship + refCategoryPD + refCategoryFixedT2Arti
refCategoryAllNonAirScoutUnits = categories.MOBILE + refCategoryStructure + refCategoryAirNonScout
refCategoryStealthGenerator = categories.STEALTHFIELD
refCategoryStealthAndCloakPersonal = categories.STEALTH
refCategoryProtectFromTML = refCategoryT2Mex + refCategoryT3Mex + refCategoryT2Power + refCategoryT3Power + refCategoryFixedT2Arti
refCategoryExperimentalLevel = categories.EXPERIMENTAL + refCategoryFixedT3Arti + refCategorySML
refCategoryFirebaseSuitable = refCategoryPD + refCategoryT1Radar + refCategoryT2Radar + refCategorySMD + refCategoryTMD + refCategoryFixedShield + refCategoryFixedT2Arti + refCategoryStructureAA
refCategoryLongRangeDFLand = refCategoryFatboy + refCategorySniperBot + refCategoryShieldDisruptor
refCategoryLongRangeMobile = refCategoryLongRangeDFLand + refCategoryNavalSurface * categories.DIRECTFIRE + refCategoryNavalSurface * categories.INDIRECTFIRE - refCategoryNavalSurface * categories.TECH1 + refCategoryIndirectT2Plus
refCategoryShortRangeMobile = refCategoryLandCombat + refCategoryFrigate - refCategoryLongRangeMobile
refCategoryReclaimable = categories.RECLAIMABLE - refCategoryAllAir

--Weapon target priorities - note these use string categories. Use "," within 's in place of "+", and just have a space in place of "*"
--refWeaponPriorityACU = {categories.COMMAND, refCategoryMobileLandShield, refCategoryFixedShield, refCategoryPD, refCategoryLandCombat, categories.MOBILE, refCategoryStructure - categories.BENIGN, categories.ALLUNITS - categories.BENIGN}
refWeaponPriorityACU = {'COMMAND', 'MOBILE LAND SHIELD', 'STRUCTURE SHIELD', 'SNIPER', 'CYBRAN MOBILE TECH2 DIRECTFIRE BOT, UEF MOBILE TECH2 DIRECTFIRE BOT', 'TECH1 INDIRECTFIRE', 'DIRECTFIRE, INDIRECTFIRE', 'ALLUNITS'}
--refWeaponPriorityNormal = {refCategoryMobileLandShield, refCategoryFixedShield, refCategoryPD, refCategorySkirmisher, refCategoryLandCombat - categories.COMMAND, refCategoryEngineer, categories.LAND * categories.MOBILE, refCategoryStructure - categories.BENIGN, categories.ALLUNITS - categories.BENIGN}
refWeaponPriorityNormal =  {'MOBILE LAND SHIELD', 'STRUCTURE SHIELD', 'SNIPER', 'CYBRAN MOBILE TECH2 DIRECTFIRE BOT, UEF MOBILE TECH2 DIRECTFIRE BOT', 'TECH1 INDIRECTFIRE', 'RECLAIMABLE DIRECTFIRE', 'RECLAIMABLE INDIRECTFIRE', 'RECLAIMABLE ENGINEER', 'MOBILE LAND', 'STRUCTURE', 'ALLUNITS'}
    --refWeaponPriorityPD = {refCategoryMobileLandShield, refCategoryFixedShield, refCategoryPD, refCategoryIndirect, refCategorySkirmisher, refCategoryLandCombat - categories.COMMAND, refCategoryEngineer, categories.LAND * categories.MOBILE, refCategoryStructure - categories.BENIGN, categories.ALLUNITS - categories.BENIGN}
refWeaponPriorityPD = {'MOBILE LAND SHIELD', 'STRUCTURE SHIELD', 'STRUCTURE DIRECTFIRE', 'MOBILE INDIRECTFIRE', 'SNIPER', 'CYBRAN MOBILE TECH2 DIRECTFIRE BOT, UEF MOBILE TECH2 DIRECTFIRE BOT', 'RECLAIMABLE DIRECTFIRE, RECLAIMABLE INDIRECTFIRE', 'RECLAIMABLE ENGINEER', 'MOBILE LAND', 'STRUCTURE', 'ALLUNITS'}
--refWeaponPriorityShieldDisruptor = {refCategoryFixedShield, refCategoryMobileLandShield, refCategoryPersonalShield + refCategoryFatboy, refCategoryRadar, categories.ALLUNITS - categories.BENIGN}
refWeaponPriorityShieldDisruptor = {'STRUCTURE SHIELD', 'MOBILE SHIELD', 'PERSONALSHIELD', 'STRUCTURE RADAR', 'ALLUNITS'}
--refWeaponPriorityOurGroundExperimental = {categories.COMMAND, refCategoryLandExperimental, categories.EXPERIMENTAL, refCategoryFixedT2Arti, refCategoryT3PD, refCategoryPD, refCategoryFixedShield, refCategoryLandCombat * categories.TECH3, refCategoryStructure - categories.TECH1, refCategoryLandCombat, categories.MOBILE, refCategoryStructure - categories.BENIGN, categories.ALLUNITS - categories.BENIGN}
refWeaponPriorityOurGroundExperimental = {'COMMAND', 'EXPERIMENTAL LAND', 'EXPERIMENTAL', 'STRUCTURE SHIELD', 'STRUCTURE DIRECTFIRE', 'STRUCTURE INDIRECTFIRE', 'MOBILE LAND DIRECTFIRE TECH3', 'MOBILE LAND INDIRECTFIRE TECH3', 'MOBILE LAND DIRECTFIRE TECH2', 'MOBILE LAND TECH2', 'ALLUNITS'}
--refWeaponPriorityOurFatboy = {refCategoryFixedShield, refCategoryFixedT2Arti, refCategoryLandExperimental, categories.EXPERIMENTAL, refCategoryT3PD, refCategoryPD, categories.COMMAND, refCategoryLandCombat * categories.TECH3, refCategoryStructure - categories.TECH1, refCategoryLandCombat, categories.MOBILE, refCategoryStructure - categories.BENIGN, categories.ALLUNITS - categories.BENIGN}
refWeaponPriorityOurFatboy = {'STRUCTURE SHIELD', 'STRUCTURE ARILLERY TECH2', 'EXPERIMENTAL MOBILE LAND', 'EXPERIMENTAL', 'STRUCTURE DIRECTFIRE TECH3', 'MOBILE LAND INDIRECTFIRE TECH3', 'STRUCTURE DIRECTFIRE', 'COMMAND', 'MOBILE LAND DIRECTFIRE TECH3', 'STRUCTURE TECH2, STRUCTURE TECH3', 'MOBILE LAND DIRECTFIRE, MOBILE LAND INDIRECTFIRE', 'STRUCTURE', 'ALLUNITS'}
--refWeaponPriorityTorpBomber = {refCategoryCruiser, refCategoryCruiserCarrier, refCategoryFrigate, refCategoryNavyThatCanBeTorpedoed, categories.ALLUNITS - categories.BENIGN}
refWeaponPriorityTorpBomber = {'NAVAL CRUISER, NAVAL CARRIER, NAVAL ANTIAIR, NAVAL FRIGATE, NAVAL, ALLUNITS'}
--refWeaponPriorityT2Arti = {refCategoryFatboy, refCategoryIndirectT2Plus + refCategoryFixedT2Arti, refCategoryFixedShield + refCategoryCruiser, refCategoryNavalSurface + refCategoryStructure - categories.TECH1 + refCategoryMobileLandShield, refCategoryStructure + refCategoryLandCombat - categories.TECH1, categories.LAND - categories.BENIGN, categories.ALLUNITS - categories.BENIGN}
refWeaponPriorityT2Arti = {'EXPERIMENTAL MOBILE LAND FACTORY', 'INDIRECTFIRE TECH2, INDIRECTFIRE TECH3 MOBILE', 'STRUCTURE SHIELD, CRUISER', 'DESTROYER, BATTLESHIP', 'STRUCTURE TECH2, STRUCTURE TECH3, STRUCTURE EXPERIMENTAL, MOBILE LAND SHIELD, MOBILE NAVAL SHIELD', 'STRUCTURE', 'DIRECTFIRE, INDIRECTFIRE', 'ALLUNITS'}
refWeaponPrioritySniperBot = {'EXPERIMENTAL MOBILE LAND', 'TECH3 MOBILE LAND DIRECTFIRE, TECH3 MOBILE LAND INDIRECTFIRE', 'STRUCTURE DIRECTFIRE, STRUCTURE INDIRECTFIRE, STRUCTURE SHIELD', 'NAVAL', 'TECH2 MOBILE LAND DIRECTFIRE', 'STRUCTURE', 'DIRECTFIRE, INDIRECTFIRE', 'ALLUNITS'}

refWeaponPriorityMissileShip = {'SHIELD STRUCTURE, ANTIMISSILE STRUCTURE', 'STRUCTURE INDIRECTFIRE ARTILLERY TECH2', 'EXPERIMENTAL STRUCTURE, STRUCTURE ARTILLERY TECH3, STRUCTURE TECH3 SILO', 'STRUCTURE TECH3 VOLATILE', 'STRUCTURE TECH3 ECONOMIC', 'STRUCTURE NAVAL TECH3, STRUCTURE NAVAL TECH2', 'STRUCTURE TECH3', 'STRUCTURE TECH2 ECONOMIC', 'STRUCTURE TECH2', 'STRUCTURE VOLATILE, STRUCTURE DEFENSE, STRUCTURE FACTORY, STRUCTURE INTELLIGENCE', 'STRUCTURE', 'NAVAL SHIELD', 'SHIELD', 'EXPERIMENTAL NAVAL', 'EXPERIMENTAL', 'TECH3 NAVAL', 'TECH2 NAVAL', 'INDIRECTFIRE NAVAL', 'TECH3', 'TECH2', 'ALLUNITS'}
refWeaponPriorityBattleShip = {'EXPERIMENTAL NAVAL, TECH3 NAVAL', 'TECH2 NAVAL', 'STRUCTURE SHIELD', 'STRUCTURE INDIRECTFIRE ARTILLERY', 'EXPERIMENTAL STRUCTURE, STRUCTURE TECH3 SILO, STRUCTURE TECH3 VOLATILE', 'MOBILE LAND EXPERIMENTAL, MOBILE LAND TECH3 DIRECTFIRE, MOBILE LAND TECH3 INDIRECTFIRE', 'EXPERIMENTAL', 'NAVAL', 'STRUCTURE', 'ALLUNITS'}
refWeaponPriorityDestroyer = {'SUBMERSIBLE', 'EXPERIMENTAL NAVAL, TECH3 NAVAL', 'TECH2 NAVAL', 'STRUCTURE SHIELD', 'STRUCTURE INDIRECTFIRE ARTILLERY', 'EXPERIMENTAL STRUCTURE, STRUCTURE TECH3 SILO, STRUCTURE TECH3 VOLATILE', 'MOBILE LAND EXPERIMENTAL, MOBILE LAND HOVER DIRECTFIRE', 'MASSPRODUCTION TECH2, MASSPRODUCTION TECH3', 'MOBILE LAND TECH3 DIRECTFIRE, MOBILE LAND TECH3 INDIRECTFIRE', 'EXPERIMENTAL', 'NAVAL', 'STRUCTURE', 'ALLUNITS'}


function GetUnitLifetimeCount(oUnit)
    local sCount = oUnit.M27LifetimeUnitCount

    if sCount == nil then
        if oUnit.GetAIBrain and oUnit.GetUnitId then
            local aiBrain = oUnit:GetAIBrain()
            local sUnitId = oUnit.UnitId
            if aiBrain.M27LifetimeUnitCount == nil then aiBrain.M27LifetimeUnitCount = {} end
            if aiBrain.M27LifetimeUnitCount[sUnitId] == nil then
                aiBrain.M27LifetimeUnitCount[sUnitId] = 1
            else aiBrain.M27LifetimeUnitCount[sUnitId] = aiBrain.M27LifetimeUnitCount[sUnitId] + 1 end
            sCount = aiBrain.M27LifetimeUnitCount[sUnitId]
            oUnit.M27LifetimeUnitCount = sCount
        else
            sCount = 'nil'
        end
    end
    return sCount
end

function GetBlueprintIDFromBuildingType(buildingType, tBuildingTemplate)
    --Returns blueprintID based on buildingType and buildingTemplate; buildingTemplate should be series of tables containing the building types and blueprint IDs for a particular faction
    for Key, Data in tBuildingTemplate do
        if Data[1] == buildingType and Data[2] then
            return Data[2]
        end
    end
end

function GetBlueprintIDFromBuildingTypeAndFaction(buildingType, iFactionNumber)
    --Returns the BlueprintID for a building type and faction number (see the BuildingTemplates lua file for a list of all building types)
    --To get iFactionNumber use e.g. factionIndex = aiBrain:GetFactionIndex()
    --1: UEF, 2: Aeon, 3: Cybran, 4: Seraphim, 5: Nomads
    --Alternatively could get faction of a unit, using the FactionName = 'Aeon' property
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    if bDebugMessages == true then LOG('About to print out entire building template:'..repru(BuildingTemplates)) end
    local tBuildingTemplateForFaction = BuildingTemplates[iFactionNumber]
    return GetBlueprintIDFromBuildingType(buildingType, tBuildingTemplateForFaction)
end

function GetFactionFromBP(oBlueprint)
    --Returns faction number for oBlueprint
    --1: UEF, 2: Aeon, 3: Cybran, 4: Seraphim, 5: Nomads, 6 = not recognised
    --Note: General.FactionName property uses lowercase for some factions; the categories.x uses upper case
    --Assumed nomads is Nomads

    local tFactionsByName = {'UEF', 'Aeon', 'Cybran', 'Seraphim', 'Nomads'}
    local sUnitFactionName = oBlueprint.General.FactionName
    for iName, sName in tFactionsByName do
        if sName == sUnitFactionName then return iName end
    end
    return 6
end

function GetBlueprintFromID(sBlueprintID)
    --returns blueprint based on the blueprintID
    return __blueprints[string.lower(sBlueprintID)]
end

function GetUnitFaction(oUnit)
    ----1: UEF, 2: Aeon, 3: Cybran, 4: Seraphim, 5: Nomads, 6 = not recognised
    return GetFactionFromBP(oUnit:GetBlueprint())
end

function GetBuildingSize(BlueprintID)
    --Returns table with X and Z size of sBlueprintID
    local tSizeXZ = {}
    local oBlueprint = GetBlueprintFromID(BlueprintID)
    tSizeXZ[1] = oBlueprint.Physics.SkirtSizeX
    tSizeXZ[2] = oBlueprint.Physics.SkirtSizeZ
    return tSizeXZ
end

function GetUnitPathingType(oUnit)
    --Returns Land, Amphibious, Air or Water or None
    --if oUnit and not(oUnit.Dead) and oUnit.GetBlueprint then
        local mType = __blueprints[oUnit.UnitId].Physics.MotionType
        if (mType == 'RULEUMT_AmphibiousFloating' or mType == 'RULEUMT_Hover' or mType == 'RULEUMT_Amphibious') then
            return refPathingTypeAmphibious
        elseif (mType == 'RULEUMT_Water' or mType == 'RULEUMT_SurfacingSub') then
            return refPathingTypeNavy
        elseif mType == 'RULEUMT_Air' then
            return refPathingTypeAir
        elseif (mType == 'RULEUMT_Biped' or mType == 'RULEUMT_Land') then
            return refPathingTypeLand
        else return refPathingTypeNone
        end
    --else
        --M27Utilities.ErrorHandler('oUnit is nil or doesnt have a GetBlueprint function')
    --end
end

function GetUnitUpgradeBlueprint(oUnitToUpgrade, bGetSupportFactory)
    --Returns support factory ID if it can be built, otherwise returns normal upgrade unit (works for any unit, not just factory)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitUpgradeBlueprint'
    --if EntityCategoryContains(refCategoryAirFactory, oUnitToUpgrade.UnitId) then bDebugMessages = true end

    if bGetSupportFactory == nil then bGetSupportFactory = true end
    --Gets the support factory blueprint, and checks if it can be built; if not then returns the normal UpgradesTo blueprint
    local sUpgradeBP
    if not(oUnitToUpgrade.Dead) and oUnitToUpgrade.CanBuild then
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code, UnitToUpgrade='..oUnitToUpgrade.UnitId..GetUnitLifetimeCount(oUnitToUpgrade)) end
        if bGetSupportFactory == true and oUnitToUpgrade.CanBuild then
            local tsSupportFactoryBP = {

                -- Aeon
                ['uab0101']  = 'zab9501',
                ['uab0102']  = 'zab9502',
                ['uab0103']  = 'zab9503',
                ['uab0201'] = 'zab9601',
                ['uab0202'] = 'zab9602',
                ['uab0203'] = 'zab9603',

                -- UEF
                ['ueb0101']  = 'zeb9501',
                ['ueb0102']  = 'zeb9502',
                ['ueb0103']  = 'zeb9503',
                ['ueb0201'] = 'zeb9601',
                ['ueb0202'] = 'zeb9602',
                ['ueb0203'] = 'zeb9603',

                -- Cybran
                ['urb0101']  = 'zrb9501',
                ['urb0102']  = 'zrb9502',
                ['urb0103']  = 'zrb9503',
                ['urb0201'] = 'zrb9601',
                ['urb0202'] = 'zrb9602',
                ['urb0203'] = 'zrb9603',

                -- Seraphim
                ['xsb0101']  = 'zsb9501',
                ['xsb0102']  = 'zsb9502',
                ['xsb0103']  = 'zsb9503',
                ['xsb0201'] = 'zsb9601',
                ['xsb0202'] = 'zsb9602',
                ['xsb0203'] = 'zsb9603',

                --Nomads
                ['xnb0101'] = 'znb9501',
                ['znb9501'] = 'znb9601',
                ['xnb0201'] = 'znb9601',
                ['xnb0102'] = 'znb9502',
                ['znb9502'] = 'znb9602',
                ['xnb0202'] = 'znb9602',
                ['xnb0103'] = 'znb9503',
                ['xnb0203'] = 'znb9603',
                ['znb9503'] = 'znb9603',
            }

            local sFactoryBP = oUnitToUpgrade.UnitId
            if tsSupportFactoryBP[sFactoryBP] then
                if bDebugMessages == true then LOG(sFunctionRef..': Support factoryBP='..tsSupportFactoryBP[sFactoryBP]) end
                sUpgradeBP = tsSupportFactoryBP[sFactoryBP]
                if bDebugMessages == true then LOG(sFunctionRef..': oUnitToUpgrade='..sFactoryBP..GetUnitLifetimeCount(oUnitToUpgrade)..'; Checking if can upgrade to sUpgradeBP='..sUpgradeBP..'; oUnitToUpgrade:CanBuild(sUpgradeBP)='..tostring(oUnitToUpgrade:CanBuild(sUpgradeBP))) end
                if not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build '..sUpgradeBP) end
                    sUpgradeBP = nil
                end
            end
        end
        if not(sUpgradeBP) then
            local oFactoryBP = oUnitToUpgrade:GetBlueprint()
            sUpgradeBP = oFactoryBP.General.UpgradesTo
            if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeBP='..(sUpgradeBP or 'nil')) end
            if not(sUpgradeBP) or sUpgradeBP == '' or not(oUnitToUpgrade:CanBuild(sUpgradeBP)) then sUpgradeBP = nil end
            if bDebugMessages == true then LOG(sFunctionRef..': Didnt have valid support factory to upgrade to; blueprint UpgradesTo='..(sUpgradeBP or 'nil')) end
        end
        if sUpgradeBP == '' then
            sUpgradeBP = nil
            if bDebugMessages == true then LOG(sFunctionRef..': Have no blueprint to upgrade to') end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Returning sUpgradeBP'..(sUpgradeBP or 'nil'))
        end
    end

    return sUpgradeBP
end

function IsUnitUnderwaterAmphibious(oUnit)
    local oUnitBP = oUnit:GetBlueprint()
    local bIsUnderwater = false
    if oUnitBP.Physics and oUnitBP.Physics.MotionType then
        if oUnitBP.Physics.MotionType == 'RULEUMT_Amphibious' then
            bIsUnderwater = true
        end
    end
    return bIsUnderwater
end

function GetUnitIDTechLevel(sUnitId)
    local iTechLevel = 1
    if EntityCategoryContains(categories.TECH1, sUnitId) then iTechLevel = 1
    elseif EntityCategoryContains(categories.TECH2, sUnitId) then iTechLevel = 2
    elseif EntityCategoryContains(categories.TECH3, sUnitId) then iTechLevel = 3
    elseif EntityCategoryContains(categories.EXPERIMENTAL, sUnitId) then iTechLevel = 4
    end
    return iTechLevel
end

function GetUnitTechLevel(oUnit)
    local sUnitId = oUnit.UnitId
    local iTechLevel = 1
    if EntityCategoryContains(categories.TECH1, sUnitId) then iTechLevel = 1
    elseif EntityCategoryContains(categories.TECH2, sUnitId) then iTechLevel = 2
    elseif EntityCategoryContains(categories.TECH3, sUnitId) then iTechLevel = 3
    elseif EntityCategoryContains(categories.EXPERIMENTAL, sUnitId) then iTechLevel = 4
    end
    return iTechLevel
end

function ConvertTechLevelToCategory(iTechLevel)
    if iTechLevel == 2 then return categories.TECH2
    elseif iTechLevel == 3 then return categories.TECH3
    elseif iTechLevel == 4 then return categories.EXPERIMENTAL
    else return categories.TECH1
    end
end

function GetUnitStrikeDamage(oUnit)
    --Gets strike damage of the first weapon in oUnit (longer term might want to make better so it considers other weapons)
    --For bombers will be subject to a minimum value as some bombers will have
    local oBP = oUnit:GetBlueprint()
    local sBP = oUnit.UnitId
    local iStrikeDamage = 0


    if EntityCategoryContains(refCategoryBomber, sBP) then
        --Doublecheck strike damage based on if it references a bomb
        local iAOE
        iAOE, iStrikeDamage = GetBomberAOEAndStrikeDamage(oUnit)
    elseif EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, sBP) then
        iStrikeDamage = GetSniperStrikeDamage(oUnit)
    elseif oBP.Weapon and oBP.Weapon[1] then
        iStrikeDamage = oBP.Weapon[1].Damage
    end
        return iStrikeDamage
end

function IsUnitUnderwater(oUnit)
    if oUnit.GetPosition and oUnit.GetBlueprint then
        return M27MapInfo.IsUnderwater({oUnit:GetPosition()[1], oUnit:GetPosition()[2] + (oUnit:GetBlueprint().SizeY or 0), oUnit:GetPosition()[3]}, false)
    else return false
    end
end

function IsUnitOnOrUnderWater(oUnit)
    if M27MapInfo.GetSegmentGroupOfLocation(refPathingTypeLand, oUnit:GetPosition()) == M27MapInfo.iLandPathingGroupForWater then
        return true
    else return false
    end
end

function IsEnemyUnitAnEngineer(aiBrain, oEnemyUnit)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsEnemyUnitAnEngineer'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local bIsEngineer = true
    local iEnemySpeed
    if oEnemyUnit.GetUnitId then

        local sEnemyID = oEnemyUnit.UnitId

        if EntityCategoryContains(categories.STRUCTURE, sEnemyID) then bIsEngineer = false
        else
            --function CanSeeUnit(aiBrain, oUnit, bTrueIfOnlySeeBlip)
            if M27Utilities.CanSeeUnit(aiBrain, oEnemyUnit, false) then
                if not(EntityCategoryContains(refCategoryEngineer, sEnemyID)) then bIsEngineer = false end
            else
                local oEnemyBP = oEnemyUnit:GetBlueprint()
                if oEnemyBP.Physics then
                    iEnemySpeed = oEnemyBP.Physics.MaxSpeed
                    if not(iEnemySpeed == 1.9) then bIsEngineer = false end
                end
             end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if oEnemyUnit with ID='..sEnemyID..' is an engineer; bIsEngineer='..tostring(bIsEngineer)..'; iEnemySpeed if we have calculated it='..(iEnemySpeed or 'nil')) end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return bIsEngineer
end

function GetACUShieldRegenRate(oUnit)
    --Cycles through every possible enhancement, sees if the unit has it, and if so what its shield regen rate is, and returns the max value
    local iRegenRate = 0
    if oUnit.HasEnhancement then
        local oBP = oUnit:GetBlueprint()
        if M27Utilities.IsTableEmpty(oBP.Enhancements) == false then
            for sEnhancement, tEnhancement in oBP.Enhancements do
                if oUnit:HasEnhancement(sEnhancement) and tEnhancement.ShieldRegenRate then
                    iRegenRate = math.max(iRegenRate, tEnhancement.ShieldRegenRate)
                end
            end
        end
    end
    return iRegenRate
end

function GetACUHealthRegenRate(oUnit)
    --Cycles through every ACU enhancement and factors it into its health regen, along with veterancy
    local oBP = oUnit:GetBlueprint()
    local iRegenRate = (oBP.Defense.RegenRate or 0)

    --Adjust for veterancy:
    local iVetLevel = (oUnit.VetLevel or oUnit.Sync.VeteranLevel or 0)
    if iVetLevel > 0 and oBP.Buffs.Regen then
        local iCurVet = 0
        for iVet, iRegenMod in oBP.Buffs.Regen do
            iCurVet = iCurVet + 1
            if iCurVet == iVetLevel then
                iRegenRate = iRegenRate + iRegenMod
                break
            end
        end
    end

    --Adjust for enhancements
    if M27Utilities.IsTableEmpty(oBP.Enhancements) == false then
        for iEnhancement, tEnhancement in oBP.Enhancements do
            if tEnhancement.NewRegenRate and oUnit:HasEnhancement(iEnhancement) then
                iRegenRate = iRegenRate + tEnhancement.NewRegenRate
            end
        end
    end

    return iRegenRate

end

function GetCurrentAndMaximumShield(oUnit, bIgnoreIfShieldFailedFromLowPower)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetCurrentAndMaximumShield'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    local iCurShield = 0
    local iMaxShield = 0
    if oUnit.MyShield then
        iCurShield = oUnit.MyShield:GetHealth()
        iMaxShield = oUnit.MyShield:GetMaxHealth()
    else
        local tShield = oUnit:GetBlueprint().Defense
        if tShield then
            iCurShield = (oUnit:GetShieldRatio(false) or 0) * iMaxShield
        end
    end
    if iCurShield > 0 then
        if not(bIgnoreIfShieldFailedFromLowPower) then
            --GetHealth doesnt look like it factors in power stall
            if not(oUnit.MyShield.Enabled) or oUnit.MyShield.DepletedByEnergy or (oUnit:GetAIBrain():GetEconomyStored('ENERGY') == 0) then iCurShield = 0 end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': iCurShield='..iCurShield..'; iMaxShield='..iMaxShield..'; ShieldRatio False='..oUnit:GetShieldRatio(false)..'; ShieldRatio true='..oUnit:GetShieldRatio(true)..' iCurShield='..iCurShield)
        if oUnit.MyShield then LOG('Unit has MyShield; IsUp='..tostring(oUnit.MyShield:IsUp())..'; shield health='..oUnit.MyShield:GetHealth()) end
    end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    return iCurShield, iMaxShield
end

--Below commented out because after profiling, the time savings are negligible so doesnt justify the loss of accuracy
--[[function GetUnitDistanceFromOurStart(aiBrain, oUnitOrPlatoon)
    --Intended to only be called once every cycle
    local iCurTime = math.floor(GetGameTimeSeconds())
    if oUnitOrPlatoon[refiLastTimeGotDistanceToStart] == iCurTime then return oUnitOrPlatoon[refiDistanceToStart]
    else
        oUnitOrPlatoon[refiLastTimeGotDistanceToStart] = iCurTime
        local tPosition = M27PlatoonUtilities.GetPlatoonFrontPosition(oUnitOrPlatoon)
        return M27Utilities.GetDistanceBetweenPositions(tPosition, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
    end
end

function GetUnitDistanceFromOurEnemy(aiBrain, oUnit)  end--]]
function IsUnitShieldEnabled(oUnit)
    return not(oUnit[refbShieldIsDisabled])
end
function DisableUnitShield(oUnit)
    oUnit[refbShieldIsDisabled] = true
    oUnit:DisableShield()
end
function EnableUnitShield(oUnit)
    oUnit:EnableShield()
    oUnit[refbShieldIsDisabled] = false
end

function DisableUnitIntel(oUnit)
    --[[
    if oUnit.DisableUnitIntel then
        oUnit:DisableUnitIntel('ToggleBit3', 'Sonar')
        oUnit:DisableUnitIntel('ToggleBit3', 'Omni')
        oUnit:DisableUnitIntel('ToggleBit3', 'Radar')
    end--]]
    oUnit:OnScriptBitSet(3)
end
function EnableUnitIntel(oUnit)
    --[[if oUnit.EnableUnitIntel then
        oUnit:EnableUnitIntel('ToggleBit3', 'Sonar')
        oUnit:EnableUnitIntel('ToggleBit3', 'Omni')
        oUnit:EnableUnitIntel('ToggleBit3', 'Radar')
    end--]]
    oUnit:OnScriptBitClear(3)
end

function DisableUnitJamming(oUnit)
    --[[if oUnit.DisableUnitIntel then
        oUnit:DisableUnitIntel('ToggleBit3', 'Jammer')
    end--]]
    oUnit:OnScriptBitSet(2)
end
function EnableUnitJamming(oUnit)
    --if oUnit.EnableUnitIntel then oUnit:EnableUnitIntel('ToggleBit3', 'Jammer') end
    oUnit:OnScriptBitClear(2)
end

function DisableUnitStealth(oUnit)
    --[[if oUnit.DisableUnitIntel then
        oUnit:DisableUnitIntel('ToggleBit3', 'RadarStealth')--]]

    --[[oUnit:OnScriptBitSet(5) --stealth
    oUnit:OnScriptBitSet(8) --cloak--]]
    oUnit:SetScriptBit('RULEUTC_StealthToggle', true)
    oUnit:SetScriptBit('RULEUTC_CloakToggle', true)
end

function EnableUnitStealth(oUnit)
    --[[oUnit:OnScriptBitClear(5)
    oUnit:OnScriptBitClear(8)
    oUnit:EnableUnitIntel('ToggleBit3', 'RadarStealth')--]]
    oUnit:SetScriptBit('RULEUTC_StealthToggle', false)
    oUnit:SetScriptBit('RULEUTC_CloakToggle', false)
end



function GetUnitFacingAngle(oUnit)
    --0/360 = north, 90 = west, 180 = south, 270 = east

    --T3 arti - get the angle of the turret
    if EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
        if oUnit.GetWeapon and oUnit:GetWeaponCount() > 0 then
            local oWeapon = oUnit:GetWeapon(1)
            if oWeapon and oWeapon.GetAimManipulator then
                return M27Utilities.ConvertRadiansToAngle(oWeapon:GetAimManipulator():GetHeadingPitch())
            else return 0
            end
        else return 0
        end
        if oUnit:IsValidBone('Turret') then
            --0% = south, 25% = east, 50% = north; want to convert from % into angle where 0 is north
            return M27Utilities.ConvertCounterclockwisePercentageToAngle(oUnit:GetBoneDirection('Turret'))
        else
            return 180 - oUnit:GetHeading() / math.pi * 180 --redundancy - for a building this is likeliy to be the same value every time
        end
    else
        --Other units (would expect to be mobile) - get the unit direction
        return 180 - oUnit:GetHeading() / math.pi * 180
    end

end

function IsUnitValid(oUnit, bMustBeComplete)
    --Returns true if unit is constructed and not dead
    --Note - if get error in this that arises from getting threat value of units, then check we're sending a table to the threat value function rather than a single unit
    if not(oUnit) or oUnit.Dead or not(oUnit.GetFractionComplete) or not(oUnit.GetUnitId) or not(oUnit.GetBlueprint) or not(oUnit.GetAIBrain) then return false
    else
        if bMustBeComplete and oUnit:GetFractionComplete() < 1 then return false
        else
            return true
        end
    end
end

function SetUnitTargetPriorities(oUnit, tPriorityTable)
    if IsUnitValid(oUnit) then
        if EntityCategoryContains(refCategoryMAA, oUnit) then M27Utilities.ErrorHandler('Changing weapon priority for MAA') end
        for i =1, oUnit:GetWeaponCount() do
            local wep = oUnit:GetWeapon(i)
            wep:SetWeaponPriorities(tPriorityTable)
        end
    end
end
function GetUnitMissileRange(oUnit)
    local oBP = oUnit:GetBlueprint()
    for iCurWeapon, oCurWeapon in oBP do
        if oCurWeapon.WeaponCategory == 'Missile' then
            return oCurWeapon.MaxRadius
        end
    end
    return nil
end
function GetUnitAARange(oUnit)
    local iMaxRange = 0
    for iCurWeapon, oCurWeapon in oUnit:GetBlueprint().Weapon do
        if oCurWeapon.WeaponCategory == 'Anti Air' then
            if not(oCurWeapon.ManualFire == true) then
                if oCurWeapon.MaxRadius > iMaxRange then iMaxRange = oCurWeapon.MaxRadius end
            end
        end
    end
    return iMaxRange
end

function GetUnitIndirectRange(oUnit, bIncludeManualFire)
    if not(oUnit[refiIndirectRange]) then
        local iMaxRange = 0
        if oUnit.GetBlueprint then
            local oBP = oUnit:GetBlueprint()
            if oBP.Weapon then
                for iCurWeapon, oCurWeapon in oBP.Weapon do
                    if (bIncludeManualFire or not(oCurWeapon.ManualFire)) and (oCurWeapon.WeaponCategory == 'Missile' and not(oCurWeapon.DamageType == 'Nuke')) or oCurWeapon.WeaponCategory == 'Artillery' or oCurWeapon.WeaponCategory == 'Indirect Fire' then
                        if oCurWeapon.MaxRadius > iMaxRange then iMaxRange = oCurWeapon.MaxRadius end
                    end
                end
            end
        end
        oUnit[refiIndirectRange] = iMaxRange
        return iMaxRange
    else
        return oUnit[refiIndirectRange]
    end
end

function GetBlueprintMaxGroundRange(oBP)
    local iMaxRange = 0
    if oBP.Weapon then
        for iCurWeapon, oCurWeapon in oBP.Weapon do
            if oCurWeapon.MaxRadius > iMaxRange and not(oCurWeapon.EnabledByEnhancement) and oCurWeapon.Damage > 0 then
                if oCurWeapon.FireTargetLayerCapsTable and oCurWeapon.FireTargetLayerCapsTable['Land'] == 'Land|Water|Seabed' and not(oCurWeapon.ManualFire) then
                    iMaxRange = math.max(iMaxRange, oCurWeapon.MaxRadius)
                end
            end
        end
    end
    return iMaxRange
end

function GetUnitMaxGroundRange(oUnit)
    if oUnit.GetBlueprint then
        if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
            local iMaxRange = 0
            --Factor in enhancements
            local oBP = oUnit:GetBlueprint()

            if oBP.Weapon then
                for sUpgrade, tEnhancement in oBP.Enhancements or {} do
                    if oUnit:HasEnhancement(sUpgrade) then
                        if tEnhancement['NewMaxRadius'] then
                            iMaxRange = math.max(tEnhancement['NewMaxRadius'], iMaxRange)
                        end
                    end
                end

                for iCurWeapon, oCurWeapon in oBP.Weapon do
                    if oCurWeapon.MaxRadius > iMaxRange and not(oCurWeapon.EnabledByEnhancement) and oCurWeapon.Damage > 0 then
                        if oCurWeapon.FireTargetLayerCapsTable and oCurWeapon.FireTargetLayerCapsTable['Land'] == 'Land|Water|Seabed' and not(oCurWeapon.ManualFire) then
                            iMaxRange = math.max(oCurWeapon.MaxRadius, iMaxRange)
                        end
                    end
                end
            end
            return iMaxRange
        else
            return GetBlueprintMaxGroundRange(oUnit:GetBlueprint())
        end
    else
        return 0
    end
end

function GetNavalDirectAndSubRange(oUnit)
    --Returns higher of units antinavy and directfire range while also updating its antinavy range; also updates indirect range
    if not(oUnit[refiDFRange]) then
        local oBP = oUnit:GetBlueprint()
        local iMaxDFRange = 0
        local iMaxAntiNavyRange = 0
        if oBP.Weapon then
            for iCurWeapon, oCurWeapon in oBP.Weapon do
                if oCurWeapon.RangeCategory == 'UWRC_DirectFire' and not(oCurWeapon.DamageType == 'Nuke') then
                    iMaxDFRange = math.max(iMaxDFRange, oCurWeapon.MaxRadius)
                elseif oCurWeapon.RangeCategory == 'UWRC_AntiNavy' then
                    iMaxAntiNavyRange = math.max(iMaxAntiNavyRange, oCurWeapon.MaxRadius)
                end
            end
        end
        if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then
            --factor in enhancements
            iMaxDFRange = math.max(iMaxDFRange, GetUnitMaxGroundRange(oUnit))
        end
        oUnit[refiDFRange] = iMaxDFRange
        oUnit[refiAntiNavyRange] = iMaxAntiNavyRange
        oUnit[refiIndirectRange] = GetUnitIndirectRange(oUnit, false) --This must come after setting the DF range or will get infinite loop
    end
    return math.max(oUnit[refiDFRange], oUnit[refiAntiNavyRange])
end

function GetUpgradeBuildTime(oUnit, sUpgradeRef)
    --Returns nil if unit cant get enhancements
    local oBP = oUnit:GetBlueprint()
    local iUpgradeTime
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeTime = tUpgrade.BuildTime
            end

        end
    end
    return iUpgradeTime
end

function GetUpgradeMassCost(oUnit, sUpgradeRef)
    local oBP = oUnit:GetBlueprint()
    local iUpgradeMass
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeMass = tUpgrade.BuildCostMass
            end

        end
    end
    if not(iUpgradeMass) then M27Utilities.ErrorHandler('oUnit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' has no upgrade with reference '..sUpgradeRef) end
    return iUpgradeMass
end

function GetUpgradeEnergyCost(oUnit, sUpgradeRef)
    local oBP = oUnit:GetBlueprint()
    local iUpgradeEnergy
    if oBP.Enhancements then
        for sUpgradeID, tUpgrade in oBP.Enhancements do
            if sUpgradeID == sUpgradeRef then
                iUpgradeEnergy = tUpgrade.BuildCostEnergy
            end

        end
    end
    if not(iUpgradeEnergy) then M27Utilities.ErrorHandler('oUnit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' has no upgrade with reference '..sUpgradeRef) end
    return iUpgradeEnergy
end

function GetBomberAOEAndStrikeDamage(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iAOE = 0
    local iStrikeDamage = 0
    local iFiringRandomness
    for sWeaponRef, tWeapon in oBP.Weapon do
        if tWeapon.WeaponCategory == 'Bomb' or tWeapon.WeaponCategory == 'Direct Fire' then
            if (tWeapon.DamageRadius or 0) > iAOE then
                iAOE = tWeapon.DamageRadius
                iStrikeDamage = tWeapon.Damage * tWeapon.MuzzleSalvoSize
                if tWeapon.MuzzleSalvoSize > 2 then iStrikeDamage = iStrikeDamage * 0.5 end
                iFiringRandomness = (tWeapon.FiringRandomness or 0)
            end
        end
    end
    if iStrikeDamage == 0 then
        M27Utilities.ErrorHandler('Couldnt identify strike damage for bomber '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; will refer to predefined value instead')
    end

    --Manual floor for strike damage due to complexity of some bomber calculations
    --Check if manual override is higher, as some weapons will fire lots of shots so above method wont be accurate
    local tiBomberStrikeDamageByFactionAndTech =
    {
        --UEF, Aeon, Cybran, Sera, Nomads (are using default), Default
        { 150, 200, 155, 250, 150, 150 }, --Tech 1
        { 350, 300, 850, 1175, 550, 550 }, --Tech 2
        { 2500, 2500, 2500, 2500, 2500, 2500}, --Tech 3 - the strike damage calculation above should be accurate so this is just as a backup, and set at a low level due to potential for more balance changes affecting this
        { 11000,11000,11000,11000,11000,11000} --Tech 4 - again as a backup
    }
    iStrikeDamage = math.max(iStrikeDamage, tiBomberStrikeDamageByFactionAndTech[GetUnitTechLevel(oUnit)][GetFactionFromBP(oBP)])


    return iAOE, iStrikeDamage, iFiringRandomness
end

function GetLauncherAOEStrikeDamageMinAndMaxRange(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iAOE = 0
    local iStrikeDamage
    local iMinRange = 0
    local iMaxRange = 0
    for sWeaponRef, tWeapon in oBP.Weapon do
        if not(tWeapon.WeaponCategory == 'Death') then
            if (tWeapon.DamageRadius or 0) > iAOE then
                iAOE = tWeapon.DamageRadius
                iStrikeDamage = tWeapon.Damage * tWeapon.MuzzleSalvoSize
            elseif (tWeapon.NukeInnerRingRadius or 0) > iAOE then
                iAOE = tWeapon.NukeInnerRingRadius
                iStrikeDamage = tWeapon.NukeInnerRingDamage
            end
            if (tWeapon.MinRadius or 0) > iMinRange then iMinRange = tWeapon.MinRadius end
            if (tWeapon.MaxRadius or 0) > iMaxRange then iMaxRange = tWeapon.MaxRadius end
        end
    end
    return iAOE, iStrikeDamage, iMinRange, iMaxRange
end

function GetBomberRange(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iRange = 0
    for sWeaponRef, tWeapon in oBP.Weapon do
        if tWeapon.WeaponCategory == 'Bomb' or tWeapon.WeaponCategory == 'Direct Fire' or tWeapon.WeaponCategory == 'Anti Navy' then
            if (tWeapon.MaxRadius or 0) > iRange then
                iRange = tWeapon.MaxRadius
            end
        end
    end
    return iRange
end

function GetBomberSalvoDelay(oUnit)
    local oBP = oUnit:GetBlueprint()
    local iDelay = 0.5 --basic default; in reality should be 0.2 or 0.25 checking zeus, scorcher and janus
    for sWeaponRef, tWeapon in oBP.Weapon do
        if tWeapon.WeaponCategory == 'Bomb' or tWeapon.WeaponCategory == 'Direct Fire' or tWeapon.WeaponCategory == 'Anti Navy' then
            if tWeapon.MuzzleSalvoDelay then return tWeapon.MuzzleSalvoDelay end
        end
    end
    return iDelay
end

function GetBomberSpeedAndTimeToReload(oBomber)
    local oBP = oBomber:GetBlueprint()
    local iTimeToReload = 5
    for iWeapon, tWeapon in oBP.Weapon do
        if tWeapon.WeaponCategory == 'Bomb' then
            if tWeapon.RateOfFire > 0 then iTimeToReload = 1 / tWeapon.RateOfFire end
        end
    end
    return oBP.Air.MaxAirspeed, iTimeToReload
end

function BomberMultiAttackMuzzle(oUnit)
    --Done to help with searching
    return DoesBomberFireSalvo(oUnit)
end
function DoesBomberFireSalvo(oUnit)
    local oBP = oUnit:GetBlueprint()
    for sWeaponRef, tWeapon in oBP.Weapon do
        if tWeapon.WeaponCategory == 'Bomb' or tWeapon.WeaponCategory == 'Direct Fire' or tWeapon.WeaponCategory == 'Anti Navy' then
            if tWeapon.MuzzleSalvoSize == 1 then
                return false
            else return true
            end
        end
    end
end

function PauseOrUnpauseMassUsage(aiBrain, oUnit, bPauseNotUnpause)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PauseOrUnpauseMassUsage'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if EntityCategoryContains(categories.COMMAND + refCategoryAirFactory, oUnit.UnitId) then bDebugMessages = true end

    if bDebugMessages == true then
        local M27Logic = import('/mods/M27AI/lua/AI/M27GeneralLogic.lua')
        LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit state='..M27Logic.GetUnitState(oUnit))
        if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()) end
    end
    if IsUnitValid(oUnit, true) and oUnit.SetPaused then

        --Want to pause unit, check for any special logic for pausing
        local bWasUnitPaused = (oUnit[refbPaused] or false)
        --Normal logic - just pause unit - exception if are dealing with a factory whose workcomplete is 100% and want to pause it
        if not(EntityCategoryContains(refCategoryAllFactories, oUnit.UnitId)) or not(bPauseNotUnpause) or (oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0 and oUnit:GetWorkProgress() < 1) then
            if oUnit.UnitId == 'xsb2401' then M27Utilities.ErrorHandler('Pausing Yolona') end
            oUnit:SetPaused(bPauseNotUnpause)
            if bDebugMessages == true then LOG(sFunctionRef..': Just set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)) end
        elseif bDebugMessages == true then
            LOG(sFunctionRef..': Factory with either no workprogress or workprogress that isnt <1')
            if oUnit.GetWorkProgress then LOG(sFunctionRef..': Workprogress='..oUnit:GetWorkProgress()) end
        end
    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function PauseOrUnpauseEnergyUsage(aiBrain, oUnit, bPauseNotUnpause)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'PauseOrUnpauseEnergyUsage'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
    --if EntityCategoryContains(categories.COMMAND + refCategoryAirFactory, oUnit.UnitId) then bDebugMessages = true end

    if bDebugMessages == true then
        local M27Logic = import('/mods/M27AI/lua/AI/M27GeneralLogic.lua')
        LOG(sFunctionRef..': Start of code, oUnit='..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' owned by brain '..oUnit:GetAIBrain().Nickname..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; Unit state='..M27Logic.GetUnitState(oUnit))
        if oUnit.GetFocusUnit and oUnit:GetFocusUnit() then LOG(sFunctionRef..': Focus unit='..oUnit:GetFocusUnit().UnitId..GetUnitLifetimeCount(oUnit:GetFocusUnit())) end
        if oUnit.GetWorkProgress then LOG(sFunctionRef..': Unit work progress='..oUnit:GetWorkProgress()..'; Unit fraction complete='..oUnit:GetFractionComplete()) end
    end
    if IsUnitValid(oUnit, true) and oUnit.SetPaused then

        --Jamming - check via blueprint since no reliable category
        local oBP = oUnit:GetBlueprint()
        if oBP.Intel.JamRadius then
            if bPauseNotUnpause then DisableUnitJamming(oUnit)
            else EnableUnitJamming(oUnit)
            end
        end

        --Want to pause unit, check for any special logic for pausing
        local bWasUnitPaused = (oUnit[refbPaused] or false)
        oUnit[refbPaused] = bPauseNotUnpause
        if oUnit.MyShield and oUnit.MyShield:GetMaxHealth() > 0 then
            if IsUnitShieldEnabled(oUnit) == bPauseNotUnpause then
                if bPauseNotUnpause then DisableUnitShield(oUnit)
                else EnableUnitShield(oUnit) end
            end
        elseif oBP.Intel.ReactivateTime and (oBP.Intel.SonarRadius or oBP.Intel.RadarRadius) then
            if bPauseNotUnpause then DisableUnitIntel(oUnit)
            else EnableUnitIntel(oUnit)
            end
        elseif oBP.Intel.Cloak or oBP.Intel.RadarStealth or oBP.Intel.RadarStealthFieldRadius then
            if bPauseNotUnpause then DisableUnitStealth(oUnit)
            else EnableUnitStealth(oUnit)
            end
        end
        --Normal logic - just pause unit - exception if are dealing with a factory whose workcomplete is 100%
        if oUnit.SetPaused and (not(EntityCategoryContains(refCategoryAllFactories, oUnit.UnitId)) or not(bPauseNotUnpause) or (oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0 and oUnit:GetWorkProgress() < 1)) then
            if oUnit.UnitId == 'xsb2401' then M27Utilities.ErrorHandler('Pausing Yolona') end
            if bDebugMessages == true then LOG(sFunctionRef..': About to set paused to '..tostring(bPauseNotUnpause)..' for unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)) end
            oUnit:SetPaused(bPauseNotUnpause)

        elseif bDebugMessages == true then
            LOG(sFunctionRef..': Factory with either no workprogress or workprogress that isnt <1')
            if oUnit.GetWorkProgress then LOG(sFunctionRef..': Workprogress='..oUnit:GetWorkProgress()) end
        end

    end

    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)

end

function GetNumberOfUpgradesObtained(oACU)
    --Returns the number of upgrades a unit (e.g. ACU) has got
    local oBP = oACU:GetBlueprint()
    local iUpgradeCount = 0
    if M27Utilities.IsTableEmpty(oBP.Enhancements) == false then
        for sEnhancement, tEnhancement in oACU:GetBlueprint().Enhancements do
            if oACU:HasEnhancement(sEnhancement) and tEnhancement.BuildCostMass > 1 then
                iUpgradeCount = iUpgradeCount + 1
            end
        end
    end
    return iUpgradeCount
end

function GetUnitHealthPercent(oUnit)
    return oUnit:GetHealth() / oUnit:GetMaxHealth()
end



function ScryTarget(oUnit, tTarget)
    oUnit:OnTargetLocation(tTarget)

    --Below for reference - attempts to get things to work (tests 1-4 were put into separate functions, only test2 worked)
    --local RemoteViewingLua = import('/lua/RemoteViewing.lua')
    --LOG('Repr of quantum optics='..reprs(oUnit))
    --LOG('repr of RemoteViewingData='..reprs(oUnit.RemoteViewingData))
    --LOG('Repr of RemoteViewingFunctions='..reprs(oUnit.RemoteViewingData.RemoteViewingFunctions))
    --RemoteViewingLua.RemoteViewing:OnTargetLocation(oUnit, tTarget) --This fails
--[[
    function Test1(oUnit, tTarget)
        local RemoteViewingLua = import('/lua/RemoteViewing.lua')
        local RemoteViewingClass = RemoteViewingLua.RemoteViewingLua
        oUnit:OnTargetLocation(tTarget)
        LOG('Test1')
    end
    function Test2(oUnit, tTarget)
        local RemoteViewingLua = import('/lua/RemoteViewing.lua')
        oUnit:OnTargetLocation(tTarget)
        LOG('Test2')
    end
    function Test3(oUnit, tTarget)
        local RemoteViewingLua = import('/lua/RemoteViewing.lua')
        RemoteViewingLua.OnTargetLocation(oUnit, tTarget)
        LOG('Test3')
    end
    function Test4(oUnit, tTarget)
        local RemoteViewingLua = import('/lua/RemoteViewing.lua')
        oUnit.RemoteViewingLua:OnTargetLocation(tTarget)
        LOG('Test4')
    end--]]

    --ForkThread(Test1, oUnit, tTarget)
    --ForkThread(Test2, oUnit, tTarget)
    --ForkThread(Test3, oUnit, tTarget)
    --ForkThread(Test4, oUnit, tTarget)
    --RemoteViewingLua.RemoteViewing.OnTargetLocation(oUnit, tTarget)
end

function GetTransportMaxCapacity(oTransport, iTechLevelToLoad)
    --https://forums.faforever.com/viewtopic.php?f=2&t=17511#:~:text=It%20can%20carry%20exactly%201,and%20more%20T2%20than%20T3.
    local iFaction = GetUnitFaction(oTransport)
    local tiCapacityByTechAndFaction --[TransportTechLevel][FactionNumber][UnitTechToHold]
    if EntityCategoryContains(categories.UEF * categories.GROUNDATTACK * categories.TECH2 * categories.AIR, oTransport.UnitId) then
        tiCapacityByTechAndFaction = {[2]={[refFactionUEF]={[1]=1,[2]=1,[3]=0,[4]=0}}}
    else tiCapacityByTechAndFaction =
        {[1]={ --T1 transports
            [refFactionUEF]={[1]=6,[2]=2,[3]=1,[4]=0},
            [refFactionAeon]={[1]=6,[2]=3,[3]=1,[4]=0},
            [refFactionCybran]={[1]=6,[2]=2,[3]=1,[4]=0},
            [refFactionSeraphim]={[1]=8,[2]=4,[3]=1,[4]=0},
            [refFactionNomads]={[1]=4,[2]=2,[3]=0,[4]=0}, --Assumed
            [refFactionUnrecognised]={[1]=2,[2]=1,[3]=0,[4]=0}, --assumed
        },
         [2]={
             [refFactionUEF]={[1]=14,[2]=6,[3]=3,[4]=0},
             [refFactionAeon]={[1]=12,[2]=6,[3]=2,[4]=0},
             [refFactionCybran]={[1]=10,[2]=4,[3]=2,[4]=0},
             [refFactionSeraphim]={[1]=16,[2]=8,[3]=4,[4]=0},
             [refFactionNomads]={[1]=8,[2]=4,[3]=2,[4]=0}, --Assumed
             [refFactionUnrecognised]={[1]=2,[2]=1,[3]=0,[4]=0}, --assumed
         },
         [3]={
             [refFactionUEF]={[1]=28,[2]=12,[3]=6,[4]=0},
             [refFactionAeon]={[1]=1,[2]=1,[3]=1,[4]=0},
             [refFactionCybran]={[1]=1,[2]=1,[3]=1,[4]=0},
             [refFactionSeraphim]={[1]=1,[2]=1,[3]=1,[4]=0},
             [refFactionNomads]={[1]=1,[2]=1,[3]=1,[4]=0},
             [refFactionUnrecognised]={[1]=1,[2]=1,[3]=1,[4]=0},
         },
         [4]={ --dummy values
             [refFactionUEF]={[1]=1,[2]=1,[3]=1,[4]=0},
             [refFactionAeon]={[1]=1,[2]=1,[3]=1,[4]=0},
             [refFactionCybran]={[1]=1,[2]=1,[3]=1,[4]=0},
             [refFactionSeraphim]={[1]=1,[2]=1,[3]=1,[4]=0},
             [refFactionNomads]={[1]=1,[2]=1,[3]=1,[4]=0},
             [refFactionUnrecognised]={[1]=1,[2]=1,[3]=1,[4]=0},
         },
        }
    end

    return tiCapacityByTechAndFaction[GetUnitTechLevel(oTransport)][iFaction][iTechLevelToLoad]
end

function GetCategoryConditionFromUnitID(sUnitId)
    --Returns a category condition that has all the categories that the blueprint of sUnitId has
    local iFullCategoryCondition = categories.ALLUNITS
    for iCategory, sCategory in __blueprints[sUnitId].Categories do
        iFullCategoryCondition = iFullCategoryCondition * ParseEntityCategory(sCategory)
    end
    return iFullCategoryCondition
end

function EnableLongRangeSniper(oUnit)
    --If unit has a sniper weapon, then toggle it
    if oUnit.SetWeaponEnabledByLabel and not(oUnit[refbSniperRifleEnabled]) then
        --[[LOG(reprs(oUnit))
        for iWeapon, oWeapon in oUnit.WeaponInstances do

            LOG('iWeapon='..iWeapon..'; Output='..reprs(oWeapon))
        end--]]
        local oBP = oUnit:GetBlueprint()
        local bHaveSniperWeapon = false
        if oBP.Weapon then
            for iWeapon, tWeapon in oBP.Weapon do
                if tWeapon.Label == 'SniperGun' then
                    bHaveSniperWeapon = true
                    break
                end
            end
        end
        --[[if bHaveSniperWeapon then
            --BELOW DIDNT DO ANYTHING
            oUnit:SetWeaponEnabledByLabel('SniperGun', true)
            oUnit:SetWeaponEnabledByLabel('MainGun', false)
            LOG('Enabled sniper gun on unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
        end

        for iWeapon, oWeapon in oUnit.WeaponInstances do
            --BELOW DIDNT DO ANYTHING
            if oWeapon.Label == 'MainGun' then oWeapon:SetWeaponEnabled(false)
            elseif oWeapon.Label == 'SniperGun' then oWeapon:SetWeaponEnabled(true)
            end
            LOG('Alt approach to enabling gun')
        end

        for iWeapon, oWeapon in oUnit.WeaponInstances do
            --BELOW DIDNT DO ANYTHING
            LOG('iWeapon='..iWeapon..'; Label='..oWeapon.Label)
            if oWeapon.Label == 'MainGun' then LOG('Setting enabled to false for this weapon') oWeapon:SetEnabled(false) end
            if oWeapon.Label == 'SniperGun' then LOG('Setting enabled to true for this weapon') oWeapon:SetEnabled(true) end
        end--]]

        if bHaveSniperWeapon then
            oUnit:OnScriptBitSet(1)
            oUnit[refbSniperRifleEnabled] = true
            --LOG('Enabled sniperrifle on unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
        end
    end
end


function DisableLongRangeSniper(oUnit)
    if oUnit.SetWeaponEnabledByLabel and oUnit[refbSniperRifleEnabled] then
        local bHaveSniperWeapon = true
        local oBP = oUnit:GetBlueprint()
        if oBP.Weapon then
            for iWeapon, tWeapon in oBP.Weapon do
                if tWeapon.Label == 'SniperGun' then
                    bHaveSniperWeapon = true
                    break
                end
            end
        end
        if bHaveSniperWeapon then
            oUnit:OnScriptBitClear(1)
            oUnit[refbSniperRifleEnabled] = false
            --LOG('Disabled long range sniper on unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit))
        end
    end
end

function GetDFRateOfFire(oUnit)
    --Intended for sniperbots but in theory could use for other units; returns 1 if no rate of fire found

    local iRateOfFire
    if oUnit.GetBlueprint then
        local oBP = oUnit:GetBlueprint()
        local sWeaponTypeRequired
        if EntityCategoryContains(refCategorySniperBot, oUnit.UnitId) then
            if oUnit[refbSniperRifleEnabled] and table.getn(oBP.Weapon) > 1 then sWeaponTypeRequired = 'SniperGun' end
        end

        if oBP.Weapon then
            for iWeapon, tWeapon in oBP.Weapon do
                if tWeapon.WeaponCategory == 'Direct Fire' then
                    if not(sWeaponTypeRequired) or tWeapon.Label == sWeaponTypeRequired then
                        if iRateOfFire then iRateOfFire = math.min(iRateOfFire, tWeapon.RateOfFire)
                        else iRateOfFire = tWeapon.RateOfFire
                        end
                    end
                end
            end
        end
    end
    if not(iRateOfFire) then iRateOfFire = 1 end
    return iRateOfFire
end

function GetSniperStrikeDamage(oUnit)
    local iStrikeDamage
    local oBP = oUnit:GetBlueprint()
    local sWeaponTypeRequired
    if EntityCategoryContains(refCategorySniperBot * categories.SERAPHIM, oUnit.UnitId) then
        if oUnit[refbSniperRifleEnabled] and table.getn(oBP.Weapon) > 1 then sWeaponTypeRequired = 'SniperGun' end
    end

    if oBP.Weapon then
        for iWeapon, tWeapon in oBP.Weapon do
            if tWeapon.WeaponCategory == 'Direct Fire' then
                if not(sWeaponTypeRequired) or tWeapon.Label == sWeaponTypeRequired then
                    if iStrikeDamage then iStrikeDamage = math.min(iStrikeDamage, tWeapon.Damage)
                    else iStrikeDamage = tWeapon.Damage
                    end
                end
            end
        end
    end
    if not(iStrikeDamage) then iStrikeDamage = 100 end
    return iStrikeDamage
end


function AssignUnitDFStrikeDamage(oAttacker, oTarget, iStrikeDamage)
    local bAlreadyAssigned = false
    if not(oTarget[reftDFUnitsAttacking]) then oTarget[reftDFUnitsAttacking] = {}
    else
        for iUnit, oUnit in oTarget[reftDFUnitsAttacking] do
            if oUnit == oAttacker then
                bAlreadyAssigned = true
                break
            end
        end
    end
    if not(bAlreadyAssigned) then
        table.insert(oTarget[reftDFUnitsAttacking], oAttacker)
        oAttacker[refoCoordinatedTarget] = oTarget
        oAttacker[refiStrikeDamage] = iStrikeDamage
        oTarget[refiDFStrikeDamageAssigned] = (oTarget[refiDFStrikeDamageAssigned] or 0) + iStrikeDamage
    end

end

function RemoveDFStrikeDamageUnitFromTarget(oTarget, oAttacker, iUnitTableRef)
    --iUnitTableRef should be the key/ref value for oTarget[reftDFUnitsAttacking]
    oTarget[refiDFStrikeDamageAssigned] = oTarget[refiDFStrikeDamageAssigned] - (oAttacker[refiStrikeDamage] or GetUnitStrikeDamage(oAttacker))
    oTarget[reftDFUnitsAttacking][iUnitTableRef] = nil
end

function RefreshUnitDFStrikeDamage(oTarget)
    --Removes any outdated units assigned to target for strike damage purposes, if we haven't checked recently
    if GetGameTimeSeconds() - (oTarget[refiTimeOfLastStrikeDamageUpdate] or 0) >= 0.99 then
        oTarget[refiTimeOfLastStrikeDamageUpdate] = GetGameTimeSeconds()
        if M27Utilities.IsTableEmpty(oTarget[reftDFUnitsAttacking]) then
            oTarget[refiDFStrikeDamageAssigned] = 0
        else
            if not(oTarget[refiDFStrikeDamageAssigned]) then oTarget[refiDFStrikeDamageAssigned] = 0 end
            local bRemoveUnit
            for iUnit, oUnit in oTarget[reftDFUnitsAttacking] do
                bRemoveUnit = false
                if not(IsUnitValid(oUnit)) or not(oUnit.PlatoonHandle) or not(oUnit[refoCoordinatedTarget]) or not(oUnit[refoCoordinatedTarget] == oTarget) then
                    bRemoveUnit = true
                elseif not(oUnit.PlatoonHandle[M27PlatoonUtilities.refiCurrentAction] == M27PlatoonUtilities.refActionCoordinatedAttack) then
                    bRemoveUnit = true
                elseif M27Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), oUnit:GetPosition()) > 5 + oUnit.PlatoonHandle[M27PlatoonUtilities.refiPlatoonMaxRange] then
                    bRemoveUnit = true
                end
                if bRemoveUnit then
                    RemoveDFStrikeDamageUnitFromTarget(oTarget, oUnit, iUnit)
                end
            end
        end
    end
end

function IsEnemyUnitLikelyMoving(oUnit)
    --Intended for combat units - currently used by T3 arti to decide if should try and lead with shots
    --local M27Logic = import('/mods/M27AI/lua/AI/M27GeneralLogic.lua') --This is only for the below log
    --LOG('Considering if unit '..oUnit.UnitId..GetUnitLifetimeCount(oUnit)..' is likely moving. Fractioncomplete='..oUnit:GetFractionComplete()..'; Unit state='..M27Logic.GetUnitState(oUnit)..'; Navigator target='..repru(oUnit:GetNavigator():GetCurrentTargetPos())..'; Range='..math.max(GetNavalDirectAndSubRange(oUnit), GetUnitIndirectRange(oUnit))..'; Postiion='..repru(oUnit:GetPosition())..'; Dist to target='..M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oUnit:GetNavigator():GetCurrentTargetPos()))
    if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and oUnit:GetFractionComplete() == 1 then
        function IsUnitAttackingOutOfRangeTarget(oAttacker)
            if oAttacker.GetNavigator then
                local oNavigator = oAttacker:GetNavigator()
                if oNavigator and M27Utilities.IsTableEmpty(oNavigator:GetCurrentTargetPos()) == false then
                    local iRange = math.max(GetNavalDirectAndSubRange(oAttacker), GetUnitIndirectRange(oAttacker))
                    if iRange < M27Utilities.GetDistanceBetweenPositions(oNavigator:GetCurrentTargetPos(), oAttacker:GetPosition()) then
                        return true
                    end
                end
            end
            return false
        end


        if oUnit:IsUnitState('Moving') then
            return true
        elseif oUnit:IsUnitState('Attacking') then
            --Get navigation target and if it's close to being in range
            return IsUnitAttackingOutOfRangeTarget(oUnit)
        elseif oUnit:IsUnitState('Guarding') then
            if oUnit.GetGuardedUnit then
                local oGuardedUnit = oUnit:GetGuardedUnit()
                if IsUnitValid(oGuardedUnit) then
                    return IsEnemyUnitLikelyMoving(oGuardedUnit)
                end
            end
        end
    end
    return false
end

function ToggleUnitDiveOrSurfaceStatus(oUnit)
    --Assumes have already checked that the unit is or isnt underwater
    M27Utilities.IssueTrackedClearCommands({ oUnit})
    IssueDive({oUnit})
    local M27UnitMicro = import('/mods/M27AI/lua/AI/M27UnitMicro.lua')
    M27UnitMicro.TrackTemporaryUnitMicro(oUnit, 1)
end
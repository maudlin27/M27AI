---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 08/10/2021 13:05
---

local M27UnitInfo = import('/mods/M27AI/lua/AI/M27UnitInfo.lua')
local M27UnitMicro = import('/mods/M27AI/lua/AI/M27UnitMicro.lua')
local M27EngineerOverseer = import('/mods/M27AI/lua/AI/M27EngineerOverseer.lua')
local M27AirOverseer = import('/mods/M27AI/lua/AI/M27AirOverseer.lua')
local M27Utilities = import('/mods/M27AI/lua/M27Utilities.lua')
local M27Overseer = import('/mods/M27AI/lua/AI/M27Overseer.lua')
local M27PlatoonFormer = import('/mods/M27AI/lua/AI/M27PlatoonFormer.lua')
local M27PlatoonUtilities = import('/mods/M27AI/lua/AI/M27PlatoonUtilities.lua')
local M27MapInfo = import('/mods/M27AI/lua/AI/M27MapInfo.lua')
local M27Conditions = import('/mods/M27AI/lua/AI/M27CustomConditions.lua')
local M27Logic = import('/mods/M27AI/lua/AI/M27GeneralLogic.lua')
local M27Config = import('/mods/M27AI/lua/M27Config.lua')
local M27Transport = import('/mods/M27AI/lua/AI/M27Transport.lua')
local M27EconomyOverseer = import('/mods/M27AI/lua/AI/M27EconomyOverseer.lua')
local M27PlatoonTemplates = import('/mods/M27AI/lua/AI/M27PlatoonTemplates.lua')


local refCategoryEngineer = M27UnitInfo.refCategoryEngineer
local refCategoryAirScout = M27UnitInfo.refCategoryAirScout

function OnPlayerDefeated(aiBrain)
    aiBrain.M27IsDefeated = true

    --Was it an M27AI assigned to a chokepoint? If so then have any teammates no longer adopt a turtle strategy
    if aiBrain.M27AI and aiBrain[M27MapInfo.refiAssignedChokepointCount] then
        for iBrain, oBrain in M27Overseer.tTeamData[aiBrain.M27Team][M27Overseer.reftFriendlyActiveM27Brains] do
            if not(oBrain == aiBrain) then
                oBrain[aiBrain[M27MapInfo.refiAssignedChokepointCount]] = nil
                oBrain[M27Overseer.refiDefaultStrategy] = oBrain[M27Overseer.refStrategyLandMain]
                oBrain[M27Overseer.refiAIBrainCurrentStrategy] = oBrain[M27Overseer.refiDefaultStrategy]
            end
        end
    end

    for iArmyIndex, oBrain in M27Overseer.tAllAIBrainsByArmyIndex do
        if aiBrain == oBrain then
            M27Overseer.tAllAIBrainsByArmyIndex[iArmyIndex] = nil
            M27Overseer.tAllActiveM27Brains[iArmyIndex] = nil
        elseif oBrain.M27AI then
            ForkThread(M27Overseer.RecordAllEnemiesAndAllies, oBrain)
        end
    end
end

function OnKilled(oUnitKilled, instigator, type, overkillRatio)
    --WARNING: Doesnt trigger when an ACU is killed

    --NOTE: Called by any unit of any player being killed; also note that OnUnitDeath triggers as well as this
    --i.e. this shoudl be used for where only want to get an event where the unit was killed by something
    --Is the unit owned by M27AI?
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnKilled'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': oUnitKilled='..oUnitKilled.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitKilled)..'; Is unit killed an ACU='..tostring(M27Utilities.IsACU(oUnitKilled))) end

        if oUnitKilled.GetAIBrain then
            local oKilledBrain = oUnitKilled:GetAIBrain()
            if oKilledBrain.M27AI then
                --were we killed by something?
                local oKillerUnit
                if instigator and not(instigator:BeenDestroyed()) and not(instigator.Dead) then
                    if instigator.Launcher then
                        oKillerUnit = instigator.Launcher
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                    if oKillerUnit and oKillerUnit.GetAIBrain then
                        M27AirOverseer.CheckForUnseenKiller(oKilledBrain, oUnitKilled, oKillerUnit)
                        if EntityCategoryContains(M27UnitInfo.refCategoryFixedT2Arti, oKillerUnit.UnitId) then
                            if oKillerUnit.Sync.totalMassKilled >= 250 and IsEnemy(oKilledBrain:GetArmyIndex(), oKillerUnit:GetAIBrain():GetArmyIndex()) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add oKillerUnit='..oKillerUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oKillerUnit)..' to list of T2 arti to avoid') end
                                --Is this already in the table?
                                local bIncludeInTable = true
                                if M27Utilities.IsTableEmpty(M27Overseer.tTeamData[oKilledBrain.M27Team][M27Overseer.reftEnemyArtiToAvoid]) == false then
                                    for iArti, oArti in M27Overseer.tTeamData[oKilledBrain.M27Team][M27Overseer.reftEnemyArtiToAvoid] do
                                        if oArti == oKillerUnit then
                                            bIncludeInTable = false
                                        end
                                    end
                                end
                                if bIncludeInTable then
                                    table.insert(M27Overseer.tTeamData[oKilledBrain.M27Team][M27Overseer.reftEnemyArtiToAvoid], oKillerUnit)
                                    --Also check for any nearby t2 arti that are closer to the killed unit's base
                                    local tNearbyT2Arti = oKillerUnit:GetAIBrain():GetUnitsAroundPoint(M27UnitInfo.refCategoryFixedT2Arti, oKillerUnit:GetPosition(), 30, 'Ally')
                                    local iDistToBase = M27Utilities.GetDistanceBetweenPositions(oKillerUnit:GetPosition(), M27MapInfo.PlayerStartPoints[oKilledBrain.M27StartPositionNumber])
                                    if M27Utilities.IsTableEmpty(tNearbyT2Arti) == false then
                                        for iUnit, oUnit in tNearbyT2Arti do
                                            if not(oUnit == oKillerUnit) then
                                                if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M27MapInfo.PlayerStartPoints[oKilledBrain.M27StartPositionNumber]) < iDistToBase then
                                                    bIncludeInTable = true
                                                    for iArti, oArti in M27Overseer.tTeamData[oKilledBrain.M27Team][M27Overseer.reftEnemyArtiToAvoid] do
                                                        if oUnit == oArti then
                                                            bIncludeInTable = false
                                                        end
                                                    end
                                                    if bIncludeInTable then
                                                        table.insert(M27Overseer.tTeamData[oKilledBrain.M27Team][M27Overseer.reftEnemyArtiToAvoid], oKillerUnit)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                --Firebase tracking
                if EntityCategoryContains(M27UnitInfo.refCategoryFirebaseSuitable, oUnitKilled.UnitId) then
                    oKilledBrain[M27EngineerOverseer.refbPotentialFirebaseBuildingChangedSinceLastFirebaseCheck] = true
                end


                --Hive assistance for fixed shields
                if EntityCategoryContains(M27UnitInfo.refCategoryHive, oUnitKilled.UnitId) then
                    local aiBrain = oUnitKilled:GetAIBrain()
                    local tNearbyHives = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryHive, oUnitKilled:GetPosition(), 20, 'Ally')
                    if M27Utilities.IsTableEmpty(tNearbyHives) then
                        local tNearbyFixedShields = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryFixedShield, oUnitKilled:GetPosition(), 23, 'Ally')
                        if M27Utilities.IsTableEmpty(tNearbyFixedShields) == false then
                            --Is the shield already flagged as wanting a hive?
                            for iNearbyShield, oNearbyShield in tNearbyFixedShields do
                                local bAddToTable = true
                                if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftShieldsWantingHives]) == false then

                                    for iShield, oShield in aiBrain[M27EngineerOverseer.reftShieldsWantingHives] do
                                        if oShield == oNearbyShield then
                                            bAddToTable = false
                                            break
                                        end
                                    end
                                end
                                if bAddToTable then table.insert(aiBrain[M27EngineerOverseer.reftShieldsWantingHives], oNearbyShield) end
                            end
                        end
                    end
                end

                if EntityCategoryContains(M27UnitInfo.refCategoryPD, oUnitKilled.UnitId) then
                    --If a PD that didnt compelte construction then track mass value so we adjust PD effectiveness
                    if not(oUnitKilled.M27OnConstructedCalled) then
                        oKilledBrain[M27EngineerOverseer.refiMassSpentOnPD] = oKilledBrain[M27EngineerOverseer.refiMassSpentOnPD] + oUnitKilled:GetBlueprint().Economy.BuildCostMass * 0.5
                    end
                    --Adjust firebase overall PD mass values
                    if oUnitKilled[M27EngineerOverseer.refiAssignedFirebase] then
                        oKilledBrain[M27EngineerOverseer.reftiFirebaseDeadPDMassCost][oUnitKilled[M27EngineerOverseer.refiAssignedFirebase]] = (oKilledBrain[M27EngineerOverseer.reftiFirebaseDeadPDMassCost][oUnitKilled[M27EngineerOverseer.refiAssignedFirebase]] or 0) + oUnitKilled:GetBlueprint().Economy.BuildCostMass * oUnitKilled:GetFractionComplete()
                        oKilledBrain[M27EngineerOverseer.reftiFirebaseDeadPDMassKills][oUnitKilled[M27EngineerOverseer.refiAssignedFirebase]] = (oKilledBrain[M27EngineerOverseer.reftiFirebaseDeadPDMassKills][oUnitKilled[M27EngineerOverseer.refiAssignedFirebase]] or 0) + (oUnitKilled.Sync.totalMassKilled or 0)
                    end
                end

                --Skirmisher tracking
                if EntityCategoryContains(M27UnitInfo.refCategorySkirmisher, oUnitKilled.UnitId) then
                    --We already track the mass killed generally from the unitdeath event; this is only for tracking if it died to DF unit
                    if oKillerUnit and EntityCategoryContains(categories.LAND * categories.MOBILE, oKillerUnit.UnitId) then
                        local aiBrain = oUnitKilled:GetAIBrain()
                        aiBrain[M27Overseer.refiSkirmisherMassDeathsFromLand] = aiBrain[M27Overseer.refiSkirmisherMassDeathsFromLand] + oUnitKilled:GetBlueprint().Economy.BuildCostMass
                    end
                end
            end
            --Did a PD or skirmisher we own kill something?
            if instigator and not(instigator.Launcher) and instigator.UnitId and IsUnit(instigator) then
                local oKillerBrain = instigator:GetAIBrain()
                if oKillerBrain.M27AI then
                    if EntityCategoryContains(M27UnitInfo.refCategoryPD, instigator.UnitId) then
                        oKillerBrain[M27EngineerOverseer.refiMassKilledByPD] = oKillerBrain[M27EngineerOverseer.refiMassKilledByPD] + oUnitKilled:GetBlueprint().Economy.BuildCostMass
                    elseif EntityCategoryContains(M27UnitInfo.refCategoryTML, instigator.UnitId) then
                        --Did we kill something with a TML that wasnt our last target (so e.g. a unit might have managed to block the TML missile meaning we can try again)?
                        if M27UnitInfo.IsUnitValid(instigator[M27EngineerOverseer.refoLastTMLTarget]) then
                            if bDebugMessages == true then LOG(sFunctionRef..': TML last target='..instigator[M27EngineerOverseer.refoLastTMLTarget].UnitId..M27UnitInfo.GetUnitLifetimeCount(instigator[M27EngineerOverseer.refoLastTMLTarget])..'; shots fired at last target='..(instigator[M27EngineerOverseer.refoLastTMLTarget][M27EngineerOverseer.refiTMLShotsFired] or 0)..'; Mass killed currently='..instigator.Sync.totalMassKilled..'; mass killed when fired missile='..instigator[M27EngineerOverseer.refiLastTMLMassKills]) end
                            --if instigator[M27EngineerOverseer.refiLastTMLMassKills] < (instigator.Sync.totalMassKilled or 0) and (instigator[M27EngineerOverseer.refoLastTMLTarget][M27EngineerOverseer.refiTMLShotsFired] or 0) > 0 then
                            --if bDebugMessages == true then LOG(sFunctionRef..': TML killed a unit that wasnt its last target so missile may have been blocked') end

                            --Allow to go to -1 to give a small margin for error incase e.g. the next time it is blocked by a higher health unit
                            instigator[M27EngineerOverseer.refoLastTMLTarget][M27EngineerOverseer.refiTMLShotsFired] = math.max((instigator[M27EngineerOverseer.refoLastTMLTarget][M27EngineerOverseer.refiTMLShotsFired] or 1) - 1, -1)
                            --end
                        end
                    elseif EntityCategoryContains(M27UnitInfo.refCategorySkirmisher, instigator.UnitId) then
                        local aiBrain = instigator:GetAIBrain()
                        aiBrain[M27Overseer.refiSkirmisherMassKills] = aiBrain[M27Overseer.refiSkirmisherMassKills] + oUnitKilled:GetBlueprint().Economy.BuildCostMass
                    elseif EntityCategoryContains(M27UnitInfo.refCategorySatellite, instigator.UnitId) then
                        ForkThread(M27AirOverseer.NovaxCoreTargetLoop, oKillerBrain, instigator, true)
                    elseif EntityCategoryContains(M27UnitInfo.refCategoryBomber * categories.TECH1,  instigator.UnitId) and M27UnitInfo.IsUnitValid(instigator) then
                        --if M27UnitInfo.GetUnitLifetimeCount(instigator) == 4 then bDebugMessages = true end
                        if bDebugMessages == true then LOG(sFunctionRef..': Killer unit='..instigator.UnitId..M27UnitInfo.GetUnitLifetimeCount(instigator)..'; is instigator valid='..tostring(M27UnitInfo.IsUnitValid(instigator))..'; unit killed='..oUnitKilled.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitKilled)) end
                        if EntityCategoryContains(M27UnitInfo.refCategoryT1Mex, oUnitKilled.UnitId) then
                            --T1 mex just killed by T1 bomber - get bomber to target nearby enemy engineer (if any)
                            ForkThread(M27AirOverseer.OneOffTargetNearbyEngineer, oKillerBrain, instigator)
                        else
                            --if just killed an engineer that were trying to kill then also look to kill another nearby engineer (this wont run if this is an engi hunter bomber, i.e. intended for bombers that targeted an engi in the above logic)
                            if EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oUnitKilled.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to target another engineer as just killed one. Cur target number='..(instigator[M27AirOverseer.refiCurTargetNumber] or 'nil')..'; is target list empty='..tostring(M27Utilities.IsTableEmpty(instigator[M27AirOverseer.reftTargetList]))) end
                                if instigator[M27AirOverseer.refiCurTargetNumber] and M27Utilities.IsTableEmpty(instigator[M27AirOverseer.reftTargetList]) == false then
                                    local oBomberTarget = instigator[M27AirOverseer.reftTargetList][instigator[M27AirOverseer.refiCurTargetNumber]][M27AirOverseer.refiShortlistUnit]
                                    if bDebugMessages == true then LOG(sFunctionRef..': oBomberTarget='..oBomberTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oBomberTarget)) end
                                    if oBomberTarget == oUnitKilled then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will look for another nearby engineer to target') end
                                        ForkThread(M27AirOverseer.OneOffTargetNearbyEngineer, oKillerBrain, instigator)
                                    end
                                end
                            end
                        end
                    end
                end

            end
            --AirAA tracking
            if EntityCategoryContains(M27UnitInfo.refCategoryAirNonScout * categories.ANTIAIR, oUnitKilled.UnitId) then
                if M27Utilities.IsTableEmpty(M27Overseer.tAllActiveM27Brains) == false then
                    for iBrain, oBrain in M27Overseer.tAllActiveM27Brains do
                        if IsEnemy(oBrain:GetArmyIndex(), oKilledBrain:GetArmyIndex()) then
                            oBrain[M27AirOverseer.refiEnemyAirAAThreat] = math.max(oBrain[M27AirOverseer.refiHighestEverEnemyAirAAThreat] * 0.5, oBrain[M27AirOverseer.refiEnemyAirAAThreat] - oUnitKilled:GetBlueprint().Economy.BuildCostMass / 3)
                        end
                    end
                end
            end


        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnMexDeath(oUnit)
    --Make the mex status available
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnMexDeath'
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        local sLocationRef = M27Utilities.ConvertLocationToStringRef(oUnit:GetPosition())
        for iRefBrain, aiBrain in M27Overseer.tAllActiveM27Brains do
            if aiBrain[M27EngineerOverseer.reftiResourceClaimedStatus][sLocationRef] then
                aiBrain[M27EngineerOverseer.reftiResourceClaimedStatus][sLocationRef][M27EngineerOverseer.refiResourceStatus] = M27EngineerOverseer.refiStatusAvailable
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnPropDestroyed(oProp)
    --Confirmed manually this triggers e.g. if a bomber destroys a rock, and if a tree is reclaimed
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnUnitDeath'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if oProp.CachePosition then
            if bDebugMessages == true then
                LOG(sFunctionRef..': Prop destroyed hook successful; will debug array and then update reclaim at the location '..repru(oProp.CachePosition)..' drawing red rectangle around cahce position')
                M27Utilities.DrawLocation(oProp.CachePosition, nil, 2, 100, nil)
                M27Utilities.DebugArray(oProp)
            end

            ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, oProp.CachePosition, 0)
        end

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end


function OnUnitDeath(oUnit)
    --WARNING: Doesnt trigger when an ACU is killed

    --NOTE: This is called by the death of any unit of any player, so careful with what commands are given
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnUnitDeath'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..'Hook successful. oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; IsACU='..tostring(M27Utilities.IsACU(oUnit))) end
        --Is it an ACU?
        if M27Utilities.IsACU(oUnit) then --NOTE: THis doesnt always trigger for ACU (not sure if it triggers some of the time, or none of the time)
            M27Overseer.iACUDeathCount = M27Overseer.iACUDeathCount + 1
            LOG(sFunctionRef..' ACU kill detected; total kills='..M27Overseer.iACUDeathCount..'; ACU position at time of death='..repru(oUnit:GetPosition()))
            --Update list of brains
            local oACUBrain = oUnit:GetAIBrain()
            if ScenarioInfo.Options.Victory == "demoralization" then
                M27Utilities.ErrorHandler('ACU has died for brain='..oACUBrain:GetArmyIndex()..'; are in assassination so will flag the brain is defeated', true)
                OnPlayerDefeated(oACUBrain)
            end
            for iArmyIndex, aiBrain in M27Overseer.tAllAIBrainsByArmyIndex do
                if aiBrain == oACUBrain and ScenarioInfo.Options.Victory == "demoralization" then
                    M27Overseer.tAllAIBrainsByArmyIndex[iArmyIndex] = nil
                    M27Overseer.tAllActiveM27Brains[iArmyIndex] = nil
                elseif aiBrain.M27AI then
                    ForkThread(M27Overseer.RecordAllEnemiesAndAllies, aiBrain)
                end
                --Clear ACU Kill strategy and last ACU position from any M27AI brain enemies
                if bDebugMessages == true then LOG(sFunctionRef..': Considering aiBrain with army index='..aiBrain:GetArmyIndex()..'; oACUBrain index='..oACUBrain:GetArmyIndex()..'; Are tehse enemies='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oACUBrain:GetArmyIndex()))..'; aiBrain[M27Overseer.refiAIBrainCurrentStrategy]='..aiBrain[M27Overseer.refiAIBrainCurrentStrategy]..'; Default strategy='..aiBrain[M27Overseer.refiDefaultStrategy]) end
                if aiBrain.M27AI and IsEnemy(aiBrain:GetArmyIndex(), oACUBrain:GetArmyIndex()) and aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyACUKill then
                    aiBrain[M27Overseer.refiAIBrainCurrentStrategy] = aiBrain[M27Overseer.refiDefaultStrategy]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering aiBrain with army index='..aiBrain:GetArmyIndex()..': Updated strategy='..aiBrain[M27Overseer.refiAIBrainCurrentStrategy]) end
                end
            end


        else
            if bDebugMessages == true then
                LOG('Will debug array of the unit')
                M27Utilities.DebugArray(oUnit)
            end
            if oUnit.CachePosition then --Redundancy to check not dealing with a unit, not sure this will actually trigger as looks like wreck deaths are picked up by the prop logic above
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Unit killed has a cache position, will draw in blue around it')
                    M27Utilities.DrawLocation(oUnit.CachePosition, nil, 1, 100, nil)
                end
                ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, oUnit.CachePosition, 0)
            else

                if oUnit.GetAIBrain then
                    --Ythotha deathball avoidance - all M27 units run away regardless of whether it was an M27 or enemy Ythotha
                    --Note -seraphimunits.lua contains SEnergyBallUnit which looks like it is for when the death ball is spawned; ID is XSL0402; SpawnElectroStorm is in the ythotha script
                    --Sandbox test - have c.36s from ythotha dying to energy ball dying, so want to run away for half of this (18s) plus extra time based on how far away we already were
                    if EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental * categories.SERAPHIM, oUnit.UnitId) then
                        --Swarm-AI workaround to deal with how it is controlled as a normal unit - slow it down so it stays in a simialr area to normal
                        if oUnit:GetAIBrain().M27SwarmAI then
                            ForkThread(M27Logic.YthothaDeathBallSearchAndSlow, oUnit:GetAIBrain(), oUnit:GetPosition())
                        end
                        local tNearbyUnits
                        if bDebugMessages == true then LOG(sFunctionRef..': Ythotha has just died, will look for nearby units and tell them to run away') end
                        local iTimeToRun
                        local iSearchRange = 70
                        for iBrain, oBrain in M27Overseer.tAllActiveM27Brains do
                            tNearbyUnits = oBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryMobileLand, oUnit:GetPosition(), 50, 'Ally')
                            if M27Utilities.IsTableEmpty(tNearbyUnits) == false then
                                for iFriendlyUnit, oFriendlyUnit in tNearbyUnits do
                                    if bDebugMessages == true then LOG(sFunctionRef..': oFriendlyUnit='..oFriendlyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..'; if we own it then will make it run away') end
                                    if oFriendlyUnit:GetAIBrain() == oBrain then --Only do this for M27 units
                                        if M27UnitInfo.IsUnitValid(oFriendlyUnit, true) then
                                            iTimeToRun = math.min(32, math.max(10, 18 + (50 - M27Utilities.GetDistanceBetweenPositions(oFriendlyUnit:GetPosition(), oUnit:GetPosition()) / (oFriendlyUnit:GetBlueprint().Physics.MaxSpeed or 1))))
                                            if bDebugMessages == true then LOG(sFunctionRef..': Telling friendly unit '..oFriendlyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..' to move away for 18s via moveawayfromtarget order') end
                                            ForkThread(M27UnitMicro.MoveAwayFromTargetTemporarily, oFriendlyUnit, iTimeToRun, oUnit:GetPosition())
                                        end
                                    end
                                end
                            end
                        end
                    end

                    --Enemy experimental dies - update all M27 threat values


                    local aiBrain = oUnit:GetAIBrain()
                    if EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental, oUnit.UnitId) then
                        for iBrain, oBrain in M27Overseer.tAllActiveM27Brains do
                            if IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                                local iMassCost = oUnit:GetBlueprint().Economy.BuildCostMass

                                if EntityCategoryContains(M27UnitInfo.refCategoryLongRangeMobile, oUnit.UnitId) then
                                    oBrain[M27Overseer.refiTotalEnemyLongRangeThreat] = oBrain[M27Overseer.refiTotalEnemyLongRangeThreat] - iMassCost
                                end
                                if EntityCategoryContains(M27UnitInfo.refCategoryShortRangeMobile, oUnit.UnitId) then
                                    oBrain[M27Overseer.refiTotalEnemyShortRangeThreat] = oBrain[M27Overseer.refiTotalEnemyShortRangeThreat] - iMassCost
                                end
                            end
                        end
                    end

                    --Is the unit owned by M27AI?
                    if aiBrain.M27AI then
                        --Flag for the platoon count of units to be updated:
                        if oUnit.PlatoonHandle then oUnit.PlatoonHandle[M27PlatoonUtilities.refbUnitHasDiedRecently] = true end

                        --Run unit type specific on death logic
                        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                        local sUnitBP = oUnit.UnitId


                        if EntityCategoryContains(refCategoryEngineer, sUnitBP) then
                            --M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..'Pre clear action')
                            M27EngineerOverseer.OnEngineerDeath(aiBrain, oUnit)
                            --M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..'Post clear action')
                        elseif EntityCategoryContains(refCategoryAirScout, sUnitBP) then
                            M27AirOverseer.OnScoutDeath(aiBrain, oUnit)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryAirAA, sUnitBP) then
                            M27AirOverseer.OnAirAADeath(oUnit)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryBomber, sUnitBP) or EntityCategoryContains(M27UnitInfo.refCategoryTorpBomber, sUnitBP) then
                            M27AirOverseer.OnBomberDeath(aiBrain, oUnit)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryFixedShield, sUnitBP) then
                            M27EngineerOverseer.CheckUnitsStillShielded(aiBrain)
                            --elseif EntityCategoryContains(M27UnitInfo.refCategoryMobileLandShield, sUnitBP) then
                            --aiBrain[M27PlatoonFormer.refbUsingMobileShieldsForPlatoons] = true
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryMex, sUnitBP) then
                            OnMexDeath(oUnit)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryTMD, sUnitBP) and M27Utilities.IsTableEmpty(oUnit[M27UnitInfo.reftTMLDefence]) == false then
                            local tUnitsWantingTMD = {}
                            for iWantingTMD, oWantingTMD in oUnit[M27UnitInfo.reftTMLDefence] do
                                if M27UnitInfo.IsUnitValid(oUnit) then table.insert(tUnitsWantingTMD, oUnit) end
                            end
                            if M27Utilities.IsTableEmpty(tUnitsWantingTMD) == false then M27Logic.DetermineTMDWantedForUnits(aiBrain, tUnitsWantingTMD) end
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryTML, sUnitBP) then
                            if (oUnit.Sync.totalMassKilled or 0) >= 800 then
                                aiBrain[M27EngineerOverseer.refiTimeOfLastFailedTML] = nil
                            else
                                local iTime = GetGameTimeSeconds()
                                aiBrain[M27EngineerOverseer.refiTimeOfLastFailedTML] = iTime
                                --Reset after 5m (unless another TML dies between now and then)
                                M27Utilities.DelayChangeVariable(aiBrain, M27EngineerOverseer.refiTimeOfLastFailedTML, nil, 300, M27EngineerOverseer.refiTimeOfLastFailedTML, iTime + 0.01, nil, nil)
                            end
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryLandFactory, sUnitBP) then
                            if not(oUnit[M27Transport.refiAssignedPlateau] == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) then
                                if aiBrain[M27MapInfo.reftOurPlateauInformation][oUnit[M27Transport.refiAssignedPlateau]][M27MapInfo.subrefPlateauLandFactories] then aiBrain[M27MapInfo.reftOurPlateauInformation][oUnit[M27Transport.refiAssignedPlateau]][M27MapInfo.subrefPlateauLandFactories][oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)] = nil end
                            end
                        elseif EntityCategoryContains(M27UnitInfo.refCategorySkirmisher, sUnitBP) then
                            aiBrain[M27Overseer.refiSkirmisherMassDeathsAll] = aiBrain[M27Overseer.refiSkirmisherMassDeathsAll] + oUnit:GetBlueprint().Economy.BuildCostMass
                            if EntityCategoryContains(M27UnitInfo.refCategorySniperBot, sUnitBP) then
                                if M27UnitInfo.IsUnitValid(oUnit[M27UnitInfo.refoCoordinatedTarget]) and M27Utilities.IsTableEmpty(oUnit[M27UnitInfo.refoCoordinatedTarget][M27UnitInfo.reftDFUnitsAttacking]) == false then
                                    for iSniper, oSniper in oUnit[M27UnitInfo.refoCoordinatedTarget][M27UnitInfo.reftDFUnitsAttacking] do
                                        if oSniper == oUnit then
                                            M27UnitInfo.RemoveDFStrikeDamageUnitFromTarget(oUnit[M27UnitInfo.refoCoordinatedTarget], oUnit, iSniper)
                                            break
                                        end
                                    end
                                end
                            end
                        end

                        --All non-mex/hydro - if have shield locations that cant build on, then check if this was near any of them
                        if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFailedShieldLocations]) == false and EntityCategoryContains(categories.STRUCTURE - M27UnitInfo.refCategoryMex - M27UnitInfo.refCategoryHydro, sUnitBP) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have failed shield locations so will check if any buildings need adjusting') end
                            local iBuildingSize = math.max(1, math.ceil(oUnit:GetBlueprint().Physics.SkirtSizeX))
                            local tLocation = oUnit:GetPosition()
                            for iXAdj = -iBuildingSize, iBuildingSize, 1 do
                                for iZAdj = -iBuildingSize, iBuildingSize, 1 do
                                    aiBrain[M27EngineerOverseer.reftFailedShieldLocations][M27Utilities.ConvertLocationToReference({tLocation[1] + iXAdj, tLocation[2], tLocation[3] + iZAdj})] = nil
                                end
                            end
                        end

                        --Shields - reset tracking of assisting engineers
                        if M27Utilities.IsTableEmpty(oUnit[M27EngineerOverseer.reftAssistingEngineers]) == false then
                            for iEngi, oEngi in oUnit[M27EngineerOverseer.reftAssistingEngineers] do
                                if M27UnitInfo.IsUnitValid(oEngi) then
                                    IssueClearCommands({oEngi})
                                    M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngi, true)
                                end
                            end
                        end

                        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                    elseif EntityCategoryContains(M27UnitInfo.refCategoryMex, oUnit.UnitId) then
                        OnMexDeath(oUnit)
                    end

                    --TMD - refresh nearby TMD
                    if EntityCategoryContains(M27UnitInfo.refCategoryTMD, oUnit.UnitId) then
                        local tTMDPosition = oUnit:GetPosition()
                        local iRadiusSize = M27EngineerOverseer.iTMDNearbyRange
                        local tNearbyTMD = GetUnitsInRect(Rect(tTMDPosition[1]-iRadiusSize, tTMDPosition[3]-iRadiusSize, tTMDPosition[1]+iRadiusSize, tTMDPosition[3]+iRadiusSize))
                        if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                            tNearbyTMD = EntityCategoryFilterDown(M27UnitInfo.refCategoryTMD, tNearbyTMD)
                            if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                                for iTMD, oTMD in tNearbyTMD do
                                    if M27UnitInfo.IsUnitValid(oTMD) then
                                        ForkThread(M27EngineerOverseer.RecordNearbyTMD, oTMD)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnWorkEnd(self, work)
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnWorkEnd'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWorkEnd'
        if bDebugMessages == true then LOG(sFunctionRef..': Hook successful') end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnShieldBubbleDamaged(self, instigator)
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnShieldBubbleDamaged'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        --Self is the shield object.  Doing a log of this, it has an Owner value, which is the unit object
        local oShield = self.Owner
        if M27UnitInfo.IsUnitValid(oShield) then
            if bDebugMessages == true then LOG(sFunctionRef..': Shield '..oShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oShield)..' has just taken damage') end
            local aiBrain = oShield:GetAIBrain()
            if aiBrain.M27AI then
                if aiBrain[M27EngineerOverseer.reftPriorityShieldsToAssist][oShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oShield)] then
                    --Dealing with a priority shield, so start a monitor if dont already have one
                    ForkThread(M27EngineerOverseer.MonitorShieldHealth, aiBrain, oShield)
                else
                    --Not a priority shield, so do nothing
                end

                --Have we just taken damage from an unseen indirect unit?
                local oKillerUnit
                if instigator and not(instigator:BeenDestroyed()) then
                    if instigator.Launcher then
                        oKillerUnit = instigator.Launcher
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                        if M27UnitInfo.IsUnitValid(oKillerUnit) then
                        M27AirOverseer.CheckForUnseenKiller(aiBrain, oShield, oKillerUnit)
                    end
                end
            end
        end

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnDamaged(self, instigator) --This doesnt trigger when a shield bubble is damaged - see OnShieldBubbleDamaged for this
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnDamaged'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if self.IsWreckage then
            --Decided to comment out the below and only update when props and wrecks are destroyed
            --[[
            if bDebugMessages == true then LOG(sFunctionRef..': Wreckage damaged, will udpate reclaim') end

            --ForkThread(DelayedReclaimUpdateAtLocation, self.CachePosition, 1) --this would Update reclaim in this segment in 1 tick
            ForkThread(RecordThatWeWantToUpdateReclaimAtLocation, self.CachePosition, 0)--]]

        else
            if bDebugMessages == true then LOG(sFunctionRef..': Non-wreck damaged') end
            if self.GetUnitId then
                if self.GetAIBrain and not(self.Dead) then
                    local aiBrain = self:GetAIBrain()
                    if aiBrain.M27AI then
                        --Has our ACU been hit by an enemy we have no sight of? Or a mex taking damage? Or a land experimental taking naval damage?
                        if M27UnitInfo.IsUnitValid(self) and ((M27Utilities.IsACU(self) and self == M27Utilities.GetACU(aiBrain)) or EntityCategoryContains(M27UnitInfo.refCategoryMex, self.UnitId) or (EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental, self.UnitId) and M27UnitInfo.IsUnitUnderwater(self))) then
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU mex or experimental has just taken damage, checking if can see the unit that damaged it') end
                            --Do we have a unit that damaged us?
                            local oUnitCausingDamage
                            if instigator and not(instigator:BeenDestroyed()) then
                                if instigator.Launcher then
                                    oUnitCausingDamage = instigator.Launcher
                                elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                                    --Can get errors for artillery shells when running IsProjectile
                                elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                                    if instigator.unit then
                                        oUnitCausingDamage = instigator.unit
                                    end
                                elseif IsUnit(instigator) then
                                    oUnitCausingDamage = instigator
                                end
                                if not(oUnitCausingDamage) and bDebugMessages == true then LOG(sFunctionRef..': Dont ahve a valid unit as instigator') end

                                if oUnitCausingDamage and M27UnitInfo.IsUnitValid(oUnitCausingDamage) then
                                    self[M27Overseer.refoLastUnitDealingDamage] = oUnitCausingDamage
                                    --Can we see the unit?
                                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if can see the unit that dealt us damage') end
                                    if not(M27Utilities.CanSeeUnit(aiBrain, oUnitCausingDamage, true)) then
                                        if M27Utilities.IsACU(self) or EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental, self.UnitId) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': self='..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..'; cant see unit that caused damage, will ask for an air scout and flag the ACU/experimental has taken damage recently') end
                                            self[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage] = GetGameTimeSeconds()
                                            self[M27Overseer.refoUnitDealingUnseenDamage] = oUnitCausingDamage
                                        else
                                            --mex taken damage for first time from unseen enemy
                                            if not(aiBrain[M27Overseer.reftPriorityLandScoutTargets]) then aiBrain[M27Overseer.reftPriorityLandScoutTargets] = {} end
                                            if not(aiBrain[M27Overseer.reftPriorityLandScoutTargets][self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)]) then
                                                aiBrain[M27Overseer.reftPriorityLandScoutTargets][self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)] = self
                                                M27Utilities.DelayChangeVariable(aiBrain[M27Overseer.reftPriorityLandScoutTargets], self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self), nil, 120)
                                            end
                                        end
                                            --Flag that we want the location (and +- 2 segments around it) the shot came from scouted asap
                                            M27AirOverseer.MakeSegmentsAroundPositionHighPriority(aiBrain, oUnitCausingDamage:GetPosition(), 2)
                                    else
                                        if oUnitCausingDamage.GetUnitId and EntityCategoryContains(M27UnitInfo.refCategoryTorpedoLandAndNavy, oUnitCausingDamage.UnitId) then
                                            self[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage] = GetGameTimeSeconds()
                                            self[M27Overseer.refoUnitDealingUnseenDamage] = oUnitCausingDamage
                                            if bDebugMessages == true then LOG(sFunctionRef..': self='..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..'; Can see unit and it is a torpedo unit so will flag that we have taken unseen or torpedo damage. self[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage]='..self[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage]) end
                                        end
                                    end
                                    --If we're upgrading consider cancelling

                                    if self.IsUnitState and self:IsUnitState('Upgrading') and EntityCategoryContains(categories.INDIRECTFIRE, oUnitCausingDamage.UnitId) and not(M27Conditions.DoesACUHaveGun(aiBrain, false, self)) then
                                        --ACU - consider cancelling
                                        if EntityCategoryContains(categories.COMMAND, self) then
                                            if self:GetWorkProgress() <= 0.25 then


                                                --Is the unit that damaged us within our range?
                                                local iOurRange = M27UnitInfo.GetUnitMaxGroundRange({ self })
                                                if bDebugMessages == true then LOG(sFunctionRef..': Taken indirect fire, consider cancelling upgrade as onl yat '..self:GetWorkProgress()..'; iOurRange='..iOurRange) end
                                                if iOurRange < M27Utilities.GetDistanceBetweenPositions(self:GetPosition(), oUnitCausingDamage:GetPosition()) then
                                                    --Do we have nearby friendly units?
                                                    if M27Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandCombat, self:GetPosition(), 40, 'Ally')) == true then
                                                        --Is the unit within range of us?
                                                        local iOurMaxRange = M27Logic.GetUnitMaxGroundRange({self})
                                                        if M27Utilities.GetDistanceBetweenPositions(self:GetPosition(), oUnitCausingDamage:GetPosition()) > iOurMaxRange then
                                                            IssueClearCommands({self})
                                                            IssueMove({self}, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                                        end
                                                    end
                                                end
                                            end
                                            if not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyAirDominance) and not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyACUKill) then
                                                if bDebugMessages == true then LOG(sFunctionRef..': ACU upgrading so switching to protect ACU mode. oUnitCausingDamage='..oUnitCausingDamage.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..'; self='..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..'; ACU state='..M27Logic.GetUnitState(self)..'; health%='..M27UnitInfo.GetUnitHealthPercent(self)..'; GameTime='..GetGameTimeSeconds()) end
                                                aiBrain[M27Overseer.refiAIBrainCurrentStrategy] = M27Overseer.refStrategyProtectACU
                                            end
                                        else
                                            function Unpause(oUnit, iWait)
                                                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                                                WaitSeconds(iWait)
                                                M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                                                if M27UnitInfo.IsUnitValid(oUnit) then
                                                    oUnit:SetPaused(false)
                                                    oUnit[M27UnitInfo.refbPaused] = false
                                                end
                                            end
                                            --Other unit e.g. mex upgrading - just pause the upgrade and then unpause in 30s
                                            if self:GetWorkProgress() <= 0.9 then
                                                self:SetPaused(true)
                                                self[M27UnitInfo.refbPaused] = true
                                                ForkThread(Unpause, self, 60)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        --General logic for shields so are very responsive with micro
                        if self.MyShield and self.MyShield.GetHealth and self.MyShield:GetHealth() < 100 and EntityCategoryContains((M27UnitInfo.refCategoryMobileLandShield + M27UnitInfo.refCategoryPersonalShield) * categories.MOBILE, self) then
                            if self.PlatoonHandle and aiBrain:PlatoonExists(self.PlatoonHandle) then M27PlatoonUtilities.RetreatLowHealthShields(self.PlatoonHandle, aiBrain)
                            else
                                --Assign to a retreating platoon
                                local oShieldPlatoon = M27PlatoonFormer.CreatePlatoon(aiBrain, 'M27RetreatingShieldUnits', {self})
                            end
                        end
                    end
                end
            end
            if instigator and not(instigator.Launcher) and IsUnit(instigator) and instigator.GetAIBrain and instigator:GetAIBrain().M27AI then
                instigator[M27UnitInfo.refbRecentlyDealtDamage] = true
                instigator[M27UnitInfo.refiGameTimeDamageLastDealt] = math.floor(GetGameTimeSeconds())
                M27Utilities.DelayChangeVariable(instigator, M27UnitInfo.refbRecentlyDealtDamage, false, 5, M27UnitInfo.refiGameTimeDamageLastDealt, instigator[M27UnitInfo.refiGameTimeDamageLastDealt] + 1, nil, nil)
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnBombFired(oWeapon, projectile)
    if M27Utilities.bM27AIInGame then
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnBombFired'
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId then
            local sUnitID = oUnit.UnitId
            if bDebugMessages == true then LOG(sFunctionRef..': bomber position when firing bomb='..repru(oUnit:GetPosition())) end
            if EntityCategoryContains(M27UnitInfo.refCategoryBomber + M27UnitInfo.refCategoryTorpBomber, sUnitID) then
                --Dont bother trying to dodge an experimental bomb
                if not(EntityCategoryContains(categories.EXPERIMENTAL, sUnitID)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and dodge the bomb fired by unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    M27UnitMicro.DodgeBomb(oUnit, oWeapon, projectile)

                end
                if oUnit.GetAIBrain and oUnit:GetAIBrain().M27AI then
                    if bDebugMessages == true then LOG(sFunctionRef..': Projectile position='..repru(projectile:GetPosition())) end
                    local iDelay = 0
                    if M27UnitInfo.DoesBomberFireSalvo(oUnit) then iDelay = 3 end

                    if not(oUnit[M27AirOverseer.refiLastFiredBomb]) or GetGameTimeSeconds() - oUnit[M27AirOverseer.refiLastFiredBomb] > iDelay then
                        oUnit[M27AirOverseer.refiLastFiredBomb] = GetGameTimeSeconds()
                        oUnit[M27AirOverseer.refiBombsDropped] = (oUnit[M27AirOverseer.refiBombsDropped] or 0) + 1
                        oUnit[M27AirOverseer.refoLastBombTarget] = oUnit[M27AirOverseer.reftTargetList][oUnit[M27AirOverseer.refiCurTargetNumber]][M27AirOverseer.refiShortlistUnit]
                    end
                    ForkThread(M27AirOverseer.DelayedBomberTargetRecheck, oUnit, iDelay)
                end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

--WARNING: OnWeaponFired and/or OnProjectilfeFired - one of these (probably the latter) resulted in error messages when t1 arti fired, disabled both of them as dont use now

function OnWeaponFired(oWeapon)
    if M27Utilities.bM27AIInGame then
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWeaponFired'
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        --NOTE: Have used hook on calcballisticacceleration instead of below now
        --if oWeapon.GetBlueprint then LOG('OnWeaponFired hook for blueprint='..repru(oWeapon:GetBlueprint())) end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId then
            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' Just fired weapon, reprs of weapon='..reprs(oWeapon)) end

            if EntityCategoryContains(M27UnitInfo.refCategoryBomber, oUnit.UnitId) and oWeapon.Label == 'GroundMissile' then
                --Corsairs dont trigger the onbombfired event normally
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Weapon fired by corsair, unit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit))
                    if oWeapon:GetCurrentTarget().GetPosition then LOG(sFunctionRef..': Target of weapon='..repru(oWeapon:GetCurrentTarget():GetPosition())) end
                end

                ForkThread(M27UnitMicro.DodgeBomb, oUnit, oWeapon, nil)
            end

            --Overcharge
            if oWeapon.GetBlueprint and oWeapon:GetBlueprint().Overcharge then
                oUnit[M27UnitInfo.refbOverchargeOrderGiven] = false
                if bDebugMessages == true then LOG('Overcharge weapon was just fired') end
                oUnit[M27UnitInfo.refiTimeOfLastOverchargeShot] = GetGameTimeSeconds()
            end

            --SML fired - have all enemy M27 brains build SMD if they havent already (better late than never...)
            if EntityCategoryContains(M27UnitInfo.refCategorySML, oUnit.UnitId) then
                local iEnemyIndex = oUnit:GetAIBrain():GetArmyIndex()
                for iBrain, oBrain in M27Overseer.tAllActiveM27Brains do
                    if IsEnemy(oBrain:GetArmyIndex(), iEnemyIndex) then
                        oBrain[M27Overseer.refbEnemyFiredNuke] = true
                    end
                end
            end

            if oUnit:GetAIBrain().M27AI then
                --T3 and experimental arti
                if EntityCategoryContains(M27UnitInfo.refCategoryFixedT3Arti + M27UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                    ForkThread(M27Logic.GetT3ArtiTarget, oUnit)
                    --DF units whose shot is blocked
                elseif EntityCategoryContains(M27UnitInfo.refCategoryDFTank, oUnit.UnitId) then
                    --Get weapon target
                    local oTarget = oWeapon:GetCurrentTarget()
                    if M27UnitInfo.IsUnitValid(oTarget) then
                        oUnit[M27UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds()
                        oUnit[M27UnitInfo.refbLastShotBlocked] = M27Logic.IsShotBlocked(oUnit, oTarget)
                        if oUnit[M27UnitInfo.refbLastShotBlocked] then
                            --Reset after 20s if we havent fired any more shots at the target
                            --function DelayChangeVariable(oVariableOwner, sVariableName, vVariableValue, iDelayInSeconds, sOptionalOwnerConditionRef, iMustBeLessThanThisTimeValue, iMustBeMoreThanThisTimeValue, vMustNotEqualThisValue)
                            M27Utilities.DelayChangeVariable(oUnit, M27UnitInfo.refbLastShotBlocked, false, 20, M27UnitInfo.refiTimeOfLastCheck, GetGameTimeSeconds() + 0.01)
                        end
                    end
                    if EntityCategoryContains(M27UnitInfo.refCategorySniperBot - categories.EXPERIMENTAL, oUnit.UnitId) then
                        oUnit[M27UnitInfo.refiTimeLastFired] = GetGameTimeSeconds()
                    end
                    --SMD, TML and SML backup to ensure missile is built
                elseif EntityCategoryContains(categories.SILO * categories.STRUCTURE, oUnit.UnitId) and oUnit.SetAutoMode then
                    oUnit:SetAutoMode(true)
                    oUnit:SetPaused(false)
                    oUnit[M27EconomyOverseer.refbWillReclaimUnit] = false
                    if EntityCategoryContains(M27UnitInfo.refCategorySML, oUnit.UnitId) then oUnit:GetAIBrain()[M27EconomyOverseer.refbReclaimNukes] = false end
                end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnMissileBuilt(self, weapon)
    if M27Utilities.bM27AIInGame then

        if self.GetAIBrain and self:GetAIBrain().M27AI then
            --Flag we've recently built a missile (so e.g. have a backup in case there's a delay in registering the missile being built, so we dont assist SMD that has just built a missile)
            self[M27EngineerOverseer.refbMissileRecentlyBuilt] = true
            M27Utilities.DelayChangeVariable(self, M27EngineerOverseer.refbMissileRecentlyBuilt, false, 5)


            --Pause if we already have 2 missiles
            local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'OnMissileBuilt'
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
            if bDebugMessages == true then
                if M27UnitInfo.IsUnitValid(self) then
                    LOG(sFunctionRef..': Have valid unit='..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self))
                else
                    LOG(sFunctionRef..': self='..DebugArray(self))
                end
            end

            local iMissiles = 1 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if self.GetTacticalSiloAmmoCount then iMissiles = iMissiles + self:GetTacticalSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles based on tactical silo ammo='..iMissiles) end
            if self.GetNukeSiloAmmoCount then iMissiles = iMissiles + self:GetNukeSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles after Nuke silo ammo='..iMissiles) end
            if iMissiles >= 2 and not(EntityCategoryContains(categories.EXPERIMENTAL, self.UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have at least 2 missiles so will set paused to true') end
                self:SetPaused(true)
                --Recheck every minute
                ForkThread(M27Logic.CheckIfWantToBuildAnotherMissile, self)
                --Clear any engineers that were assisting
                local aiBrain = self:GetAIBrain()
                if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionAssistNuke]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have engineers with assist nuke action - will clear') end
                    local oEngineer
                    local sActionRef
                    if EntityCategoryContains(M27UnitInfo.refCategorySML, self.UnitId) then sActionRef = M27EngineerOverseer.refActionAssistNuke
                    elseif EntityCategoryContains(M27UnitInfo.refCategoryTML, self.UnitId) then sActionRef = M27EngineerOverseer.refActionAssistTML
                    elseif EntityCategoryContains(M27UnitInfo.refCategorySMD, self.UnitId) then sActionRef = M27EngineerOverseer.refActionAssistSMD
                    end
                    if sActionRef then
                        for iRef, tSubtable in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][sActionRef] do
                            oEngineer = tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]
                            --if oEngineer:IsUnitState('Building') or oEngineer:IsUnitState('Repairing') then bDebugMessages = true M27Utilities.ErrorHandler('Clearing an engineer whose unit state is building or repairing') end
                            --if GetEngineerUniqueCount(oEngineer) == 58 and GetGameTimeSeconds() >= 2040 then bDebugMessages = true else bDebugMessages = false end
                            if oEngineer.GetFocusUnit and oEngineer:GetFocusUnit() == self then
                                IssueClearCommands({oEngineer})
                                M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngineer, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Cleared engineer UC='..M27EngineerOverseer.GetEngineerUniqueCount(oEngineer)..' with LC='..M27UnitInfo.GetUnitLifetimeCount(oEngineer)) end
                            end
                        end
                    end
                end
            end
            --Start logic to periodically check for targets to fire the missile at (in case there are no targets initially)
            if not(self[M27UnitInfo.refbActiveMissileChecker]) and not(EntityCategoryContains(M27UnitInfo.refCategorySMD, self.UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Calling logic to consider launching a missile') end
                ForkThread(M27Logic.ConsiderLaunchingMissile, self, weapon)
            end

            --SMD - clear any assisting engineers (dont both with missile count check, since it's off slightly and we want to stop at 1 missile anyway and this event means it has 1 missile
            if EntityCategoryContains(M27UnitInfo.refCategorySMD, self.UnitId) then
                local aiBrain = self:GetAIBrain()
                if bDebugMessages == true then LOG(sFunctionRef..': SMD '..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..' has just loaded a missile, is table of assist SMD actions empty='..tostring(M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionAssistSMD]))) end
                if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionAssistSMD]) == false then
                    for iSubtable, tSubtable in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionAssistSMD] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Cycling through each assigned subtable. Engineer='..tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef].UnitId..M27UnitInfo.GetUnitLifetimeCount(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef])..' with UC='..M27EngineerOverseer.GetEngineerUniqueCount(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef])..'; Unit being assisted='..tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refoUnitBeingAssisted].UnitId..M27UnitInfo.GetUnitLifetimeCount(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refoUnitBeingAssisted])) end
                        if tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refoUnitBeingAssisted] == self then
                            if M27UnitInfo.IsUnitValid(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]) then IssueClearCommands({tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]}) end
                            M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef], true)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have sent a clear commands action to the engineer') end
                        end
                    end
                end
            end

            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        end
    end
end

--[[
function OnProjectileFired(oWeapon, oMuzzle)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnProjectileFired'
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    if oWeapon.GetBlueprint then
        LOG('OnWeaponFired hook for blueprint='..repru(oWeapon:GetBlueprint()))
    end
    if oWeapon.unit then
        LOG('Have a unit; unit position='..repru(oWeapon.unit:GetPosition()))
    end
end--]]

function OnConstructionStarted(oEngineer, oConstruction, sOrder)
    if M27Utilities.bM27AIInGame then
        --Track experimental construction and other special on construction logic
        if oEngineer.GetAIBrain and oEngineer:GetAIBrain().M27AI and oConstruction.GetUnitId and not(oConstruction['M27FirstConstructionStart']) then
            local sFunctionRef = 'OnConstructionStarted'
            local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

            oConstruction['M27FirstConstructionStart'] = true
            local aiBrain = oEngineer:GetAIBrain()

            --Game enders - check if we have already started a gameender nearby, and if so clear current building and reclaim it
            local bCancelAndReclaim = false
            local oUnitToSwitchTo
            if EntityCategoryContains(M27UnitInfo.refCategoryExperimentalStructure, oConstruction.UnitId) then
                local tNearbyGameEnders = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryExperimentalStructure, oConstruction:GetPosition(), 150, 'Ally')

                if M27Utilities.IsTableEmpty(tNearbyGameEnders) == false then
                    local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oConstruction:GetPosition())
                    for iUnit, oUnit in tNearbyGameEnders do
                        if not(oUnit == oConstruction) and oUnit:GetFractionComplete() < 1 and iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnit:GetPosition()) then
                            bCancelAndReclaim = true
                            oUnitToSwitchTo = oUnit
                            break
                        end
                    end
                end
            end
            if bCancelAndReclaim then
                IssueClearCommands({oEngineer})
                IssueReclaim({oEngineer}, oConstruction)
                if oUnitToSwitchTo then
                    IssueRepair({oEngineer}, oUnitToSwitchTo)
                end
            else
                --Decide if we want to shield the construction
                if EntityCategoryContains(categories.STRUCTURE + M27UnitInfo.refCategoryExperimentalStructure, oConstruction.UnitId) then
                    local oBP = oConstruction:GetBlueprint()
                    if oBP.Economy.BuildCostMass >= 2000 then
                        if oBP.Defense.Health / oBP.Economy.BuildCostMass < 1 or EntityCategoryContains(M27UnitInfo.refCategoryFixedT2Arti, oConstruction.UnitId) or (aiBrain[M27Overseer.refbDefendAgainstArti] and oBP.Economy.BuildCostMass >= 3000 and EntityCategoryContains(M27UnitInfo.refCategoryStructure, oConstruction.UnitId)) then
                            oConstruction[M27EngineerOverseer.refiShieldsWanted] = 1
                            table.insert(aiBrain[M27EngineerOverseer.reftUnitsWantingFixedShield], oConstruction)
                            --Flag if we want it to have a heavy shield
                            if aiBrain[M27Overseer.refbDefendAgainstArti] then
                                oConstruction[M27EngineerOverseer.refbNeedsLargeShield] = true
                                aiBrain[M27EngineerOverseer.refbHaveUnitsWantingHeavyShield] = true --Redundancy (should already check for the defendagainstarti flag)
                                if oBP.Economy.BuildCostMass >= 12000 then
                                    oConstruction[M27EngineerOverseer.refiShieldsWanted] = 2
                                end
                            else
                                if oBP.Economy.BuildCostMass >= 12000 then

                                    if oBP.Economy.BuildCostMass >= 20000 then
                                        oConstruction[M27EngineerOverseer.refbNeedsLargeShield] = true
                                        aiBrain[M27EngineerOverseer.refbHaveUnitsWantingHeavyShield] = true
                                    else
                                        --Cybran - shield nukes with T3 shields.  Other factions can use t2
                                        if EntityCategoryContains(categories.CYBRAN, oConstruction.UnitId) then
                                            oConstruction[M27EngineerOverseer.refbNeedsLargeShield] = true
                                            aiBrain[M27EngineerOverseer.refbHaveUnitsWantingHeavyShield] = true
                                        end
                                    end

                                end
                            end
                        end
                    end


                    --Check for construction of nuke
                    --if aiBrain[M27EngineerOverseer.refiLastExperimentalReference] then
                    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
                    local sFunctionRef = 'OnConstructionStarted'
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have just started construction on a nuke; if so then will start a monitor; UnitID='..oConstruction.UnitId..'; oConstruction[M27UnitInfo.refbActiveSMDChecker]='..(tostring(oConstruction[M27UnitInfo.refbActiveSMDChecker] or false))) end

                    if EntityCategoryContains(M27UnitInfo.refCategorySML - categories.EXPERIMENTAL, oConstruction.UnitId) then
                        --Are building a nuke, check if already monitoring SMD somehow
                        if not(oConstruction[M27UnitInfo.refbActiveSMDChecker]) and oConstruction:GetFractionComplete() < 1 then
                            --if aiBrain[M27EngineerOverseer.refiLastExperimentalReference] == M27UnitInfo.refCategorySML and not(aiBrain[M27UnitInfo.refbActiveSMDChecker]) then
                            ForkThread(M27EngineerOverseer.CheckForEnemySMD, aiBrain, oConstruction)
                        end
                    end
                    --end

                    --Firebase tracking
                    if EntityCategoryContains(M27UnitInfo.refCategoryFirebaseSuitable, oConstruction.UnitId) then
                        --First check in case ACU is already building something
                        local oUnitToSwitchTo
                        local bReclaimAnyway = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if ACU building firebase unit near us in which case will switch to assisting it instead.  Cur strategy='..aiBrain[M27Overseer.refiAIBrainCurrentStrategy]..'; oEngineer[M27EngineerOverseer.refiEngineerCurrentAction]='..(oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] or 'nil')) end
                        if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle and oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] == M27EngineerOverseer.refActionFortifyFirebase then
                            local oACU = M27Utilities.GetACU(aiBrain)
                            local iFirebaseCategoryWanted = aiBrain[M27EngineerOverseer.refiFirebaseCategoryWanted][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]]
                            if bDebugMessages == true and oPlatoon[refbACUInPlatoon] then LOG(sFunctionRef..': ACU state='..M27Logic.GetUnitState(oACU)) end
                            if iFirebaseCategoryWanted and oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') then
                                local oACUTarget = oACU:GetFocusUnit()
                                if M27UnitInfo.IsUnitValid(oACUTarget) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': oACUTarget='..oACUTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oACUTarget)..'; Fraction complete='..oACUTarget:GetFractionComplete()..'; Dist to oConstruction='..M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oConstruction:GetPosition())) end
                                    if oACUTarget:GetFractionComplete() < 1 and M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oConstruction:GetPosition()) <= 35 then
                                        --Is the ACU building a firebase category, and is that our action?
                                        if EntityCategoryContains(aiBrain[M27EngineerOverseer.refiFirebaseCategoryWanted][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]], oACUTarget.UnitId) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will switch so we assist this unit instead') end
                                            oUnitToSwitchTo = oACUTarget
                                        end
                                    end
                                end
                            end
                            if iFirebaseCategoryWanted and not(oUnitToSwitchTo) and M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oConstruction:GetPosition()) <= 35 and M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), aiBrain[M27MapInfo.reftChokepointBuildLocation]) <= 50 then
                                local tNearbyUnitsOfType = aiBrain:GetUnitsAroundPoint(iFirebaseCategoryWanted, oConstruction:GetPosition(), 35, 'Ally')
                                if M27Utilities.IsTableEmpty(tNearbyUnitsOfType) == false then
                                    for iUnit, oUnit in tNearbyUnitsOfType do
                                        if oUnit:GetFractionComplete() < 1 then
                                            oUnitToSwitchTo = oUnit
                                            break
                                        end
                                    end
                                end
                            end
                            --Did we just start on a radar at a firebase that already has one complete nearby?
                            if not(oUnitToSwitchTo) and EntityCategoryContains(M27UnitInfo.refCategoryRadar, oConstruction.UnitId) then
                                local iTechCategory = M27UnitInfo.ConvertTechLevelToCategory(M27UnitInfo.GetUnitTechLevel(oConstruction))
                                local tNearbyRadar = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryRadar * iTechCategory, oConstruction:GetPosition(), 35, 'Ally')
                                if M27Utilities.IsTableEmpty(tNearbyRadar) == false then
                                    for iUnit, oUnit in tNearbyRadar do
                                        if oUnit:GetFractionComplete() == 1 then
                                            bReclaimAnyway = true
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        if bReclaimAnyway or (oUnitToSwitchTo and not(oUnitToSwitchTo == oConstruction)) then
                            IssueClearCommands({oEngineer})
                            IssueReclaim({oEngineer}, oConstruction)
                            if oUnitToSwitchTo then
                                IssueRepair({oEngineer}, oUnitToSwitchTo)
                                ForkThread(M27EngineerOverseer.FirebaseTrackingOfConstruction, aiBrain, oEngineer, oUnitToSwitchTo)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have told engineer '..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' to switch to assist what the ACU is building') end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Engineer was building radar but we have one nearby now, will reclaim the radar')
                            end
                        else
                            ForkThread(M27EngineerOverseer.FirebaseTrackingOfConstruction, aiBrain, oEngineer, oConstruction)
                        end
                    end

                    --Scathis tracking (since impacts where we can build)
                    if EntityCategoryContains(M27UnitInfo.refCategoryExperimentalArti * categories.MOBILE, oConstruction.UnitId) then
                        aiBrain[M27EngineerOverseer.reftFriendlyScathis][oConstruction.UnitId..M27UnitInfo.GetUnitLifetimeCount(oConstruction)] = oConstruction
                    end

                    --TMD tracking for multiple TMD
                    if EntityCategoryContains(M27UnitInfo.refCategoryTMD, oConstruction.UnitId) then
                        local tTMDPosition = oConstruction:GetPosition()
                        local iRadiusSize = M27EngineerOverseer.iTMDNearbyRange
                        local tNearbyTMD = GetUnitsInRect(Rect(tTMDPosition[1]-iRadiusSize, tTMDPosition[3]-iRadiusSize, tTMDPosition[1]+iRadiusSize, tTMDPosition[3]+iRadiusSize))
                        if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                            tNearbyTMD = EntityCategoryFilterDown(M27UnitInfo.refCategoryTMD, tNearbyTMD)
                            if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                                for iTMD, oTMD in tNearbyTMD do
                                    if M27UnitInfo.IsUnitValid(oTMD) then
                                        ForkThread(M27EngineerOverseer.RecordNearbyTMD, oTMD)
                                    end
                                end
                            end
                        end
                    end
                end
            end

            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        end
    end
end
function OnConstructed(oEngineer, oJustBuilt)
    --WARNING: This doesnt seem to trigger for the ACU

    --NOTE: This is called every time an engineer stops building a unit whose fractioncomplete is 100%, so can be called multiple times
    if M27Utilities.bM27AIInGame then

        if oJustBuilt:GetAIBrain().M27AI and not(oJustBuilt.M27OnConstructedCalled) then
            local sFunctionRef = 'OnConstructed'
            local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)


            if bDebugMessages == true then LOG(sFunctionRef..': oEngineer='..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oJustBuilt='..oJustBuilt.UnitId..M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)) end

            oJustBuilt.M27OnConstructedCalled = true
            oJustBuilt[M27UnitInfo.refiTimeConstructed] = GetGameTimeSeconds()

            --LOG('OnConstructed hook test; oJustBuilt='..oJustBuilt.UnitId..'; oEngineer='..oEngineer.UnitId)
            local aiBrain = oJustBuilt:GetAIBrain()
            if EntityCategoryContains(M27UnitInfo.refCategoryFixedT2Arti, oJustBuilt.UnitId) then
                ForkThread(M27UnitInfo.SetUnitTargetPriorities, oJustBuilt, M27UnitInfo.refWeaponPriorityT2Arti)
            end

            --Firebase tracking
            if EntityCategoryContains(M27UnitInfo.refCategoryFirebaseSuitable, oJustBuilt.UnitId) then
                aiBrain[M27EngineerOverseer.refbPotentialFirebaseBuildingChangedSinceLastFirebaseCheck] = true
                ForkThread(M27EngineerOverseer.FirebaseTrackingOfConstruction, aiBrain, oEngineer, oJustBuilt)
                --If just built by ACU than refresh firebase so ACU doesnt risk building loads more T2 PD to try and get a firebase to register
                if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then ForkThread(M27EngineerOverseer.RefreshListOfFirebases, aiBrain) end

                --Shields wanting hives
                if EntityCategoryContains(M27UnitInfo.refCategoryFixedShield * categories.TECH3, oJustBuilt.UnitId) then
                    table.insert(aiBrain[M27EngineerOverseer.reftShieldsWantingHives], oJustBuilt)
                end
            end

            --Initial categories below are for if not protecting from TML
            --Mexes built by spare engineers - want to clear already assigned engineers
            if EntityCategoryContains(M27UnitInfo.refCategoryT1Mex, oJustBuilt.UnitId) then
                if oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] == M27EngineerOverseer.refActionSpare then
                    --reftEngineerAssignmentsByLocation --[x][y][z];  x is the unique location ref (need to use ConvertLocationToReference in utilities to use), [y] is the actionref, z is the engineer unique ref assigned to this location; returns the engineer object
                    local sLocationRef = M27Utilities.ConvertLocationToStringRef(oJustBuilt:GetPosition())
                    if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef][M27EngineerOverseer.refActionBuildMex]) == false then
                        for iEngi, oEngi in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef][M27EngineerOverseer.refActionBuildMex] do
                            IssueClearCommands({ oEngi })
                            M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngi, true)
                        end
                    end
                end
            elseif EntityCategoryContains(M27UnitInfo.refCategoryLandFactory, oJustBuilt.UnitId) then
                --Is this a land factory on a plateau?
                local iPlateauGroup = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oJustBuilt:GetPosition())
                if not (iPlateauGroup == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) then
                    oJustBuilt[M27Transport.refiAssignedPlateau] = iPlateauGroup
                    if M27Utilities.IsTableEmpty(aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup]) then
                        aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup] = {}
                    end
                    if M27Utilities.IsTableEmpty(aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][M27MapInfo.subrefPlateauLandFactories]) then
                        aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][M27MapInfo.subrefPlateauLandFactories] = {}
                    end
                    aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][M27MapInfo.subrefPlateauLandFactories][oJustBuilt.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)] = oJustBuilt
                    LOG('Have just recorded factory ' .. oJustBuilt.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oJustBuilt) .. ' in the list of factories for iPlateauGroup=' .. iPlateauGroup)
                end
            elseif EntityCategoryContains(M27UnitInfo.refCategoryPD, oJustBuilt.UnitId) then
                --Update PD tracking
                aiBrain[M27EngineerOverseer.refiMassSpentOnPD] = aiBrain[M27EngineerOverseer.refiMassSpentOnPD] + oJustBuilt:GetBlueprint().Economy.BuildCostMass
            elseif EntityCategoryContains(M27UnitInfo.refCategoryRadar - categories.TECH1, oJustBuilt.UnitId) then
                local tNearbyLowerTechRadar
                local iIntelRange = oJustBuilt:GetBlueprint().Intel.RadarRadius
                if iIntelRange >= 120 then
                    if M27UnitInfo.GetUnitTechLevel(oJustBuilt) >= 3 then
                        tNearbyLowerTechRadar = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT1Radar + M27UnitInfo.refCategoryT2Radar, oJustBuilt:GetPosition(), iIntelRange, 'Ally')
                    else
                        tNearbyLowerTechRadar = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT1Radar, oJustBuilt:GetPosition(), iIntelRange, 'Ally')
                    end
                    if M27Utilities.IsTableEmpty(tNearbyLowerTechRadar) == false then
                        local iCurDist
                        local iCurIntel
                        for iUnit, oUnit in tNearbyLowerTechRadar do
                            if oUnit:GetAIBrain().M27AI then
                                --Are we adding any intel from here?
                                iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJustBuilt:GetPosition())
                                iCurIntel = oUnit:GetBlueprint().Intel.RadarRadius or 0
                                if bDebugMessages == true then LOG(sFunctionRef..': Just built radar '..oJustBuilt.UnitId..M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; will consider whether have obsolete radar to destroy, oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' where iCurDist='..iCurDist..'; iCurIntel='..iCurIntel..'; iIntelRange='..iIntelRange) end
                                if iCurDist + iCurIntel <= iIntelRange then
                                    oUnit:Kill()
                                end
                            end
                        end
                    end
                end
            elseif EntityCategoryContains(M27UnitInfo.refCategoryHive, oJustBuilt.UnitId) then
                ForkThread(M27EngineerOverseer.HiveManager, oJustBuilt)

            else
                --Have we just built an experimental unit? If so then tell our ACU to return to base as even if we havent scouted enemy threat they could have an experimental by now
                if EntityCategoryContains(categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                    aiBrain[M27Overseer.refbAreBigThreats] = true
                end
                if aiBrain[M27Overseer.refbEnemyTMLSightedBefore] and M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyTML]) == false then
                    if EntityCategoryContains(M27UnitInfo.refCategoryProtectFromTML, oJustBuilt.UnitId) then
                        M27Logic.DetermineTMDWantedForUnits(aiBrain, { oJustBuilt })
                    elseif EntityCategoryContains(M27UnitInfo.refCategoryTMD, oJustBuilt.UnitId) then
                        --Update list of units wanting TMD to factor in if they have TMD coverage from all threats now that we have just built a TMD
                        M27Logic.DetermineTMDWantedForUnits(aiBrain, aiBrain[M27EngineerOverseer.reftUnitsWantingTMD])
                    end
                end
                if EntityCategoryContains(M27UnitInfo.refCategoryFixedT3Arti + M27UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) and not (oJustBuilt[M27UnitInfo.refbActiveTargetChecker]) then
                    aiBrain[M27Overseer.refbAreBigThreats] = true
                    --T3 arti - first time its constructed want to start thread checking for power, and also tell it what to fire
                    oJustBuilt[M27UnitInfo.refbActiveTargetChecker] = true
                    ForkThread(M27Logic.GetT3ArtiTarget, oJustBuilt)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just built t3 arti or equivalent so have called the logic to get t3 arti target') end
                end
                --Quantum optics redundancy
                if EntityCategoryContains(M27UnitInfo.refCategoryQuantumOptics, oJustBuilt.UnitId) then
                    ForkThread(M27AirOverseer.QuantumOpticsManager, aiBrain, oJustBuilt)
                end
            end

            --If have just upgraded a shield then clear tracking (redundancy as should also trigger from 'death' of old shield)
            if EntityCategoryContains(M27UnitInfo.refCategoryStructure - M27UnitInfo.refCategoryEngineer, oEngineer.UnitId) and M27Utilities.IsTableEmpty(oJustBuilt[M27EngineerOverseer.reftAssistingEngineers]) == false then
            for iEngi, oEngi in oJustBuilt[M27EngineerOverseer.reftAssistingEngineers] do
            if M27UnitInfo.IsUnitValid(oEngi) then
            IssueClearCommands({ oEngi })
            M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngi, true)
            end
            end
            end

            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        elseif M27Config.M27ShowEnemyUnitNames then
            oJustBuilt:SetCustomName(oJustBuilt.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oJustBuilt))
        end
        --Engineer callbacks
        if oEngineer:GetAIBrain().M27AI and not (oEngineer.Dead) and EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oEngineer:GetUnitId()) then
            local sFunctionRef = 'OnConstructed'
            local bDebugMessages = false
            if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
            ForkThread(M27EngineerOverseer.ReassignEngineers, oEngineer:GetAIBrain(), true, { oEngineer })
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        end
    end
end

function OnReclaimStarted(oEngineer, oReclaim)
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnReclaimStarted'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)


        if oEngineer:GetAIBrain().M27AI then
            if oEngineer.PlatoonHandle and oEngineer.PlatoonHandle[M27PlatoonUtilities.refbNotStartedReclaimingYet] then
                --Platoon specific - flag that have started the reclaim
                oEngineer.PlatoonHandle[M27PlatoonUtilities.refbNotStartedReclaimingYet] = false
            elseif oEngineer[M27PlatoonUtilities.refbNotStartedReclaimingYet] then
                oEngineer[M27PlatoonUtilities.refbNotStartedReclaimingYet] = false
            end
        end

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnReclaimFinished(oEngineer, oReclaim)
    if M27Utilities.bM27AIInGame then
        --Update the segment that the reclaim is at, or the engineer if hte reclaim doesnt have one
        local sFunctionRef = 'OnReclaimFinished'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming, gametime='..GetGameTimeSeconds()) end

        if oReclaim and oReclaim.CachePosition then
            --LOG('OnReclaimFinished temp log - remove once confirmed this works - about to update reclaim data near location='..repru(oReclaim.CachePosition))
            ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, oReclaim.CachePosition, 0)
            --M27MapInfo.UpdateReclaimDataNearLocation(oReclaim.CachePosition, 0, nil)
        else
            --LOG('OnReclaimFinished alt temp log - couldnt find reclaim position so will use engineer position')
            ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, oEngineer:GetPosition(), 1)
            --M27MapInfo.UpdateReclaimDataNearLocation(oEngineer:GetPosition(), 1, nil)
        end
        --If dealing with M27 unit that is in a platoon that is reclaiming a specific target or a hive, then look for a new target
        if M27UnitInfo.IsUnitValid(oEngineer) and oEngineer:GetAIBrain().M27AI then
            if bDebugMessages == true then LOG(sFunctionRef..': Platoon current action='..(oEngineer.PlatoonHandle[M27PlatoonUtilities.refiCurrentAction] or 'nil')..'; last order type='..(oEngineer.PlatoonHandle[M27PlatoonUtilities.refiLastOrderType] or 'nil')..'; Engineer='..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Engineer action='..(oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] or 'nil')..'; Is idle platoon='..tostring((oEngineer.PlatoonHandle[M27PlatoonTemplates.refbIdlePlatoon]) or false)) end
            if (oEngineer.PlatoonHandle and not(oEngineer.PlatoonHandle[M27PlatoonTemplates.refbIdlePlatoon])) or EntityCategoryContains(M27UnitInfo.refCategoryHive, oEngineer.UnitId) then
                local aiBrain = oEngineer:GetAIBrain()
                if aiBrain:GetEconomyStoredRatio('MASS') <= 0.6 then
                    if oEngineer.PlatoonHandle[M27PlatoonUtilities.refiCurrentAction] == M27PlatoonUtilities.refActionReclaimTarget or oEngineer.PlatoonHandle[M27PlatoonUtilities.refiLastOrderType] == M27PlatoonUtilities.refiOrderIssueReclaim or EntityCategoryContains(M27UnitInfo.refCategoryHive, oEngineer.UnitId) then
                        local iBuildRange = oEngineer:GetBlueprint().Economy.MaxBuildDistance
                        if iBuildRange > 1 then
                            local tEnemiesToReclaim = oEngineer:GetAIBrain():GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure + M27UnitInfo.refCategoryMobileLand + M27UnitInfo.refCategoryAllNavy - categories.COMMAND - categories.SUBCOMMANDER, oEngineer:GetPosition(), iBuildRange, 'Enemy')
                            if M27Utilities.IsTableEmpty(tEnemiesToReclaim) == false then
                                local oUnitToReclaim = M27Utilities.GetNearestUnit(tEnemiesToReclaim, oEngineer:GetPosition())
                                IssueClearCommands({oEngineer}) --need to clear commands or else we will continue reclaiming a wreck when we coudl be reclaiming an enemy
                                IssueReclaim({oEngineer}, oUnitToReclaim)
                                if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' to reclaim enemy unit '..oUnitToReclaim.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToReclaim)) end
                            else
                                --Check for wrecks to reclaim within build range
                                local oNearestReclaim, iNearestReclaim = M27EngineerOverseer.GetWreckInCurrentRangeToReclaim(oEngineer:GetAIBrain(), oEngineer)
                                if iNearestReclaim <= iBuildRange + 0.5 and oNearestReclaim then
                                    --(shouldnt need to issue clear commands)
                                    IssueReclaim({oEngineer}, oNearestReclaim)
                                end
                            end
                        end
                    end
                end
            elseif oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] == M27EngineerOverseer.refActionSelenMexBuild and not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) then
                IssueClearCommands({oEngineer})
                M27EngineerOverseer.BuildStructureAtLocation(oEngineer:GetAIBrain(), oEngineer, M27UnitInfo.refCategoryT1Mex, 1, nil, oEngineer[M27EngineerOverseer.reftEngineerCurrentTarget], true, false, nil, true, nil, nil, M27EngineerOverseer.refActionSelenMexBuild)
                if bDebugMessages == true then LOG(sFunctionRef..': Engineer '..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming something, and its action was selenbuildmex, so will try and get it to build a mex at its target location of '..repru((oEngineer[M27EngineerOverseer.reftEngineerCurrentTarget] or {'nil'}))) end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnCreateWreck(tPosition, iMass, iEnergy)
    --Dont check if M27brains are in game yet as can be called at start of game before we have recorded any aiBrain; instead will have check in the delayedreclaim
    if M27Utilities.bM27AIInGame  or GetGameTimeSeconds() <= 5 then
        --LOG('OnCreateWreck temp log - remove once confirmed this works; wreck position='..repru(tPosition)..'; iMass='..(iMass or 'nil')..'; iEnergy='..(iEnergy or 'nil'))
        local sFunctionRef = 'OnCreateWreck'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if GetGameTimeSeconds() <= 5 then --Some variables wont be setup yet (probably only need to do <=1s but will do 5s to be safe)
            ForkThread(M27MapInfo.DelayedReclaimRecordAtLocation, tPosition, 0, 5)
        else
            ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, tPosition, 0)
            --[[if GetGameTimeSeconds() >= 590 then bDebugMessages = true end
            if bDebugMessages == true then
                local iReclaimSegmentX, iReclaimSegmentZ = M27MapInfo.GetReclaimSegmentsFromLocation(tPosition)
                LOG(sFunctionRef..' wreck just created, iMass='..(iMass or 0)..'; tPosition='..repru(tPosition)..'; reclaim segments of position='..iReclaimSegmentX..'-'..iReclaimSegmentZ)
                --bDebugMessages = false WaitTicks(1) LOG(sFunctionRef..': repr of tReclaimSegmentsToUpdate='..repru(M27MapInfo.tReclaimSegmentsToUpdate))
            end--]]
        end
        --M27MapInfo.UpdateReclaimDataNearLocation(tPosition, 0, nil)
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnTransportLoad(oUnit, oTransport, bone)
    if oUnit:GetAIBrain().M27AI and oTransport:GetAIBrain().M27AI then
        local sFunctionRef = 'OnTransportUnload'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        M27Transport.UpdateTransportForLoadedUnit(oUnit, oTransport)
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnTransportUnload(oUnit, oTransport, bone)

    if M27UnitInfo.IsUnitValid(oUnit) then
        local aiBrain = oUnit:GetAIBrain()
        if aiBrain.M27AI then
            local sFunctionRef = 'OnTransportUnload'
            local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
            IssueClearCommands({oUnit})
            oUnit[M27Transport.refiAssignedPlateau] = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnit:GetPosition())
            --Make sure we have correctly recorded the plateau if we have landed engineers

            if not(oUnit[M27Transport.refiAssignedPlateau] == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) and EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                if M27MapInfo.RecheckPathingOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnit, oUnit:GetPosition()) then
                    oUnit[M27Transport.refiAssignedPlateau] = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnit:GetPosition())
                end
            end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        end
    end
end

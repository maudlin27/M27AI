---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 08/10/2021 13:05
---

local M27UnitInfo = import('/mods/M27AI/lua/AI/M27UnitInfo.lua')
local M27UnitMicro = import('/mods/M27AI/lua/AI/M27UnitMicro.lua')
local M27EngineerOverseer = import('/mods/M27AI/lua/AI/M27EngineerOverseer.lua')
local M27AirOverseer = import('/mods/M27AI/lua/AI/M27AirOverseer.lua')
local M27Utilities = import('/mods/M27AI/lua/M27Utilities.lua')
local M27Stats = import('/mods/M27AI/lua/M27StatTracking.lua')
local M27Overseer = import('/mods/M27AI/lua/AI/M27Overseer.lua')
local M27PlatoonFormer = import('/mods/M27AI/lua/AI/M27PlatoonFormer.lua')
local M27PlatoonUtilities = import('/mods/M27AI/lua/AI/M27PlatoonUtilities.lua')
local M27MapInfo = import('/mods/M27AI/lua/AI/M27MapInfo.lua')
local M27Conditions = import('/mods/M27AI/lua/AI/M27CustomConditions.lua')
local M27Logic = import('/mods/M27AI/lua/AI/M27GeneralLogic.lua')
local M27Config = import('/mods/M27AI/lua/M27Config.lua')
local M27Transport = import('/mods/M27AI/lua/AI/M27Transport.lua')
local M27EconomyOverseer = import('/mods/M27AI/lua/AI/M27EconomyOverseer.lua')
local M27PlatoonTemplates = import('/mods/M27AI/lua/AI/M27PlatoonTemplates.lua')
local M27Team = import('/mods/M27AI/lua/AI/M27Team.lua')
local M27Chat = import('/mods/M27AI/lua/AI/M27Chat.lua')
local M27Navy = import('/mods/M27AI/lua/AI/M27Navy.lua')


local refCategoryEngineer = M27UnitInfo.refCategoryEngineer
local refCategoryAirScout = M27UnitInfo.refCategoryAirScout

function OnPlayerDefeated(aiBrain)
    aiBrain.M27IsDefeated = true




    --Was it an M27AI?
    if aiBrain.M27AI then
        --Give resources to teammates
        if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.toAllyBrains]) == false then
            ForkThread(M27Team.GiveAllResourcesToAllies, aiBrain)
        end

        --Was it assigned to a chokepoint? If so then have any teammates no longer adopt a turtle strategy
        if aiBrain[M27MapInfo.refiAssignedChokepointCount] then
            for iBrain, oBrain in M27Team.tTeamData[aiBrain.M27Team][M27Team.reftFriendlyActiveM27Brains] do
                if not(oBrain == aiBrain) then
                    oBrain[aiBrain[M27MapInfo.refiAssignedChokepointCount]] = nil
                    oBrain[M27Overseer.refiDefaultStrategy] = M27Overseer.refStrategyLandMain
                    oBrain[M27Overseer.refiAIBrainCurrentStrategy] = oBrain[M27Overseer.refiDefaultStrategy]
                end
            end
        end
    end

    for iArmyIndex, oBrain in M27Overseer.tAllAIBrainsByArmyIndex do
        if aiBrain == oBrain then
            M27Overseer.tAllAIBrainsByArmyIndex[iArmyIndex] = nil
            M27Overseer.tAllActiveM27Brains[iArmyIndex] = nil
        elseif oBrain.M27AI then
            ForkThread(M27Overseer.RecordAllEnemiesAndAllies, oBrain)
        end
    end
end

function OnACUKilled(oUnit)
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnACUKilled'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
            --Update list of brains
            local oACUBrain = oUnit:GetAIBrain()
            if not(oACUBrain.M27IsDefeated) and not(oUnit.M27IsDefeated) then
                oUnit.M27IsDefeated = true --As OnACUKilled may be called multiple times as have the logic in several places to make sure its picked up
                M27Overseer.iACUDeathCount = M27Overseer.iACUDeathCount + 1
                LOG(sFunctionRef..' ACU kill detected; total kills='..M27Overseer.iACUDeathCount..'; ACU position at time of death='..repru(oUnit:GetPosition()))

                if ScenarioInfo.Options.Victory == "demoralization" then
                    M27Utilities.ErrorHandler('ACU has died for brain='..oACUBrain:GetArmyIndex()..'; are in assassination so will flag the brain is defeated', true)
                    OnPlayerDefeated(oACUBrain)
                end

                if oACUBrain.M27AI then
                    --Was this a long game and we got to build multiple experimentals?
                    if bDebugMessages == true then LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Experimental lifetime build count='..M27Conditions.GetLifetimeBuildCount(oACUBrain, M27UnitInfo.refCategoryExperimentalLevel)) end
                    if GetGameTimeSeconds() >= 3600 and M27Conditions.GetLifetimeBuildCount(oACUBrain, M27UnitInfo.refCategoryExperimentalLevel) >= 3 then
                        M27Chat.SendMessage(oACUBrain, 'Epic game', 'That was an epic game!', 3, 10000)
                    else
                        local iRandom = math.random(1,3)
                        if iRandom == 1 and  M27Conditions.GetLifetimeBuildCount(oACUBrain, M27UnitInfo.refCategoryExperimentalLevel) >= 2 then
                            --Do we have a teammate?
                            local iAliveM27Allies = 0
                            if M27Utilities.IsTableEmpty(oACUBrain[M27Overseer.toAllyBrains]) == false then
                                for iBrain, oBrain in oACUBrain[M27Overseer.toAllyBrains] do
                                    if oBrain.M27AI and not(oBrain.M27IsDefeated) and not(oBrain == oACUBrain) then
                                        iAliveM27Allies = iAliveM27Allies + 1
                                    end
                                end
                            end
                            if iAliveM27Allies > 0 then
                                M27Chat.SendMessage(oACUBrain, 'Our ACU Died', 'wp', 3, 60)
                            else
                                M27Chat.SendMessage(oACUBrain, 'Our ACU Died', 'gg, closer than I thought it would be', 3, 60)
                            end
                        elseif iRandom == 2 then
                            M27Chat.SendMessage(oACUBrain, 'Our ACU Died', 'gg wp', 3, 60)
                        else
                            M27Chat.SendMessage(oACUBrain, 'Our ACU Died', 'gg', 3, 60)
                        end
                    end

                end
                for iArmyIndex, aiBrain in M27Overseer.tAllAIBrainsByArmyIndex do
                    if aiBrain == oACUBrain and ScenarioInfo.Options.Victory == "demoralization" then
                        M27Overseer.tAllAIBrainsByArmyIndex[iArmyIndex] = nil
                        M27Overseer.tAllActiveM27Brains[iArmyIndex] = nil
                    elseif aiBrain.M27AI and ScenarioInfo.Options.Victory == "demoralization" then
                        ForkThread(M27Overseer.RecordAllEnemiesAndAllies, aiBrain)
                    end
                    --Clear ACU Kill strategy and last ACU position from any M27AI brain enemies
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering aiBrain with army index='..aiBrain:GetArmyIndex()..'; oACUBrain index='..oACUBrain:GetArmyIndex()..'; Are tehse enemies='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oACUBrain:GetArmyIndex()))..'; aiBrain[M27Overseer.refiAIBrainCurrentStrategy]='..(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] or 'nil')..'; Default strategy='..(aiBrain[M27Overseer.refiDefaultStrategy] or 'nil')) end
                    if aiBrain.M27AI and IsEnemy(aiBrain:GetArmyIndex(), oACUBrain:GetArmyIndex()) and aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyACUKill then
                        aiBrain[M27Overseer.refiAIBrainCurrentStrategy] = aiBrain[M27Overseer.refiDefaultStrategy]
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering aiBrain with army index='..aiBrain:GetArmyIndex()..': Updated strategy='..aiBrain[M27Overseer.refiAIBrainCurrentStrategy]) end
                    end
                end
            end
        end

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnKilled(oUnitKilled, instigator, type, overkillRatio)
    --WARNING: Doesnt trigger when an ACU is killed

    --NOTE: Called by any unit of any player being killed; also note that OnUnitDeath triggers as well as this
    --i.e. this shoudl be used for where only want to get an event where the unit was killed by something
    --Is the unit owned by M27AI?
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnKilled'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        local refbAlreadyRun = 'M27EventsOnKilledRun'
        if not(oUnitKilled[refbAlreadyRun]) then
            oUnitKilled[refbAlreadyRun] = true

            if bDebugMessages == true then LOG(sFunctionRef..': oUnitKilled='..oUnitKilled.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitKilled)..'; Is unit killed an ACU='..tostring(M27Utilities.IsACU(oUnitKilled))..'; GameTime='..GetGameTimeSeconds()) end

            if oUnitKilled.GetAIBrain then
                if EntityCategoryContains(categories.COMMAND, oUnitKilled.UnitId) then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to call the OnACUKilled function') end
                    OnACUKilled(oUnitKilled)
                end
                local oKilledBrain = oUnitKilled:GetAIBrain()
                if instigator and instigator.GetAIBrain and instigator.UnitId and oUnitKilled.UnitId and EntityCategoryContains(M27UnitInfo.refCategoryGunship, instigator.UnitId) then
                    local oKillerBrain = instigator:GetAIBrain()
                    if oKillerBrain.M27AI then
                        --Gunship effectiveness

                        oKillerBrain[M27AirOverseer.refiGunshipMassKilled] = oKillerBrain[M27AirOverseer.refiGunshipMassKilled] + (oUnitKilled:GetBlueprint().Economy.BuildCostMass or 0)
                    end
                end


                if oKilledBrain.M27AI then
                    --Flag for the platoon to update
                    if oUnitKilled.PlatoonHandle then oUnitKilled.PlatoonHandle[M27PlatoonUtilities.refbPlatoonUnitDetailsChangedRecently] = true end


                    --were we killed by something?
                    local oKillerUnit

                    if instigator and not(instigator:BeenDestroyed()) and not(instigator.Dead) then
                        if instigator.GetLauncher and instigator:GetLauncher() then
                            oKillerUnit = instigator:GetLauncher()
                        elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                            --Can get errors for artillery shells when running IsProjectile
                        elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                            if instigator.unit then
                                oKillerUnit = instigator.unit
                            end
                        elseif IsUnit(instigator) then
                            oKillerUnit = instigator
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Have an instigator, checking if have valid killer unit. Is valid='..tostring(M27UnitInfo.IsUnitValid(oKillerUnit))) end
                        if oKillerUnit and oKillerUnit.GetAIBrain then
                            M27AirOverseer.CheckForUnseenKiller(oKilledBrain, oUnitKilled, oKillerUnit)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have a killer, will consider specific callbacks, oKillerUnit='..oKillerUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oKillerUnit)..'; oJunitKilled='..oUnitKilled.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitKilled)..'; Killer brain='..oKillerUnit:GetAIBrain().Nickname..'; Killed brain='..oUnitKilled:GetAIBrain().Nickname) end
                            --Platoons - track when unit last died to ground attack
                            if EntityCategoryContains(categories.LAND + categories.STRUCTURE + M27UnitInfo.refCategoryNavalSurface, oKillerUnit.UnitId) and oUnitKilled.PlatoonHandle and not(oUnitKilled.PlatoonHandle[M27PlatoonTemplates.refbIdlePlatoon]) then
                                oUnitKilled.PlatoonHandle[M27PlatoonUtilities.refiTimeOfLastDeathToSurfaceUnit] = GetGameTimeSeconds()
                            end


                            if EntityCategoryContains(M27UnitInfo.refCategoryFixedT2Arti, oKillerUnit.UnitId) then
                                if (oKillerUnit.VetExperience or oKillerUnit.Sync.totalMassKilled) >= 250 and IsEnemy(oKilledBrain:GetArmyIndex(), oKillerUnit:GetAIBrain():GetArmyIndex()) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to add oKillerUnit='..oKillerUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oKillerUnit)..' owned by brain '..oKillerUnit:GetAIBrain().Nickname..' that just killed '..oUnitKilled.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitKilled)..' that was owned by '..oUnitKilled:GetAIBrain().Nickname..' to list of T2 arti to avoid') end
                                    M27Team.RecordUnseenArti(oKilledBrain, oKillerUnit)
                                end
                                --Record dangerous AA that we may struggle to overwhelm with t1 bombers so can avoid
                            elseif EntityCategoryContains(M27UnitInfo.refCategoryMAA * categories.LAND, oKillerUnit.UnitId) and EntityCategoryContains(categories.TECH3 * categories.UEF + categories.TECH3 * categories.SERAPHIM + categories.TECH2, oKillerUnit.UnitId) and EntityCategoryContains(categories.AIR, oUnitKilled.UnitId) then
                                if bDebugMessages == true then LOG(sFunctionRef..': MAA just killed a unit, check if want to record as dangerous AA. Total mass killed='..(oKillerUnit.VetExperience or oKillerUnit.Sync.totalMassKilled)..'; Is killer an enemy='..tostring(IsEnemy(oKilledBrain:GetArmyIndex(), oKillerUnit:GetAIBrain():GetArmyIndex()))) end
                                if (oKillerUnit.VetExperience or oKillerUnit.Sync.totalMassKilled) >= 2000 and IsEnemy(oKilledBrain:GetArmyIndex(), oKillerUnit:GetAIBrain():GetArmyIndex()) then
                                    --if not(EntityCategoryContains(categories.STRUCTURE * categories.TECH3, oKillerUnit.UnitId)) or oKillerUnit.Sync.totalMassKilled >= 2500 then
                                    M27Team.RecordDangerousAA(oKilledBrain, oKillerUnit)
                                    --end
                                end
                            end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': Dont have valid instigator. Is instigator nil='..tostring(instigator == nil))
                    end

                    --Gunship effectiveness
                    if EntityCategoryContains(M27UnitInfo.refCategoryGunship, oUnitKilled.UnitId) then
                        oKilledBrain[M27AirOverseer.refiGunshipMassLost] = oKilledBrain[M27AirOverseer.refiGunshipMassLost] + math.min(2000, (oUnitKilled:GetBlueprint().Economy.BuildCostMass or 0), (oKillerUnit.VetExperience or oKillerUnit.Sync.totalMassKilled))
                        if oKilledBrain[M27AirOverseer.refiGunshipMassKilled] < 2000 then
                            oKilledBrain[M27AirOverseer.refiGunshipMassKilled] = math.max(oKilledBrain[M27AirOverseer.refiGunshipMassKilled], oUnitKilled:GetBlueprint().Economy.BuildCostMass)
                        end
                    end

                    --Firebase tracking
                    if EntityCategoryContains(M27UnitInfo.refCategoryFirebaseSuitable, oUnitKilled.UnitId) then
                        oKilledBrain[M27EngineerOverseer.refbPotentialFirebaseBuildingChangedSinceLastFirebaseCheck] = true
                    end


                    --Hive assistance for fixed shields
                    if EntityCategoryContains(M27UnitInfo.refCategoryHive, oUnitKilled.UnitId) then
                        local aiBrain = oUnitKilled:GetAIBrain()
                        local tNearbyHives = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryHive, oUnitKilled:GetPosition(), 20, 'Ally')
                        if M27Utilities.IsTableEmpty(tNearbyHives) then
                            local tNearbyFixedShields = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryFixedShield, oUnitKilled:GetPosition(), 23, 'Ally')
                            if M27Utilities.IsTableEmpty(tNearbyFixedShields) == false then
                                --Is the shield already flagged as wanting a hive?
                                for iNearbyShield, oNearbyShield in tNearbyFixedShields do
                                    local bAddToTable = true
                                    if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftShieldsWantingHives]) == false then

                                        for iShield, oShield in aiBrain[M27EngineerOverseer.reftShieldsWantingHives] do
                                            if oShield == oNearbyShield then
                                                bAddToTable = false
                                                break
                                            end
                                        end
                                    end
                                    if bAddToTable then table.insert(aiBrain[M27EngineerOverseer.reftShieldsWantingHives], oNearbyShield) end
                                end
                            end
                        end
                    end

                    if EntityCategoryContains(M27UnitInfo.refCategoryPD, oUnitKilled.UnitId) then
                        --If a PD that didnt compelte construction then track mass value so we adjust PD effectiveness
                        if not(oUnitKilled.M27OnConstructedCalled) then
                            oKilledBrain[M27EngineerOverseer.refiMassSpentOnPD] = oKilledBrain[M27EngineerOverseer.refiMassSpentOnPD] + oUnitKilled:GetBlueprint().Economy.BuildCostMass * 0.5
                        end
                        --Adjust firebase overall PD mass values
                        if oUnitKilled[M27EngineerOverseer.refiAssignedFirebase] then
                            oKilledBrain[M27EngineerOverseer.reftiFirebaseDeadPDMassCost][oUnitKilled[M27EngineerOverseer.refiAssignedFirebase]] = (oKilledBrain[M27EngineerOverseer.reftiFirebaseDeadPDMassCost][oUnitKilled[M27EngineerOverseer.refiAssignedFirebase]] or 0) + oUnitKilled:GetBlueprint().Economy.BuildCostMass * oUnitKilled:GetFractionComplete()
                            oKilledBrain[M27EngineerOverseer.reftiFirebaseDeadPDMassKills][oUnitKilled[M27EngineerOverseer.refiAssignedFirebase]] = (oKilledBrain[M27EngineerOverseer.reftiFirebaseDeadPDMassKills][oUnitKilled[M27EngineerOverseer.refiAssignedFirebase]] or 0) + (oUnitKilled.VetExperience or oUnitKilled.Sync.totalMassKilled or 0)
                        end
                    end

                    --Skirmisher tracking
                    if EntityCategoryContains(M27UnitInfo.refCategorySkirmisher, oUnitKilled.UnitId) then
                        --We already track the mass killed generally from the unitdeath event; this is only for tracking if it died to DF unit
                        if oKillerUnit and EntityCategoryContains(categories.LAND * categories.MOBILE, oKillerUnit.UnitId) then
                            local aiBrain = oUnitKilled:GetAIBrain()
                            aiBrain[M27Overseer.refiSkirmisherMassDeathsFromLand] = aiBrain[M27Overseer.refiSkirmisherMassDeathsFromLand] + oUnitKilled:GetBlueprint().Economy.BuildCostMass
                        end
                    end

                    --Naval factory destroyed - track re pond
                    if EntityCategoryContains(M27UnitInfo.refCategoryNavalFactory, oUnitKilled.UnitId) then
                        local iCurPond = oUnitKilled[M27Navy.refiAssignedPond]
                        local aiBrain = oUnitKilled:GetAIBrain()
                        if not(iCurPond) then
                            iCurPond = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeNavy, oUnitKilled:GetPosition())
                        end
                        M27Team.tTeamData[aiBrain.M27Team][M27Team.refiDestroyedNavalFactoriesByPond][iCurPond] = (M27Team.tTeamData[aiBrain.M27Team][M27Team.refiDestroyedNavalFactoriesByPond][iCurPond] or 0) + 1
                        M27Team.tTeamData[aiBrain.M27Team][M27Team.refiTimeOfLastNavalFactoryDestruction][iCurPond] = GetGameTimeSeconds()

                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit killed doesnt belogn to M27. Killed unit brain nickname='..oUnitKilled:GetAIBrain().Nickname)
                end
                --Did a PD or skirmisher we own kill something?
                if instigator and not(instigator.GetLauncher and instigator:GetLauncher()) and instigator.UnitId and IsUnit(instigator) then
                    local oKillerBrain = instigator:GetAIBrain()
                    if oKillerBrain.M27AI then
                        --Chat message for experimentals
                        if bDebugMessages == true then LOG(sFunctionRef..': Instigator='..instigator.UnitId..'; Time since last OC='..GetGameTimeSeconds() - (instigator[M27UnitInfo.refiTimeOfLastOverchargeShot] or -100)..'; oUnitKilled='..oUnitKilled.UnitId..'; killed nearby experimental value='..(M27Chat.tiM27VoiceTauntByType['Killed nearby experimental'] or 'nil')..'; Did we kill a land experimental='..tostring(EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental, oUnitKilled.UnitId))..'; Did we kill it with an ACU='..tostring(EntityCategoryContains(categories.COMMAND, instigator.UnitId))..'; repru of M27Chat.tiM27VoiceTauntByType='..repru(M27Chat.tiM27VoiceTauntByType)) end
                        if EntityCategoryContains(categories.EXPERIMENTAL, oUnitKilled.UnitId) and not(M27Chat.tiM27VoiceTauntByType['Killed nearby experimental']) and (oUnitKilled.VetExperience or oUnitKilled.Sync.totalMassKilled or 0) <= math.min(10000, oUnitKilled:GetBlueprint().Economy.BuildCostMass * 0.35) and M27Utilities.GetDistanceBetweenPositions(oUnitKilled:GetPosition(), M27MapInfo.PlayerStartPoints[oKillerBrain.M27StartPositionNumber]) <= 150 and M27Logic.GetCombatThreatRating(oKillerBrain, oKillerBrain:GetUnitsAroundPoint(categories.EXPERIMENTAL, oUnitKilled:GetPosition(), 150, 'Enemy')) <= 5000 then
                            M27Chat.SendMessage(oKillerBrain, 'Killed nearby experimental', 'Thanks for the mass', 5, 10000)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental, oUnitKilled.UnitId) and EntityCategoryContains(categories.COMMAND, instigator.UnitId) and GetGameTimeSeconds() - (instigator[M27UnitInfo.refiTimeOfLastOverchargeShot] or -100) <= 5 then
                            --Dont send message if enemy still have nearby dangerous units
                            if M27Utilities.IsTableEmpty(oKillerBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandExperimental + M27UnitInfo.refCategoryLandCombat * categories.TECH3, instigator:GetPosition(), 60, 'Enemy')) then
                                if bDebugMessages == true then LOG(sFunctionRef..': About to send ACU OC message') end
                                local sMessage = 'Wow, talk about a clutch overcharge'
                                if math.random(1,2) == 1 and M27Conditions.DoesACUHaveGun(oKillerBrain, false, instigator) then sMessage = 'Lol, turns out guncom counters '..LOCF(oUnitKilled:GetBlueprint().General.UnitName) end
                                M27Chat.SendMessage(oKillerBrain, 'ACU OC experimental', sMessage, 5, 10000)
                            end
                        elseif EntityCategoryContains(categories.STRUCTURE * M27UnitInfo.refCategoryExperimentalLevel, oUnitKilled.UnitId) and oUnitKilled:GetFractionComplete() >= 0.5 then
                            M27Chat.SendGloatingMessage(oKillerBrain, 1, 900)
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Will consider if we killed a target that got lots of kills') end

                            local iMassKilled = (oUnitKilled.VetExperience or oUnitKilled.Sync.totalMassKilled or 0)
                            if bDebugMessages == true then LOG(sFunctionRef..': Just killed '..oUnitKilled.UnitId..'; Mass that unit had killed='..iMassKilled..'; Is this chat message empty='..(M27Chat.tiM27VoiceTauntByType['Killed deadly unit'] or 'nil')..'; BP mass cost='..(oUnitKilled:GetBlueprint().Economy.BuildCostMass or 'nil')..'; Vet level='..(oUnitKilled.VetLevel or oUnitKilled.Sync.VeteranLevel or 'nil')) end
                            --Dont send message unless the killer is still alive (to avoid e.g. ACU killing something via its death explosion)
                            if iMassKilled >= 4000 and M27UnitInfo.IsUnitValid(instigator) and not(M27Chat.tiM27VoiceTauntByType['Killed deadly unit']) and not(EntityCategoryContains(categories.COMMAND, oUnitKilled.UnitId)) and (oUnitKilled.VetLevel or oUnitKilled.Sync.VeteranLevel) >= 5 and oUnitKilled.GetAIBrain and not(M27Logic.IsCivilianBrain(oUnitKilled:GetAIBrain())) then
                                --local oBP = oUnitKilled:GetBlueprint()
                                --if iMassKilled >= oBP.Economy.BuildCostMass * 7 then
                                if not(EntityCategoryContains(categories.COMMAND, instigator.UnitId)) or M27UnitInfo.GetUnitHealthPercent(instigator) >= 0.9 then

                                    local sMessage = 'Wow, that  '..LOCF(oUnitKilled:GetBlueprint().General.UnitName)..' managed '..math.floor(iMassKilled)..' in mass kills :('
                                    local iRandom = math.random(1,3)
                                    if iRandom == 1 then
                                        sMessage = 'Ah well, at least I managed to kill that '..LOCF(oUnitKilled:GetBlueprint().General.UnitName)..' that did so much damage'
                                    elseif iRandom == 2 then
                                        sMessage = 'That '..LOCF(oUnitKilled:GetBlueprint().General.UnitName)..' did way too much damage'
                                    end
                                    M27Chat.SendMessage(oKillerBrain, 'Killed deadly unit', sMessage, 2, 10000)
                                end
                                --end
                            end
                        end

                        if EntityCategoryContains(M27UnitInfo.refCategoryPD, instigator.UnitId) then
                            oKillerBrain[M27EngineerOverseer.refiMassKilledByPD] = oKillerBrain[M27EngineerOverseer.refiMassKilledByPD] + oUnitKilled:GetBlueprint().Economy.BuildCostMass
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryTML, instigator.UnitId) then
                            --Did we kill something with a TML that wasnt our last target (so e.g. a unit might have managed to block the TML missile meaning we can try again)?
                            if M27UnitInfo.IsUnitValid(instigator[M27EngineerOverseer.refoLastTMLTarget]) then
                                if bDebugMessages == true then LOG(sFunctionRef..': TML last target='..instigator[M27EngineerOverseer.refoLastTMLTarget].UnitId..M27UnitInfo.GetUnitLifetimeCount(instigator[M27EngineerOverseer.refoLastTMLTarget])..'; shots fired at last target='..(instigator[M27EngineerOverseer.refoLastTMLTarget][M27EngineerOverseer.refiTMLShotsFired] or 0)..'; Mass killed currently='..(instigator.VetExperience or instigator.Sync.totalMassKilled)..'; mass killed when fired missile='..instigator[M27EngineerOverseer.refiLastTMLMassKills]) end
                                --if instigator[M27EngineerOverseer.refiLastTMLMassKills] < (instigator.Sync.totalMassKilled or 0) and (instigator[M27EngineerOverseer.refoLastTMLTarget][M27EngineerOverseer.refiTMLShotsFired] or 0) > 0 then
                                --if bDebugMessages == true then LOG(sFunctionRef..': TML killed a unit that wasnt its last target so missile may have been blocked') end

                                --Allow to go to -1 to give a small margin for error incase e.g. the next time it is blocked by a higher health unit
                                instigator[M27EngineerOverseer.refoLastTMLTarget][M27EngineerOverseer.refiTMLShotsFired] = math.max((instigator[M27EngineerOverseer.refoLastTMLTarget][M27EngineerOverseer.refiTMLShotsFired] or 1) - 1, -1)
                                --end
                            end
                        elseif EntityCategoryContains(M27UnitInfo.refCategorySkirmisher, instigator.UnitId) then
                            local aiBrain = instigator:GetAIBrain()
                            aiBrain[M27Overseer.refiSkirmisherMassKills] = aiBrain[M27Overseer.refiSkirmisherMassKills] + oUnitKilled:GetBlueprint().Economy.BuildCostMass
                        elseif EntityCategoryContains(M27UnitInfo.refCategorySatellite, instigator.UnitId) then
                            ForkThread(M27AirOverseer.NovaxCoreTargetLoop, oKillerBrain, instigator, true)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryBomber * categories.TECH1,  instigator.UnitId) and M27UnitInfo.IsUnitValid(instigator) then
                            --if M27UnitInfo.GetUnitLifetimeCount(instigator) == 4 then bDebugMessages = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': Killer unit='..instigator.UnitId..M27UnitInfo.GetUnitLifetimeCount(instigator)..'; is instigator valid='..tostring(M27UnitInfo.IsUnitValid(instigator))..'; unit killed='..oUnitKilled.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitKilled)) end
                            if EntityCategoryContains(M27UnitInfo.refCategoryT1Mex, oUnitKilled.UnitId) then
                                --T1 mex just killed by T1 bomber - get bomber to target nearby enemy engineer (if any)
                                ForkThread(M27AirOverseer.OneOffTargetNearbyEngineer, oKillerBrain, instigator)
                            else
                                --if just killed an engineer that were trying to kill then also look to kill another nearby engineer (this wont run if this is an engi hunter bomber, i.e. intended for bombers that targeted an engi in the above logic)
                                if EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oUnitKilled.UnitId) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want to target another engineer as just killed one. Cur target number='..(instigator[M27AirOverseer.refiCurTargetNumber] or 'nil')..'; is target list empty='..tostring(M27Utilities.IsTableEmpty(instigator[M27AirOverseer.reftTargetList]))) end
                                    if instigator[M27AirOverseer.refiCurTargetNumber] and M27Utilities.IsTableEmpty(instigator[M27AirOverseer.reftTargetList]) == false then
                                        local oBomberTarget = instigator[M27AirOverseer.reftTargetList][instigator[M27AirOverseer.refiCurTargetNumber]][M27AirOverseer.refiShortlistUnit]
                                        if bDebugMessages == true then LOG(sFunctionRef..': oBomberTarget='..oBomberTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oBomberTarget)) end
                                        if oBomberTarget == oUnitKilled then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will look for another nearby engineer to target') end
                                            ForkThread(M27AirOverseer.OneOffTargetNearbyEngineer, oKillerBrain, instigator)
                                        end
                                    end
                                end
                            end
                        end
                    end

                end
                --AirAA tracking
                if EntityCategoryContains(M27UnitInfo.refCategoryAirNonScout * categories.ANTIAIR, oUnitKilled.UnitId) then
                    if M27Utilities.IsTableEmpty(M27Overseer.tAllActiveM27Brains) == false then
                        for iBrain, oBrain in M27Overseer.tAllActiveM27Brains do
                            if IsEnemy(oBrain:GetArmyIndex(), oKilledBrain:GetArmyIndex()) then
                                local iThreatReductionMod = 0.6
                                if EntityCategoryContains(categories.EXPERIMENTAL, oUnitKilled.UnitId) then iThreatReductionMod = 0.7 end
                                oBrain[M27AirOverseer.refiEnemyAirAAThreat] = math.max(math.min(oBrain[M27AirOverseer.refiHighestEverEnemyAirAAThreat] * (1 - iThreatReductionMod), oBrain[M27AirOverseer.refiEnemyAirAAThreat]), oBrain[M27AirOverseer.refiEnemyAirAAThreat] - oUnitKilled:GetBlueprint().Economy.BuildCostMass * iThreatReductionMod)
                            end
                        end
                    end
                    --Ythotha death logic
                elseif oUnitKilled.UnitId == 'xsl0401' then
                    OnYthothaDeath(oUnitKilled)
                end

            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit killed doesnt have a brain')
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end

    --Stat tracking
    if M27Config.M27StatTracking then
        if oUnitKilled.GetAIBrain then
            local refbAlreadyRun = 'M27EventsOnKilledStatsRun'
            if not(oUnitKilled[refbAlreadyRun]) then
                oUnitKilled[refbAlreadyRun] = true
                local oKillerUnit
                if instigator then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oKillerUnit = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                end
                if oKillerUnit then
                    ForkThread(M27Stats.UpdateStatsForKiller, oKillerUnit, oUnitKilled)
                end
                ForkThread(M27Stats.UpdateStatsForKilled,oUnitKilled)
            end
        end
    end
end

function OnMexDeath(oUnit)
    --Make the mex status available
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnMexDeath'
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        local sLocationRef = M27Utilities.ConvertLocationToStringRef(oUnit:GetPosition())
        for iRefBrain, aiBrain in M27Overseer.tAllActiveM27Brains do
            if aiBrain[M27EngineerOverseer.reftiResourceClaimedStatus][sLocationRef] then
                aiBrain[M27EngineerOverseer.reftiResourceClaimedStatus][sLocationRef][M27EngineerOverseer.refiResourceStatus] = M27EngineerOverseer.refiStatusAvailable
            end
        end
        local aiBrain = oUnit:GetAIBrain()
        if EntityCategoryContains(categories.TECH3, oUnit.UnitId) then
            if aiBrain.M27AI and M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftT3MexesUnderConstruction]) then
                ForkThread(M27EngineerOverseer.RefreshUnderConstructionT3MexList, aiBrain)
            end
        end
        --Plateau tracking
        if oUnit[M27Transport.refiAssignedPlateau] and not(oUnit[M27Transport.refiAssignedPlateau] == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) then
            if aiBrain[M27MapInfo.reftOurPlateauInformation][oUnit[M27Transport.refiAssignedPlateau]][M27MapInfo.subrefPlateauMexBuildings] then aiBrain[M27MapInfo.reftOurPlateauInformation][oUnit[M27Transport.refiAssignedPlateau]][M27MapInfo.subrefPlateauMexBuildings][oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)] = nil end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnPropDestroyed(oProp)
    --Confirmed manually this triggers e.g. if a bomber destroys a rock, and if a tree is reclaimed
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnPropDestroyed'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if oProp.CachePosition then
            if bDebugMessages == true then
                LOG(sFunctionRef..': Prop destroyed hook successful; will debug array and then update reclaim at the location '..repru(oProp.CachePosition)..' drawing red rectangle around cahce position')
                M27Utilities.DrawLocation(oProp.CachePosition, nil, 2, 100, nil)
                M27Utilities.DebugArray(oProp)
            end

            ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, oProp.CachePosition, 0)
        end

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnYthothaDeath(oUnit)
    --Called when a ythotha (oUnit) is flagged as dying or being killed
    --Swarm-AI workaround to deal with how it is controlled as a normal unit - slow it down so it stays in a simialr area to normal
    local refbYthothaDeath = 'M27EventYthothaDeath'

    local sFunctionRef = 'OnYthothaDeath'
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if not(oUnit[refbYthothaDeath]) then
        oUnit[refbYthothaDeath] = true
        if oUnit:GetAIBrain().M27SwarmAI then
            ForkThread(M27Logic.YthothaDeathBallSearchAndSlow, oUnit:GetAIBrain(), oUnit:GetPosition())
        end
        local tNearbyUnits
        if bDebugMessages == true then LOG(sFunctionRef..': Ythotha has just died, will look for nearby units and tell them to run away') end
        local iTimeToRun
        local iSearchRange = 70
        for iBrain, oBrain in M27Overseer.tAllActiveM27Brains do
            tNearbyUnits = oBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryMobileLand, oUnit:GetPosition(), 50, 'Ally')
            if M27Utilities.IsTableEmpty(tNearbyUnits) == false then
                for iFriendlyUnit, oFriendlyUnit in tNearbyUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': oFriendlyUnit='..oFriendlyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..'; if we own it then will make it run away') end
                    if oFriendlyUnit:GetAIBrain() == oBrain then --Only do this for M27 units
                        if M27UnitInfo.IsUnitValid(oFriendlyUnit, true) then
                            iTimeToRun = math.min(32, math.max(10, 18 + (50 - M27Utilities.GetDistanceBetweenPositions(oFriendlyUnit:GetPosition(), oUnit:GetPosition()) / (oFriendlyUnit:GetBlueprint().Physics.MaxSpeed or 1))))
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling friendly unit '..oFriendlyUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..' to move away for 18s via moveawayfromtarget order') end
                            ForkThread(M27UnitMicro.MoveAwayFromTargetTemporarily, oFriendlyUnit, iTimeToRun, oUnit:GetPosition())
                        end
                    end
                end
            end
        end
    end

end


function OnUnitDeath(oUnit)
    --WARNING: Doesnt trigger when an ACU is killed

    --NOTE: This is called by the death of any unit of any player, so careful with what commands are given
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnUnitDeath'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)


        if bDebugMessages == true then LOG(sFunctionRef..'Hook successful. oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; IsACU='..tostring(M27Utilities.IsACU(oUnit))..'; GameTime='..GetGameTimeSeconds()) end
        --Is it an ACU?
        if M27Utilities.IsACU(oUnit) then --NOTE: THis doesnt always trigger for ACU (not sure if it triggers some of the time, or none of the time)
            OnACUKilled(oUnit)

        else
            if bDebugMessages == true then
                LOG('Will debug array of the unit')
                M27Utilities.DebugArray(oUnit)
            end
            if oUnit.CachePosition then --Redundancy to check not dealing with a unit, not sure this will actually trigger as looks like wreck deaths are picked up by the prop logic above
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Unit killed has a cache position, will draw in blue around it')
                    M27Utilities.DrawLocation(oUnit.CachePosition, nil, 1, 100, nil)
                end
                ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, oUnit.CachePosition, 0)
            else

                if oUnit.GetAIBrain then
                    --Ythotha deathball avoidance - all M27 units run away regardless of whether it was an M27 or enemy Ythotha
                    --Note -seraphimunits.lua contains SEnergyBallUnit which looks like it is for when the death ball is spawned; ID is XSL0402; SpawnElectroStorm is in the ythotha script
                    --Sandbox test - have c.36s from ythotha dying to energy ball dying, so want to run away for half of this (18s) plus extra time based on how far away we already were
                    if EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental * categories.SERAPHIM, oUnit.UnitId) then
                        OnYthothaDeath(oUnit)
                    end

                    --Enemy experimental dies - update all M27 threat values


                    local aiBrain = oUnit:GetAIBrain()
                    if EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental, oUnit.UnitId) then
                        for iBrain, oBrain in M27Overseer.tAllActiveM27Brains do
                            if IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                                local iMassCost = oUnit:GetBlueprint().Economy.BuildCostMass

                                if EntityCategoryContains(M27UnitInfo.refCategoryLongRangeMobile, oUnit.UnitId) then
                                    oBrain[M27Overseer.refiTotalEnemyLongRangeThreat] = oBrain[M27Overseer.refiTotalEnemyLongRangeThreat] - iMassCost
                                end
                                if EntityCategoryContains(M27UnitInfo.refCategoryShortRangeMobile, oUnit.UnitId) then
                                    oBrain[M27Overseer.refiTotalEnemyShortRangeThreat] = oBrain[M27Overseer.refiTotalEnemyShortRangeThreat] - iMassCost
                                end
                            end
                        end
                    end

                    --Is the unit owned by M27AI?
                    if aiBrain.M27AI then
                        --Flag for the platoon count of units to be updated:
                        if oUnit.PlatoonHandle then oUnit.PlatoonHandle[M27PlatoonUtilities.refbPlatoonUnitDetailsChangedRecently] = true end

                        --Run unit type specific on death logic
                        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                        local sUnitBP = oUnit.UnitId


                        if EntityCategoryContains(refCategoryEngineer, sUnitBP) then
                            --M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..'Pre clear action')
                            M27EngineerOverseer.OnEngineerDeath(aiBrain, oUnit)
                            --M27EngineerOverseer.TEMPTEST(aiBrain, sFunctionRef..'Post clear action')
                        elseif EntityCategoryContains(refCategoryAirScout, sUnitBP) then
                            M27AirOverseer.OnScoutDeath(aiBrain, oUnit)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryAirAA, sUnitBP) then
                            M27AirOverseer.OnAirAADeath(oUnit)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryBomber, sUnitBP) or EntityCategoryContains(M27UnitInfo.refCategoryTorpBomber, sUnitBP) then
                            M27AirOverseer.OnBomberDeath(aiBrain, oUnit)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryFixedShield, sUnitBP) then
                            M27EngineerOverseer.CheckUnitsStillShielded(aiBrain)
                            --elseif EntityCategoryContains(M27UnitInfo.refCategoryMobileLandShield, sUnitBP) then
                            --aiBrain[M27PlatoonFormer.refbUsingMobileShieldsForPlatoons] = true
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryMex, sUnitBP) then
                            OnMexDeath(oUnit)
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryLandScout, sUnitBP) then
                            aiBrain[M27Overseer.refbScoutBuiltOrDied] = true
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryMAA, sUnitBP) then
                            aiBrain[M27Overseer.refbMAABuiltOrDied] = true
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryTMD, sUnitBP) and M27Utilities.IsTableEmpty(oUnit[M27UnitInfo.reftTMLDefence]) == false then
                            local tUnitsWantingTMD = {}
                            for iWantingTMD, oWantingTMD in oUnit[M27UnitInfo.reftTMLDefence] do
                                if M27UnitInfo.IsUnitValid(oUnit) then table.insert(tUnitsWantingTMD, oUnit) end
                            end
                            if M27Utilities.IsTableEmpty(tUnitsWantingTMD) == false then M27Logic.DetermineTMDWantedForUnits(aiBrain, tUnitsWantingTMD) end
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryTML, sUnitBP) then
                            if (oUnit.VetExperience or oUnit.Sync.totalMassKilled or 0) >= 800 then
                                aiBrain[M27EngineerOverseer.refiTimeOfLastFailedTML] = nil
                            else
                                local iTime = GetGameTimeSeconds()
                                aiBrain[M27EngineerOverseer.refiTimeOfLastFailedTML] = iTime
                                --Reset after 5m (unless another TML dies between now and then)
                                M27Utilities.DelayChangeVariable(aiBrain, M27EngineerOverseer.refiTimeOfLastFailedTML, nil, 300, M27EngineerOverseer.refiTimeOfLastFailedTML, iTime + 0.01, nil, nil)
                            end
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryLandFactory, sUnitBP) then
                            if not(oUnit[M27Transport.refiAssignedPlateau] == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) then
                                if aiBrain[M27MapInfo.reftOurPlateauInformation][oUnit[M27Transport.refiAssignedPlateau]][M27MapInfo.subrefPlateauLandFactories] then aiBrain[M27MapInfo.reftOurPlateauInformation][oUnit[M27Transport.refiAssignedPlateau]][M27MapInfo.subrefPlateauLandFactories][oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)] = nil end
                            end
                        elseif EntityCategoryContains(M27UnitInfo.refCategorySkirmisher, sUnitBP) then
                            aiBrain[M27Overseer.refiSkirmisherMassDeathsAll] = aiBrain[M27Overseer.refiSkirmisherMassDeathsAll] + oUnit:GetBlueprint().Economy.BuildCostMass
                            if EntityCategoryContains(M27UnitInfo.refCategorySniperBot, sUnitBP) then
                                if M27UnitInfo.IsUnitValid(oUnit[M27UnitInfo.refoCoordinatedTarget]) and M27Utilities.IsTableEmpty(oUnit[M27UnitInfo.refoCoordinatedTarget][M27UnitInfo.reftDFUnitsAttacking]) == false then
                                    for iSniper, oSniper in oUnit[M27UnitInfo.refoCoordinatedTarget][M27UnitInfo.reftDFUnitsAttacking] do
                                        if oSniper == oUnit then
                                            M27UnitInfo.RemoveDFStrikeDamageUnitFromTarget(oUnit[M27UnitInfo.refoCoordinatedTarget], oUnit, iSniper)
                                            break
                                        end
                                    end
                                end
                            end
                        elseif EntityCategoryContains(M27UnitInfo.refCategoryTransport, sUnitBP) then
                            if M27Utilities.IsTableEmpty(aiBrain[M27Transport.reftTransportsAssignedByPlateauGroup]) == false then
                                for iPlateauGroup, tTransports in aiBrain[M27Transport.reftTransportsAssignedByPlateauGroup] do
                                    if M27Utilities.IsTableEmpty(tTransports) == false then
                                        if tTransports[oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)] then tTransports[oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)] = nil end
                                    end
                                end
                            end
                        end

                        --All non-mex/hydro - if have shield locations that cant build on, then check if this was near any of them
                        if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftFailedShieldLocations]) == false and EntityCategoryContains(categories.STRUCTURE - M27UnitInfo.refCategoryMex - M27UnitInfo.refCategoryHydro, sUnitBP) then
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': Have failed shield locations so will check if any buildings need adjusting')
                            end
                            local iBuildingSize = math.max(1, math.ceil(oUnit:GetBlueprint().Physics.SkirtSizeX))
                            local tLocation = oUnit:GetPosition()
                            for iXAdj = -iBuildingSize, iBuildingSize, 1 do
                                for iZAdj = -iBuildingSize, iBuildingSize, 1 do
                                    aiBrain[M27EngineerOverseer.reftFailedShieldLocations][M27Utilities.ConvertLocationToReference({ tLocation[1] + iXAdj, tLocation[2], tLocation[3] + iZAdj })] = nil
                                end
                            end
                        end

                        --Shields - reset tracking of assisting engineers
                        if M27Utilities.IsTableEmpty(oUnit[M27EngineerOverseer.reftAssistingEngineers]) == false then
                            for iEngi, oEngi in oUnit[M27EngineerOverseer.reftAssistingEngineers] do
                                if M27UnitInfo.IsUnitValid(oEngi) then
                                    M27Utilities.IssueTrackedClearCommands({ oEngi })
                                    M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngi, true)
                                end
                            end
                        end

                        --Naval shield tracking
                        if M27Utilities.IsTableEmpty(oUnit[M27Navy.reftoAssignedShields]) == false then
                            for iShield, oShield in oUnit[M27Navy.reftoAssignedShields] do
                                if M27UnitInfo.IsUnitValid(oShield) then M27Navy.RemoveShieldAssignment(oShield) end
                            end
                        end
                        if oUnit[M27Navy.refoSupportTarget] then
                            M27Navy.RemoveShieldAssignment(oUnit)
                        end


                        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                    elseif EntityCategoryContains(M27UnitInfo.refCategoryMex, oUnit.UnitId) then
                        OnMexDeath(oUnit)
                    end

                    --TMD - refresh nearby TMD
                    if EntityCategoryContains(M27UnitInfo.refCategoryTMD, oUnit.UnitId) then
                        local tTMDPosition = oUnit:GetPosition()
                        local iRadiusSize = M27EngineerOverseer.iTMDNearbyRange
                        local tNearbyTMD = GetUnitsInRect(Rect(tTMDPosition[1]-iRadiusSize, tTMDPosition[3]-iRadiusSize, tTMDPosition[1]+iRadiusSize, tTMDPosition[3]+iRadiusSize))
                        if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                            tNearbyTMD = EntityCategoryFilterDown(M27UnitInfo.refCategoryTMD, tNearbyTMD)
                            if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                                for iTMD, oTMD in tNearbyTMD do
                                    if M27UnitInfo.IsUnitValid(oTMD) then
                                        ForkThread(M27EngineerOverseer.RecordNearbyTMD, oTMD)
                                    end
                                end
                            end
                        end
                    end

                    --Naval units
                    if (oUnit[M27Navy.refiAssignedPond] or 0) > 0 then
                        M27Navy.RemoveUnitFromAssignedPond(oUnit)
                    end
                end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnWorkEnd(self, work)
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnWorkEnd'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWorkEnd'
        if bDebugMessages == true then LOG(sFunctionRef..': Hook successful') end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnEnhancementComplete(oUnit, sEnhancement)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnEnhancementComplete'
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Enhancement completed for self='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; sEnhancement='..reprs(sEnhancement)) end

    if sEnhancement == 'Teleporter' then M27AirOverseer.bTeleportersInGame = true end
    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
end

function OnShieldBubbleDamaged(self, instigator)
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnShieldBubbleDamaged'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        --Self is the shield object.  Doing a log of this, it has an Owner value, which is the unit object
        local oShield = self.Owner
        if M27UnitInfo.IsUnitValid(oShield) then
            if bDebugMessages == true then LOG(sFunctionRef..': Shield '..oShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oShield)..' has just taken damage') end
            local aiBrain = oShield:GetAIBrain()
            if aiBrain.M27AI then
                if aiBrain[M27EngineerOverseer.reftPriorityShieldsToAssist][oShield.UnitId..M27UnitInfo.GetUnitLifetimeCount(oShield)] then
                    --Dealing with a priority shield, so start a monitor if dont already have one
                    ForkThread(M27EngineerOverseer.MonitorShieldHealth, aiBrain, oShield)
                else
                    --Not a priority shield, so do nothing
                end

                --Have we just taken damage from an unseen indirect unit?
                local oKillerUnit
                if instigator and not(instigator:BeenDestroyed()) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oKillerUnit = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                        if M27UnitInfo.IsUnitValid(oKillerUnit) then
                        M27AirOverseer.CheckForUnseenKiller(aiBrain, oShield, oKillerUnit)
                    end
                end
            end
        end

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnDamaged(self, instigator) --This doesnt trigger when a shield bubble is damaged - see OnShieldBubbleDamaged for this
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnDamaged'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if self.IsWreckage then
            --Decided to comment out the below and only update when props and wrecks are destroyed
            --[[
            if bDebugMessages == true then LOG(sFunctionRef..': Wreckage damaged, will udpate reclaim') end

            --ForkThread(DelayedReclaimUpdateAtLocation, self.CachePosition, 1) --this would Update reclaim in this segment in 1 tick
            ForkThread(RecordThatWeWantToUpdateReclaimAtLocation, self.CachePosition, 0)--]]

        else
            if bDebugMessages == true then LOG(sFunctionRef..': Non-wreck damaged') end
            if self.GetUnitId then
                if self.GetAIBrain and not(self.Dead) then
                    local aiBrain = self:GetAIBrain()
                    if aiBrain.M27AI then
                        local oUnitCausingDamage
                        if instigator and not(instigator:BeenDestroyed()) then
                            if instigator.GetLauncher and instigator:GetLauncher() then
                                oUnitCausingDamage = instigator:GetLauncher()
                            elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                                --Can get errors for artillery shells when running IsProjectile
                            elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                                if instigator.unit then
                                    oUnitCausingDamage = instigator.unit
                                end
                            elseif IsUnit(instigator) then
                                oUnitCausingDamage = instigator
                            end
                            if not(oUnitCausingDamage) and bDebugMessages == true then LOG(sFunctionRef..': Dont ahve a valid unit as instigator') end
                        end
                        --Has our ACU been hit by an enemy we have no sight of? Or a mex taking damage? Or a land experimental taking naval damage?
                        if M27UnitInfo.IsUnitValid(self) and ((M27Utilities.IsACU(self) and self == M27Utilities.GetACU(aiBrain)) or EntityCategoryContains(M27UnitInfo.refCategoryMex, self.UnitId) or (EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental, self.UnitId) and M27UnitInfo.IsUnitUnderwater(self))) then
                            if bDebugMessages == true then LOG(sFunctionRef..': ACU mex or experimental has just taken damage, checking if can see the unit that damaged it') end
                            --Do we have a unit that damaged us?
                            if oUnitCausingDamage and M27UnitInfo.IsUnitValid(oUnitCausingDamage) then
                                self[M27Overseer.refoLastUnitDealingDamage] = oUnitCausingDamage
                                --Can we see the unit?
                                if bDebugMessages == true then LOG(sFunctionRef..': Checking if can see the unit that dealt us damage') end
                                if not(M27Utilities.CanSeeUnit(aiBrain, oUnitCausingDamage, true)) then
                                    if M27Utilities.IsACU(self) or EntityCategoryContains(M27UnitInfo.refCategoryLandExperimental, self.UnitId) then
                                        if bDebugMessages == true then LOG(sFunctionRef..': self='..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..'; cant see unit that caused damage, will ask for an air scout and flag the ACU/experimental has taken damage recently') end
                                        self[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage] = GetGameTimeSeconds()
                                        self[M27Overseer.refoUnitDealingUnseenDamage] = oUnitCausingDamage
                                    else
                                        --mex taken damage for first time from unseen enemy
                                        if not(aiBrain[M27Overseer.reftPriorityLandScoutTargets]) then aiBrain[M27Overseer.reftPriorityLandScoutTargets] = {} end
                                        if not(aiBrain[M27Overseer.reftPriorityLandScoutTargets][self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)]) then
                                            aiBrain[M27Overseer.reftPriorityLandScoutTargets][self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)] = self
                                            M27Utilities.DelayChangeVariable(aiBrain[M27Overseer.reftPriorityLandScoutTargets], self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self), nil, 120)
                                        end
                                    end
                                    --Flag that we want the location (and +- 2 segments around it) the shot came from scouted asap
                                    M27AirOverseer.MakeSegmentsAroundPositionHighPriority(aiBrain, oUnitCausingDamage:GetPosition(), 2)
                                else
                                    if oUnitCausingDamage.GetUnitId and EntityCategoryContains(M27UnitInfo.refCategoryTorpedoLandAndNavy, oUnitCausingDamage.UnitId) then
                                        self[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage] = GetGameTimeSeconds()
                                        self[M27Overseer.refoUnitDealingUnseenDamage] = oUnitCausingDamage
                                        if bDebugMessages == true then LOG(sFunctionRef..': self='..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..'; Can see unit and it is a torpedo unit so will flag that we have taken unseen or torpedo damage. self[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage]='..self[M27Overseer.refiACULastTakenUnseenOrTorpedoDamage]) end
                                    end
                                end
                                --If we're upgrading consider cancelling

                                if self.IsUnitState and self:IsUnitState('Upgrading') and EntityCategoryContains(categories.INDIRECTFIRE, oUnitCausingDamage.UnitId) and not(M27Conditions.DoesACUHaveGun(aiBrain, false, self)) then
                                    --ACU - consider cancelling
                                    if EntityCategoryContains(categories.COMMAND, self) then
                                        if self:GetWorkProgress() <= 0.25 then


                                            --Is the unit that damaged us within our range?
                                            local iOurRange = M27UnitInfo.GetUnitMaxGroundRange({ self })
                                            if bDebugMessages == true then LOG(sFunctionRef..': Taken indirect fire, consider cancelling upgrade as onl yat '..self:GetWorkProgress()..'; iOurRange='..iOurRange) end
                                            if iOurRange < M27Utilities.GetDistanceBetweenPositions(self:GetPosition(), oUnitCausingDamage:GetPosition()) then
                                                --Do we have nearby friendly units?
                                                if M27Utilities.IsTableEmpty(aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryLandCombat, self:GetPosition(), 40, 'Ally')) == true then
                                                    --Is the unit within range of us?
                                                    local iOurMaxRange = M27Logic.GetUnitMaxGroundRange({self})
                                                    if bDebugMessgaes == true then LOG(sFunctionRef..': iOurMaxRange='..iOurMaxRange..'; Dist to enemy causing damage='..M27Utilities.GetDistanceBetweenPositions(self:GetPosition(), oUnitCausingDamage:GetPosition())) end
                                                    if M27Utilities.GetDistanceBetweenPositions(self:GetPosition(), oUnitCausingDamage:GetPosition()) > iOurMaxRange then
                                                        if bDebugMessages == true then LOG(sFunctionRef..': Will cancel upgrade and start moving towards base') end
                                                        M27Utilities.IssueTrackedClearCommands({self})
                                                        IssueMove({self}, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
                                                    end
                                                end
                                            end
                                        end
                                        if not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyAirDominance) and not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyACUKill) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': ACU upgrading so switching to protect ACU mode. oUnitCausingDamage='..oUnitCausingDamage.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..'; self='..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..'; ACU state='..M27Logic.GetUnitState(self)..'; health%='..M27UnitInfo.GetUnitHealthPercent(self)..'; GameTime='..GetGameTimeSeconds()) end
                                            aiBrain[M27Overseer.refiAIBrainCurrentStrategy] = M27Overseer.refStrategyProtectACU
                                        end
                                    else
                                        function Unpause(oUnit, iWait)
                                            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                                            WaitSeconds(iWait)
                                            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                                            if M27UnitInfo.IsUnitValid(oUnit) then
                                                oUnit:SetPaused(false)
                                                oUnit[M27UnitInfo.refbPaused] = false
                                            end
                                        end
                                        --Other unit e.g. mex upgrading - just pause the upgrade and then unpause in 30s
                                        if self:GetWorkProgress() <= 0.9 then
                                            self:SetPaused(true)
                                            self[M27UnitInfo.refbPaused] = true
                                            ForkThread(Unpause, self, 60)
                                        end
                                    end
                                end
                            end
                        end

                        if M27UnitInfo.IsUnitValid(oUnitCausingDamage) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Unit causing damage='..oUnitCausingDamage.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..'; Can see unit='..tostring(M27Utilities.CanSeeUnit(aiBrain, oUnitCausingDamage, true))..'; Does the category contain PD='..tostring(EntityCategoryContains(M27UnitInfo.refCategoryPD, oUnitCausingDamage.UnitId))) end
                            --Unseen T2+ PD
                            if EntityCategoryContains(M27UnitInfo.refCategoryPD, oUnitCausingDamage.UnitId) and not(M27Utilities.CanSeeUnit(aiBrain, oUnitCausingDamage, true)) then
                                ForkThread(M27Team.RecordUnseenPD, oUnitCausingDamage, self)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have recrded unseen PD') end
                            end

                            --Unseen T2 arti and its either close to our base or damaged a high mass unit
                            if EntityCategoryContains(M27UnitInfo.refCategoryFixedT2Arti, oUnitCausingDamage.UnitId) then
                                if IsEnemy(self:GetAIBrain():GetArmyIndex(), oUnitCausingDamage:GetAIBrain():GetArmyIndex()) and ((self.GetBlueprint and self:GetBlueprint().Economy.BuildCostMass >= 1000) or M27Utilities.GetDistanceBetweenPositions(oUnitCausingDamage:GetPosition(), M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]) <= 200) then
                                    M27Team.RecordUnseenArti(aiBrain, oUnitCausingDamage)
                                    if bDebugMessages == true then LOG(sFunctionRef..': Enemy Arti caused damage to a unit with high mass cost, self='..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..' owned by '..self:GetAIBrain().Nickname..'; Arit='..oUnitCausingDamage.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitCausingDamage)..' owned by '..oUnitCausingDamage:GetAIBrain().Nickname..'; these two brains are considered enemies') end
                                end
                            end


                            --Unseen naval units - record if they have dealt us damage
                            if not(oUnitCausingDamage[M27UnitInfo.reftLastKnownPosition]) and EntityCategoryContains(M27UnitInfo.refCategoryAllAmphibiousAndNavy, oUnitCausingDamage.UnitId) then
                                M27Navy.UpdateUnitPond(oUnitCausingDamage, aiBrain.M27Team, IsEnemy(aiBrain:GetArmyIndex(), oUnitCausingDamage:GetAIBrain():GetArmyIndex()))
                            end

                            --Big threat
                            if EntityCategoryContains(M27Overseer.iAllBigThreatCategories, oUnitCausingDamage.UnitId) then ForkThread(M27Overseer.AddUnitToBigThreatTable, aiBrain, oUnitCausingDamage) end
                        end
                        --General logic for shields so are very responsive with micro
                        if self.MyShield and self.MyShield.GetHealth and self.MyShield:GetHealth() < 100 and EntityCategoryContains((M27UnitInfo.refCategoryMobileLandShield + M27UnitInfo.refCategoryPersonalShield) * categories.MOBILE, self) then
                            if self.PlatoonHandle and aiBrain:PlatoonExists(self.PlatoonHandle) then M27PlatoonUtilities.RetreatLowHealthShields(self.PlatoonHandle, aiBrain)
                            else
                                --Assign to a retreating platoon
                                local oShieldPlatoon = M27PlatoonFormer.CreatePlatoon(aiBrain, 'M27RetreatingShieldUnits', {self})
                            end
                        end

                        --Logic for gunships so are more responsive
                        if EntityCategoryContains(M27UnitInfo.refCategoryGunship, self.UnitId) and self[M27AirOverseer.refiGunshipPlacement] and not(aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyACUKill or aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyProtectACU) and M27UnitInfo.GetUnitHealthPercent(self) < M27AirOverseer.iGunshipLowHealthPercent then
                            if bDebugMessages == true then LOG(sFunctionRef..': Gunship '..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..' has just taken damage and now has '.. M27UnitInfo.GetUnitHealthPercent(self)..' health vs low health percent of '..M27AirOverseer.iGunshipLowHealthPercent..' so will retreat gunship') end
                            M27AirOverseer.ClearAirUnitAssignmentTrackers(aiBrain, self, false) --sends unit back to base/rally point
                        end

                    end
                end
            end
            if instigator and not(instigator.GetLauncher and instigator:GetLauncher()) and IsUnit(instigator) and instigator.GetAIBrain and instigator:GetAIBrain().M27AI then
                instigator[M27UnitInfo.refbRecentlyDealtDamage] = true
                instigator[M27UnitInfo.refiGameTimeDamageLastDealt] = math.floor(GetGameTimeSeconds())
                M27Utilities.DelayChangeVariable(instigator, M27UnitInfo.refbRecentlyDealtDamage, false, 5, M27UnitInfo.refiGameTimeDamageLastDealt, instigator[M27UnitInfo.refiGameTimeDamageLastDealt] + 1, nil, nil)
                --If just damaged T2+ mex or high value building with surface naval unit then have it attack that unit specifically until it is dead
                if EntityCategoryContains(M27UnitInfo.refCategoryNavalSurface, instigator.UnitId) and EntityCategoryContains(M27UnitInfo.refCategoryT2Mex + M27UnitInfo.refCategoryT3Mex + categories.VOLATILE * categories.STRUCTURE - M27UnitInfo.refCategoryT1Power + M27UnitInfo.refCategoryFixedT3Arti + M27UnitInfo.refCategorySML * categories.STRUCTURE + categories.EXPERIMENTAL * categories.STRUCTURE, self.UnitId) then
                    ForkThread(M27UnitMicro.FocusDownTarget, instigator, self)
                elseif EntityCategoryContains(M27UnitInfo.refCategoryFixedT3Arti + M27UnitInfo.refCategoryExperimentalArti, instigator.UnitId) then
                    if M27UnitInfo.IsUnitValid(self) then self[M27Logic.refiT3ArtiShotCount] = 0 end --reset count of missed arti shots
                end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnBombFired(oWeapon, projectile)
    if M27Utilities.bM27AIInGame then
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnBombFired'
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId then
            local sUnitID = oUnit.UnitId
            if bDebugMessages == true then LOG(sFunctionRef..': bomber position when firing bomb='..repru(oUnit:GetPosition())) end
            if EntityCategoryContains(M27UnitInfo.refCategoryBomber + M27UnitInfo.refCategoryTorpBomber, sUnitID) then
                --Dont bother trying to dodge an experimental bomb
                if not(EntityCategoryContains(categories.EXPERIMENTAL, sUnitID)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and dodge the bomb fired by unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    M27UnitMicro.DodgeBomb(oUnit, oWeapon, projectile)

                end
                if oUnit.GetAIBrain and oUnit:GetAIBrain().M27AI then
                    local iDelay = 0
                    if M27UnitInfo.DoesBomberFireSalvo(oUnit) then iDelay = 2 end



                    if bDebugMessages == true then LOG(sFunctionRef..': Projectile position='..repru(projectile:GetPosition())..'; Last fired bomb time='..(oUnit[M27AirOverseer.refiLastFiredBomb] or 0)..'; Cur time='..GetGameTimeSeconds()..'; iDelay='..iDelay) end
                    if not(oUnit[M27AirOverseer.refiLastFiredBomb]) or GetGameTimeSeconds() - oUnit[M27AirOverseer.refiLastFiredBomb] > iDelay then
                        oUnit[M27AirOverseer.refiBombsDropped] = (oUnit[M27AirOverseer.refiBombsDropped] or 0) + 1
                        oUnit[M27AirOverseer.refoLastBombTarget] = oUnit[M27AirOverseer.reftTargetList][oUnit[M27AirOverseer.refiCurTargetNumber]][M27AirOverseer.refiShortlistUnit]
                        if iDelay == 2 then iDelay = iDelay + 1 end --Increase by 1s since will be tracking when last fired a bomb as an extra check
                        ForkThread(M27AirOverseer.DelayedBomberTargetRecheck, oUnit, projectile, iDelay)
                    end
                    oUnit[M27AirOverseer.refiLastFiredBomb] = GetGameTimeSeconds()
                end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

--WARNING: OnWeaponFired and/or OnProjectilfeFired - one of these (probably the latter) resulted in error messages when t1 arti fired, disabled both of them as dont use now

function OnWeaponFired(oWeapon)
    if M27Utilities.bM27AIInGame then
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWeaponFired'
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; oWeapon='..reprs(oWeapon)) end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId then
            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' Just fired weapon, reprs of weapon='..reprs(oWeapon)) end

            if EntityCategoryContains(M27UnitInfo.refCategoryBomber, oUnit.UnitId) and oWeapon.Label == 'GroundMissile' then
                --Corsairs dont trigger the onbombfired event normally
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Weapon fired by corsair, unit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit))
                    if oWeapon:GetCurrentTarget().GetPosition then LOG(sFunctionRef..': Target of weapon='..repru(oWeapon:GetCurrentTarget():GetPosition())) end
                end

                ForkThread(M27UnitMicro.DodgeBomb, oUnit, oWeapon, nil)
            else
                --Dodge logic for certain other attacks (conditions for this are in considerdodgingshot)
                if bDebugMessages == true then LOG(sFunctionRef..': Will consider whether we want to dodge the shot') end
                ForkThread(M27UnitMicro.ConsiderDodgingShot, oUnit, oWeapon)

                --Update last known position if have one
                if oUnit[M27UnitInfo.reftLastKnownPosition] then oUnit[M27UnitInfo.reftLastKnownPosition] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]} end
            end

            --Overcharge
            if oWeapon.GetBlueprint and oWeapon:GetBlueprint().Overcharge then
                oUnit[M27UnitInfo.refbOverchargeOrderGiven] = false
                if bDebugMessages == true then LOG('Overcharge weapon was just fired') end
                oUnit[M27UnitInfo.refiTimeOfLastOverchargeShot] = GetGameTimeSeconds()
            end

            --SML fired - have all enemy M27 brains build SMD if they havent already (better late than never...); also have ACUs run to SMD if have any loaded
            if EntityCategoryContains(M27UnitInfo.refCategorySML, oUnit.UnitId) then
                local iEnemyIndex = oUnit:GetAIBrain():GetArmyIndex()
                for iBrain, oBrain in M27Overseer.tAllActiveM27Brains do
                    if IsEnemy(oBrain:GetArmyIndex(), iEnemyIndex) then
                        oBrain[M27Overseer.refbEnemyFiredNuke] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': About to setup forked thread to run from nuke for the ACU of brain '..oBrain.Nickname) end
                        ForkThread(M27UnitMicro.RunFromNuke, M27Utilities.GetACU(oBrain), oUnit)
                    end
                end
            end




            if oUnit:GetAIBrain().M27AI then
                --T3 and experimental arti
                if bDebugMessages == true then LOG(sFunctionRef..': Shot just fired by '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; Weapon range category='..oWeapon.Blueprint.RangeCategory or 'nil') end
                if EntityCategoryContains(M27UnitInfo.refCategoryFixedT3Arti + M27UnitInfo.refCategoryExperimentalArti, oUnit.UnitId) then
                    ForkThread(M27Logic.GetT3ArtiTarget, oUnit)
                    --DF units whose DF shot is blocked
                elseif oWeapon.Blueprint.RangeCategory == 'UWRC_DirectFire' and EntityCategoryContains(M27UnitInfo.refCategoryDFTank + M27UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M27UnitInfo.refCategorySeraphimDestroyer - M27UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                    --Get weapon target if it is a DF weapon
                    --if EntityCategoryContains(M27UnitInfo.refCategoryNavalSurface, oUnit.UnitId) then bDebugMessages = true LOG('reprs of weapon='..reprs(oWeapon)..'; will now do log of the weapon blueprint='..reprs(oWeapon.Blueprint)) end
                    local oTarget = oWeapon:GetCurrentTarget()
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' has just fired a shot. Do we have a valid target for our weapon='..tostring(M27UnitInfo.IsUnitValid(oTarget))..'; time last shot was blocked='..(oUnit[M27UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                    if M27UnitInfo.IsUnitValid(oTarget) then

                        oUnit[M27UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds()
                        oUnit[M27UnitInfo.refbLastShotBlocked] = M27Logic.IsShotBlocked(oUnit, oTarget)
                        if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is shot blocked='..tostring(oUnit[M27UnitInfo.refbLastShotBlocked])..'; built in blocking terrain result for low profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'Low'))..'; High profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'High'))) end

                        if oUnit[M27UnitInfo.refbLastShotBlocked] then
                            --Reset after 20s if we havent fired any more shots at the target
                            --function DelayChangeVariable(oVariableOwner, sVariableName, vVariableValue, iDelayInSeconds, sOptionalOwnerConditionRef, iMustBeLessThanThisTimeValue, iMustBeMoreThanThisTimeValue, vMustNotEqualThisValue)
                            M27Utilities.DelayChangeVariable(oUnit, M27UnitInfo.refbLastShotBlocked, false, 20, M27UnitInfo.refiTimeOfLastCheck, GetGameTimeSeconds() + 0.01)
                        end
                    end
                    --Track time of last shot firing for sniperbots and ACU:
                    if EntityCategoryContains(M27UnitInfo.refCategorySniperBot - categories.EXPERIMENTAL + categories.COMMAND, oUnit.UnitId) then
                        oUnit[M27UnitInfo.refiTimeLastFired] = GetGameTimeSeconds()
                    end
                    --SMD, TML and SML backup to ensure missile is built
                elseif EntityCategoryContains(categories.SILO * categories.STRUCTURE, oUnit.UnitId) and oUnit.SetAutoMode then
                    oUnit:SetAutoMode(true)
                    oUnit:SetPaused(false)
                    oUnit[M27EconomyOverseer.refbWillReclaimUnit] = false
                    if EntityCategoryContains(M27UnitInfo.refCategorySML, oUnit.UnitId) then oUnit:GetAIBrain()[M27EconomyOverseer.refbReclaimNukes] = false end

                    if EntityCategoryContains(M27UnitInfo.refCategorySMD, oUnit.UnitId) then
                        local aiBrain = oUnit:GetAIBrain()
                        if M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyNukeLaunchers]) == false and table.getn(aiBrain[M27Overseer.reftEnemyNukeLaunchers]) == 1 then
                            local sMessage = 'Nice try'
                            if math.random(1,2) == 1 then sMessage = 'Loaded :)' end
                            M27Chat.SendMessage(aiBrain, 'Stopped nuke', sMessage, 2, 10000)
                        end
                    end
                end
            else
                --Experimental fired - add to table of big threats
                if EntityCategoryContains(M27UnitInfo.refCategoryExperimentalLevel + M27UnitInfo.refCategoryTML, oUnit.UnitId) then
                    local aiBrain = oUnit:GetAIBrain()
                    for iBrain, oBrain in ArmyBrains do
                        if oBrain.M27AI and IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                            M27Overseer.AddUnitToBigThreatTable(oBrain, oUnit)
                        end
                    end
                end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnMissileBuilt(self, weapon)
    if M27Utilities.bM27AIInGame then

        if self.GetAIBrain and self:GetAIBrain().M27AI then
            --Flag we've recently built a missile (so e.g. have a backup in case there's a delay in registering the missile being built, so we dont assist SMD that has just built a missile)
            self[M27EngineerOverseer.refbMissileRecentlyBuilt] = true
            M27Utilities.DelayChangeVariable(self, M27EngineerOverseer.refbMissileRecentlyBuilt, false, 5)


            --Pause if we already have 2 missiles
            local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'OnMissileBuilt'
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
            if bDebugMessages == true then
                if M27UnitInfo.IsUnitValid(self) then
                    LOG(sFunctionRef..': Have valid unit='..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self))
                else
                    LOG(sFunctionRef..': self='..DebugArray(self))
                end
            end

            local iMissiles = 1 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if self.GetTacticalSiloAmmoCount then iMissiles = iMissiles + self:GetTacticalSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles based on tactical silo ammo='..iMissiles) end
            if self.GetNukeSiloAmmoCount then iMissiles = iMissiles + self:GetNukeSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles after Nuke silo ammo='..iMissiles) end
            if iMissiles >= 2 and not(EntityCategoryContains(categories.EXPERIMENTAL, self.UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have at least 2 missiles so will set paused to true') end
                self:SetPaused(true)
                --Recheck every minute
                ForkThread(M27Logic.CheckIfWantToBuildAnotherMissile, self)
                --Clear any engineers that were assisting
                local aiBrain = self:GetAIBrain()
                if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionAssistNuke]) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have engineers with assist nuke action - will clear') end
                    local oEngineer
                    local sActionRef
                    if EntityCategoryContains(M27UnitInfo.refCategorySML, self.UnitId) then sActionRef = M27EngineerOverseer.refActionAssistNuke
                    elseif EntityCategoryContains(M27UnitInfo.refCategoryTML, self.UnitId) then sActionRef = M27EngineerOverseer.refActionAssistTML
                    elseif EntityCategoryContains(M27UnitInfo.refCategorySMD, self.UnitId) then sActionRef = M27EngineerOverseer.refActionAssistSMD
                    end
                    if sActionRef and M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][sActionRef]) == false then
                        for iRef, tSubtable in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][sActionRef] do
                            oEngineer = tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]
                            --if oEngineer:IsUnitState('Building') or oEngineer:IsUnitState('Repairing') then bDebugMessages = true M27Utilities.ErrorHandler('Clearing an engineer whose unit state is building or repairing') end
                            --if GetEngineerUniqueCount(oEngineer) == 58 and GetGameTimeSeconds() >= 2040 then bDebugMessages = true else bDebugMessages = false end
                            if oEngineer.GetFocusUnit and oEngineer:GetFocusUnit() == self then
                                M27Utilities.IssueTrackedClearCommands({oEngineer})
                                M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngineer, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': Cleared engineer UC='..M27EngineerOverseer.GetEngineerUniqueCount(oEngineer)..' with LC='..M27UnitInfo.GetUnitLifetimeCount(oEngineer)) end
                            end
                        end
                    end
                end
            end
            --Start logic to periodically check for targets to fire the missile at (in case there are no targets initially)
            if not(self[M27UnitInfo.refbActiveMissileChecker]) and not(EntityCategoryContains(M27UnitInfo.refCategorySMD, self.UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Calling logic to consider launching a missile') end
                ForkThread(M27Logic.ConsiderLaunchingMissile, self, weapon)
            end

            --SMD - clear any assisting engineers (dont both with missile count check, since it's off slightly and we want to stop at 1 missile anyway and this event means it has 1 missile
            if EntityCategoryContains(M27UnitInfo.refCategorySMD, self.UnitId) then
                local aiBrain = self:GetAIBrain()
                if bDebugMessages == true then LOG(sFunctionRef..': SMD '..self.UnitId..M27UnitInfo.GetUnitLifetimeCount(self)..' has just loaded a missile, is table of assist SMD actions empty='..tostring(M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionAssistSMD]))) end
                if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionAssistSMD]) == false then
                    for iSubtable, tSubtable in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByActionRef][M27EngineerOverseer.refActionAssistSMD] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Cycling through each assigned subtable. Engineer='..tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef].UnitId..M27UnitInfo.GetUnitLifetimeCount(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef])..' with UC='..M27EngineerOverseer.GetEngineerUniqueCount(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef])..'; Unit being assisted='..tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refoUnitBeingAssisted].UnitId..M27UnitInfo.GetUnitLifetimeCount(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refoUnitBeingAssisted])) end
                        if tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef][M27EngineerOverseer.refoUnitBeingAssisted] == self then
                            if M27UnitInfo.IsUnitValid(tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]) then M27Utilities.IssueTrackedClearCommands({tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef]}) end
                            M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, tSubtable[M27EngineerOverseer.refEngineerAssignmentEngineerRef], true)
                            if bDebugMessages == true then LOG(sFunctionRef..': Have sent a clear commands action to the engineer') end
                        end
                    end
                end
            end

            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        end
    end
end

function TrackProjectile(oProjectile)
    for i = 1, 110 do
        WaitTicks(1)
        LOG('i='..i..'; oProjectile position='..reprs(oProjectile:GetPosition()))
    end
end
--[[function OnProjectileFired(oWeapon, oMuzzle, oProjectile)
    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnProjectileFired'

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    if oWeapon.GetBlueprint then
        LOG('OnWeaponFired hook for blueprint='..repru(oWeapon:GetBlueprint()))
    end
    if oWeapon.unit then
        LOG('Have a unit; unit position='..repru(oWeapon.unit:GetPosition()))
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': reprs of oMuzzle='..reprs(oMuzzle))
        LOG(sFunctionRef..': reprs of oProjectile='..reprs(oProjectile))
        ForkThread(TrackProjectile, oProjectile)

    end
end--]]

function OnConstructionStarted(oEngineer, oConstruction, sOrder)
    if M27Utilities.bM27AIInGame then
        --Track experimental construction and other special on construction logic
        if oEngineer.GetAIBrain and oEngineer:GetAIBrain().M27AI and oConstruction.GetUnitId and not(oConstruction['M27FirstConstructionStart']) then
            local sFunctionRef = 'OnConstructionStarted'
            local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

            oConstruction['M27FirstConstructionStart'] = true
            local aiBrain = oEngineer:GetAIBrain()


            --Game enders - check if we have already started a gameender nearby, and if so clear current building and reclaim it
            local bCancelAndReclaim = false
            local oUnitToSwitchTo
            if bDebugMessages == true then LOG(sFunctionRef..': Construction started for unit '..oConstruction.UnitId..M27UnitInfo.GetUnitLifetimeCount(oConstruction)..'; Is it an experimental structure='..tostring(EntityCategoryContains(M27UnitInfo.refCategoryExperimentalLevel, oConstruction.UnitId))) end
            if EntityCategoryContains(M27UnitInfo.refCategoryExperimentalLevel, oConstruction.UnitId) and oConstruction:GetFractionComplete() <= 0.04 then --redundancy - ignore this logic if are already 4%+ done with the experimental
                local tNearbyGameEnders = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryExperimentalStructure, oConstruction:GetPosition(), 150, 'Ally')
                if bDebugMessages == true then LOG(sFunctionRef..': Is table of nearby gameenders empty='..tostring(M27Utilities.IsTableEmpty(tNearbyGameEnders))) end
                if M27Utilities.IsTableEmpty(tNearbyGameEnders) == false then
                    local iPathingGroupWanted = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oConstruction:GetPosition())
                    for iUnit, oUnit in tNearbyGameEnders do
                        if not(oUnit == oConstruction) and oUnit:GetFractionComplete() < 1 and iPathingGroupWanted == M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnit:GetPosition()) then
                            bCancelAndReclaim = true
                            oUnitToSwitchTo = oUnit
                            break
                        end
                    end
                end
                if not(bCancelAndReclaim) then
                    --Have we just started an experimental level unit and we have the same unit under construction nearby and we aren't close to overflowing, and we dont have loads of mass?
                    if bDebugMessages == true then LOG(sFunctionRef..': Gross mass income='..aiBrain[M27EconomyOverseer.refiGrossMassBaseIncome]..'; Mass stored ratio='..aiBrain:GetEconomyStoredRatio('MASS')..'; Have low mass='..tostring(M27Conditions.HaveLowMass(aiBrain))..'; oConstruction='..oConstruction.UnitId..M27UnitInfo.GetUnitLifetimeCount(oConstruction)) end
                    if (aiBrain[M27EconomyOverseer.refiGrossMassBaseIncome] <= 50 or aiBrain:GetEconomyStoredRatio('MASS') <= 0.25) and (M27Conditions.HaveLowMass(aiBrain) or aiBrain:GetEconomyStoredRatio('MASS') <= 0.4) then
                        local tNearbyExperimentalLevel = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryExperimentalLevel, oConstruction:GetPosition(), 150, 'Ally')
                        for iUnit, oUnit in tNearbyExperimentalLevel do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..'; Fraction complete='..oUnit:GetFractionComplete()) end
                            if not(oUnit == oConstruction) and (oUnit:GetFractionComplete() < 0.9 or (oUnit:GetFractionComplete() < 1 and aiBrain:GetEconomyStoredRatio('MASS') < 0.1)) and (oUnit.UnitId == oConstruction.UnitId or (EntityCategoryContains(M27UnitInfo.refCategoryFixedT3Arti, oConstruction.UnitId) and EntityCategoryContains(M27UnitInfo.refCategoryFixedT3Arti, oUnit.UnitId))) then
                                bCancelAndReclaim = true
                                oUnitToSwitchTo = oUnit
                                if bDebugMessages == true then LOG(sFunctionRef..': Are buildling the same unit nearby so will switch to this, oUnitToSwitchTo='..oUnitToSwitchTo.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToSwitchTo)..' with fraction complete='..oUnitToSwitchTo:GetFractionComplete()) end
                                break
                            end
                        end
                    end
                end

            end
            if bCancelAndReclaim then
                oConstruction['M27FirstConstructionStart'] = false --redundancy so if we arent able to find all the other engineers assigned to help construct this unit we will rerun this code whenever an engineer starts construction
                local iActionRef = oEngineer[M27EngineerOverseer.refiEngineerCurrentAction]
                local iUniqueRef = M27EngineerOverseer.GetEngineerUniqueCount(oEngineer)
                local sLocationRef = aiBrain[M27EngineerOverseer.reftEngineerActionsByEngineerRef][iUniqueRef][1][M27EngineerOverseer.refEngineerAssignmentLocationRef]
                if not(sLocationRef) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find the locationref but will rerun this code whenever an engineer starts construction on this unit') end
                end


                M27Utilities.IssueTrackedClearCommands({oEngineer})
                IssueReclaim({oEngineer}, oConstruction)
                if oUnitToSwitchTo then
                    IssueRepair({oEngineer}, oUnitToSwitchTo)
                end

                if bDebugMessages == true then LOG(sFunctionRef..': iActionRef='..(iActionRef or 'nil')..'; iUniqueRef='..(iUniqueRef or 'nil')..'; sLocationRef='..(sLocationRef or 'nil')..'; Is table of assignemnts for this empty='..tostring(M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef][iActionRef]))) end


                if sLocationRef and M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef]) == false and M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef][iActionRef]) == false then
                    for iOtherEngi, oOtherEngi in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef][iActionRef] do
                        M27Utilities.IssueTrackedClearCommands({oOtherEngi})

                        if oUnitToSwitchTo then
                            IssueRepair({oOtherEngi}, oUnitToSwitchTo)
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling oOtherEngi='..oOtherEngi.UnitId..M27UnitInfo.GetUnitLifetimeCount(oOtherEngi)..' to also switch to repairing '..oUnitToSwitchTo.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToSwitchTo)) end
                        end
                    end
                end
            else
                --T3 mex tracking
                if EntityCategoryContains(M27UnitInfo.refCategoryT3Mex, oConstruction.UnitId) and EntityCategoryContains(M27UnitInfo.refCategoryEngineer + categories.COMMAND + categories.SUBCOMMANDER + M27UnitInfo.refCategoryEngineerStation, oEngineer.UnitId) then
                    local bAddToTable = true
                    if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftT3MexesUnderConstruction]) == false then
                        for iMex, oMex in aiBrain[M27EngineerOverseer.reftT3MexesUnderConstruction] do
                            if oMex == oConstruction then
                                bAddToTable = false
                                break
                            end
                        end
                    end
                    if bAddToTable then
                        table.insert( aiBrain[M27EngineerOverseer.reftT3MexesUnderConstruction], oConstruction)
                    end
                end


                --Decide if we want to shield the construction
                if EntityCategoryContains(categories.STRUCTURE + M27UnitInfo.refCategoryExperimentalStructure, oConstruction.UnitId) then
                    local oBP = oConstruction:GetBlueprint()
                    if oBP.Economy.BuildCostMass >= 1650 and (oBP.Defense.Shield.ShieldMaxHealth or 0) == 0  then
                        if oBP.Defense.Health / oBP.Economy.BuildCostMass < 1 or EntityCategoryContains(M27UnitInfo.refCategoryFixedT2Arti, oConstruction.UnitId) or (aiBrain[M27Overseer.refbDefendAgainstArti] and oBP.Economy.BuildCostMass >= 3000 and EntityCategoryContains(M27UnitInfo.refCategoryStructure, oConstruction.UnitId)) then
                            oConstruction[M27EngineerOverseer.refiShieldsWanted] = 1
                            table.insert(aiBrain[M27EngineerOverseer.reftUnitsWantingFixedShield], oConstruction)
                            --Flag if we want it to have a heavy shield
                            if aiBrain[M27Overseer.refbDefendAgainstArti] then
                                oConstruction[M27EngineerOverseer.refbNeedsLargeShield] = true
                                aiBrain[M27EngineerOverseer.refbHaveUnitsWantingHeavyShield] = true --Redundancy (should already check for the defendagainstarti flag)
                                if oBP.Economy.BuildCostMass >= 12000 then
                                    oConstruction[M27EngineerOverseer.refiShieldsWanted] = 2
                                end
                            else
                                if oBP.Economy.BuildCostMass >= 12000 then

                                    if oBP.Economy.BuildCostMass >= 20000 then
                                        oConstruction[M27EngineerOverseer.refbNeedsLargeShield] = true
                                        aiBrain[M27EngineerOverseer.refbHaveUnitsWantingHeavyShield] = true
                                    else
                                        --Cybran - shield nukes with T3 shields.  Other factions can use t2
                                        if EntityCategoryContains(categories.CYBRAN, oConstruction.UnitId) then
                                            oConstruction[M27EngineerOverseer.refbNeedsLargeShield] = true
                                            aiBrain[M27EngineerOverseer.refbHaveUnitsWantingHeavyShield] = true
                                        end
                                    end

                                end
                            end
                        end
                    end


                    --Check for construction of nuke
                    --if aiBrain[M27EngineerOverseer.refiLastExperimentalReference] then
                    local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
                    local sFunctionRef = 'OnConstructionStarted'
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have just started construction on a nuke; if so then will start a monitor; UnitID='..oConstruction.UnitId..'; oConstruction[M27UnitInfo.refbActiveSMDChecker]='..(tostring(oConstruction[M27UnitInfo.refbActiveSMDChecker] or false))) end

                    if EntityCategoryContains(M27UnitInfo.refCategorySML - categories.EXPERIMENTAL, oConstruction.UnitId) then
                        --Are building a nuke, check if already monitoring SMD somehow
                        if not(oConstruction[M27UnitInfo.refbActiveSMDChecker]) and oConstruction:GetFractionComplete() < 1 then
                            --if aiBrain[M27EngineerOverseer.refiLastExperimentalReference] == M27UnitInfo.refCategorySML and not(aiBrain[M27UnitInfo.refbActiveSMDChecker]) then
                            ForkThread(M27EngineerOverseer.CheckForEnemySMD, aiBrain, oConstruction)
                        end
                    end
                    --end

                    --Firebase tracking
                    if EntityCategoryContains(M27UnitInfo.refCategoryFirebaseSuitable, oConstruction.UnitId) then
                        --First check in case ACU is already building something
                        local oUnitToSwitchTo
                        local bReclaimAnyway = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Checking if ACU building firebase unit near us in which case will switch to assisting it instead.  Cur strategy='..aiBrain[M27Overseer.refiAIBrainCurrentStrategy]..'; oEngineer[M27EngineerOverseer.refiEngineerCurrentAction]='..(oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] or 'nil')) end
                        if aiBrain[M27Overseer.refiAIBrainCurrentStrategy] == M27Overseer.refStrategyTurtle and oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] == M27EngineerOverseer.refActionFortifyFirebase then
                            local oACU = M27Utilities.GetACU(aiBrain)
                            local iFirebaseCategoryWanted = aiBrain[M27EngineerOverseer.refiFirebaseCategoryWanted][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]]
                            if bDebugMessages == true and oPlatoon[refbACUInPlatoon] then LOG(sFunctionRef..': ACU state='..M27Logic.GetUnitState(oACU)) end
                            if iFirebaseCategoryWanted and oACU:IsUnitState('Building') or oACU:IsUnitState('Repairing') then
                                local oACUTarget = oACU:GetFocusUnit()
                                if M27UnitInfo.IsUnitValid(oACUTarget) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': oACUTarget='..oACUTarget.UnitId..M27UnitInfo.GetUnitLifetimeCount(oACUTarget)..'; Fraction complete='..oACUTarget:GetFractionComplete()..'; Dist to oConstruction='..M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oConstruction:GetPosition())) end
                                    if oACUTarget:GetFractionComplete() < 1 and  aiBrain[M27EngineerOverseer.refiFirebaseCategoryWanted][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]] and M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oConstruction:GetPosition()) <= 35 then
                                        --Is the ACU building a firebase category, and is that our action?
                                        if EntityCategoryContains(aiBrain[M27EngineerOverseer.refiFirebaseCategoryWanted][aiBrain[M27MapInfo.refiAssignedChokepointFirebaseRef]], oACUTarget.UnitId) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Will switch so we assist this unit instead') end
                                            oUnitToSwitchTo = oACUTarget
                                        end
                                    end
                                end
                            end
                            if iFirebaseCategoryWanted and not(oUnitToSwitchTo) and M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oConstruction:GetPosition()) <= 35 and M27Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), aiBrain[M27MapInfo.reftChokepointBuildLocation]) <= 50 then
                                local tNearbyUnitsOfType = aiBrain:GetUnitsAroundPoint(iFirebaseCategoryWanted, oConstruction:GetPosition(), 35, 'Ally')
                                if M27Utilities.IsTableEmpty(tNearbyUnitsOfType) == false then
                                    for iUnit, oUnit in tNearbyUnitsOfType do
                                        if oUnit:GetFractionComplete() < 1 then
                                            oUnitToSwitchTo = oUnit
                                            break
                                        end
                                    end
                                end
                            end
                            --Did we just start on a radar at a firebase that already has one complete nearby?
                            if not(oUnitToSwitchTo) and EntityCategoryContains(M27UnitInfo.refCategoryRadar, oConstruction.UnitId) then
                                local iTechCategory = M27UnitInfo.ConvertTechLevelToCategory(M27UnitInfo.GetUnitTechLevel(oConstruction))
                                local tNearbyRadar = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryRadar * iTechCategory, oConstruction:GetPosition(), 35, 'Ally')
                                if M27Utilities.IsTableEmpty(tNearbyRadar) == false then
                                    for iUnit, oUnit in tNearbyRadar do
                                        if oUnit:GetFractionComplete() == 1 then
                                            bReclaimAnyway = true
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        if bReclaimAnyway or (oUnitToSwitchTo and not(oUnitToSwitchTo == oConstruction)) then
                            M27Utilities.IssueTrackedClearCommands({oEngineer})
                            IssueReclaim({oEngineer}, oConstruction)
                            if oUnitToSwitchTo then
                                IssueRepair({oEngineer}, oUnitToSwitchTo)
                                ForkThread(M27EngineerOverseer.FirebaseTrackingOfConstruction, aiBrain, oEngineer, oUnitToSwitchTo)
                                if bDebugMessages == true then LOG(sFunctionRef..': Have told engineer '..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' to switch to assist what the ACU is building') end
                            elseif bDebugMessages == true then LOG(sFunctionRef..': Engineer was building radar but we have one nearby now, will reclaim the radar')
                            end
                        else
                            ForkThread(M27EngineerOverseer.FirebaseTrackingOfConstruction, aiBrain, oEngineer, oConstruction)
                        end
                    end

                    --Scathis tracking (since impacts where we can build)
                    if EntityCategoryContains(M27UnitInfo.refCategoryExperimentalArti * categories.MOBILE, oConstruction.UnitId) then
                        aiBrain[M27EngineerOverseer.reftFriendlyScathis][oConstruction.UnitId..M27UnitInfo.GetUnitLifetimeCount(oConstruction)] = oConstruction
                    end

                    --TMD tracking for multiple TMD
                    if EntityCategoryContains(M27UnitInfo.refCategoryTMD, oConstruction.UnitId) then
                        local tTMDPosition = oConstruction:GetPosition()
                        local iRadiusSize = M27EngineerOverseer.iTMDNearbyRange
                        local tNearbyTMD = GetUnitsInRect(Rect(tTMDPosition[1]-iRadiusSize, tTMDPosition[3]-iRadiusSize, tTMDPosition[1]+iRadiusSize, tTMDPosition[3]+iRadiusSize))
                        if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                            tNearbyTMD = EntityCategoryFilterDown(M27UnitInfo.refCategoryTMD, tNearbyTMD)
                            if M27Utilities.IsTableEmpty(tNearbyTMD) == false then
                                for iTMD, oTMD in tNearbyTMD do
                                    if M27UnitInfo.IsUnitValid(oTMD) then
                                        ForkThread(M27EngineerOverseer.RecordNearbyTMD, oTMD)
                                    end
                                end
                            end
                        end
                    end
                end
            end

            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        end
    end
end
function OnConstructed(oEngineer, oJustBuilt)
    --WARNING: This doesnt seem to trigger for the ACU; it does trigger when untis are constructed by a factory

    --NOTE: This is called every time an engineer stops building a unit whose fractioncomplete is 100%, so can be called multiple times
    if M27Utilities.bM27AIInGame then
        local bGivenSubsequentEngineerOrder = false

        if oJustBuilt:GetAIBrain().M27AI and not(oJustBuilt.M27OnConstructedCalled) then
            local sFunctionRef = 'OnConstructed'
            local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)

            --Make sure we have a LC set for this unit
            local iLC = M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)



            oJustBuilt.M27OnConstructedCalled = true
            oJustBuilt[M27UnitInfo.refiTimeConstructed] = GetGameTimeSeconds()

            --LOG('OnConstructed hook test; oJustBuilt='..oJustBuilt.UnitId..'; oEngineer='..oEngineer.UnitId)
            local aiBrain = oJustBuilt:GetAIBrain()

            if bDebugMessages == true then
                LOG(sFunctionRef..': oEngineer='..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..'; oJustBuilt='..oJustBuilt.UnitId..M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; Assigned pond='..(oJustBuilt[M27Navy.refiAssignedPond] or 'nil'))
                LOG('Have we just built experimental level unit='..tostring(EntityCategoryContains(M27UnitInfo.refCategoryExperimentalLevel, oJustBuilt.UnitId))..'; LC for experimental level='..M27Conditions.GetLifetimeBuildCount(aiBrain, M27UnitInfo.refCategoryExperimentalLevel)..'; T3 arti LC='..M27Conditions.GetLifetimeBuildCount(aiBrain, M27UnitInfo.refCategoryFixedT3Arti))
            end

            if EntityCategoryContains(M27UnitInfo.refCategoryFixedT2Arti, oJustBuilt.UnitId) then
                ForkThread(M27UnitInfo.SetUnitTargetPriorities, oJustBuilt, M27UnitInfo.refWeaponPriorityT2Arti)
                ForkThread(M27UnitMicro.ConsiderT2ArtiGroundFire, oJustBuilt)

                --Do we want to build radar here?
                if bDebugMessages == true then LOG(sFunctionRef..': Engineer '..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' just completed a T2 Arti, checking if want to build a T1 radar. Intel coverage='..M27Logic.GetIntelCoverageOfPosition(aiBrain, oJustBuilt:GetPosition(), nil, true)) end
                if oEngineer and oEngineer:GetAIBrain().M27AI and EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oEngineer.UnitId) and not(M27Logic.GetIntelCoverageOfPosition(aiBrain, oJustBuilt:GetPosition(), 104, true)) then
                    --Check we dont have 2+ radar close by as backup in case we keep trying to build t1 radar in the same place and there's no space
                    local tNearbyT1Radar = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT1Radar, oJustBuilt:GetPosition(), 25, 'Ally')
                    if M27Utilities.IsTableEmpty(tNearbyT1Radar) or table.getn(tNearbyT1Radar) <= 1 then
                        M27Utilities.IssueTrackedClearCommands({ oEngineer })
                        M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngineer, true)


                        bGivenSubsequentEngineerOrder = true
                        --Build t1 radar nearby regardless of adjacency
                        M27EngineerOverseer.AssignActionToEngineer(aiBrain, oEngineer, M27EngineerOverseer.refActionBuildT1Radar, M27Utilities.MoveInDirection(oJustBuilt:GetPosition(), M27Utilities.GetAngleFromAToB(oJustBuilt:GetPosition(), M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)), 5, true), nil, 1, true)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just given order for oEngineer='..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' to build T1 radar at location '..repru(M27Utilities.MoveInDirection(oJustBuilt:GetPosition(), M27Utilities.GetAngleFromAToB(oJustBuilt:GetPosition(), M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)), 5, true))) end
                    end
                end

                --Weapon priority updates:
            elseif EntityCategoryContains(M27UnitInfo.refCategoryPD, oJustBuilt.UnitId) then
                ForkThread(M27UnitInfo.SetUnitTargetPriorities, oJustBuilt, M27UnitInfo.refWeaponPriorityPD)
            elseif EntityCategoryContains(M27UnitInfo.refCategoryMissileShip, oJustBuilt.UnitId) then
                ForkThread(M27UnitInfo.SetUnitTargetPriorities, oJustBuilt, M27UnitInfo.refWeaponPriorityMissileShip)
            elseif EntityCategoryContains(M27UnitInfo.refCategoryBattleship, oJustBuilt.UnitId) then
                ForkThread(M27UnitInfo.SetUnitTargetPriorities, oJustBuilt, M27UnitInfo.refWeaponPriorityBattleShip)
            elseif EntityCategoryContains(M27UnitInfo.refCategorySniperBot, oJustBuilt.UnitId) then
                ForkThread(M27UnitInfo.SetUnitTargetPriorities, oJustBuilt, M27UnitInfo.refWeaponPrioritySniperBot)
            elseif EntityCategoryContains(M27UnitInfo.refCategoryDestroyer, oJustBuilt.UnitId) then
                ForkThread(M27UnitInfo.SetUnitTargetPriorities, oJustBuilt, M27UnitInfo.refWeaponPriorityDestroyer)


                --Other units:
            elseif EntityCategoryContains(M27UnitInfo.refCategoryMassStorage, oJustBuilt.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': Just built mass storage '..oJustBuilt.UnitId..M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)..';, will refresh mass fab locations') end
                ForkThread(M27EngineerOverseer.UpdateMassFabPotentialLocations, oJustBuilt)
            elseif EntityCategoryContains(M27UnitInfo.refCategoryMobileLandShield + M27UnitInfo.refCategoryMobileLandStealth, oJustBuilt.UnitId) then
                ForkThread(M27Team.ConsiderGiftingShieldOrStealthToSubteam, oJustBuilt)
            elseif EntityCategoryContains(M27UnitInfo.refCategoryPower - categories.TECH1, oJustBuilt.UnitId) then
                --Power - flag if we have just built a lot of power
                ForkThread(M27EconomyOverseer.UpdateIfJustBuiltLotsOfPower, oJustBuilt)
            end

            --Firebase tracking
            if EntityCategoryContains(M27UnitInfo.refCategoryFirebaseSuitable, oJustBuilt.UnitId) then
                aiBrain[M27EngineerOverseer.refbPotentialFirebaseBuildingChangedSinceLastFirebaseCheck] = true
                ForkThread(M27EngineerOverseer.FirebaseTrackingOfConstruction, aiBrain, oEngineer, oJustBuilt)
                --If just built by ACU than refresh firebase so ACU doesnt risk building loads more T2 PD to try and get a firebase to register
                if oEngineer and EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then ForkThread(M27EngineerOverseer.RefreshListOfFirebases, aiBrain) end

                --Shields wanting hives
                if EntityCategoryContains(M27UnitInfo.refCategoryFixedShield * categories.TECH3, oJustBuilt.UnitId) then
                    table.insert(aiBrain[M27EngineerOverseer.reftShieldsWantingHives], oJustBuilt)
                end

                --SAMs covering friendly mexes
                if EntityCategoryContains(M27UnitInfo.refCategoryStructureAA * categories.TECH3, oJustBuilt.UnitId) then
                    local tNearbyT3Mexes = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT3Mex, oJustBuilt:GetPosition(), M27EngineerOverseer.iSAMCreepCoverageRange, 'Ally')
                    if M27Utilities.IsTableEmpty(tNearbyT3Mexes) == false then
                        for iMex, oMex in tNearbyT3Mexes do
                            if not(M27UnitInfo.IsUnitValid(oMex[M27EngineerOverseer.refoNearbyFriendlyAA])) then
                                oMex[M27EngineerOverseer.refoNearbyFriendlyAA] = oJustBuilt
                            end
                        end
                    end
                end
            end

            --All mexes - on construction check if we have allied M27 mass storage nearby (e.g. we have rebuilt on a mex that they used to have) and if so then have that M27 gift over their mass storage
            if EntityCategoryContains(M27UnitInfo.refCategoryMex, oJustBuilt.UnitId) and aiBrain.M27AI then
                local tMexLocation = oJustBuilt:GetPosition()
                local tNearbyUnits = GetUnitsInRect(Rect(tMexLocation[1] - 2.1, tMexLocation[3] - 2.1, tMexLocation[1] + 2.1, tMexLocation[3] + 2.1)) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; therefore added extra check for 1.5; the mass storage should be exactly 2 from the mex
                if M27Utilities.IsTableEmpty(tNearbyUnits) == false then
                    for iUnit, oUnit in tNearbyUnits do
                        if EntityCategoryContains(M27UnitInfo.refCategoryMassStorage, oUnit.UnitId) and oUnit:GetAIBrain().M27AI and not(oUnit:GetAIBrain() == aiBrain) then
                            if bDebugMessages == true then LOG(sFunctionRef..': About to transfer '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' from brain '..oUnit:GetAIBrain().Nickname..' to '..aiBrain.Nickname..'; Dist from unit to tMexLocation='..M27Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition())) end
                            if M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMexLocation) <= 2.1 then
                                M27Team.TransferUnitsToPlayer({oUnit}, aiBrain:GetArmyIndex(), false)
                            end
                        end
                    end
                end

                --T3 mexes - flag as wanting AA coverage
                if EntityCategoryContains(categories.TECH3, oJustBuilt.UnitId) then
                    ForkThread(M27EngineerOverseer.CheckIfMexWantsAACoverage, aiBrain, oJustBuilt)
                end

                --Record plateau that mex is on
                local iPlateauGroup = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oJustBuilt:GetPosition())
                if not (iPlateauGroup == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) then
                    oJustBuilt[M27Transport.refiAssignedPlateau] = iPlateauGroup
                    if M27Utilities.IsTableEmpty(aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup]) then
                        aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup] = {}
                    end
                    if M27Utilities.IsTableEmpty(aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][M27MapInfo.subrefPlateauMexBuildings]) then
                        aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][M27MapInfo.subrefPlateauMexBuildings] = {}
                    end
                    aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][M27MapInfo.subrefPlateauMexBuildings][oJustBuilt.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)] = oJustBuilt
                    LOG('Have just recorded factory ' .. oJustBuilt.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oJustBuilt) .. ' in the list of factories for iPlateauGroup=' .. iPlateauGroup)
                end
            end

            --Initial categories below are for if not protecting from TML
            --Mexes built by spare engineers - want to clear already assigned engineers
            if EntityCategoryContains(M27UnitInfo.refCategoryT1Mex, oJustBuilt.UnitId) then
                if oEngineer and oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] == M27EngineerOverseer.refActionSpare then
                    --reftEngineerAssignmentsByLocation --[x][y][z];  x is the unique location ref (need to use ConvertLocationToReference in utilities to use), [y] is the actionref, z is the engineer unique ref assigned to this location; returns the engineer object
                    local sLocationRef = M27Utilities.ConvertLocationToStringRef(oJustBuilt:GetPosition())
                    if M27Utilities.IsTableEmpty(aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef][M27EngineerOverseer.refActionBuildMex]) == false then
                        for iEngi, oEngi in aiBrain[M27EngineerOverseer.reftEngineerAssignmentsByLocation][sLocationRef][M27EngineerOverseer.refActionBuildMex] do
                            M27Utilities.IssueTrackedClearCommands({ oEngi })
                            M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngi, true)
                        end
                    end
                end
            elseif EntityCategoryContains(M27UnitInfo.refCategoryLandFactory, oJustBuilt.UnitId) then
                --Is this a land factory on a plateau?
                local iPlateauGroup = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oJustBuilt:GetPosition())
                if not (iPlateauGroup == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) then
                    oJustBuilt[M27Transport.refiAssignedPlateau] = iPlateauGroup
                    if M27Utilities.IsTableEmpty(aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup]) then
                        aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup] = {}
                    end
                    if M27Utilities.IsTableEmpty(aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][M27MapInfo.subrefPlateauLandFactories]) then
                        aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][M27MapInfo.subrefPlateauLandFactories] = {}
                    end
                    aiBrain[M27MapInfo.reftOurPlateauInformation][iPlateauGroup][M27MapInfo.subrefPlateauLandFactories][oJustBuilt.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)] = oJustBuilt
                    LOG('Have just recorded factory ' .. oJustBuilt.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oJustBuilt) .. ' in the list of factories for iPlateauGroup=' .. iPlateauGroup)
                end
            elseif EntityCategoryContains(M27UnitInfo.refCategoryPD, oJustBuilt.UnitId) then
                --Update PD tracking
                aiBrain[M27EngineerOverseer.refiMassSpentOnPD] = aiBrain[M27EngineerOverseer.refiMassSpentOnPD] + oJustBuilt:GetBlueprint().Economy.BuildCostMass
            elseif EntityCategoryContains(M27UnitInfo.refCategoryRadar - categories.TECH1, oJustBuilt.UnitId) then
                local tNearbyLowerTechRadar
                local iIntelRange = oJustBuilt:GetBlueprint().Intel.RadarRadius
                if iIntelRange >= 120 then
                    if M27UnitInfo.GetUnitTechLevel(oJustBuilt) >= 3 then
                        tNearbyLowerTechRadar = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT1Radar + M27UnitInfo.refCategoryT2Radar, oJustBuilt:GetPosition(), iIntelRange, 'Ally')
                    else
                        tNearbyLowerTechRadar = aiBrain:GetUnitsAroundPoint(M27UnitInfo.refCategoryT1Radar, oJustBuilt:GetPosition(), iIntelRange, 'Ally')
                    end
                    if M27Utilities.IsTableEmpty(tNearbyLowerTechRadar) == false then
                        local iCurDist
                        local iCurIntel
                        for iUnit, oUnit in tNearbyLowerTechRadar do
                            if oUnit:GetAIBrain().M27AI then
                                --Are we adding any intel from here?
                                iCurDist = M27Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oJustBuilt:GetPosition())
                                iCurIntel = oUnit:GetBlueprint().Intel.RadarRadius or 0
                                if bDebugMessages == true then LOG(sFunctionRef..': Just built radar '..oJustBuilt.UnitId..M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; will consider whether have obsolete radar to destroy, oUnit='..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit)..' where iCurDist='..iCurDist..'; iCurIntel='..iCurIntel..'; iIntelRange='..iIntelRange) end
                                if iCurDist + iCurIntel <= iIntelRange then
                                    oUnit:Kill()
                                end
                            end
                        end
                    end
                end
            elseif EntityCategoryContains(M27UnitInfo.refCategoryHive, oJustBuilt.UnitId) then
                ForkThread(M27EngineerOverseer.HiveManager, oJustBuilt)

                --Mobile unit tracking:
            elseif EntityCategoryContains(M27UnitInfo.refCategoryLandScout, oJustBuilt.UnitId) then
                aiBrain[M27Overseer.refbScoutBuiltOrDied] = true
            elseif EntityCategoryContains(M27UnitInfo.refCategoryMAA, oJustBuilt.UnitId) then
                aiBrain[M27Overseer.refbMAABuiltOrDied] = true
                --naval factory just built something?
            elseif oEngineer and EntityCategoryContains(M27UnitInfo.refCategoryNavalFactory, oEngineer.UnitId) then
                --Clear assisting engineers
                if M27Utilities.IsTableEmpty(oEngineer[M27EngineerOverseer.reftAssistingEngineers]) == false then
                    for iAssistingEngi, oAssistingEngi in oEngineer[M27EngineerOverseer.reftAssistingEngineers] do
                        --Dont clear engineers still travelling to the naval factory
                        if M27Utilities.GetDistanceBetweenPositions(oAssistingEngi:GetPosition(), oEngineer:GetPosition()) <= 30 then
                            M27Utilities.IssueTrackedClearCommands({ oAssistingEngi})
                            ClearEngineerActionTrackers(aiBrain, oAssistingEngi, true)
                        end
                    end
                end

                --Workaround to reduce risk naval units self destruct - Have we just built a T3 naval unit? If so then send it to an open stretch of water if we have nearby land that is closer to us than the naval factory
                if EntityCategoryContains(M27UnitInfo.refCategoryNavalSurface * categories.TECH3, oJustBuilt.UnitId) then
                    if not(oEngineer[M27Navy.refbCheckedFactoryForNearbyLand]) then
                        --Check if have nearby land and need a detour
                        local iDistanceCheck = 16
                        local iInterval = 360 / 8
                        local tCurLocation
                        local tFactoryLocation = oEngineer:GetPosition()
                        local tPossibleWaterLocation
                        local iBaseAngle = M27Utilities.GetAngleFromAToB(tFactoryLocation, M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain))
                        local tUnitLocation = oJustBuilt:GetPosition()
                        oEngineer[M27Navy.refbCheckedFactoryForNearbyLand] = true
                        local bHaveNearbyLand = false
                        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer='..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just built '..oJustBuilt.UnitId..M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)) end
                        for iAngleAdjust = 0, (360 - iInterval), iInterval do
                            tCurLocation = M27Utilities.MoveInDirection(tUnitLocation, iBaseAngle + iAngleAdjust, iDistanceCheck, true)
                            tCurLocation[2] = GetTerrainHeight(tCurLocation[1], tCurLocation[3])
                            --Are we underwater by at least 2?
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering tCurLocation='..repru(tCurLocation)..'; Terrain height='..GetTerrainHeight(tCurLocation[1], tCurLocation[3])..'; Surface height='..GetSurfaceHeight(tCurLocation[1], tCurLocation[3])..'; Is underwater by at least 2='..tostring(M27MapInfo.IsUnderwater(tCurLocation, false, 2))) end
                            if M27MapInfo.IsUnderwater(tCurLocation, false, 2) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a potential water location to move to; do we already ahve a possible water location='..repru(tPossibleWaterLocation)) M27Utilities.DrawLocation(tCurLocation) end
                                if not(tPossibleWaterLocation) then
                                    tPossibleWaterLocation = {tCurLocation[1], tCurLocation[2], tCurLocation[3]}


                                    if bHaveNearbyLand then break end
                                end
                            else
                                --Is this location closer to us than our naval factory?
                                if bDebugMessages == true then LOG(sFunctionRef..': Cant path here with naval unit. bHaveNearbyLand='..tostring(bHaveNearbyLand)..'; Distance to unit='..M27Utilities.GetDistanceBetweenPositions(tUnitLocation, tCurLocation)..'; Distance to factory='..M27Utilities.GetDistanceBetweenPositions(tFactoryLocation, tCurLocation))  M27Utilities.DrawLocation(tCurLocation, nil, 2)  end
                                if not(bHaveNearbyLand) and M27Utilities.GetDistanceBetweenPositions(tUnitLocation, tCurLocation) <= M27Utilities.GetDistanceBetweenPositions(tFactoryLocation, tCurLocation) then
                                    bHaveNearbyLand = true
                                    if tPossibleWaterLocation then break
                                    end
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': bHaveNearbyLand='..tostring(bHaveNearbyLand)..'; tPossibleWaterLocation='..repru(tPossibleWaterLocation)) end
                        if bHaveNearbyLand then
                            if not(tPossibleWaterLocation) then tPossibleWaterLocation = tFactoryLocation end

                            oEngineer[M27Navy.reftInitialFactoryRallyPointOverride] = {tPossibleWaterLocation[1], tPossibleWaterLocation[2], tPossibleWaterLocation[3]}
                        end
                    end
                    if M27Utilities.IsTableEmpty(oEngineer[M27Navy.reftInitialFactoryRallyPointOverride]) == false then
                        M27UnitMicro.TrackTemporaryUnitMicro(oJustBuilt, 10)
                        M27Utilities.IssueTrackedClearCommands({oJustBuilt})
                        IssueMove({oJustBuilt}, oEngineer[M27Navy.reftInitialFactoryRallyPointOverride])
                        if bDebugMessages == true then LOG(sFunctionRef..': Sent special micro order to the unit '..oJustBuilt.UnitId..M27UnitInfo.GetUnitLifetimeCount(oJustBuilt)..' to try and move to open water') end
                    end
                end


                --Other tracking
            else
                --Have we just built an experimental unit? If so then tell our ACU to return to base as even if we havent scouted enemy threat they could have an experimental by now
                if EntityCategoryContains(categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                    aiBrain[M27Overseer.refbAreBigThreats] = true
                end
                if aiBrain[M27Overseer.refbEnemyTMLSightedBefore] and M27Utilities.IsTableEmpty(aiBrain[M27Overseer.reftEnemyTML]) == false then
                    if EntityCategoryContains(M27UnitInfo.refCategoryProtectFromTML, oJustBuilt.UnitId) then
                        M27Logic.DetermineTMDWantedForUnits(aiBrain, { oJustBuilt })
                    elseif EntityCategoryContains(M27UnitInfo.refCategoryTMD, oJustBuilt.UnitId) then
                        --Update list of units wanting TMD to factor in if they have TMD coverage from all threats now that we have just built a TMD
                        for iPlateau, toUnits in aiBrain[M27EngineerOverseer.reftUnitsWantingTMDByPlateau] do
                            M27Logic.DetermineTMDWantedForUnits(aiBrain, toUnits)
                        end
                    end
                end
                if EntityCategoryContains(M27UnitInfo.refCategoryFixedT3Arti + M27UnitInfo.refCategoryExperimentalArti, oJustBuilt.UnitId) and not (oJustBuilt[M27UnitInfo.refbActiveTargetChecker]) then
                    aiBrain[M27Overseer.refbAreBigThreats] = true
                    --T3 arti - first time its constructed want to start thread checking for power, and also tell it what to fire
                    oJustBuilt[M27UnitInfo.refbActiveTargetChecker] = true
                    ForkThread(M27Logic.GetT3ArtiTarget, oJustBuilt, true)
                    if bDebugMessages == true then LOG(sFunctionRef..': Just built t3 arti or equivalent so have called the logic to get t3 arti target') end
                end
                --Quantum optics redundancy
                if EntityCategoryContains(M27UnitInfo.refCategoryQuantumOptics, oJustBuilt.UnitId) then
                    ForkThread(M27AirOverseer.QuantumOpticsManager, aiBrain, oJustBuilt)
                end
            end


            --Update pond
            if not(oJustBuilt[M27Navy.refiAssignedPond]) and ((oEngineer and EntityCategoryContains(M27UnitInfo.refCategoryNavalFactory, oEngineer.UnitId)) or EntityCategoryContains(categories.NAVAL + M27UnitInfo.refCategorySonar + M27UnitInfo.refCategoryNavalFactory + M27UnitInfo.refCategoryTorpedoLauncher, oJustBuilt.UnitId)) then
                --Exception for 1st engineer of current tech level (as want this used by normal logic)
                if not(EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oJustBuilt.UnitId) and M27UnitInfo.GetUnitLifetimeCount(oJustBuilt) <= 1) then
                    M27Navy.UpdateUnitPond(oJustBuilt, oJustBuilt:GetAIBrain().M27Team, false)
                end
            end

            --If have just upgraded a shield then clear tracking (redundancy as should also trigger from 'death' of old shield)
            if oEngineer and EntityCategoryContains(M27UnitInfo.refCategoryStructure - M27UnitInfo.refCategoryEngineer, oEngineer.UnitId) and M27Utilities.IsTableEmpty(oJustBuilt[M27EngineerOverseer.reftAssistingEngineers]) == false then
                for iEngi, oEngi in oJustBuilt[M27EngineerOverseer.reftAssistingEngineers] do
                    if M27UnitInfo.IsUnitValid(oEngi) then
                        M27Utilities.IssueTrackedClearCommands({ oEngi })
                        M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oEngi, true)
                    end
                end
            end

            --T3 mex tracking
            if EntityCategoryContains(M27UnitInfo.refCategoryT3Mex, oJustBuilt.UnitId) then ForkThread(M27EngineerOverseer.RefreshUnderConstructionT3MexList, aiBrain) end

            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        elseif M27Config.M27ShowEnemyUnitNames then
            oJustBuilt:SetCustomName(oJustBuilt.UnitId .. M27UnitInfo.GetUnitLifetimeCount(oJustBuilt))
        end


        --Engineer callbacks
        if not(bGivenSubsequentEngineerOrder) and oEngineer and oEngineer:GetAIBrain().M27AI and not (oEngineer.Dead) then
            if EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oEngineer:GetUnitId()) then
                --Dont do this if just built t1 pd as want it to have walls
                if not(EntityCategoryContains(M27UnitInfo.refCategoryWall + M27UnitInfo.refCategoryPD * categories.TECH1, oJustBuilt.UnitId)) then
                    local sFunctionRef = 'OnConstructed'
                    local bDebugMessages = false
                    if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
                    ForkThread(M27EngineerOverseer.ReassignEngineers, oEngineer:GetAIBrain(), true, { oEngineer })
                    M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
                end
            elseif EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                local bDebugMessages = false
                local sFunctionRef = 'OnConstructed'
                if bDebugMessages == true then LOG(sFunctionRef..': About to run ACU logic update out of cycle as it has just finished construction') end
                ForkThread(M27PlatoonUtilities.RunPlatoonSingleCycle, oEngineer.PlatoonHandle)
            end
        end
    end

    if M27Config.M27StatTracking then
        if not(oJustBuilt['M27StatsTrackedConstruction']) then
            oJustBuilt['M27StatsTrackedConstruction'] = true
            ForkThread(M27Stats.UpdateStatsForBuilt, oJustBuilt)
        end

    end
end

function OnReclaimStarted(oEngineer, oReclaim)
    if M27Utilities.bM27AIInGame then
        local sFunctionRef = 'OnReclaimStarted'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)


        if oEngineer:GetAIBrain().M27AI then
            if oEngineer.PlatoonHandle and oEngineer.PlatoonHandle[M27PlatoonUtilities.refbNotStartedReclaimingYet] then
                --Platoon specific - flag that have started the reclaim
                oEngineer.PlatoonHandle[M27PlatoonUtilities.refbNotStartedReclaimingYet] = false
            elseif oEngineer[M27PlatoonUtilities.refbNotStartedReclaimingYet] then
                oEngineer[M27PlatoonUtilities.refbNotStartedReclaimingYet] = false
            end
        elseif M27UnitInfo.IsUnitValid(oReclaim) and oReclaim:GetAIBrain().M27AI and oReclaim:GetFractionComplete() == 1 then
            local oReclaimingBrain = oEngineer:GetAIBrain()
            if not(oReclaimingBrain == oReclaim:GetAIBrain()) then
                if IsAlly(oReclaimingBrain:GetArmyIndex(), oReclaim:GetAIBrain():GetArmyIndex()) then
                    M27Chat.SendMessage(oReclaim:GetAIBrain(), 'Ally reclaiming', 'Hey, stop reclaiming my units '..oEngineer:GetAIBrain().Nickname, 0, 60)
                else
                    if EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oReclaim.UnitId) and EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oEngineer.UnitId) and IsEnemy(oReclaimingBrain:GetArmyIndex(), oReclaim:GetAIBrain():GetArmyIndex()) then
                        --Tell engineer to reclaim the target if it isnt already
                        if bDebugMessages == true then LOG(sFunctionRef..': About to get engineer check for nearby enemies now as it has just started being reclaimed by an enemy engineer') end
                        M27EngineerOverseer.ProcessingEngineerActionForNearbyEnemies(oReclaim:GetAIBrain(), oReclaim)
                    end
                end
            end
        end

        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnReclaimFinished(oEngineer, oReclaim)
    if M27Utilities.bM27AIInGame then
        --Update the segment that the reclaim is at, or the engineer if hte reclaim doesnt have one
        local sFunctionRef = 'OnReclaimFinished'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming, gametime='..GetGameTimeSeconds()) end

        if oReclaim and oReclaim.CachePosition then
            --LOG('OnReclaimFinished temp log - remove once confirmed this works - about to update reclaim data near location='..repru(oReclaim.CachePosition))
            ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, oReclaim.CachePosition, 0)
            --M27MapInfo.UpdateReclaimDataNearLocation(oReclaim.CachePosition, 0, nil)
        else
            --LOG('OnReclaimFinished alt temp log - couldnt find reclaim position so will use engineer position')
            ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, oEngineer:GetPosition(), 1)
            --M27MapInfo.UpdateReclaimDataNearLocation(oEngineer:GetPosition(), 1, nil)
        end
        --If dealing with M27 unit that is in a platoon that is reclaiming a specific target or a hive, then look for a new target
        if M27UnitInfo.IsUnitValid(oEngineer) and oEngineer:GetAIBrain().M27AI then
            if bDebugMessages == true then LOG(sFunctionRef..': Platoon current action='..(oEngineer.PlatoonHandle[M27PlatoonUtilities.refiCurrentAction] or 'nil')..'; last order type='..(oEngineer.PlatoonHandle[M27PlatoonUtilities.refiLastOrderType] or 'nil')..'; Engineer='..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Engineer action='..(oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] or 'nil')..'; Is idle platoon='..tostring((oEngineer.PlatoonHandle[M27PlatoonTemplates.refbIdlePlatoon]) or false)) end
            if (oEngineer.PlatoonHandle and not(oEngineer.PlatoonHandle[M27PlatoonTemplates.refbIdlePlatoon])) or EntityCategoryContains(M27UnitInfo.refCategoryHive, oEngineer.UnitId) then
                local aiBrain = oEngineer:GetAIBrain()
                if aiBrain:GetEconomyStoredRatio('MASS') <= 0.6 then
                    if oEngineer.PlatoonHandle[M27PlatoonUtilities.refiCurrentAction] == M27PlatoonUtilities.refActionReclaimTarget or oEngineer.PlatoonHandle[M27PlatoonUtilities.refiLastOrderType] == M27PlatoonUtilities.refiOrderIssueReclaim or EntityCategoryContains(M27UnitInfo.refCategoryHive, oEngineer.UnitId) then
                        local iBuildRange = oEngineer:GetBlueprint().Economy.MaxBuildDistance
                        if iBuildRange > 1 then
                            local tEnemiesToReclaim = oEngineer:GetAIBrain():GetUnitsAroundPoint(M27UnitInfo.refCategoryStructure + M27UnitInfo.refCategoryMobileLand + M27UnitInfo.refCategoryAllNavy - categories.COMMAND - categories.SUBCOMMANDER, oEngineer:GetPosition(), iBuildRange, 'Enemy')
                            if M27Utilities.IsTableEmpty(tEnemiesToReclaim) == false then
                                local oUnitToReclaim = M27Utilities.GetNearestUnit(tEnemiesToReclaim, oEngineer:GetPosition())
                                M27Utilities.IssueTrackedClearCommands({oEngineer}) --need to clear commands or else we will continue reclaiming a wreck when we coudl be reclaiming an enemy
                                IssueReclaim({oEngineer}, oUnitToReclaim)
                                if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' to reclaim enemy unit '..oUnitToReclaim.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitToReclaim)) end
                            else
                                --Check for wrecks to reclaim within build range
                                local oNearestReclaim, iNearestReclaim = M27EngineerOverseer.GetWreckInCurrentRangeToReclaim(oEngineer:GetAIBrain(), oEngineer)
                                if iNearestReclaim <= iBuildRange + 0.5 and oNearestReclaim then
                                    --(shouldnt need to issue clear commands)
                                    IssueReclaim({oEngineer}, oNearestReclaim)
                                end
                            end
                        end
                    end
                end
            elseif oEngineer[M27EngineerOverseer.refiEngineerCurrentAction] == M27EngineerOverseer.refActionSelenMexBuild and not(oEngineer:IsUnitState('Building')) and not(oEngineer:IsUnitState('Repairing')) then
                M27Utilities.IssueTrackedClearCommands({oEngineer})
                M27EngineerOverseer.BuildStructureAtLocation(oEngineer:GetAIBrain(), oEngineer, M27UnitInfo.refCategoryT1Mex, 1, nil, oEngineer[M27EngineerOverseer.reftEngineerCurrentTarget], true, false, nil, true, nil, nil, M27EngineerOverseer.refActionSelenMexBuild)
                if bDebugMessages == true then LOG(sFunctionRef..': Engineer '..oEngineer.UnitId..M27UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming something, and its action was selenbuildmex, so will try and get it to build a mex at its target location of '..repru((oEngineer[M27EngineerOverseer.reftEngineerCurrentTarget] or {'nil'}))) end
            end
        end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnCreateWreck(tPosition, iMass, iEnergy)
    --Dont check if M27brains are in game yet as can be called at start of game before we have recorded any aiBrain; instead will have check in the delayedreclaim
    if M27Utilities.bM27AIInGame  or GetGameTimeSeconds() <= 5 then
        --LOG('OnCreateWreck temp log - remove once confirmed this works; wreck position='..repru(tPosition)..'; iMass='..(iMass or 'nil')..'; iEnergy='..(iEnergy or 'nil'))
        local sFunctionRef = 'OnCreateWreck'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        if GetGameTimeSeconds() <= 5 then --Some variables wont be setup yet (probably only need to do <=1s but will do 5s to be safe)
            ForkThread(M27MapInfo.DelayedReclaimRecordAtLocation, tPosition, 0, 5)
        else
            ForkThread(M27MapInfo.RecordThatWeWantToUpdateReclaimAtLocation, tPosition, 0)
            if iMass >= 15 then

                local tNearbyUnits = GetUnitsInRect(Rect(tPosition[1] - 2.5, tPosition[3] - 2.5, tPosition[1] + 2.5, tPosition[3] + 2.5))
                if M27Utilities.IsTableEmpty(tNearbyUnits) == false then
                    local tEngineers = EntityCategoryFilterDown(M27UnitInfo.refCategoryEngineer, tNearbyUnits)
                    if M27Utilities.IsTableEmpty(tEngineers) == false then
                        for iUnit, oUnit in tEngineers do
                            if M27UnitInfo.IsUnitValid(oUnit) then
                                if oUnit:GetAIBrain().M27AI then
                                    if not(oUnit[M27EngineerOverseer.refbPrimaryBuilder]) and not(oUnit:IsUnitState('Reclaiming')) then
                                        if not(oUnit[M27EngineerOverseer.refiEngineerCurrentAction] == M27EngineerOverseer.refActionBuildEmergencyPD) and M27Utilities.GetDistanceBetweenPositions(tPosition, oUnit:GetPosition()) <= oUnit:GetBlueprint().Economy.MaxBuildDistance then
                                            local aiBrain = oUnit:GetAIBrain()
                                            if aiBrain:GetEconomyStoredRatio('MASS') <= 0.3 then
                                                local tNearbyReclaim = M27MapInfo.GetReclaimInRectangle(4, Rect(oUnit:GetPosition()[1] - 2.5, oUnit:GetPosition()[3] - 2.5, oUnit:GetPosition()[1] + 2.5, oUnit:GetPosition()[3] + 2.5))
                                                if M27Utilities.IsTableEmpty(tNearbyReclaim) == false then
                                                    M27Utilities.IssueTrackedClearCommands({oUnit})
                                                    M27EngineerOverseer.ClearEngineerActionTrackers(aiBrain, oUnit, true)
                                                    M27EngineerOverseer.UpdateEngineerActionTrackers(aiBrain, oUnit, M27EngineerOverseer.refActionReclaimUnit, tPosition, false, 50, nil, true, nil, nil)
                                                    local iBuildRange = oUnit:GetBlueprint().Economy.MaxBuildDistance
                                                    for iWreck, oWreck in tNearbyReclaim do
                                                        if oWreck.MaxMassReclaim > 0 and oWreck.CachePosition and M27Utilities.GetDistanceBetweenPositions(oWreck.CachePosition, oUnit:GetPosition()) <= iBuildRange then
                                                            IssueReclaim({oUnit}, oWreck)
                                                            --LOG('Issuing reclaim callback for unit '..oUnit.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnit))
                                                        end
                                                    end
                                                end
                                            end
                                            break
                                        end
                                    end
                                    break
                                end
                            end
                        end

                    end
                end
            end
            --[[if GetGameTimeSeconds() >= 590 then bDebugMessages = true end
            if bDebugMessages == true then
                local iReclaimSegmentX, iReclaimSegmentZ = M27MapInfo.GetReclaimSegmentsFromLocation(tPosition)
                LOG(sFunctionRef..' wreck just created, iMass='..(iMass or 0)..'; tPosition='..repru(tPosition)..'; reclaim segments of position='..iReclaimSegmentX..'-'..iReclaimSegmentZ)
                --bDebugMessages = false WaitTicks(1) LOG(sFunctionRef..': repr of tReclaimSegmentsToUpdate='..repru(M27MapInfo.tReclaimSegmentsToUpdate))
            end--]]
        end
        --M27MapInfo.UpdateReclaimDataNearLocation(tPosition, 0, nil)
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnTransportLoad(oUnit, oTransport, bone)
    if oUnit:GetAIBrain().M27AI and oTransport:GetAIBrain().M27AI then
        local sFunctionRef = 'OnTransportUnload'
        local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
        M27Transport.UpdateTransportForLoadedUnit(oUnit, oTransport)
        M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
    end
end

function OnTransportUnload(oUnit, oTransport, bone)

    if M27UnitInfo.IsUnitValid(oUnit) then
        local aiBrain = oUnit:GetAIBrain()
        if aiBrain.M27AI then
            local sFunctionRef = 'OnTransportUnload'
            local bDebugMessages = false if M27Utilities.bGlobalDebugOverride == true then   bDebugMessages = true end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerStart)
            M27Utilities.IssueTrackedClearCommands({oUnit})
            oUnit[M27Transport.refiAssignedPlateau] = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnit:GetPosition())
            --Make sure we have correctly recorded the plateau if we have landed engineers

            if not(oUnit[M27Transport.refiAssignedPlateau] == aiBrain[M27MapInfo.refiOurBasePlateauGroup]) and EntityCategoryContains(M27UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                if M27MapInfo.RecheckPathingOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnit, oUnit:GetPosition()) then
                    oUnit[M27Transport.refiAssignedPlateau] = M27MapInfo.GetSegmentGroupOfLocation(M27UnitInfo.refPathingTypeAmphibious, oUnit:GetPosition())
                end
            end

            if not(oTransport.GetCargo) or M27Utilities.IsTableEmpty(oTransport:GetCargo()) then oTransport[M27Transport.refiUnitsLoaded] = 0
            else
                oTransport[M27Transport.refiUnitsLoaded] = math.max(0, (oTransport[M27Transport.refiUnitsLoaded] or 0) - 1)
            end
            M27Utilities.FunctionProfiler(sFunctionRef, M27Utilities.refProfilerEnd)
        end
    end
end

function OnDetectedBy(oUnitDetected, iBrainIndex)
    --Appears to be called when iBrainIndex detects oUnitDetected

    --For now used to make sure we have up to date naval info
    if M27Utilities.bM27AIInGame then
        local aiBrain = ArmyBrains[iBrainIndex]
        --LOG('OnDetectedBy: UnitID='..oUnitDetected.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitDetected)..'; tAllAIBrainsByArmyIndex[iBrainIndex] name='..M27Overseer.tAllAIBrainsByArmyIndex[iBrainIndex].Nickname..'; ArmyBrains nickname='..ArmyBrains[iBrainIndex].Nickname..'; Does entity contain navy='..tostring(EntityCategoryContains(M27UnitInfo.refCategoryAllAmphibiousAndNavy, oUnitDetected.UnitId))..'; aiBrain.M27AI='..tostring((aiBrain.M27AI or false)))
        if aiBrain.M27AI then
            if not(oUnitDetected[M27UnitInfo.reftLastKnownPosition]) and M27UnitInfo.IsUnitValid(oUnitDetected) and EntityCategoryContains(M27UnitInfo.refCategoryAllAmphibiousAndNavy, oUnitDetected.UnitId) and aiBrain.M27Team then
                --LOG('OnDetectedBy: aiBrain='..aiBrain.Nickname..' has just detected unit '..oUnitDetected.UnitId..M27UnitInfo.GetUnitLifetimeCount(oUnitDetected))
                M27Navy.UpdateUnitPond(oUnitDetected, aiBrain.M27Team, IsEnemy(iBrainIndex, oUnitDetected:GetAIBrain():GetArmyIndex()))
            end
            --Mobile stealth flag
            if not(aiBrain[M27Overseer.refbEnemyHasMobileT2PlusStealth]) and EntityCategoryContains(categories.STEALTH * categories.MOBILE * categories.LAND + categories.STEALTH * categories.MOBILE * categories.NAVAL - categories.TECH1, oUnitDetected.UnitId) then
                aiBrain[M27Overseer.refbEnemyHasMobileT2PlusStealth] = true
            end
        end
    end
end


--[[Note: As at 2023-03017 there's a bug with the FAF capture callback which Jip confirmed - will be fixed in the next faf development patch/version - revisit at this point
function OnCaptured(oSlave, oCaptor)
    LOG('OnCaptured start, oSlave='..oSlave.UnitId..M27UnitInfo.GetUnitLifetimeCount(oSlave)..'; Is slave valid='..tostring(M27UnitInfo.IsUnitValid(oSlave))..'; slave owner='..oSlave:GetAIBrain().Nickname)
    --WaitSeconds(1)
    --LOG('OnCaptured after wait, oSlave='..oSlave.UnitId..M27UnitInfo.GetUnitLifetimeCount(oSlave)..'; Is slave valid='..tostring(M27UnitInfo.IsUnitValid(oSlave))..'; slave owner='..oSlave:GetAIBrain().Nickname)
end

function OnCapturedAlt(oOldUnit, oNewUnit)
    WaitSeconds(1)
    LOG('OnCapturedAlt: oNewUnit='..(oNewUnit.UnitId or 'nil')..(M27UnitInfo.GetUnitLifetimeCount(oNewUnit) or 'nil'))
    LOG('OnCapturedAlt: Owner='..oNewUnit:GetAIBrain().Nickname)
end--]]
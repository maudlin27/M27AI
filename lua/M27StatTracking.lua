---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 22/10/2022 11:02
---

--Intended to keep most variables (outside of callbacks) for stat tracking in one place
local M27Logic = import('/mods/M27AI/lua/AI/M27GeneralLogic.lua')
local M27Utilities = import('/mods/M27AI/lua/M27Utilities.lua')


--Stats table
tStatsByBrain = {} --Broken down by 4 tables; 1st is brain index, 2nd is the rounded game time, 3rd is the stat type ref, 4th (where used) is the unit type ref, i.e. tStatsByBrain[BrainIndex][RoundedTime][StatRef][UnitTechAndTypeRef]
--refiBrainNumber = 'M27StatsBrainNumber' --Brain number, first index of master table
--refiStatType = 'M27StatsType' --2nd index of master table
subrefTypeMassKiller = 'M27StatsMassKiller' --if a unit gets a kill, this records the killer by unit type
subrefTypeMassConstructed = 'M27StatsMassConstructed' --broken down by unit type
subrefTypeMassActive = 'M27StatsMassActive' --broken down by unit type
subrefTypeMassLost = 'M27StatsMassLost' --broken down by unit type
subrefNetMassIncome = 'M27StatsNetMassIncome' --Not broken down further
subrefNetEnergyIncome = 'M27StatsNetEnergyIncome' --Not broken down further

refiUnitTechAndTypeRef = 'M27UnitType' --3rd index of master table - shoudl contain the unit tech and unit type reference
--Unit types - assumption is will check in order from first to last, so dont need to add exclusions to some of hte later categories
tUnitTypesByRef = {
    [1] = {'EcoMass', categories.MASSPRODUCTION * categories.STRUCTURE},
    [2] = {'EcoPower', categories.ENERGYPRODUCTION * categories.STRUCTURE},
    [3] = {'BuildPower', categories.ENGINEER + categories.STRUCTURE * categories.FACTORY - categories.COMMAND -categories.SUBCOMMANDER},
    [4] = {'BuildingAttack', categories.STRUCTURE * categories.DIRECTFIRE + categories.STRUCTURE * categories.SILO - categories.STRUCTURE * categories.SILO * categories.DEFENSE * categories.ANTIMISSILE + categories.STRUCTURE * categories.INDIRECTFIRE + categories.STRUCTURE * categories.ANTINAVY},
    [5] = {'BuildingDefence', categories.STRUCTURE * categories.SHIELD + categories.STRUCTURE * categories.ANTIMISSILE + categories.STRUCTURE * categories.ANTIAIR},
    [6] = {'BuildingOther', categories.STRUCTURE},
    [7] = {'ACU', categories.COMMAND},
    [8] = {'LandSkirmisher', categories.SNIPER * categories.TECH3 * categories.MOBILE * categories.LAND + categories.BOT * categories.TECH2 * categories.DIRECTFIRE * categories.UEF + categories.BOT * categories.TECH2 * categories.DIRECTFIRE * categories.CYBRAN},
    [9] = {'LandAA', categories.MOBILE * categories.LAND * categories.ANTIAIR},
    [10] = {'LandIndirect', categories.LAND * categories.INDIRECTFIRE * categories.MOBILE},
    [11] = {'LandTank', categories.LAND * categories.MOBILE * categories.DIRECTFIRE},
    [12] = {'LandOther', categories.LAND * categories.MOBILE},
    [13] = {'NavySubs', categories.NAVAL * categories.SUBMERSIBLE},
    [14] = {'NavySurfaceCombat', categories.FRIGATE + categories.DESTROYER + categories.BATTLESHIP - categories.BATTLESHIP * categories.INDIRECTFIRE},
    [15] = {'NavyOther', categories.NAVAL},
    [16] = {'AirAttack', categories.AIR * categories.DIRECTFIRE + categories.AIR * categories.BOMBER + categories.AIR * categories.GROUNDATTACK - categories.TRANSPORTATION},
    [17] = {'AirAntiAir', categories.AIR * categories.ANTIAIR},
    [18] = {'AirOther', categories.AIR}
}

iStatsInterval = 60 --Number of seconds to record details in
bHaveInitiatedMonitors = false
tBrainsToConsider = {}

function GetTimeInterval()
    return math.ceil(GetGameTimeSeconds() / iStatsInterval) * iStatsInterval
end

function ExpandTablesIfEmpty(iBrainIndex, iRoundedTime)
    if not(tStatsByBrain[iBrainIndex][iRoundedTime]) then
        tStatsByBrain[iBrainIndex][iRoundedTime] = {}
        tStatsByBrain[iBrainIndex][iRoundedTime][subrefTypeMassKiller] = {}
        tStatsByBrain[iBrainIndex][iRoundedTime][subrefTypeMassConstructed] = {}
        tStatsByBrain[iBrainIndex][iRoundedTime][subrefTypeMassActive] = {}
        tStatsByBrain[iBrainIndex][iRoundedTime][subrefTypeMassLost] = {}
        tStatsByBrain[iBrainIndex][iRoundedTime][subrefNetMassIncome] = {}
        tStatsByBrain[iBrainIndex][iRoundedTime][subrefNetEnergyIncome] = {}
    end
end

function GetUnitRefFromUnitId(sUnitId)
    for iOrder, tSubtable in tUnitTypesByRef do
        --if sUnitId == 'ual0106' then LOG('Does sUnitId='..sUnitId..' contain category for iOrder='..iOrder..'; subtable='..repru(tSubtable)) end
        if EntityCategoryContains(tSubtable[2], sUnitId) then
            return tSubtable[1]
        end
    end
    return 'Other'
end

function GetBrainName(iIndex)
    for iBrain, oBrain in ArmyBrains do
        if oBrain:GetArmyIndex() == iIndex then return oBrain.Nickname..iIndex
        end
    end
end

function MonitorIncomeGeneration()
    --Setup table

    for iBrain, oBrain in ArmyBrains do
        --if not(M27Logic.IsCivilianBrain(oBrain)) then --Civilians can get kills and be killed so want to have their brain in the table
            tStatsByBrain[oBrain:GetArmyIndex()] = {}
            tBrainsToConsider[oBrain:GetArmyIndex()] = oBrain
            LOG('Setup stats table for brain '..oBrain.Nickname..' with index '..oBrain:GetArmyIndex())
            --[[local iCurIndex = oBrain:GetArmyIndex()

            tBrainsToConsider[iCurIndex] = oBrain
            tBrainsToConsider[iCurIndex][subrefTypeMassKiller] = {}
            tBrainsToConsider[iCurIndex][subrefTypeMassConstructed] = {}
            tBrainsToConsider[iCurIndex][subrefTypeMassActive] = {}
            tBrainsToConsider[iCurIndex][subrefTypeMassLost] = {}
            tBrainsToConsider[iCurIndex][subrefNetMassIncome] = {}
            tBrainsToConsider[iCurIndex][subrefNetEnergyIncome] = {}--]]
        --end
    end

    --Main loop
    local iRoundedTime
    local iPrevRoundedTime = iStatsInterval
    local tActiveUnits

    while M27Utilities.IsTableEmpty(tBrainsToConsider) == false do
        iRoundedTime = GetTimeInterval()
        for iBrainIndex, oBrain in tBrainsToConsider do
            if oBrain:IsDefeated() then tBrainsToConsider[iBrainIndex] = nil
            else
                --Setup variables if they dont exist
                ExpandTablesIfEmpty(iBrainIndex, iRoundedTime)
                --Record mass and energy income
                tStatsByBrain[iBrainIndex][iRoundedTime][subrefNetMassIncome] = oBrain:GetEconomyTrend('MASS')
                tStatsByBrain[iBrainIndex][iRoundedTime][subrefNetEnergyIncome] = oBrain:GetEconomyTrend('ENERGY')
            end
        end

        --Slower update of all active units
        if iRoundedTime > iPrevRoundedTime then
            for iBrainIndex, oBrain in tBrainsToConsider do
                tStatsByBrain[iBrainIndex][iPrevRoundedTime][subrefTypeMassActive] = {}
                tActiveUnits = oBrain:GetListOfUnits(categories.ALLUNITS - categories.BENIGN - categories.COMMAND)
                if M27Utilities.IsTableEmpty(tActiveUnits) == false then
                    for iUnit, oUnit in tActiveUnits do
                        UpdateStatsForUnit(iBrainIndex, oUnit, subrefTypeMassActive, nil, iPrevRoundedTime)
                    end
                end
            end

            --Output the tables
            LOG('?=*1Time='..iPrevRoundedTime..';About to list out the full stats table for each brain')
            for iIndex, tSubtable in tStatsByBrain do
                if tBrainsToConsider[iIndex].Nickname and not(M27Logic.IsCivilianBrain(tBrainsToConsider[iIndex])) then
                    --LOG('Brain index '..iIndex..': Does it have an empty subtable='..tostring(M27Utilities.IsTableEmpty(tSubtable[iPrevRoundedTime])))
                    if tSubtable[iPrevRoundedTime] then
                        LOG('Brain='..GetBrainName(iIndex)..'; BrainIndex='..iIndex..'; Stats for time='..iPrevRoundedTime..'='..reprs(tSubtable[iPrevRoundedTime]))
                    end
                end
            end
            LOG('?=*2End of list of full stats for this time')
        end

        iPrevRoundedTime = iRoundedTime
        WaitTicks(1)
    end
end

function UpdateStatsForUnit(iBrainIndex, oBaseUnit, sVariableRef, iOptionalMassOverride, iOptionalRoundedTime)
    local iRoundedTime = iOptionalRoundedTime or GetTimeInterval()
    ExpandTablesIfEmpty(iBrainIndex, iRoundedTime)
    if oBaseUnit.GetBlueprint then
        local iMassCost = iOptionalMassOverride or oBaseUnit:GetBlueprint().Economy.BuildCostMass
        if iMassCost > 0 then
            local sUnitRef = GetUnitRefFromUnitId(oBaseUnit.UnitId)
            --LOG('Unit ref for oBaseUnit='..oBaseUnit.UnitId..'='..sUnitRef)
            if not(tStatsByBrain[iBrainIndex][iRoundedTime][sVariableRef]) then tStatsByBrain[iBrainIndex][iRoundedTime][sVariableRef] = {} end
            tStatsByBrain[iBrainIndex][iRoundedTime][sVariableRef][sUnitRef] = (tStatsByBrain[iBrainIndex][iRoundedTime][sVariableRef][sUnitRef] or 0) + iMassCost
        end
    end
end


function UpdateStatsForKiller(oKiller, oKilled)
    if oKilled.GetBlueprint and oKiller.GetAIBrain then
        UpdateStatsForUnit(oKiller:GetAIBrain():GetArmyIndex(), oKiller, subrefTypeMassKiller, oKilled:GetBlueprint().Economy.BuildCostMass)
    end
end

function UpdateStatsForKilled(oKilled)
    if oKilled.GetAIBrain then
        --NOTE: Only way to avoid occasional lua errors seems to be checking oKilled:IsDestroyed(), but this then means we dont record any units killed so defeats the purpose
        UpdateStatsForUnit(oKilled:GetAIBrain():GetArmyIndex(), oKilled, subrefTypeMassLost)
    end
end

function UpdateStatsForBuilt(oBuilt)
    if oBuilt.GetAIBrain then

            UpdateStatsForUnit(oBuilt:GetAIBrain():GetArmyIndex(), oBuilt, subrefTypeMassConstructed)
    end
end



function StatTrackingInitialisation()
    if not(bHaveInitiatedMonitors) then
        bHaveInitiatedMonitors = true
        WaitSeconds(5)


        ForkThread(MonitorIncomeGeneration)
    end
end